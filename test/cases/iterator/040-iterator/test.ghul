
namespace IteratorTest is
    use System;

    /*
    The Iteratable<T> trait is part of the L library.

    In ghul it would be defined as:

    trait Iterable[T] is
        Iterator: Iterator[T]
    si


    The Iterator[T] trait is also part of the L library

    In ghul it would be defined as

    trait Iterator[T]: Iterable[T] is
        hasMoreElements() -> bool;
        nextElement() -> T;
    si

    */

    class Main is
        init() is
            let animals = new SimpleList[String](["stoat", "otter", "ocelot", "badger", "weasle"]);

            test_with_for(animals);
            test_with_while(animals);
            test_with_awkward(animals);
            test_with_redundant_has_more_elements(animals);
            test_without_has_more_elements(animals);
        si

        test_with_for(animals: Generic.Iterable[String]) is
            IO.Std.err.println("test with for");
            // for can loop over anything that's either Iterable or
            // an Iterator.
            // if you give it an Iterable, it will use the 'Iterator'
            // property to get an Iterator
            // Type of the loop variable is inferred from the type of
            // the Iterator:
            for animal in animals do
                IO.Std.err.println("have animal: " + animal);
            od
        si

        test_with_while(animals: Generic.Iterable[String]) is
            IO.Std.err.println("test with while");
            // this while loop is appropximately equivalent
            // to the for loop in the function above:
            let iterator = animals.Iterator;

            while iterator.hasMoreElements() do
                let animal = iterator.nextElement();

                IO.Std.err.println("have animal: " + animal);
            od
        si

        test_with_awkward(animals: SimpleList[String]) is
            IO.Std.err.println("test with awkard iterator");
            // you can explicitly give the for loop a particular iterator
            // instead of it just getting one through Iterarable[T].Iterator:
            for animal in animals.AwkwardIterator do
                IO.Std.err.println("have animal: " + animal);
            od
        si        

        test_with_redundant_has_more_elements(animals: Generic.Iterable[String]) is
            IO.Std.err.println("test with redundant has more elements");
            let iterator = animals.Iterator;

            /// you can call hasMoreElements() as often as you like:
            while iterator.hasMoreElements() && iterator.hasMoreElements() do
                let animal = iterator.nextElement();

                IO.Std.err.println("have animal: " + animal);
            od
        si

        test_without_has_more_elements(animals: SimpleList[String]) is
            IO.Std.err.println("test without has more elements");
            let iterator = animals.AwkwardIterator;

            while iterator.hasMoreElements() do
                try
                    let animal_1 = iterator.nextElement();

                    /// this might fail, because we did not call
                    // hasMoreElements() first:
                    let animal_2 = iterator.nextElement();

                    IO.Std.err.println("have animal 1: " + animal_1);
                    IO.Std.err.println("have animal 2: " + animal_2);

                catch e: AwkwardIteratorException
                    IO.Std.err.println("expected: calling nextElement may not succeed if hasMoreElements() not called first");
                yrt
            od
        si
    si

    class SimpleList[T]: Object, Generic.Iterable[T] is
        _values: T[];
        length: int => _values.Length;

        [index: int]: T
            => _values[index],
            = value is
                _values[index] = value;
            si        

        // this is what makes SimpleList[T] iterable.
        // It's just a regular property that implements the 
        // Iterable[T] trait:
        Iterator: Generic.Iterator[T] => new SimpleListIterator[T](self);

        AwkwardIterator: Generic.Iterator[T] => new AwkwardListIterator[T](self);

        init(values: Generic.List[T]) is
            _values = new T[](values.Length);

            for i in 0..values.Length do
                self[i] = values[i];
            od
        si

    si

    class SimpleListIterator[T]: Object, Generic.Iterator[T] is
        _list: SimpleList[T];
        _position: int;

        Iterator: Generic.Iterator[T] => self; // iterators are themselves iterable

        init(list: SimpleList[T]) is
            _list = list;
        si

        // does this Iterator still have
        // elements available? If hasMoreElements()
        // returns true, then the next call to 
        // nextElement() must succeed.
        hasMoreElements() -> bool
            => _position < _list.length;

        // advance the Iterator to the next element
        // and return it. Note that how the Iterator
        // chooses to keep track of its position
        // is private.
        nextElement() -> T is
            let result = _list[_position];

            _position = _position + 1;

            return result; 
        si
    si

    class AwkwardListIterator[T]: Object, Generic.Iterator[T] is
        _expecting_next_element: bool;
        _list: SimpleList[T];
        _position: int;

        Iterator: Generic.Iterator[T] => self; // iterators are themselves iterable

        init(list: SimpleList[T]) is
            _list = list;
        si

        hasMoreElements() -> bool is
            _expecting_next_element = true;

            return _position < _list.length;
        si

        nextElement() -> T is
            if !_expecting_next_element then
                throw new AwkwardIteratorException("you didn't call hasMoreElements() first!");
            fi

            let result = _list[_position];

            _position = _position + 1;

            _expecting_next_element = false;

            return result; 
        si
    si    

    class AwkwardIteratorException: Exception is
        init(message: String) is
            super.init(message);
        si
    si
si