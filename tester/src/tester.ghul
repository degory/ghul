namespace Tester is
    use System; 
    use Generic;
    
    class Main is
        _dummy: TEST_SUITE[] static;

        init() is
            IO.Std.err.FlushOnPrintln = true;

            let cases_root = "cases/";

            let test_cases = new Vector[TEST_CASE]();

            let timer = new TIMER();

            let to_run = new Vector[String]();

            if System.Arguments.ProgramArguments.Length > 1 then
                for i in 1..System.Arguments.ProgramArguments.Length do
                    let stat = new IO.Stat();

                    var f = System.Arguments.ProgramArguments[i];

                    let split_at = f.lastIndexOf('/');

                    if split_at > 0 then
                        f = f.substring(split_at + 1);
                    fi
                    
                    if
                        stat.stat(cases_root + f + "/ghulflags") &&
                        !stat.stat(cases_root + f + "/disabled")
                    then
                        to_run.add(f);
                    else
                        IO.Std.err.println("bad test: " + cases_root + f);
                    fi
                od                             
            else
                for f in new IO.DIRECTORY(cases_root) do
                    let stat = new IO.Stat();

                    if
                        stat.stat(cases_root + f + "/ghulflags") &&
                        !stat.stat(cases_root + f + "/disabled")
                    then
                        to_run.add(f);
                    fi
                od
            fi

            IO.Std.err.print("will run % test cases with: " % [to_run.Length]: Object);
            IO.Std.err.flush();

            new Util.Process().run("ghul", ["ghul"], System.Arguments.ProgramEnvironment);

            cast Sort[String](null).sort(to_run);

            for i in 0..to_run.Length do
                let f = to_run[i];

                IO.Std.err.println("run test case %/%: %..." % [i + 1, to_run.Length, f]);

                let runner = new TEST_RUNNER(f, f, cases_root + "/" + f);                
                
                test_cases.add(runner.test());

                i = i + 1;
            od

            let duration = timer.elapsed_milli_seconds;

            let suite = new TEST_SUITE(
                "integration",
                test_cases,
                duration
            );

            let result = new TEST_SUITES(duration, [suite]);

            let result_file = IO.File.openCreate("junit.xml");

            result_file.println(result);

            result_file.close();

            if suite.failures > 0 then
                IO.Std.err.println("exiting with % failures" % [suite.failures]:Object);
                System.Exit.exit(1);
            else
                IO.Std.err.println("exiting success");
                System.Exit.exit(0);                
            fi
        si
    si

    class XML is
        escape(value: String) -> String static is
            let result = new StringBuffer();
            
            for c in value do
                case c
                when '<':
                    result.append("&lt;");

                when '>':
                    result.append("&gt;");

                when '&':
                    result.append("&amp;");

                when cast char(39):
                    result.append("&apos;");

                when cast char(34):
                    result.append("&quot;");
                
                default
                    result.append(c);
                
                esac                
            od

            return result;
        si
    si
    
    class TIMER is
        start_time: long;

        elapsed_micro_seconds: long is
            return cast long(native.__get_micro_time()) - start_time;
        si
        
        elapsed_milli_seconds: int is
            return cast int(elapsed_micro_seconds/1000L);
        si
        
        init() is
            restart();
        si
        
        restart() is
            start_time = cast long(native.__get_micro_time());
        si
    si
    
    class DURATION is
        milliseconds: int;

        init(milliseconds: int) is
            self.milliseconds = milliseconds;
        si

        toString() -> String is
            let result = new StringBuffer();

            result.append(milliseconds / 1000);
            result.append('.');
            result.append(cast int(milliseconds % 1000), 10, 3, '0');

            return result;
        si
    si

    class TEST_SUITES is
        duration: DURATION;

        test_suites: Iterable[TEST_SUITE];

        init(
            duration: int,
            test_suites: Iterable[TEST_SUITE]
        ) is
            self.duration = new DURATION(duration);
            self.test_suites = test_suites;
        si        

        toString() -> String is
            let result = new StringBuffer();

            result
                .append("<testsuites duration=\"")
                .append(duration)
                .append("\">\n");

            for ts in test_suites do
                result
                    .append(ts);
            od

            result
                .append("</testsuites>\n");
            
            return result;                
        si
    si

    class TEST_SUITE is
        _next_id: int static;

        name: String;
        id: int;

        tests: int;
        failures: int;

        time: DURATION;

        test_cases: Iterable[TEST_CASE];

        next_id: int static is
            _next_id = _next_id + 1;
            return _next_id - 1;
        si
        
        init(
            name: String,
            test_cases: Iterable[TEST_CASE],
            time: int
        ) is
            self.id = next_id;

            self.name = name;
            self.test_cases = test_cases;
            self.time = new DURATION(time);

            for tc in test_cases do
                tests = tests + 1;

                for f in tc.failures do
                    failures = failures + 1;
                od                
            od            
        si

        toString() -> String is
            let result = new StringBuffer();

            result
                .append("<testsuite name=\"")
                .append(XML.escape(name))
                .append("\" tests=\"")
                .append(tests)
                .append("\" failures=\"")
                .append(failures)
                .append("\" time=\"")
                .append(time)
                .append("\" id=\"")
                .append(id)
                .append("\">\n");
                
            for tc in test_cases do
                result
                    .append(tc);
            od

            result
                .append("</testsuite>\n");

            return result;
        si
    si

    class TEST_CASE is
        name: String;
        classname: String;
        failures: Iterable[FAILURE];
        time: DURATION;
        std_out: String;
        std_err: String;

        init(
            name: String,
            classname: String,
            failures: Iterable[FAILURE],
            time: int,
            std_out: String,
            std_err: String
        ) is
            self.name = name;
            self.classname = classname;
            self.failures = failures;
            self.time = new DURATION(time);
            self.std_out = std_out;
            self.std_err = std_err;
        si

        toString() -> String is
            let result = new StringBuffer();

            result
                .append("<testcase name=\"")
                .append(XML.escape(name))
                .append("\" time=\"")
                .append(time)
                .append("\" classname=\"")
                .append(XML.escape(classname))
                .append("\">\n");

            if failures? then
                for f in failures do
                    result.append(f);
                od                  
            fi

            if std_out? && std_out.Length > 0 then
                result
                    .append("<system-out>")
                    .append(XML.escape(std_out))
                    .append("</system-out>\n");
            fi

            if std_err? && std_err.Length > 0 then
                result
                    .append("<system-err>")
                    .append(XML.escape(std_err))
                    .append("</system-err>\n");
            fi

            result
                .append("</testcase>\n");

            return result;
        si
    si

    class FAILURE is
        message: String;
        type: String;

        init(message: String, type: String) is
            self.message = message;
            self.type = type;

            if
                message == null || message.Length == 0 ||
                type == null || type.Length == 0
            then
                throw new Exception("incomplete failure");
            fi
        si
        
        toString() -> String is
            let result = new StringBuffer();

            result
                .append("<failure type=\"")
                .append(XML.escape(type))
                .append("\" message=\"")
                .append(XML.escape(type))
                .append("\">\n");
            
            if message? && message.Length > 0 then
                result
                    .append(XML.escape(message));

                if !message.endsWith('\n') then
                    result.append('\n');
                fi
            fi

            result.append("</failure>\n");

            return result;
        si
    si  
si