namespace Tester is
    use System; 
    use Generic;
    
    class Main is
        _dummy: TEST_SUITE[] static;

        init() is
            IO.Std.err.FlushOnPrintln = true;

            let cases_root = "cases/";

            let test_cases = new Vector[TEST_CASE]();

            let timer = new TIMER();

            let to_run = new Vector[String]();

            if System.Arguments.ProgramArguments.Length > 1 then
                for i in 1..System.Arguments.ProgramArguments.Length do
                    let stat = new IO.Stat();

                    var f = System.Arguments.ProgramArguments[i];

                    let split_at = f.lastIndexOf('/');

                    if split_at > 0 then
                        f = f.substring(split_at + 1);
                    fi
                    
                    if
                        stat.stat(cases_root + f + "/ghulflags") &&
                        !stat.stat(cases_root + f + "/disabled")
                    then
                        to_run.add(f);
                    else
                        IO.Std.err.println("bad test: " + cases_root + f);
                    fi
                od                             
            else
                for f in new IO.DIRECTORY(cases_root) do
                    let stat = new IO.Stat();

                    if
                        stat.stat(cases_root + f + "/ghulflags") &&
                        !stat.stat(cases_root + f + "/disabled")
                    then
                        to_run.add(f);
                    fi
                od
            fi

            IO.Std.err.print("will run % test cases with: " % [to_run.Length]: Object);
            IO.Std.err.flush();

            new Util.Process().run("ghul", ["ghul"], System.Arguments.ProgramEnvironment);

            cast Sort[String](null).sort(to_run);

            for i in 0..to_run.Length do
                let f = to_run[i];

                IO.Std.err.print("test case %/%: %: " % [i + 1, to_run.Length, f]);
                IO.Std.err.flush();

                let runner = new TEST_RUNNER(f, f, cases_root + "/" + f);                
                
                test_cases.add(runner.test());

                i = i + 1;
            od

            let duration = timer.elapsed_milli_seconds;

            let suite = new TEST_SUITE(
                "default",
                test_cases,
                duration
            );

            suite.write();

            if suite.failures > 0 then
                IO.Std.err.println("exiting with % failures" % [suite.failures]:Object);
                System.Exit.exit(1);
            else
                IO.Std.err.println("exiting success");
                System.Exit.exit(0);                
            fi
        si
    si

    class JSON_ESCAPER is
        escape(text: String) -> String static is
            let result = new StringBuffer(text.Length * 2);

            result.append("\"");

            for c in text do
                let ec = escape(c);

                if ec? then
                    result.append(ec);
                else
                    result.append(c);
                fi
            od

            result.append("\"");

            return result;
        si
        
        escape(c: char) -> String static is
            case cast int(c)
            when 9:
                return "\\t";

            when 10:
                return "\\n";

            when 13:
                return "\\r";

            when 34:
                return "\\\"";

            when 92:
                return "\\\\";

            esac        
        si  
    si
    
    
    class TIMER is
        start_time: long;

        elapsed_micro_seconds: long is
            return cast long(native.__get_micro_time()) - start_time;
        si
        
        elapsed_milli_seconds: int is
            return cast int(elapsed_micro_seconds/1000L);
        si
        
        init() is
            restart();
        si
        
        restart() is
            start_time = cast long(native.__get_micro_time());
        si
    si
    
    class DURATION is
        milliseconds: int;

        init(milliseconds: int) is
            self.milliseconds = milliseconds;
        si

        toString() -> String is
            let result = new StringBuffer();

            result.append(milliseconds / 1000);
            result.append('.');
            result.append(cast int(milliseconds % 1000), 10, 3, '0');

            return result;
        si
    si

    class TEST_SUITES is
        duration: DURATION;

        test_suites: Iterable[TEST_SUITE];

        init(
            duration: int,
            test_suites: Iterable[TEST_SUITE]
        ) is
            self.duration = new DURATION(duration);
            self.test_suites = test_suites;
        si        

        toString() -> String is
            let result = new StringBuffer();            

            for ts in test_suites do
                result
                    .append(ts);
            od

            return result;                
        si
    si

    class TEST_SUITE is
        _next_id: int static;

        name: String;
        id: int;

        tests: int;
        failures: int;

        time: DURATION;

        test_cases: Iterable[TEST_CASE];

        next_id: int static is
            _next_id = _next_id + 1;
            return _next_id - 1;
        si
        
        init(
            name: String,
            test_cases: Iterable[TEST_CASE],
            time: int
        ) is
            self.id = next_id;

            self.name = name;
            self.test_cases = test_cases;
            self.time = new DURATION(time);

            for tc in test_cases do
                tests = tests + 1;

                if tc.failures.Length > 0 then
                    failures = failures + 1;
                fi
            od            
        si

        write() is
            write_conclusion();
            write_output();
        si
        
        write_conclusion() is
            let conclusion_file = IO.File.openCreate("test-conclusion.txt");
            let conclusion: String;

            if tests == 0 then
                conclusion = "neutral";
            elif failures > 0 then
                conclusion = "failure";
            else
                conclusion = "success";
            fi

            conclusion_file.println(conclusion);
            conclusion_file.close();            
        si

        write_output() is
            let summary = get_summary();
            let text_description = get_text_description();

            let markdown_file = IO.File.openCreate("test-results.md");

            markdown_file.println(summary);
            markdown_file.println(text_description);

            markdown_file.close();

            let output_file = IO.File.openCreate("test-output.json");

            output_file.print("{ \"summary\": ");
            output_file.print(JSON_ESCAPER.escape(summary));

            output_file.print(", \"text_description\": ");
            output_file.print(JSON_ESCAPER.escape(text_description));

            output_file.print("}");

            output_file.close();
        si

        get_summary() -> String is
            let md = new MARKDOWN();

            if tests == 0 then
                md.append_line("# No tests executed");
            elif failures > 0 then
                md.append_line("# ❌ Failed");
                md.append_line("## " + (tests - failures) + "/" + tests + " tests passed");
                md.append_line("## " + failures + " failed");
                md.append_line("Run time " + time + " seconds");
            else
                md.append_line("# ✔️ Success");
                md.append_line("## " + tests + "/" + tests + " tests passed");
                md.append_line("Run time " + time + " seconds");
            fi

            return md.toString();
        si
        
        get_text_description() -> String is
            let md = new MARKDOWN();

            for tc in test_cases do
                if tc.failures.Length != 0 then
                    tc.append_to(md);
                fi
            od

            for tc in test_cases do
                if tc.failures.Length == 0 then
                    tc.append_to(md);
                fi
            od            

            return md.toString();
        si
    si

    class MARKDOWN is
        buffer: StringBuffer;

        init() is
            buffer = new StringBuffer();
        si

        toString() -> String => buffer;

        append(text: String) is
            buffer.append(text);
        si

        append_line() is
            if buffer.Length > 0 && buffer[buffer.Length-1] != '\n' then
                buffer.append('\n');
            fi

            buffer.append('\n');
        si

        append_line(text: String) is
            buffer.append(text);

            if text.Length < 1 || text[text.Length-1] != '\n' then
                buffer.append('\n');
            fi

            buffer.append('\n');
        si

        append_half_line(text: String) is
            buffer.append(text);

            if text.Length < 1 || text[text.Length-1] != '\n' then
                buffer.append('\n');
            fi
        si

        ensure_new_line() is
            if buffer.Length > 0 && buffer[buffer.Length-1] != '\n' then
                buffer.append('\n');
            fi
        si

        append_on_new_line(text: String) is
            if buffer.Length > 0 && buffer[buffer.Length-1] != '\n' then
                buffer.append('\n');
            fi

            buffer.append(text);
        si

        append_failed_mark() is
            buffer
                .append("### ❌ Failed: ");
        si

        append_success_mark() is
            buffer
                .append("### ✔️ Passed: ");
        si

        enter_details(is_open: bool) is       
            if is_open then
                append_line("<details open>");
            else
                append_line("<details>");
            fi
        si

        leave_details() is
            append_line("</details>");
        si
        

        enter_code() is
            append_on_new_line("\`\`\`\n");
        si
        
        leave_code() is
            append_on_new_line("\`\`\`\n");
        si
    si
    
    class TEST_CASE is
        name: String;
        classname: String;
        failures: List[FAILURE];
        time: DURATION;
        std_out: String;
        std_err: String;

        init(
            name: String,
            classname: String,
            failures: List[FAILURE],
            time: int,
            std_out: String,
            std_err: String
        ) is
            self.name = name;
            self.classname = classname;
            self.failures = failures;
            self.time = new DURATION(time);
            self.std_out = std_out;
            self.std_err = std_err;
        si

        append_to(md: MARKDOWN) is
            let is_failed = failures? && failures.Length > 0;
            let has_build_out = std_err? && std_err.Length > 0;
            let has_run_out = std_out? && std_out.Length > 0;

            let result = new StringBuffer();

            if is_failed then
                md.append_failed_mark();

                md.append_line(name);
            else 
                md.append_success_mark();

                md.append_line(name);
            fi

            if is_failed then
                md.enter_details(true);

                for f in failures do
                    f.append_to(md);
                od

            elif has_build_out || has_run_out then
                md.enter_details(false); 
            fi

            if std_err? && std_err.Length > 0 then
                md.append_line("#### Build output");

                md.enter_code();

                md.append_line(std_err);

                md.leave_code();
            fi
            
            if std_out? && std_out.Length > 0 then
                md.append_line("#### Test output");

                md.enter_code();

                md.append_line(std_out);

                md.leave_code();
            fi

            if is_failed || has_build_out || has_run_out then
                md.leave_details();
            fi
        si
    si

    class FAILURE is
        message: String;
        type: String;

        init(message: String, type: String) is
            self.message = message;
            self.type = type;

            if
                message == null || message.Length == 0 ||
                type == null || type.Length == 0
            then
                throw new Exception("incomplete failure");
            fi
        si
        
        append_to(md: MARKDOWN) -> String is
            md.append_line("#### " + type);

            if message? && message.Length > 0 then
                md.enter_code();
                md.append_half_line(message);
                md.leave_code();
            fi            
        si
    si  
si