namespace Tester is
    use System; 
    use Generic;
    
    class Main is
        init() is
            IO.Std.err.FlushOnPrintln = true;

            let cases_root = "cases/";

            let test_cases = new Vector[TEST_CASE]();

            let timer = new TIMER();

            let to_run = new Vector[String]();

            for f in new IO.DIRECTORY(cases_root) do
                let stat = new IO.Stat();

                if
                    stat.stat(cases_root + f + "/ghulflags") &&
                    !stat.stat(cases_root + f + "/disabled")
                then
                    to_run.add(f);
                fi
            od

            cast Sort[String](null).sort(to_run);

            for i in 0..to_run.Length do
                let f = to_run[i];

                IO.Std.err.println("run test case %/%: %..." % [i + 1, to_run.Length, f]);

                let runner = new TEST_RUNNER(f, cases_root + f + "/");
                
                test_cases.add(runner.test());
                
                i = i + 1;
            od

            let duration = timer.elapsed_milli_seconds;

            let result = new TEST_SUITE(
                "integration",
                "integration",
                "integration",
                test_cases,
                duration
            );

            let result_file = IO.File.openCreate("../results/junit.xml");

            result_file.println(result);

            result_file.close();

            if result.failures > 0 then
                System.Exit.exit(1);
            else
                System.Exit.exit(0);                
            fi
        si
    si

    class XML is
        escape(value: String) -> String static is
            let result = new StringBuffer();
            
            for c in value do
                case c
                when '<':
                    result.append("&lt;");

                when '>':
                    result.append("&gt;");

                when '&':
                    result.append("&amp;");

                when cast char(39):
                    result.append("&apos;");

                when cast char(34):
                    result.append("&quot;");
                
                default
                    result.append(c);
                
                esac                
            od

            return result;
        si
    si
    
    class TIMER is
        start_time: long;

        elapsed_micro_seconds: long is
            return cast long(native.__get_micro_time()) - start_time;
        si
        
        elapsed_milli_seconds: int is
            return cast int(elapsed_micro_seconds/1000L);
        si
        
        init() is
            restart();
        si
        
        restart() is
            start_time = cast long(native.__get_micro_time());
        si
    si
    
    class DURATION is
        milliseconds: int;

        init(milliseconds: int) is
            self.milliseconds = milliseconds;
        si

        toString() -> String is
            let result = new StringBuffer();

            result.append(milliseconds / 1000);
            result.append('.');
            result.append(cast int(milliseconds % 1000), 10, 3, '0');

            return result;
        si
    si

    class TEST_SUITES is
        duration: DURATION;

        test_suites: Iterable[TEST_SUITE];

        init(
            duration: int,
            test_suites: Iterable[TEST_SUITE]
        ) is
            self.duration = new DURATION(duration);
            self.test_suites = test_suites;
        si        

        toString() -> String is
            let result = new StringBuffer();

            result
                .append("<testsuites duration=\"")
                .append(duration)
                .append("\">");

            for ts in test_suites do
                result
                    .append(ts);
            od

            result
                .append("</testsuites>\n");
            
            return result;                
        si
    si

    class TEST_SUITE is
        id: String;
        failures: int;
        name: String;
        package: String;
        tests: int;
        time: DURATION;

        test_cases: Iterable[TEST_CASE];

        init(
            id: String,
            name: String,
            package: String,
            test_cases: Iterable[TEST_CASE],
            time: int
        ) is
            self.id = id;
            self.name = name;
            self.package = package;
            self.test_cases = test_cases;
            self.time = new DURATION(time);

            for tc in test_cases do
                tests = tests + 1;

                for f in tc.failures do
                    failures = failures + 1;
                od                
            od            
        si

        toString() -> String is
            let result = new StringBuffer();

            result
                .append("<testsuite id=\"")
                .append(XML.escape(id))
                .append("\" failures=\"")
                .append(failures)
                .append("\" name=\"")
                .append(XML.escape(name))
                .append("\" package=\"")
                .append(XML.escape(package))
                .append("\" tests=\"")
                .append(tests)
                .append("\" time=\"")
                .append(time)
                .append("\">\n");
                
            for tc in test_cases do
                result
                    .append(tc);
            od

            result
                .append("</testsuite>\n");

            return result;
        si
    si

    class TEST_CASE is
        //      <testcase classname="tests/suites/casper/agent" name="Default user agent matches /CasperJS/" time="0.103"/>
        classname: String;
        failures: Iterable[FAILURE];
        id: String;
        name: String;
        time: DURATION;

        init(
            classname: String,
            failures: Iterable[FAILURE],
            id: String,
            name: String,
            time: int
        ) is
            self.classname = classname;
            self.failures = failures;
            self.id = id;
            self.name = name;
            self.time = new DURATION(time);   
        si        

        toString() -> String is
            let result = new StringBuffer();

            result
                .append("<testcase classname=\"")
                .append(XML.escape(classname))
                .append("\" id=\"")
                .append(XML.escape(id))
                .append("\" name=\"")
                .append(name)
                .append("\" time=\"")
                .append(time)
                .append("\">\n");

            if failures? then
                for f in failures do
                    result.append(f);
                od                  
            fi

            result
                .append("</testcase>\n");

            return result;
        si
    si

    class FAILURE is
        message: String;
        type: String;

        init(message: String, type: String) is
            self.message = message;
            self.type = type;

            if
                message == null || message.Length == 0 ||
                type == null || type.Length == 0
            then
                throw new Exception("incomplete failure");
            fi
        si
        
        toString() -> String is
            let result = new StringBuffer();

            result
                .append("<failure type=\"")
                .append(XML.escape(type))
                .append("\">\n");
            
            if message? && message.Length > 0 then
                result
                    .append(XML.escape(message));

                if !message.endsWith('\n') then
                    result.append('\n');
                fi
            fi

            result.append("</failure>\n");

            return result;
        si
    si  
si