namespace Tester is
    use System;
    use Generic;
    
    class TEST_RUNNER is
        name: String;
        classname: String;

        root: String;
        directory: String;

        dup2(from: int, to: int) -> int native;
        close(handle: int) native;

        init(name: String, classname: String, directory: String) is
            self.name = name;
            self.classname = classname;
            self.directory = directory;
        si

        file_exists(path: String) -> bool is
            let stat = new IO.Stat();

            return stat.stat(path);
        si

        files_matching(path: String, extension: String) -> Iterable[String] is
            let result = new Vector[String]();

            for f in new IO.DIRECTORY(path) do
                if f.endsWith(extension) then
                    result.add(f);
                fi
            od

            return result;
        si
        
        wait_status(wait_result: int) -> int is
            return 
                (wait_result & 0xFF00) >> 8;
        si

        wait_exited(wait_result: int) -> bool is
            return
                (wait_result & 0xFF) == 0;
        si

        wait_failed(wait_result: int) -> bool is
            return
                !wait_exited(wait_result) ||
                wait_status(wait_result) != 0;
        si

        test() -> TEST_CASE is
            let cwd = IO.File.WorkingDirectory;

            try
                native.chdir(directory.toCString());

                return _test();
            finally
                native.chdir(cwd.toCString());
            yrt            
        si

        _test() -> TEST_CASE is
            let timer = new TIMER();
            let failures = new Vector[FAILURE]();

            IO.Std.err.FlushOnPrintln = true;

            let p = new Util.Process();

            let binary_path = "./binary";

            let errors_expected_path = "err.expected";
            let warnings_expected_path = "warn.expected";
            let il_expected_path = "il.expected";
            let run_expected_path = "run.expected";

            let build_out_path = "compiler.out";
            let run_out_path = "run.out";

            let errors_out_path = "err.out";
            let warnings_out_path = "warn.out";
            let il_out_path = "il.out";

            let errors_sort_path = "err.sort";
            let warnings_sort_path = "warn.sort";

            let errors_diff_path = "err.diff";
            let warnings_diff_path = "warn.diff";
            let il_diff_path = "il.diff";
            let run_diff_path = "run.diff";

            let failed_marker_path = "failed";

            let fail_expected = file_exists("fail.expected");

            var std_out: String;
            var std_err: String;

            if p.fork() then
                let ghul_args = new Vector[String](["ghul"]);

                ghul_args.add(get_ghul_options());

                ghul_args.add(["-o", binary_path]);

                for f in files_matching(".", ".ghul") do
                    ghul_args.add(f);
                od
                
                // IO.Std.err.println(ghul_args.toString().replace(',', ' '));

                let out = IO.File.openWriteStream("/dev/null");
                let err = IO.File.openCreateStream(build_out_path);

                dup2(out.Handle, 1);
                close(out.Handle);
                dup2(err.Handle, 2);
                close(err.Handle);

                p.spawn("ghul", ghul_args.Array, System.Arguments.ProgramEnvironment);

                throw new Exception("spawn failed");
            fi

            std_err = read_all(build_out_path);
            
            let build_wait_result = p.wait();

            if wait_failed(build_wait_result) then
                if !file_exists(build_out_path) then
                    IO.Std.err.println("no compiler output present: giving up");

                    failures.add(
                        new FAILURE("build failed with no output", "build")
                    );
                elif !fail_expected then
                    failures.add(
                        new FAILURE("unexpected build failure", "build")
                    );
                fi
            elif !file_exists(binary_path) then
                if !fail_expected then
                    IO.Std.err.println("no binary: " + binary_path);
                    failures.add(
                        new FAILURE("unexpected build failure", "build")
                    );
                fi
            elif fail_expected then
                IO.Std.err.println("unexpected binary: " + binary_path);
                failures.add(
                    new FAILURE("unexpected build success", "build")
                );
            else
                if p.fork() then
                    let out = IO.File.openCreateStream(run_out_path);
    
                    dup2(out.Handle, 1);
                    dup2(out.Handle, 2);
                    close(out.Handle);

                    p.spawn(binary_path, ["binary"], System.Arguments.ProgramEnvironment);

                    throw new Exception("spawn failed");
                fi

                let run_wait_result = p.wait();

                std_out = read_all(run_out_path);
                
                if !file_exists(run_out_path) then
                    failures.add(
                        new FAILURE("no output file found", "run")
                    );
                else
                    let run_diff_result = !diff(run_expected_path, run_out_path, run_diff_path, false);

                    add_diff_failure(
                        failures,
                        run_diff_result,
                        "test output mismatch",
                        run_diff_path
                    );
                fi
            fi

            grep(build_out_path, errors_out_path, "error:");
            grep(build_out_path, warnings_out_path, "warn:");

            sort(errors_out_path, errors_sort_path);
            sort(warnings_out_path, warnings_sort_path);

            let errors_diff_result = !diff(errors_expected_path, errors_sort_path, errors_diff_path, false);
            let warnings_diff_result = !diff(warnings_expected_path, warnings_sort_path, warnings_diff_path, false);

            let il_diff_result = true;
            
            il_diff_result = file_exists(il_expected_path) && !diff(il_expected_path, il_out_path, il_diff_path, true);

            add_diff_failure(
                failures,
                errors_diff_result,
                "compiler error mismatch",
                errors_diff_path
            );

            add_diff_failure(
                failures,
                warnings_diff_result,
                "compiler warning mismatch",
                warnings_diff_path
            );

            add_diff_failure(
                failures,
                il_diff_result,
                "IL output mismatch",
                il_diff_path
            );

            if failures.Length == 0 then
                IO.File.deleteQuiet(build_out_path);
                IO.File.deleteQuiet(run_out_path);
    
                IO.File.deleteQuiet(errors_out_path);
                IO.File.deleteQuiet(warnings_out_path);
                IO.File.deleteQuiet(il_out_path);
    
                IO.File.deleteQuiet(errors_sort_path);
                IO.File.deleteQuiet(warnings_sort_path);
    
                IO.File.deleteQuiet(errors_diff_path);
                IO.File.deleteQuiet(warnings_diff_path);
                IO.File.deleteQuiet(il_diff_path);
                IO.File.deleteQuiet(run_diff_path);

                IO.File.deleteQuiet(failed_marker_path);

                IO.File.deleteQuiet(binary_path);
                IO.File.deleteQuiet(binary_path + ".bc");
                IO.File.deleteQuiet(binary_path + ".lh");
                else
                IO.File.openCreateStream(failed_marker_path).close();
            fi

    
            let elapsed = timer.elapsed_milli_seconds;

            return
                new TEST_CASE(
                    name,
                    classname,
                    failures,
                    elapsed,
                    std_out,
                    std_err
                );                    
        si

        add_diff_failure(
            list: List[FAILURE],
            is_failed: bool,
            type: String,
            path: String
        )
        is
            if is_failed then
                if file_exists(path) then
                    let message = IO.File.openRead(path).readAll();

                    list.add(
                        new FAILURE(
                            message,
                            type
                        )
                    );
                else
                    list.add(
                        new FAILURE(
                            "no diff file present",
                            type
                        )
                    );                
                fi
            fi
        si        

        grep(in_path: String, out_path: String, pattern: String) -> bool is
            let p = new Util.Process();

            if p.fork() then
                let err = IO.File.openCreateStream(out_path);

                dup2(err.Handle, 1);
                close(err.Handle);
                
                p.spawn("grep", ["grep", pattern, in_path], System.Arguments.ProgramEnvironment);                                
            else
                let result = p.wait();

                return !wait_failed(result);
            fi
        si

        sort(in_path: String, out_path: String) -> bool is
            let p = new Util.Process();

            if p.fork() then
                let err = IO.File.openCreateStream(out_path);

                dup2(err.Handle, 1);
                
                p.spawn("sort", ["sort", in_path], System.Arguments.ProgramEnvironment);                                
            else
                let result = p.wait();

                return !wait_failed(result);
            fi
        si        

        diff(expected_path: String, actual_path: String, out_path: String, ignore_space_changes: bool) -> bool is
            let p = new Util.Process();

            if
                !file_exists(expected_path)
            then
                IO.Std.err.println("expected file missing: " + expected_path);

                IO.File.openCreateStream(expected_path).close();
            fi

            if
                !file_exists(actual_path)
            then
                IO.Std.err.println("actual file missing: " + actual_path);
                return false;
            fi
            
            if p.fork() then
                let err = IO.File.openCreateStream(out_path);

                dup2(err.Handle, 1);

                let args: String[];

                if ignore_space_changes then
                    args = ["diff", "-b", expected_path, actual_path];
                else
                    args = ["diff", expected_path, actual_path];
                fi
                
                
                p.spawn("diff", args, System.Arguments.ProgramEnvironment);
                                
            else
                let wait_result = p.wait();

                if !wait_exited(wait_result) then
                    IO.Std.err.println("diff process failed");
                    return false;
                fi

                let result = wait_status(wait_result);

                if result != 0 then
                    IO.Std.err.println("actual differs from expected");
                    IO.Std.err.println(out_path + ": " + IO.File.openRead(out_path).readAll());
                fi
                
                return result == 0;
            fi
        si

        read_all(path: String) -> String is
            if file_exists(path) then
                return IO.File.openRead(path).readAll();
            else
                return "";    
            fi
        si
        

        get_ghul_options() -> Generic.Iterable[String] is
            let result = new Vector[String]();

            let options_reader = IO.File.openRead("ghulflags");
            
            let options_string = options_reader.readAll();

            for o in options_string.split(' ') do
                result.add(o.trim());
            od

            return result;
        si
    si
si
