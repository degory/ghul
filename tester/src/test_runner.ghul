namespace Tester is
    use System;
    use Generic;
    
    class TEST_RUNNER is
        name: String;
        path: String;

        dup2(from: int, to: int) -> int native;
        close(handle: int) native;

        init(name: String, path: String) is
            self.name = name;
            self.path = path;
        si

        test() -> TEST_CASE is
            let failures = new Vector[FAILURE]();

            let timer = new TIMER();

            failures.add(build());

            let elapsed = timer.elapsed_milli_seconds;

            return
                new TEST_CASE(name, failures, name, name, elapsed);
        si

        file_exists(path: String) -> bool is
            let stat = new IO.Stat();

            return stat.stat(path);
        si

        wait_status(wait_result: int) -> int is
            return 
                (wait_result & 0xFF00) >> 8;
        si

        wait_exited(wait_result: int) -> bool is
            return
                (wait_result & 0xFF) == 0;
        si

        wait_failed(wait_result: int) -> bool is
            return
                !wait_exited(wait_result) ||
                wait_status(wait_result) != 0;
        si

        build() -> Iterable[FAILURE] is
            let failures = new Vector[FAILURE]();

            IO.Std.err.FlushOnPrintln = true;

            let p = new Util.Process();

            let binary_path = path + "binary";

            let errors_expected_path = path + "err.expected";
            let warnings_expected_path = path + "warn.expected";
            let run_expected_path = path + "out.expected";

            let build_out_path = path + "compiler.out";
            let run_out_path = path + "run.out";

            let errors_out_path = path + "err.out";
            let warnings_out_path = path + "warn.out";

            let errors_sort_path = path + "err.sort";
            let warnings_sort_path = path + "warn.sort";

            let errors_diff_path = path + "err.diff";
            let warnings_diff_path = path + "warn.diff";
            let run_diff_path = path + "run.diff";

            let fail_expected = file_exists(path + "fail.expected");

            if p.fork() then
                let ghul_args = new Vector[String](["ghul", "-D", "-L"]);

                ghul_args.add(get_ghul_options());

                ghul_args.add(["-o", binary_path]);

                ghul_args.add("cases/" + name + "/test.ghul");

                IO.Std.err.println(ghul_args.toString().replace(',', ' '));

                // let out = IO.File.openWriteStream("/dev/null");
                let err = IO.File.openCreateStream(build_out_path);

                // dup2(out.Handle, 1);
                // close(out.Handle);
                if dup2(err.Handle, 2) != 2 then
                    IO.Std.out.println("oops: dup2 probably failed: " + cast int(native.__geterrno()));
                fi

                close(err.Handle);

                IO.Std.err.println("this should go to stderr...");

                p.spawn("/home/degory/ghul/ghul", ghul_args.Array, System.Arguments.ProgramEnvironment);

                throw new Exception("spawn failed");
            fi

            let build_wait_result = p.wait();

            if wait_failed(build_wait_result) then
                if !file_exists(build_out_path) then
                    IO.Std.err.println("no compiler output present: giving up");

                    return [
                        new FAILURE("build failed with no output", "build")
                    ];
                elif !fail_expected then
                    failures.add(
                        new FAILURE("unexpected build failure", "build")
                    );
                fi
            elif !file_exists(binary_path) then
                if !fail_expected then
                    IO.Std.err.println("no binary: " + binary_path);
                    failures.add(
                        new FAILURE("unexpected build failure", "build")
                    );
                fi
            elif fail_expected then
                IO.Std.err.println("unexpected binary: " + binary_path);
                failures.add(
                    new FAILURE("unexpected build success", "build")
                );
            else
                IO.Std.err.println("build succeeded, running test");
                if p.fork() then
                    let out = IO.File.openCreateStream(run_out_path);
    
                    dup2(out.Handle, 1);
                    dup2(out.Handle, 2);
                    close(out.Handle);
    
                    p.spawn(binary_path, ["binary"], System.Arguments.ProgramEnvironment);

                    throw new Exception("spawn failed");
                fi

                let run_wait_result = p.wait();
                
                if !file_exists(run_out_path) then
                    failures.add(
                        new FAILURE("no output file found", "run")
                    );
                else
                    let run_diff_result = !diff(run_expected_path, run_out_path, run_diff_path);

                    add_diff_failure(
                        failures,
                        run_diff_result,
                        "test output mismatch",
                        run_diff_path
                    );
                fi
            fi

            grep(build_out_path, errors_out_path, "error:");
            grep(build_out_path, warnings_out_path, "warn:");

            sort(errors_out_path, errors_sort_path);
            sort(warnings_out_path, warnings_sort_path);

            let errors_diff_result = !diff(errors_expected_path, errors_sort_path, errors_diff_path);
            let warnings_diff_result = !diff(warnings_expected_path, warnings_sort_path, warnings_diff_path);

            add_diff_failure(
                failures,
                errors_diff_result,
                "compiler error mismatch",
                errors_diff_path
            );

            add_diff_failure(
                failures,
                warnings_diff_result,
                "compiler warning mismatch",
                warnings_diff_path
            );

            if failures.Length == 0 then
                IO.File.deleteQuiet(build_out_path);
                IO.File.deleteQuiet(run_out_path);
    
                IO.File.deleteQuiet(errors_out_path);
                IO.File.deleteQuiet(warnings_out_path);
    
                IO.File.deleteQuiet(errors_sort_path);
                IO.File.deleteQuiet(warnings_sort_path);
    
                IO.File.deleteQuiet(errors_diff_path);
                IO.File.deleteQuiet(warnings_diff_path);
                IO.File.deleteQuiet(run_diff_path);

                IO.File.deleteQuiet(binary_path);                
            fi

            return failures;
        si

        add_diff_failure(
            list: List[FAILURE],
            is_failed: bool,
            type: String,
            path: String
        )
        is
            if is_failed then
                if file_exists(path) then
                    let message = IO.File.openRead(path).readAll();

                    list.add(
                        new FAILURE(
                            message,
                            type
                        )
                    );
                else
                    let message = IO.File.openRead(path).readAll();

                    list.add(
                        new FAILURE(
                            "no diff file present",
                            type
                        )
                    );                
                fi
            fi
        si        

        grep(in_path: String, out_path: String, pattern: String) -> bool is
            let p = new Util.Process();

            if p.fork() then
                let err = IO.File.openCreateStream(out_path);

                dup2(err.Handle, 1);
                close(err.Handle);
                
                p.spawn("grep", ["grep", pattern, in_path], System.Arguments.ProgramEnvironment);                                
            else
                let result = p.wait();

                return !wait_failed(result);
            fi
        si

        sort(in_path: String, out_path: String) -> bool is
            let p = new Util.Process();

            if p.fork() then
                let err = IO.File.openCreateStream(out_path);

                dup2(err.Handle, 1);
                
                p.spawn("sort", ["sort", in_path], System.Arguments.ProgramEnvironment);                                
            else
                let result = p.wait();

                return !wait_failed(result);
            fi
        si        

        diff(expected_path: String, actual_path: String, out_path: String) -> bool is
            let p = new Util.Process();

            if
                !file_exists(expected_path)
            then
                IO.Std.err.println("expected file missing: " + expected_path);
                return false;
            fi

            if
                !file_exists(actual_path)
            then
                IO.Std.err.println("actual file missing: " + actual_path);
                return false;
            fi
            
            if p.fork() then
                let err = IO.File.openCreateStream(out_path);

                dup2(err.Handle, 1);
                
                p.spawn("diff", ["diff", expected_path, actual_path], System.Arguments.ProgramEnvironment);
                                
            else
                let wait_result = p.wait();

                if !wait_exited(wait_result) then
                    IO.Std.err.println("diff process failed");
                    return false;
                fi

                let result = wait_status(wait_result);

                if result != 0 then
                    IO.Std.err.println("actual differs from expected");
                    IO.Std.err.println(out_path + ": " + IO.File.openRead(out_path).readAll());
                fi
                
                return result == 0;
            fi
        si

        get_ghul_options() -> Generic.Iterable[String] is
            let result = new Vector[String]();

            let options_reader = IO.File.openRead(path + "ghulflags");
            
            let options_string = options_reader.readAll();

            for o in options_string.split(' ') do
                result.add(o.trim());
            od

            return result;
        si
    si
si
