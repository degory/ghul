namespace Tester is
    use System;
    use Generic;
    
    class TEST_RUNNER is
        name: String;
        path: String;

        dup2(from: int, to: int) -> int native;

        init(name: String, path: String) is
            self.name = name;
            self.path = path;
        si

        test() -> TEST_CASE is
            let failures = new Vector[FAILURE]();

            let timer = new TIMER();

            failures.add(build());

            let elapsed = timer.elapsed_milli_seconds;

            return
                new TEST_CASE(name, failures, name, name, elapsed);
        si

        file_exists(path: String) -> bool is
            let stat = new IO.Stat();

            return stat.stat(path);
        si

        wait_status(wait_result: int) -> int is
            return 
                (wait_result & 0xFF00) >> 8;
        si

        wait_exited(wait_result: int) -> bool is
            return
                (wait_result & 0xFF) == 0;
        si

        wait_failed(wait_result: int) -> bool is
            return
                !wait_exited(wait_result) ||
                wait_status(wait_result) != 0;
        si

        build() -> Iterable[FAILURE] is
            let failures = new Vector[FAILURE]();

            IO.Std.err.FlushOnPrintln = true;

            let p = new Util.Process();

            let errors_expected_path = path + "err.expected";
            let warnings_expected_path = path + "warn.expected";

            let compiler_out_path = path + "compiler.out";

            let errors_out_path = path + "err.out";
            let warnings_out_path = path + "warn.out";

            let errors_diff_path = path + "err.diff";
            let warnings_diff_path = path + "warn.diff";

            if p.fork() then
                let ghul_args = new Vector[String](["ghul", "-D"]);

                ghul_args.add(get_ghul_options());

                ghul_args.add("cases/" + name + "/test.ghul");

                let err = IO.File.openCreateStream(compiler_out_path);

                dup2(err.Handle, 2);

                p.spawn("/home/degory/ghul/ghul", ghul_args.Array, System.Arguments.ProgramEnvironment);                
            else
                let result = p.wait();

                IO.Std.err.println("build: result is: " + result);

                if wait_failed(result) then
                    if !file_exists(compiler_out_path) then
                        IO.Std.err.println("no compiler output present: giving up");

                        return [
                            new FAILURE("build failed with no output", "build failed")
                        ];
                    fi
                fi

                grep(compiler_out_path, errors_out_path, "error:");
                grep(compiler_out_path, warnings_out_path, "warn:");

                let errors_diff_result = !diff(errors_expected_path, errors_out_path, errors_diff_path);
                let warnings_diff_result = !diff(warnings_expected_path, warnings_out_path, warnings_diff_path);

                add_diff_failure(
                    failures,
                    errors_diff_result,
                    "compiler error mismatch",
                    errors_diff_path
                );

                add_diff_failure(
                    failures,
                    warnings_diff_result,
                    "compiler warning mismatch",
                    warnings_diff_path
                );

                return failures;
            fi
        si

        add_diff_failure(
            list: List[FAILURE],
            is_failed: bool,
            type: String,
            path: String
        )
        is
            if is_failed then
                if file_exists(path) then
                    let message = IO.File.openRead(path).readAll();

                    list.add(
                        new FAILURE(
                            message,
                            type
                        )
                    );
                else
                    let message = IO.File.openRead(path).readAll();

                    list.add(
                        new FAILURE(
                            "no diff file present",
                            type
                        )
                    );                
                fi
            fi
        si        

        grep(in_path: String, out_path: String, pattern: String) -> bool is
            IO.Std.err.println("grep for '" + pattern + "' in: " + in_path);

            let p = new Util.Process();

            if p.fork() then
                let err = IO.File.openCreateStream(out_path);

                dup2(err.Handle, 1);
                
                p.spawn("grep", ["grep", pattern, in_path], System.Arguments.ProgramEnvironment);                                
            else
                let result = p.wait();

                IO.Std.err.println("grep result: " + IO.File.openRead(out_path).readAll());

                return !wait_failed(result);
            fi
        si

        diff(expected_path: String, actual_path: String, out_path: String) -> bool is
            let p = new Util.Process();

            if
                !file_exists(expected_path)
            then
                IO.Std.err.println("expected file missing: " + expected_path);
                return false;
            fi

            if
                !file_exists(actual_path)
            then
                IO.Std.err.println("actual file missing: " + actual_path);
                return false;
            fi
            
            if p.fork() then
                let err = IO.File.openCreateStream(out_path);

                dup2(err.Handle, 1);
                
                p.spawn("diff", ["diff", expected_path, actual_path], System.Arguments.ProgramEnvironment);
                                
            else
                let wait_result = p.wait();

                if !wait_exited(wait_result) then
                    IO.Std.err.println("diff process failed");
                    return false;
                fi

                let result = wait_status(wait_result);

                if result == 0 then
                    IO.Std.err.println("actual matches expected");
                else
                    IO.Std.err.println("actual differs from expected");
                fi
                
                return result == 0;
            fi
        si

        get_ghul_options() -> Generic.Iterable[String] is
            let result = new Vector[String]();

            let options_reader = IO.File.openRead(path + "ghulflags");
            
            let options_string = options_reader.readAll();

            for o in options_string.split(' ') do
                result.add(o.trim());
            od

            return result;
        si
    si
si
