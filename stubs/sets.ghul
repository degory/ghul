namespace Collections is    
    @IL.name("System.Collections.Generic.Set`1")
    trait Set[T]: Bag[T],Iterable[T] is
        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Iterable[T]) -> bool;

        @IL.name("IsSubsetOf")
        is_subset_of(other: Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Iterable[T]) -> bool;
    si

    @IL.name("System.Collections.Generic.ISet`1")
    trait MutableSet[T]: MutableBag[T],Iterable[T] is
        @IL.name("Add")
        add(item: T) -> bool;

        @IL.name("UnionWith")
        union_with(other: Iterable[T]);

        @IL.name("IntersectWith")
        intersect_with(other: Iterable[T]);

        @IL.name("ExceptWith")
        except_with(other: Iterable[T]);

        @IL.name("SymmetricExceptWith")
        symmetric_except_with(other: Iterable[T]);

        @IL.name("IsSubsetOf")
        is_subset_of(other: Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Iterable[T]) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Iterable[T]) -> bool;
    si

    @IL.name("System.Collections.Generic.HashSet`1")
    class SET[T]:
        MutableBag[T],Iterable[T],MutableSet[T],Bag[T],Set[T]
    is
        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("Remove")
        remove(item: T) -> bool;

        @IL.name.read("GetEnumerator")
        iterator: Iterator[T];

        @IL.name("Add")
        add(item: T) -> bool;

        @IL.name("TryGetValue")
        try_get_value(equal_value: T, actual_value: T ref) -> bool;

        @IL.name("UnionWith")
        union_with(other: Iterable[T]);

        @IL.name("IntersectWith")
        intersect_with(other: Iterable[T]);

        @IL.name("ExceptWith")
        except_with(other: Iterable[T]);

        @IL.name("SymmetricExceptWith")
        symmetric_except_with(other: Iterable[T]);

        @IL.name("IsSubsetOf")
        is_subset_of(other: Iterable[T]) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Iterable[T]) -> bool;

        @IL.name("CopyTo")
        copy_to(array: T[]);

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int);

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int, count: int);

        @IL.name("RemoveWhere")
        remove_where(match: PREDICATE[T]) -> int;

        @IL.name("EnsureCapacity")
        ensure_capacity(capacity: int) -> int;

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("CreateSetComparer")
        create_set_comparer() -> EqualityComparer[SET[T]] static;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        hash() -> int;

        @IL.name(".ctor")
        init();

        @IL.name(".ctor")
        init(comparer: EqualityComparer[T]);

        @IL.name(".ctor")
        init(capacity: int);

        @IL.name(".ctor")
        init(collection: Iterable[T]);

        @IL.name(".ctor")
        init(collection: Iterable[T], comparer: EqualityComparer[T]);

        @IL.name(".ctor")
        init(capacity: int, comparer: EqualityComparer[T]);

        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Comparer") 
        comparer: EqualityComparer[T];
    si
si
