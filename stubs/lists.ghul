namespace Collections is
    use System;
    use Ghul;
        
    @IL.name("System.Collections.Generic.IReadOnlyList`1")
    trait List[T]: Bag[T],Iterable[T] is
        @IL.name.read("get_Item") 
        [index: int]: T,;
    si

    @IL.name("System.Collections.Generic.IList`1")
    trait MutableList[T]: MutableBag[T],Iterable[T] is
        @IL.name("IndexOf")
        index_of(item: T) -> int;

        @IL.name("Insert")
        insert(index: int, item: T);

        @IL.name("RemoveAt")
        remove_at(index: int);

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [index: int]: T, = value;
    si

    class LIST_ITERATOR[T] is
        _list: LIST[T];
        _index: int;

        init(list: LIST[T]) is
            _list = list;
            _index = -1;
        si

        current: T => _list[_index];

        move_next() -> bool is
            _index = _index + 1;

            return _index < _list.count;
        si
		
		// L compatibility:
		hasMoreElements() -> bool => _index + 1 < _list.count;

		nextElement() -> T is
			move_next();

			return current;
		si		
    si
    
    @IL.name("System.Collections.Generic.List`1")
    class LIST[T: System.IEquatable[T]]: System.Object,MutableList[T],MutableBag[T],Iterable[T],List[T],Bag[T] is
        _list: T[];
		_count: int;
		
        @IL.name("Add")
        add(item: T) is
            _reserve(_count + 1);
            _list[_count] = item;
            _count = _count + 1;
        si
        
        @IL.name("AddRange")
        add_range(collection: Iterable[T]) is
            for v in collection do
                add(v);
            od
        si        

        @IL.name("AsReadOnly")
        as_read_only() -> Bag[T];

        @IL.name("BinarySearch")
        binary_search(index: int, count: int, item: T, comparer: Comparer[T]) -> int;

        @IL.name("BinarySearch")
        binary_search(item: T) -> int;

        @IL.name("BinarySearch")
        binary_search(item: T, comparer: Comparer[T]) -> int;

        @IL.name("Clear")
        clear() is _count = 0; si

        @IL.name("Contains")
        contains(item: T) -> bool => index_of(item) >= 0;

        // convert_all[TOutput](converter: System.Converter[T,TOutput]) -> LIST[TOutput];

        @IL.name("CopyTo")
        copy_to(array: T[]);

        @IL.name("CopyTo")
        copy_to(index: int, array: T[], array_index: int, count: int);

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int);

        @IL.name("Exists")
        exists(match: PREDICATE[T]) -> bool;

        @IL.name("Find")
        find(match: PREDICATE[T]) -> T;

        @IL.name("FindAll")
        find_all(match: PREDICATE[T]) -> LIST[T];

        @IL.name("FindIndex")
        find_index(match: PREDICATE[T]) -> int;

        @IL.name("FindIndex")
        find_index(start_index: int, match: PREDICATE[T]) -> int;

        @IL.name("FindIndex")
        find_index(start_index: int, count: int, match: PREDICATE[T]) -> int;

        @IL.name("FindLast")
        find_last(match: PREDICATE[T]) -> T;

        @IL.name("FindLastIndex")
        find_last_index(match: PREDICATE[T]) -> int;

        @IL.name("FindLastIndex")
        find_last_index(start_index: int, match: PREDICATE[T]) -> int;

        @IL.name("FindLastIndex")
        find_last_index(start_index: int, count: int, match: PREDICATE[T]) -> int;

        @IL.name("ForEach")
        for_each(action: Ghul.ACTION_0[T]);

        @IL.name.read("GetEnumerator")
		iterator: Iterator[T] => new LIST_ITERATOR[T](self);

        @IL.name("GetRange")
        get_range(index: int, count: int) -> LIST[T];

        @IL.name("IndexOf")
        index_of(item: T) -> int is
			for i in 0.._count do
                if _list[i] =~ item then                    
					return i;
				fi
			od
	
			return -1;				
		si

        @IL.name("IndexOf")
        index_of(item: T, index: int) -> int;

        @IL.name("IndexOf")
        index_of(item: T, index: int, count: int) -> int;

        @IL.name("Insert")
        insert(index: int, item: T);

        @IL.name("InsertRange")
        insert_range(index: int, collection: Iterable[T]);

        @IL.name("LastIndexOf")
        last_index_of(item: T) -> int;

        @IL.name("LastIndexOf")
        last_index_of(item: T, index: int) -> int;

        @IL.name("LastIndexOf")
        last_index_of(item: T, index: int, count: int) -> int;

        @IL.name("Remove")
        remove(item: T) -> bool is
			let index = index_of(item);

			if index >= 0 then
				remove_at(index);
				return true;
			fi

			return false;
		si
		
        @IL.name("RemoveAll")
        remove_all(match: PREDICATE[T]) -> int;

        @IL.name("RemoveAt")
		remove_at(index: int) is
			_count = _count - 1;

			while index < _count do
				_list[index] = _list[index + 1];
			od			
		si		

        @IL.name("RemoveRange")
        remove_range(index: int, count: int);

        @IL.name("Reverse")
        reverse();

        @IL.name("Reverse")
        reverse(index: int, count: int);

        @IL.name("Sort")
        sort();

        @IL.name("Sort")
        sort(comparer: Comparer[T]);

        @IL.name("Sort")
        sort(index: int, count: int, comparer: Comparer[T]);

        // @IL.name("Sort")
        // sort(comparison: System.Comparison[T]);

        @IL.name("ToArray")
        to_array() -> T[];

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("TrueForAll")
        true_for_all(match: PREDICATE[T]) -> bool;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        hash() -> int;

        @IL.name(".ctor")
        init();

        @IL.name(".ctor")
        init(capacity: int) is
			super.init();

			_list = new T[](capacity);
		si
		

        @IL.name(".ctor")
        init(collection: Iterable[T]) is
			self.init();

			add_range(collection);
		si
		
        @IL.name.read("get_Capacity") @IL.name.assign("set_Capacity") 
        capacity: int => _list.length, = value is
            _reserve(value);
        si

        @IL.name.read("get_Count") 
        count: int => _count;

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [index: int]: T is
            if index < _count then
                return _list[index];
            else
                throw new BoundsException();
            fi        
        si,
        = value is
            if index < count then
                _list[index] = value;
            else
                throw new BoundsException();
            fi
        si

        _reserve( l: int) is
            let i: int;

            let new_list: T[];

            if l > _list.length then
                let new_length: int;
    
                if l < 2048 then
                    new_length = l * 2;
                else 
                    new_length = l + 1024;
                fi
    
                new_list = new T[](new_length);

                for i in 0.._list.length do
                    new_list[i] = _list[i];
                od

                _list = new_list;
            fi
        si
    
    si
si