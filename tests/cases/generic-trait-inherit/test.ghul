namespace InheritOverrideTest is
    class Bloop is
        bloop(times: int) is
            let v = new Vec[int]();

            for i in 0..times do
                v.wargle(i);
            od

            v.wargle();

            let h = new Hole[char]();

            h.wargle()
        si
    si
    

    trait Vec[L]: Hole[L] is
        wargle(value: L);
        get(index: int) -> L;
        put(index: int, value: L);
        // wargle(gloop: System.String);
    si

    trait Hole[H]: Blob[H] is
        wargle(value: H);
        put(index: int, value: H);
    si

    trait Blob[B] is
        wargle(value: B);
    si
    


    // class Main is
    //     entry() static is
    //         @IL.entrypoint()

    //         let m: MAP_PAIR_VEC[int, System.String];

    //         let p = m.get(1234);
    //         p.get_key();
    //         p.get_value();

    //         let mm: MAP[System.String, int];

    //         // Vec may not be correctly specialized here - so we have MAP's put correct but not Vec's?
    //         mm.put();

    //         let l: Vec[PAIR[System.String, int]];

    //         l = mm;

    //         // or is it that Vec _is_ correctly specialized but we've somehow also pulled the open generic Vec's wargle method into the same function group?
    //         // as this has both the correct wargle overload and an apparently unspecialized version of the same method taken from Vec:
    //         l.put()

    //         let pp = mm.get(0);

    //         let kk: System.String;
    //         kk = pp.get_key();

    //         return;
    //     si
    // si

    // class MAP[K,V]: Vec[PAIR[K,V]] is
    //     init() is
    //     si
    // si
    

    // class PAIR[K,V] is
    //     get_key() -> K public;
    //     get_value() -> V public;

    //     init(key: K, value: V) is
    //     si
        
    // si

    

    // class MAP_PAIR_VEC[KK,VV] : Vec[PAIR[KK,VV]]    
    // is
    //     get(index: int) -> PAIR[KK,VV] is
    //         // let dummy: Vec[PAIR[KK,VV]];

    //         let x: PAIR[KK,VV];

    //         let y = x.get_key();

    //         let z = new PAIR[int,int](123,456);

    //         // return z;
    //     si
        

    //     put(index: int, value: PAIR[KK,VV]);
    // si    
    
si