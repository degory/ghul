use IO.Std.write_line;

entry() is
    write_line("simple_expression_body(5) = " + simple_expression_body_1(5)); // 10
    write_line("simple_expression_body((5, 6)) = " + simple_expression_body_2((5, 6))); // 11
    recursive_anonymous_function();

    write_line("if_expression_condition_1(5) = " + if_expression_condition_1(5)); // 5 * 2 less than 10
    write_line("if_expression_condition_2(5, 6) = " + if_expression_condition_2(5, 6)); // 5 * 2 less than 10

    write_line("generator_1().take(5).to_list() = " + generator_incremental() | .take(5)); // [0, 1, 2, 3, 4]
    write_line("generator_fibonacci().take(5).to_list() = " + generator_fibonacci() | .take(5)); // [0, 1, 1, 2, 3]
    write_line("generator_factorial().take(5).to_list() = " + generator_factorial() | .take(5)); // [1, 1, 2, 6, 24]
si

simple_expression_body_1(i: int) -> int =>
    let times_2 = i * 2
    in times_2;

simple_expression_body_2(i: (int, int)) -> int =>
    let (a, b) = i
    in a + b;

recursive_anonymous_function() is
    let fib = (n: int) -> int rec =>
        let fib = rec in
        if n < 2 then
            n
        else
            fib(n - 1) + fib(n - 2);
        fi;

    for (i, f) in (0..6) | .map(i => fib(i)) .index() do
        write_line("fib(" + i + ") = " + f);
    od
si

generator_incremental() -> Collections.Iterable[int] =>
    generate(0, 
        (i: int) =>
            let next = i + 1 in (next, i)); 

generator_fibonacci() -> Collections.Iterable[int] =>
    generate((0, 1), 
        (state: (int, int)) =>
            let 
                (a, b) = state,
                next = (b, a + b)
            in (next, a));

generator_factorial() -> Collections.Iterable[int] =>
    generate((1, 1), 
        (state: (int, int)) =>
            let 
                (i, f) = state,
                next = (i + 1, f * (i + 1))
            in (next, f));

if_expression_condition_1(i: int) -> string =>
    if 
        let x = i * 2 in x < 10    
    then
        "{i} * 2 less than 10"
    else
        "{i} * 2 more than 10"
    fi;

if_expression_condition_2(i: int, j: int) -> string =>
    if 
        let x = i * 2 in x < 10    
    then
        "{i} * 2 less than 10"
    elif
        let y = j * 2 in y < 10
    then
        "{j} * 2 less than 10"
    else
        "{i} * 2 and {j} * 2 more than 10"
    fi;


class GENERATOR[T, S]: Collections.Iterator[T], Collections.Iterable[T] is
    current: T;
    iterator: Collections.Iterator[T] => self;

    _initial: S;
    _state: S;
    _generator: S -> (S, T); // given the current state, return the next state and the current value

    init(initial: S, generator: S -> (S, T)) is
        _initial = initial;
        _generator = generator;
        reset();
    si

    init() is
        reset();
    si
        
    move_next() -> bool is
        (_state, current) = _generator(_state);
        return true;
    si

    reset() is
        _state = _initial;
    si

    dispose() is
    si
si

// generator constructor helper so we don't have to specify types
generate[T, S](initial: S, generator: S -> (S, T)) -> GENERATOR[T, S] =>
    new GENERATOR[T, S](initial, generator);