
union Option[T] is
    SOME(value: T);
    NONE;
si

union Result[T, E] is
    OK(value: T);
    ERROR(error: E);
si

entry() is
    let i: int;
    let s: string;

    let any_result: Result[int, string];
    let ok_result = new Result[int,string].OK(42);
    let error_result = new Result[int,string].ERROR("error");

    ok_result = new Result[int,string].OK(50); // OK
    error_result = new Result[int,string].ERROR("fatal"); // OK

    ok_result = error_result; // expect error variable type mismatch
    error_result = ok_result; // expect error variable type mismatch

    any_result = ok_result; // OK base class assignable from derived class
    any_result = error_result; // OK base class assignable from derived class

    i = ok_result.ok; // OK
    i = error_result.ok; // expect error ok is int not string

    s = ok_result.error; // OK
    s = error_result.error; // expect error error is string not int

    let any_option: Option[int];
    let some_option = new Option[int].SOME(42);
    let none_option = new Option[int].NONE();

    some_option = new Option[int].SOME(50); // OK
    none_option = new Option[int].NONE(); // OK

    some_option = none_option; // expect error variable type mismatch
    none_option = some_option; // expect error variable type mismatch

    any_option = some_option; // OK base class assignable from derived class
    any_option = none_option; // OK base class assignable from derived class

    i = some_option.value; // OK
    i = none_option.value; // expect error value is int not void


si