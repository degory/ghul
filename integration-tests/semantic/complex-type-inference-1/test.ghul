
use Collections;

use IO.Std.write_line;

entry() is
    let f = (x: int) => object();
    // OK string is compatible with object
    f = (x: int) => "{x + 1}";

    let g = (x: int) => "{x + 1}";
    // expect error object is not compatible with string 
    g = (x: int) => object();

    // inferred type constraint should propogate down into the list:
    apply([x => x, x => x + 1], 123);

    apply([x => x, x => x], 456);

    // type variance should work across list elements:
    let ll = [(x: int) => object(), (x: int) => "{x + 1}"];
    let lm = [(x: int) => "{x + 1}", (x: int) => object()];

    // type variance should work across if branches:
    let ln = if true then
        [(x: int) => object(), (x: int) => "{x + 1}"]
    else
        [(x: int) => "{x + 1}", (x: int) => object()]
    fi;

    // and combined together with type inferrence:
    apply(
        if true then
            [x => object(), x => "{x + 1}"]
        else
            [x => "{x + 1}", x => object()]
        fi,
        123
    );

    // including where the lambda return types are
    // potentially ambigious

    let i: int;

    i = apply(
        if true then
            [x => x, x => x + 1]
        else
            [x => x * 2, x => x + 1]
        fi,
        123
    );

    i = apply([x => x, x => x, x => x], 456);

    i = apply(
        if true then
            [x => x, x => x]
        else
            [x => x, x => x]
        fi,
        123
    );

    // deliberate error to ensure we get this far
    let x: int = "hello";
si

function[T,U](v: T) -> U;

apply[T,U](f: Iterable[T -> U], v: T) -> U;

