
namespace Collection is
    use System.Object;
    use System.String;
    use System.StringBuffer;

    /// tree node color for red-black tree
    enum NodeColor is RED, BLACK si

    /// An associative array that is naturally sorted
    /// \param K type of keys in the Map. K must implement int operator>(K,K)
    /// \param V type of values in the Map.
    class SortedMap[K,V]: Object, Generic.Dict[K,V], Generic.Iterable[V] is
        root: TreeNode[K,V] public;

        Length: int => length(root);    

        Iterator: Generic.PairValueIterator[K,V] => new Generic.PairValueIterator[K,V](Pairs);

        Keys: Generic.PairKeyIterator[K,V] => new Generic.PairKeyIterator[K,V](Pairs);

        Pairs: SortedMapIterator[K,V] => new SortedMapIterator[K,V](root);

        ReversePairs: SortedMapReverseIterator[K,V] => new SortedMapReverseIterator[K,V](root);

        [key: K]: V public
            is
                let n = lookupTreeNode(key);

                if n == null then
                    return cast V(null); // V.none;
                fi

                return n.value;
            si,
            = value
            is
                let insertedTreeNode = new TreeNode[K,V](key, value, NodeColor.RED, null, null);

                if root == null then
                    root = insertedTreeNode;
                else
                    let n = root;

                    do
                        let compResult = key.opCompare(n.key);

                        if compResult == 0 then
                            n.value = value;
                            return;
                        elif compResult < 0 then
                            if n.left == null then
                                n.left = insertedTreeNode;
                                break;
                            else
                                n = n.left;
                            fi
                        else
                            if n.right == null then
                                n.right = insertedTreeNode;
                                break;
                            else
                                n = n.right;
                            fi
                        fi
                    od

                    insertedTreeNode.parent = n;
                fi

                insertCase1(insertedTreeNode);
            si        

        /// Construct an empty SortedMap[K,V]
        init() is
            root = null;
        si

        /*
        find(prefix: String, results: Generic.List[String]) is

        si
        */        

        toString() -> String is
            let buffer = new System.StringBuffer();
            toString(root, buffer);
            return buffer;
        si

        isEmpty() -> bool is
            return root == null;
        si

        clear() is
            root = null;
        si

        remove(key: K) -> V is
            let n = lookupTreeNode(key);

            if n == null then
                return cast V(null); // V.none;  // Key not found, do nothing
            fi

            var result = n.value;

            if n.left != null && n.right != null then
                // Copy key/value from predecessor and then delete it instead
                let pred = maximumTreeNode(n.left);
                n.key   = pred.key;
                n.value = pred.value;
                n = pred;
            fi

            var child: TreeNode[K,V];

            if n.right == null then
                child = n.left;
            else
                child = n.right;
            fi

            if nodeNodeColor(n) == NodeColor.BLACK then
                n.color = nodeNodeColor(child);
                deleteCase1(n);
            fi

            replaceTreeNode(n, child);
            
            if nodeNodeColor(root) == NodeColor.RED then
                root.color = NodeColor.BLACK;
            fi	

            return result;
        si    

        contains(key: K) -> bool is
            let n = lookupTreeNode(key);

            return n != null;
        si

        /// Internal method
        nodeNodeColor(n: TreeNode[K,V]) -> NodeColor static is
            if n == null then
                return NodeColor.BLACK;
            fi

            return n.color;
        si

        /// Internal method
        lookupTreeNode(key: K) -> TreeNode[K,V] is
            let n = root;

            while n != null do
                let compResult = key.opCompare(n.key);

                if compResult == 0 then
                    return n;
                elif compResult < 0 then
                    n = n.left;
                else
                    n = n.right;
                fi
            od

            return n;
        si        

        rotateLeft(n: TreeNode[K,V]) is
            let r = n.right;

            replaceTreeNode(n, r);

            n.right = r.left;

            if r.left != null then
                r.left.parent = n;
            fi

            r.left = n;
            n.parent = r;
        si

        rotateRight(n: TreeNode[K,V]) is
            let l = n.left;

            replaceTreeNode(n, l);

            n.left = l.right;

            if l.right != null then
                l.right.parent = n;
            fi

            l.right = n;
            n.parent = l;
        si

        replaceTreeNode(oldn: TreeNode[K,V], newn: TreeNode[K,V]) is
            if oldn.parent == null then
                root = newn;
            else
                if oldn == oldn.parent.left then
                    oldn.parent.left = newn;
                else
                    oldn.parent.right = newn;
                fi
            fi

            if newn != null then
                newn.parent = oldn.parent;
            fi
        si

        insertCase1(n: TreeNode[K,V]) is
            if n.parent == null then
                n.color = NodeColor.BLACK;
            else
                insertCase2(n);
            fi
        si

        insertCase2(n: TreeNode[K,V]) is
            if nodeNodeColor(n.parent) == NodeColor.BLACK then
                return; // Tree is still valid
            else
                insertCase3(n);
            fi
        si

        insertCase3(n: TreeNode[K,V]) is
            if nodeNodeColor(n.uncle()) == NodeColor.RED then
                n.parent.color = NodeColor.BLACK;
                n.uncle().color = NodeColor.BLACK;
                n.grandparent().color = NodeColor.RED;
                insertCase1(n.grandparent());
            else
                insertCase4(n);
            fi
        si

        insertCase4(n: TreeNode[K,V]) is
            if n == n.parent.right && n.parent == n.grandparent().left then
                rotateLeft(n.parent);
                n = n.left;
            elif n == n.parent.left && n.parent == n.grandparent().right then
                rotateRight(n.parent);
                n = n.right;
            fi
            insertCase5(n);
        si

        insertCase5(n: TreeNode[K,V]) is
            n.parent.color = NodeColor.BLACK;
            n.grandparent().color = NodeColor.RED;
            if n == n.parent.left && n.parent == n.grandparent().left then
                rotateRight(n.grandparent());
            else
                rotateLeft(n.grandparent());
            fi
        si

        minimumTreeNode(n: TreeNode[K,V]) -> TreeNode[K,V] static is
            while n.left != null do
                n = n.left;
            od

            return n;
        si

        maximumTreeNode(n: TreeNode[K,V]) -> TreeNode[K,V] static is
            while n.right != null do
                n = n.right;
            od
            return n;
        si

        deleteCase1(n: TreeNode[K,V]) is
            if n.parent == null then
                return;
            else
                deleteCase2(n);
            fi
        si

        deleteCase2(n: TreeNode[K,V]) is
            if nodeNodeColor(n.sibling()) == NodeColor.RED then
                n.parent.color = NodeColor.RED;
                n.sibling().color = NodeColor.BLACK;
                if n == n.parent.left then
                    rotateLeft(n.parent);
                else
                    rotateRight(n.parent);
                fi
            fi
            deleteCase3(n);
        si

        deleteCase3(n: TreeNode[K,V]) is
            if nodeNodeColor(n.parent) == NodeColor.BLACK &&
                nodeNodeColor(n.sibling()) == NodeColor.BLACK &&
                nodeNodeColor(n.sibling().left) == NodeColor.BLACK &&
                nodeNodeColor(n.sibling().right) == NodeColor.BLACK
            then
                n.sibling().color = NodeColor.RED;
                deleteCase1(n.parent);
            else
                deleteCase4(n);
            fi
        si

        deleteCase4(n: TreeNode[K,V]) is
            if nodeNodeColor(n.parent) == NodeColor.RED &&
                nodeNodeColor(n.sibling()) == NodeColor.BLACK &&
                nodeNodeColor(n.sibling().left) == NodeColor.BLACK &&
                nodeNodeColor(n.sibling().right) == NodeColor.BLACK
            then
                n.sibling().color = NodeColor.RED;
                n.parent.color = NodeColor.BLACK;
            else
                deleteCase5(n);
            fi
        si

        deleteCase5(n: TreeNode[K,V]) is
            if n == n.parent.left &&
                nodeNodeColor(n.sibling()) == NodeColor.BLACK &&
                nodeNodeColor(n.sibling().left) == NodeColor.RED &&
                nodeNodeColor(n.sibling().right) == NodeColor.BLACK
            then
                n.sibling().color = NodeColor.RED;
                n.sibling().left.color = NodeColor.BLACK;
                rotateRight(n.sibling());
            elif n == n.parent.right &&
                nodeNodeColor(n.sibling()) == NodeColor.BLACK &&
                nodeNodeColor(n.sibling().right) == NodeColor.RED &&
                nodeNodeColor(n.sibling().left) == NodeColor.BLACK
            then
                n.sibling().color = NodeColor.RED;
                n.sibling().right.color = NodeColor.BLACK;
                rotateLeft(n.sibling());
            fi
            deleteCase6(n);
        si

        deleteCase6(n: TreeNode[K,V]) is
            n.sibling().color = nodeNodeColor(n.parent);
            n.parent.color = NodeColor.BLACK;
            if n == n.parent.left then
                n.sibling().right.color = NodeColor.BLACK;
                rotateLeft(n.parent);
            else
                n.sibling().left.color = NodeColor.BLACK;
                rotateRight(n.parent);
            fi
        si

        length(n: TreeNode[K,V]) -> int static is
            if n == null then
                return 0;
            else
                return length(n.left) + length(n.right);
            fi
        si

        toString(n: TreeNode[K,V], b: StringBuffer) static is
            if n == null then
                b.append("()");
                return;
            fi

            b.append('(');

            b.append( n );

            if n.left != null then
                b.append(',');
                toString(n.left, b);
            fi

            b
                .append(',')
                .append(n.key)
                .append("=>")
                .append(n.value);

            if n.right != null then
                b.append( ',' );
                toString(n.right, b);
            fi

            b.append(')');
        si    
    si

    /// A node in the SortedMap[K,V] Red-black tree 
    class TreeNode[K,V]: Generic.Pair[K,V] is
        // key: K;
        // value: V;
        left: TreeNode[K,V] public;
        right: TreeNode[K,V] public;
        parent: TreeNode[K,V] public;
        color: NodeColor public;

        init(key: K, value: V, nodeNodeColor: NodeColor, left: TreeNode[K,V], right: TreeNode[K,V]) is
            // @NoWarnInit;
            self.key = key;
            self.value = value;
            self.color = nodeNodeColor;
            self.left = left;
            self.right = right;

            if left  != null then
                left.parent = self;
            fi

            if right != null then
                right.parent = self;
            fi

            self.parent = null;
        si

        grandparent() -> TreeNode[K,V] is
            return parent.parent;
        si

        sibling() -> TreeNode[K,V] is
            if self == parent.left then
                return parent.right;
            else
                return parent.left;
            fi
        si

        uncle() -> TreeNode[K,V] is
            return parent.sibling();
        si

        toString() -> String is
            return new StringBuffer()
                .append(key)
                .append("=>")
                .append(value);
        si
    si

    /// Iterates over elements of a SortedMap[K,V] in order
    class SortedMapIterator[K,V]: Object, Generic.Iterator[Generic.Pair[K,V]] is
        current: TreeNode[K,V];

        init(root: TreeNode[K,V]) is
            if root? then
                current =
                    // parser can't handle "SortedMapIterator[K,V].minimumTreeNode(root)
                    cast SortedMap[K,V](null)
                        .minimumTreeNode(root);
            fi
        si

        hasMoreElements() -> bool
            => current != null;

        nextElement() -> TreeNode[K,V] is
            let result = current;

            current = successor(current);

            return result;
        si
    
        successor(x: TreeNode[K,V]) -> TreeNode[K,V] is
            if x.right != null then
                return
                    // parser can't handle "SortedMap[K,V].minimumTreeNode(x.right)""
                    cast SortedMap[K,V](null)
                        .minimumTreeNode(x.right);
            else
                var y = x.parent;

                while y != null && x == y.right do
                    x = y;
                    y = y.parent;
                od

                return y;
            fi
        si

        Iterator: SortedMapIterator[K,V] => self;
    si

    /// Iterates over elements of a SortedMap[K,V] in reverse order
    class SortedMapReverseIterator[K,V]: Object, Generic.Iterator[Generic.Pair[K,V]] is
        current: TreeNode[K,V];

        init(root: TreeNode[K,V]) is
        
            current = 
                // parser can't handle SortedMap[K,V].maximumTreeNode(root);
                cast SortedMap[K,V](null)
                    .maximumTreeNode(root);
        si

        hasMoreElements() -> bool is
            return current != null;
        si

        nextElement() -> TreeNode[K,V] is
            var result = current;
            current = predecessor(current);
            return result;
        si
    
        predecessor(x: TreeNode[K,V]) -> TreeNode[K,V] is
            if x.left != null then
                cast SortedMap[K,V](null)
                    .maximumTreeNode(x.left);
            else
                var y = x.parent;
                while y != null && x == y.left do
                    x = y;
                    y = y.parent;
                od

                return y;
            fi
        si

        Iterator: SortedMapReverseIterator[K,V] => self;
    si
si