namespace Tester is
    use System.Console;

    use System.Threading.Tasks.Task_0;
    use System.Threading.Tasks.Task;

    use Collections.Iterable;
    use Collections.LIST;

    class TASK_QUEUE is
        _max_tasks: int;

        _running_tasks: LIST[Task[Result]];

        _running_tasks_as_tasks: Task_0[] =>
            new LIST[Task_0](new Shim.MAPPER[Task[Result], Task_0](_running_tasks, (task: Task[Result]) -> Task_0 => task)).to_array();

        init(max_tasks: int) is
            _max_tasks = max_tasks;

            _running_tasks = new LIST[Task[Result]](max_tasks);
        si

        queue(task: () -> Result) -> Iterable[Result] is
            let result = wait_any();

            let new_task = new Task[Result](task);

            new_task.start();

            _running_tasks.add(new_task);

            return result;
        si

        drain() -> Iterable[Result] is
            if _running_tasks.count == 0 then
                return null;
            fi

            return wait_all();
        si

        wait_any() -> Iterable[Result] => wait(false);
        wait_all() -> Iterable[Result] => wait(true);

        wait(all: bool) -> Iterable[Result] is
            let result = new LIST[Result]();

            if !all && _running_tasks.count < _max_tasks then
                return result;
            fi

            Task.wait_any(_running_tasks_as_tasks);

            let new_tasks = new LIST[Task[Result]]();

            for task in _running_tasks do
                if task.is_completed then
                    result.add(task.result);
                else
                    new_tasks.add(task);
                fi                
            od

            _running_tasks = new_tasks;

            return result;
        si
    si
si

