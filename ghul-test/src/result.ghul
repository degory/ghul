namespace Tester is
    use System.String;
    use System.Console;
    use System.Text.StringBuilder;

    use Collections.Iterable;
    use Collections.MutableList;
    use Collections.LIST;

    class Result is
        test: TEST;

        progress: int public;

        progress_string: String => progress.to_string().pad_left(2) + "%";

        is_pass: bool is
            throw new System.NotImplementedException();            
        si

        is_fail: bool is
            throw new System.NotImplementedException();            
        si

        is_executed: bool => is_pass || is_fail;

        head: String is
            throw new System.NotImplementedException();
        si
        
        body: String => null;

        init(test: TEST) is
            self.test = test;
            test.result = self;
        si
        
        format(test_name: String) -> String is
            let result = progress_string + " " + head + ": " + test_name;

            if body? && body !~ "" then
                result = result + ": " + body;
            fi            

            return result;
        si

        to_string() -> String => format(test.path);            
    si

    class SKIP: Result is
        is_pass: bool => false;
        is_fail: bool => false;
        head: String => "  skip";

        init(test: TEST) is super.init(test); si        
    si

    class PASS: Result is
        is_pass: bool => true;
        is_fail: bool => false;
        head: String => "✅ pass";

        init(test: TEST) is super.init(test); si        
    si

    class FAILURE: Result is
        _details: MutableList[DETAILS];

        is_pass: bool => false;
        is_fail: bool => true;
        head: String => "❌ fail";

        body: String is
            if _details.count == 0 then
                return null;
            elif _details.count == 1 then
                return _details[0].to_string();
            else
                let buffer = new StringBuilder();

                for details in _details do
                    buffer
                        .append("\n")
                        .append(details);
                od

                return buffer.to_string();
            fi            
        si

        init(test: TEST) is
            super.init(test);
            _details = new LIST[DETAILS]();
        si

        init(test: TEST, details: DETAILS) is
            init(test);
            add(details);
        si

        init(test: TEST, message: String) is
            init(test, new DETAILS(message));
        si

        init(test: TEST, message: String, details: String) is
            init(test, new DETAILS(message, details));
        si
                        
        add(details: DETAILS) is
            _details.add(details);
        si
    si
    
    class DETAILS is
        message: String;
        details: String;

        init(message: String) is
            self.message = message;
        si
        
        init(message: String, details: String) is
            self.message = message;
            self.details = details;
        si
        
        to_string() -> String is
            let result = new StringBuilder();

            result.append(message);
            
            if details? then
                result
                    .append(":");

                if !details.contains('\n') then
                    result
                        .append(" ")
                        .append(details);
                else
                    for line in details.split(['\n']) do
                        result
                            .append("\n    ")
                            .append(line);
                    od                
                fi
            fi

            return result.to_string();
        si        
    si
si
