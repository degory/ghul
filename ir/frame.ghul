namespace IR is
    use System;
    use Generic;

    class Frame is
        enclosing: Frame => null;

        alloc_variable(builder: LLVM.Builder, type: LLVM.Type) -> int is
            throw new NotImplementedException(ClassName + " cannot allocate variable");
        si

        get_address(base: LLVM.Value, index: int) -> LLVM.Value is
            throw new NotImplementedException(ClassName + " cannot get address");
        si

        get_address(base: LLVM.Value, frame: Frame, index: int) -> LLVM.Value is
            throw new NotImplementedException(ClassName + " cannot get address");
        si
    si

    class GLOBAL_FRAME: Frame is
        types: List[LLVM.Type];

        init() is
            super.init();

            types = new Vector[LLVM.Type]();
        si

        alloc_variable(builder: LLVM.Builder, type: LLVM.Type) -> int is
            types.add(type);
        si
    si

    class INSTANCE_FRAME: Frame is
        enclosing: Frame;
        types: List[LLVM.Type];

        init(enclosing: Frame) is
            super.init();

            self.enclosing = enclosing;

            types = new Vector[LLVM.Type]();
        si

        alloc_variable(builder: LLVM.Builder, type: LLVM.Type) -> int is
            types.add(type);
        si
    si

    class HEAP_FRAME: Frame is
        enclosing: Frame;
        types: Vector[LLVM.Type];

        init(enclosing: Frame) is
            super.init();

            self.enclosing = enclosing;

            types = new Vector[LLVM.Type]();
        si

        alloc_variable(builder: LLVM.Builder, type: LLVM.Type) -> int is
            types.add(type);

            return types.Length - 1;
        si

        complete_alloc(context: LLVM.Context, builder: LLVM.Builder) is
            let type = LLVM.CORE.LLVMStructTypeInContext(context, types.Array.address, types.Length, cast LLVM.Bool(false));

            enclosing.alloc_variable(builder, type);
        si

        get_address(base: LLVM.Value, index: int) -> LLVM.Value is
            let index_value =
                LLVM.CORE.LLVMConstInt(
                    LLVM.CORE.LLVMIntType(32),
                    cast long(index),
                    cast LLVM.Bool(false)
                );

            return LLVM.CORE.LLVMConstInBoundsGEP(base, [index_value].address, 1);
        si

        get_address(base: LLVM.Value, frame: Frame, index: int) -> LLVM.Value is
        si
    si

    class STACK_FRAME: Frame is
        enclosing: Frame;
        captured: Frame;

        variables: List[LLVM.Value];

        init(enclosing: Frame, captured: Frame) is
            super.init();

            self.enclosing = enclosing;
            self.captured = captured;

            variables = new Vector[LLVM.Value]();
        si

        alloc_variable(builder: LLVM.Builder, type: LLVM.Type) -> int is
            variables.add(
                LLVM.CORE.LLVMBuildAlloca(builder, type, "".toCString())
            );

            return variables.Length - 1;
        si

        get_address(base: LLVM.Value, index: int) -> LLVM.Value is
            return variables[index];
        si

        get_address(base: LLVM.Value, frame: Frame, index: int) -> LLVM.Value is
            if frame == self then
                return get_address(base, index);
            elif frame == captured then
                // FIXME: wrong
                return captured.get_address(base, index);
            elif enclosing? then
                return enclosing.get_address(base, frame, index);
            else
                throw new Exception("frame not found: " + frame);
            fi
        si
    si
si
