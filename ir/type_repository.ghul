namespace IR is
    use System;
    use Generic;

    use LLVM;

    class TYPE_REPOSITORY is
        _type_map: Dict[Semantic.Type.BASE,LLVM.Type];
        _named_map: Dict[String,LLVM.Type];

        context: LLVM.Context;

        init(
            context: LLVM.Context
        ) is
            self.context = context;
            _type_map = new Map[Semantic.Type.BASE,LLVM.Type]();
            _named_map = new Map[String,LLVM.Type]();
        si

        get_type(type: Semantic.Type.BASE) -> LLVM.Type is
            var result = _type_map[type];

            if result? then
                return result;
            fi

            result = type.get_ir_type(self);

            if result? then
                IO.Std.err.FlushOnPrintln = true;

                IO.Std.err.println("IR type of " + type + " is:");

                LLVM.CORE.LLVMDumpType(result);

                _type_map[type] = result;
            else
                IO.Std.err.println("null result mapping semantic type " + type + " to IR type");
            fi

            return result;
        si

        get_int_type(bits: int) -> LLVM.Type =>
            LLVM.CORE.LLVMIntTypeInContext(context, bits);

        get_pointer_type(type: Semantic.Type.BASE) -> LLVM.Type =>
            LLVM.CORE.LLVMPointerType(get_type(type), 0);

        get_array_type(type: Semantic.Type.BASE) -> LLVM.Type =>
            LLVM.CORE.LLVMArrayType(get_type(type), 0);

        get_array_type(type: Semantic.Type.BASE, length: int) -> LLVM.Type =>
            LLVM.CORE.LLVMArrayType(get_type(type), length);

        get_struct_type(types: List[Semantic.Type.BASE]) -> LLVM.Type is
            let llvm_types = new LLVM.Type[](types.Length);

            for i in 0..types.Length do
                llvm_types.add(get_type(types[i]));
            od

            return LLVM.CORE.LLVMStructTypeInContext(context, llvm_types.address, llvm_types.length, cast LLVM.Bool(false));
        si

        get_function_type(types: List[Semantic.Type.BASE]) -> LLVM.Type is
            let llvm_types = new LLVM.Type[](types.Length-1);

            for i in 0..types.Length-1 do
                let type = get_type(types[i]);

                if type? then
                    llvm_types[i] = type;
                else
                    throw new Exception("argument's IR type is null: " + types[i]);
                fi
            od

            let type = get_type(types[types.Length-1]);

            IO.Std.err.println("Will call get function for: ");

            for t in llvm_types do
                IO.Std.err.println("" + cast long(t));
                LLVM.CORE.LLVMDumpType(t);
            od

            IO.Std.err.println("" + cast long(type));
            LLVM.CORE.LLVMDumpType(type);

            return LLVM.CORE.LLVMFunctionType(
                type,
                llvm_types.address,
                llvm_types.Length,
                cast LLVM.Bool(false)
            );
        si

        get_named_type(name: String) -> LLVM.Type is
            var result = _named_map[name];

            if !result? then
                result = LLVM.CORE.LLVMStructCreateNamed(context, name.toCString());
                _named_map[name] = result;
            fi

            return result;
        si

        get_pointer_to_named_type(name: String) -> LLVM.Type is
            return LLVM.CORE.LLVMPointerType(get_named_type(name), 0);
        si
    si
si
