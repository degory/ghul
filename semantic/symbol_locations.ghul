namespace Semantic is
    use System;
    use Generic;

    use Source;

    class SYMBOL_LOCATIONS is
        _symbol_use_map: LOCATION_MAP[Symbol.BASE];

        init() is
            clear();
        si

        clear() is
            _symbol_use_map = new LOCATION_MAP[Symbol.BASE]();
        si

        add_symbol_use(location: LOCATION, symbol: Symbol.BASE) is
            _symbol_use_map.put(location, symbol);
        si

        find_definition_from_use(file_name: String, line: int, column: int) -> Symbol.BASE is
            return _symbol_use_map.find(file_name, line, column);
        si
    si

    class LOCATION_MAP[T] is
        file_name_to_file: Dict[String, Dict[int, List[Pair[LOCATION,T]]]];

        init() is
            file_name_to_file = new Map[String, Dict[int, List[Pair[LOCATION,T]]]]();
        si

        put(location: LOCATION, value: T) is
            assert(location.start_line == location.end_line, "location must not span more than one line");

            IO.Std.err.println("put symbol location: " + value);

            var file = file_name_to_file[location.file_name];

            if file == null then
                file = new Map[int, List[Pair[LOCATION,T]]]();
                file_name_to_file[location.file_name] = file;
            fi

            let line = location.start_line;

            var list = file[line];

            if list == null then
                list = new Vector[Pair[LOCATION,T]]();
                file[line] = list;
            fi

            list.add(new Pair[LOCATION,T](location,value));
        si

        find(file_name: String, line: int, column: int) -> T is
            let file = file_name_to_file[file_name];

            IO.Std.err.println("find symbol, file is: " + file);

            if file == null then
                return null;
            fi

            let list = file[line];

            IO.Std.err.println("find symbol, list is: " + list);

            if list == null then
                IO.Std.err.println("no symbols on line " + line);

                for k in file.Keys do
                    IO.Std.err.println("" + k + " != " + line);
                od

                return null;
            fi

            let line_column = LOCATION.pair(line, column);

            for p in list do
                IO.Std.err.println("maybe: " + p.key + "," + p.value);

                if p.key.contains(line_column) then
                    IO.Std.err.println("found: " + p.key + "," + p.value);
                    return p.value;
                fi
            od
        si
    si    
si
