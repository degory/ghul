namespace Semantic.Type is
    use System;
    use Generic;

    use Source;
    
    trait SettableTyped: Typed is
        settype(type: BASE);
    si
    
    trait Typed is
        type: BASE;
    si

    enum MATCH is
        SAME = 0,
        ASSIGNABLE = 1,
        CONVERTABLE = 2,
        DIFFERENT = 100000
    si

    class BASE: Object, Typed is
        scope: Scope => null;
    
        type: BASE => self;

        init() is
        si

        =~(other: BASE) -> bool => false;

        compare(other: BASE) -> MATCH
            => MATCH.DIFFERENT;

        find_member(name: String) -> Symbol.BASE
            => null;

        specialize(type_map: Dict[String,Type.BASE]) -> BASE is
            IO.Std.err.println("specialize " + ClassName + " " + self + " with " + type_map + " does nothing ");
            return self;
        si            
    si

    class ANY: BASE is
        init() is
            super.init();
        si

        =~(other: BASE) -> bool
            => true;

        compare(other: BASE) -> Type.MATCH
            => MATCH.ASSIGNABLE;
    si

    class NAMED: BASE is
        name: String => symbol.name;

        scope: Scope => symbol;

        symbol: Symbol.BASE;

        init(symbol: Symbol.BASE) is
            self.symbol = symbol;
        si

        specialize(type_map: Dict[String,BASE]) -> Type.BASE is
            IO.Std.err.println("-- specialize " + ClassName + " " + self + " with " + type_map);
            let result = type_map[name];

            if result? then
                IO.Std.err.println("-- " + self + " maps to " + result);
                return result;
            else
                IO.Std.err.println("-- " + self + " no match");
                return self;
            fi
        si        

        =~(other: BASE) -> bool is
            if isa NAMED(other) then
                let other_symbol = cast NAMED(other);
                return symbol == other_symbol.symbol;
            fi
        si

        compare(other: BASE) -> Type.MATCH is
            if isa ANY(other) then
                return Type.MATCH.ASSIGNABLE;
            fi

            if symbol == null || other == null then
                return Type.MATCH.DIFFERENT;
            elif isa NAMED(other) then
                let other_named = cast NAMED(other);

                if symbol == other_named.symbol then
                    return Type.MATCH.SAME;
                fi
                
                return symbol.compare_type(other_named.symbol);
            elif isa GENERIC(other) then
                // FIXME: should we ever want to compare an unresolved generic type?
                let other_generic = cast GENERIC(other);

                return symbol.compare_type(other_generic.symbol);
            fi

            return Type.MATCH.DIFFERENT;            
        si        

        find_member(name: String) -> Symbol.BASE is
            if symbol? then
                return symbol.find_member(name);
            fi
        si

        hash() -> int => symbol.hash();

        toString() -> String is
            if symbol? then
                return symbol.qualified_name;
            else
                return "(null symbol) " + name;
            fi
        si
    si

    class GENERIC: NAMED is
        arguments: List[BASE] => cast Symbol.GENERIC(symbol).arguments;
        ancestors: List[BASE] => cast Symbol.GENERIC(symbol).ancestors;

        init(
            location: LOCATION,
            symbol: Symbol.ScopedWithInheritance,
            arguments: List[BASE]
        ) is
            super.init(new Symbol.GENERIC(location, symbol, arguments));
        si

        specialize(type_map: Dict[String,BASE]) -> Type.GENERIC is
            IO.Std.err.println("-- specialize " + ClassName + " " + self + " with " + type_map);
        
            var seen_any_new = false;

            let generic_symbol = cast Symbol.GENERIC(symbol);

            let new_arguments = new Vector[BASE](generic_symbol.arguments.Length);

            for i in 0..arguments.Length do
                let argument_name
                    = generic_symbol.symbol.argument_names[i];

                let mapped_type = type_map[argument_name];

                if mapped_type? then
                    new_arguments[i] = mapped_type;

                    seen_any_new = true;
                else
                    new_arguments[i] = generic_symbol.arguments[i].specialize(type_map);
                fi
            od

            // if seen_any_new then
                return new GENERIC(symbol.location, generic_symbol.symbol, new_arguments);
            // else
            //   return self;
            // fi

            IO.Std.err.println("-- specialize " + ClassName + " " + self + " with " + type_map);            
        si

        =~(other: BASE) -> bool is
            IO.Std.err.println("are equal " + self + " vs " + other + "?");

            if !isa GENERIC(other) then
                return false;
            fi

            let generic_other = cast GENERIC(other);

            if symbol == generic_other.symbol then
                IO.Std.err.println("identical generic symbols");
                return true;
            fi

            let generic_symbol = cast Symbol.GENERIC(symbol);
            let generic_other_symbol = cast Symbol.GENERIC(generic_other.symbol);

            if generic_symbol.symbol != generic_other_symbol.symbol then
                IO.Std.err.println("different underlying symbols");
                return false;
            fi

            if generic_symbol.arguments.Length != generic_other_symbol.arguments.Length then
                IO.Std.err.println("different argument list lengths");
                return false;
            fi

            for i in 0..generic_symbol.arguments.Length do
                if generic_symbol.arguments[i] !~ generic_other_symbol.arguments[i] then                
                    IO.Std.err.println(
                        "not equal " + self + " vs " + other + " argument[" + i + "] differs (" 
                            + generic_symbol.arguments[i] + " != " + generic_other_symbol.arguments[i] + ")");;
                    return false;
                fi
            od

            return true;
        si

        compare(other: BASE) -> Type.MATCH is
            IO.Std.err.println("compare " + self + " vs " + other);

            if isa ANY(other) then
                IO.Std.err.println("any is assignable to anything");
                return Type.MATCH.ASSIGNABLE;
            fi

            if symbol == null || other == null then
                IO.Std.err.println("null symbol not assignable");
                return Type.MATCH.DIFFERENT;
            elif isa GENERIC(other) then
                IO.Std.err.println("other is also a generic");

                let other_generic = cast GENERIC(other);
                
                if self =~ other then
                    IO.Std.err.println("same generic type");
                    return Type.MATCH.SAME;
                else
                    IO.Std.err.println("search ancestors...");
                
                    for a in other_generic.ancestors do
                        let match = self.compare(a);

                        if match <= Type.MATCH.ASSIGNABLE then
                            return Type.MATCH.ASSIGNABLE;
                        elif match == Type.MATCH.CONVERTABLE then
                            return Type.MATCH.CONVERTABLE;
                        fi
                    od
                fi
            else
                IO.Std.err.println("other is not a generic: " + other);
            fi

            return Type.MATCH.DIFFERENT;
        si

        hash() -> int => symbol.hash();

        toString() -> String is 
            return symbol.toString();
        si
    si    

    class FUNCTION_GROUP: BASE is
        name: String;

        function_group: Symbol.FUNCTION_GROUP;

        init(name: String, function_group: Symbol.FUNCTION_GROUP) is
            super.init();

            self.name = name;
            self.function_group = function_group;
        si

        =~(other: BASE) -> bool is
            if isa FUNCTION_GROUP(other) then
                let other_function_group = cast FUNCTION_GROUP(other);
                return function_group == other_function_group.function_group;
            fi
        si

        specialize(generic_cache: GENERIC_CACHE, arguments: Dict[String,Type.BASE]) -> FUNCTION_GROUP is
            return new FUNCTION_GROUP(
                name,
                function_group.specialize(arguments)
            );
        si

        toString() -> String => name + "(...)";
    si    
si