namespace Semantic.Type is
    use System;
    use Generic;
    
    trait SettableTyped: Typed is
        settype(type: BASE);
    si
    
    trait Typed is
        type: BASE;
    si

    enum MATCH is
        SAME = 0,
        ASSIGNABLE = 1,
        CONVERTABLE = 2,
        DIFFERENT = 100000
    si

    class BASE: Object, Typed is
        type: BASE => self;

        specialized_from: GENERIC => null;

        init() is
        si

        =~(other: BASE) -> bool => false;

        compare(other: BASE) -> MATCH
            => MATCH.DIFFERENT;

        specialize(specializer: GENERIC_SPECIALIZER) -> BASE
            => self;

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,BASE]) -> BASE
            => self;
    si

    class ANY: BASE is
        init() is
            super.init();
        si

        =~(other: BASE) -> bool
            => true;

        compare(other: BASE) -> Type.MATCH
            => MATCH.ASSIGNABLE;
    si

    class NAMED: BASE is
        name: String;
        specialized_from: GENERIC;
        arguments_string: String public;

        scope: Scope => symbol;

        symbol: Symbol.Scoped;

        init(name: String, symbol: Symbol.Scoped) is
            init(name, symbol, null, "");
        si

        init(name: String, symbol: Symbol.Scoped, specialized_from: GENERIC, arguments_string: String) is
            super.init();

            self.name = name;
            self.symbol = symbol;
            self.specialized_from = specialized_from;
            self.arguments_string = arguments_string;
        si

        =~(other: BASE) -> bool is
            if isa NAMED(other) then
                let other_symbol = cast NAMED(other);
                return symbol == other_symbol.symbol;
            fi
        si

        compare(other: BASE) -> Type.MATCH is
            if symbol == null || other == null then
                return Type.MATCH.DIFFERENT;
            elif isa NAMED(other) then
                let other_named = cast NAMED(other);
                
                return symbol.compare_type(other_named.symbol);
            elif isa GENERIC(other) then
                // FIXME: should we ever want to compare an unresolved generic type?
                let other_generic = cast GENERIC(other);

                return symbol.compare_type(other_generic.symbol);
            fi

            return Type.MATCH.DIFFERENT;            
        si        
        
        specialize(specializer: GENERIC_SPECIALIZER) -> NAMED
            => self;    

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> Type.BASE is
            Compiler.TRACE.enter("specialize " + ClassName + " " + name);

            let result = type_map[name];

            if result? then
                Compiler.TRACE.print("specialize " + ClassName + " " + name + ": mapping type variable " + name + " to actual type " + result);
                Compiler.TRACE.exit("specialize " + ClassName + " " + name);
                return result;
            fi

            Compiler.TRACE.print("specialize " + ClassName + " " + name + ": no mapping found for type variable " + name);

            Compiler.TRACE.exit("specialize " + ClassName + " " + name);

            return self;
        si

        hash() -> int => symbol.hash();

        toString() -> String is
            if symbol? then
                return symbol.qualified_name + arguments_string;
            else
                return name + arguments_string;
            fi
        si
    si

    class GENERIC: NAMED is
        _hash: int;

        arguments: List[BASE];

        init(
            name: String,
            symbol: Symbol.ScopedWithInheritance,
            arguments: List[BASE]
        ) is
            super.init(name, symbol);

            self.arguments = arguments;
        si

        specialize(specializer: GENERIC_SPECIALIZER) -> NAMED is
            return specialize(specializer, new Map[String,BASE]());
        si

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,BASE]) -> NAMED is
            if symbol? then
                Compiler.TRACE.enter("specialize " + ClassName + " " + symbol.qualified_name + " [ " + arguments + " ] (" + name + ")");
            else
                Compiler.TRACE.enter("specialize " + ClassName + " " + name + " [ " + arguments + " ] ");
            fi

            // IO.Std.err.println("called from: " + new Backtrace());

            let from = IoC.CONTAINER.instance.symbol_table.current_declaration_context;

            if from? && isa Symbol.BASE(from) then
                Compiler.TRACE.print("specialize " + ClassName + " " + name + " from " + cast Symbol.BASE(from).qualified_name);
            fi
            
            var result = specializer[self];

            if result? then
                Compiler.TRACE.exit("specialize " + ClassName + " " + name + ": already done, unspecialized arguments - this is probably wrong");
                return result;
            fi

            assert(isa Symbol.ScopedWithInheritance(symbol), "can't specialize type that is neither class not trait:" + symbol);

            let specialized_symbol = cast Symbol.ScopedWithInheritance(symbol).copy_for_specialize();
            let specialized_type = new NAMED(name, specialized_symbol, self, "[" + arguments + "]");

            let specialized_arguments = new Vector[BASE]();

            Compiler.TRACE.print("specialize " + ClassName + " " + symbol.qualified_name);

            for a in arguments do
                specialized_arguments.add(a.specialize(specializer, type_map));
            od

            for i in 0..arguments.Length do
                Compiler.TRACE.print("specialize " + ClassName + " " + name + " with argument " + arguments[i] + " => " + specialized_arguments[i] + "..."); 
            od

            let self_with_specialized_arguments = new GENERIC(name, cast Symbol.ScopedWithInheritance(symbol), specialized_arguments);

            result = specializer[self_with_specialized_arguments];

            if result? then
                Compiler.TRACE.exit("specialize " + ClassName + " " + name + ": already done, specialized arguments");
            
                return result;
            fi

            specializer[self_with_specialized_arguments] = specialized_type;

            specialized_type.arguments_string = "[" + specialized_arguments + "]";

            specialized_symbol.specialize_self(specializer, specialized_arguments);

            Compiler.TRACE.exit("specialize " + ClassName + " " + symbol.qualified_name);            

            return specialized_type;
        si

        =~(other: GENERIC) -> bool is
            if symbol != other.symbol then
                return false;
            fi

            if arguments.Length != other.arguments.Length then
                return false;
            fi

            for i in 0..arguments.Length do
                if arguments[i] !~ other.arguments[i] then                
                    return false;
                fi
            od

            return true;
        si

        hash() -> int is
            if _hash != 0 then
                return _hash;
            fi

            var result = super.hash();

            for a in arguments do
                result = result + a.hash();
            od

            if result == 0 then
                result = 1;
            fi

            _hash = result;

            return result;
        si        

        toString() -> String => name + "[" + arguments + "]"; //" {" + Object.dump(symbol) + "}";
    si    

    class FUNCTION_GROUP: BASE is
        name: String;

        function_group: Symbol.FUNCTION_GROUP;

        init(name: String, function_group: Symbol.FUNCTION_GROUP) is
            super.init();

            self.name = name;
            self.function_group = function_group;
        si

        =~(other: BASE) -> bool is
            if isa FUNCTION_GROUP(other) then
                let other_function_group = cast FUNCTION_GROUP(other);
                return function_group == other_function_group.function_group;
            fi
        si

        specialize(specializer: GENERIC_SPECIALIZER, arguments: Dict[String,Type.BASE]) -> FUNCTION_GROUP is
            return new FUNCTION_GROUP(
                name,
                function_group.specialize(specializer, arguments)
            );
        si

        toString() -> String => name + "(...)";
    si    
si