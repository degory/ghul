namespace Semantic.Graph.Value is
    use System;

    use Generic;

    class BASE: Object, Semantic.Type.Typed is
        has_type: bool => false;

        type: Type.BASE is
            throw new NotImplementedException(Object.dump(self) + " has no type");
        si

        gen_effect(context: IR.CONTEXT) is
            gen_value(context);
        si

        gen_value(context: IR.CONTEXT) -> LLVM.Value is
            throw new NotImplementedException(Object.dump(self) + " has no value");
        si

        init() is si
    si

    /*
    class IR: BASE is
        value: LLVM.Value;
    si
    */

    class SKIP: BASE is
        init() is
            super.init();
        si
    si

    class NEW: BASE is
        has_type: bool => type?;
        type: Type.BASE;
        constructor: Symbol.Function;
        arguments: Iterable[BASE];

        init(
            type: Type.BASE,
            constructor: Symbol.Function,
            arguments: Iterable[BASE]
        ) is
            super.init();

            self.type = type;
            self.constructor = constructor;
            self.arguments = arguments;
        si

        gen_value(context: IR.CONTEXT) -> LLVM.Value is
            return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
        si

        toString() -> String =>
            "new:" + type + "(\"" + constructor.name + "\"," + arguments + ")";
    si

    class CAST: BASE is
        has_type: bool => type?;
        type: Type.BASE;
        value: BASE;

        init(
            type: Type.BASE,
            value: BASE
        ) is
            super.init();

            self.type = type;
            self.value = value;
        si

        gen_value(context: IR.CONTEXT) -> LLVM.Value is
            return LLVM.CORE.LLVMBuildBitCast(
                context.builder,
                value.gen_value(context),
                type.get_ir_type(context.type_repository),
                "cast".toCString()
            );
        si

        toString() -> String =>
            "cast:" + type + "(" + value + ")";
    si

    class DUMMY: BASE, Type.Typed is
        has_type: bool => type?;
        type: Type.BASE;

        init(type: Type.BASE) is
            super.init();

            self.type = type;
        si

        gen_value(context: IR.CONTEXT) -> LLVM.Value is
            return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
        si
    si

    class NATIVE: BASE, Type.Typed is
        has_type: bool => type?;
        type: Type.BASE;

        init(type: Type.BASE) is
            super.init();

            self.type = type;
        si

        gen_value(context: IR.CONTEXT) -> LLVM.Value is
            return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
        si
    si

    class TUPLE: BASE, Type.Typed is
        has_type: bool => type?;
        type: Type.BASE;

        values: Iterable[BASE];

        init(type: Type.BASE, values: Iterable[BASE]) is
            super.init();

            self.type = type;
            self.values = values;
        si

        gen_value(context: IR.CONTEXT) -> LLVM.Value is
            return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
        si

        toString() -> String => "tuple:" + type + "(" + values + ")";
    si

    namespace Need is
        class STORE: BASE is
            has_type: bool => value? && value.has_type;
            type: Type.BASE => value.type;
            value: BASE;

            init(value: BASE) is
                super.init();

                self.value = value;
            si

            toString() -> String =>
                "need-store:" + type;
        si
    si

    namespace Expect is
        class STORABLE: BASE is
            has_type: bool => type?;
            type: Type.BASE;

            init(type: Type.BASE) is
                super.init();

                self.type = type;
            si

            toString() -> String =>
                "expect-storable:" + type;
        si
    si

    namespace Load is
        class SELF: BASE, Type.Typed is
            self_: Symbol.BASE;
            self_as_typed: Type.Typed => cast Type.Typed(self_);
            type: Type.BASE => self_as_typed.type;

            init(self_: Symbol.BASE) is
                super.init();

                assert(self_?, ClassName + " arg is null");

                self.self_ = self_;
            si

            gen_value(context: IR.CONTEXT) -> LLVM.Value is
                return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
            si

            toString() -> String => "self:" + type;
        si

        class LOCAL: BASE is
            init() is
                super.init();
            si

            gen_value(context: IR.CONTEXT) -> LLVM.Value is
                return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
            si

            toString() -> String => "local";
        si

        class SYMBOL: BASE, Type.Typed is
            symbol: Symbol.BASE;
            symbol_as_typed: Type.Typed => cast Type.Typed(symbol);
            type: Type.BASE => symbol_as_typed.type;
            from: BASE;

            init(from: BASE, symbol: Symbol.BASE) is
                super.init();

                assert(symbol?, ClassName + " arg is null");

                self.from = from;
                self.symbol = symbol;
            si

            gen_value(context: IR.CONTEXT) -> LLVM.Value is
                return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
            si

            toString() -> String =>
                "load:" + type + "(" + from + ",\"" + symbol.name + "\")";
        si
    si

    namespace Store is
        class SYMBOL: BASE, Type.Typed is
            symbol: Symbol.BASE;
            symbol_as_typed: Type.Typed => cast Type.Typed(symbol);
            type: Type.BASE => symbol_as_typed.type;
            from: BASE;
            value: Graph.Value.BASE;

            init(from: BASE, symbol: Symbol.BASE, value: Graph.Value.BASE) is
                super.init();

                assert(symbol?, ClassName + " arg is null");

                self.from = from;
                self.symbol = symbol;
                self.value = value;
            si

            gen_value(context: IR.CONTEXT) -> LLVM.Value is
                return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
            si            

            toString() -> String =>
                "store:" + type + "(" + from + ",\"" + symbol.name + "\"," + value + ")";
        si
    si

    namespace Call is
        class GLOBAL: BASE, Type.Typed is
            function: Symbol.Function;
            arguments: Iterable[BASE];
            type: Type.BASE => function.type;

            init(function: Symbol.Function, arguments: Iterable[BASE]) is
                super.init();

                self.function = function;
                self.arguments = arguments;
            si

            gen_value(context: IR.CONTEXT) -> LLVM.Value is
                return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
            si

            toString() -> String =>
                "global-call:" + type + "(\"" + function.name + "\"," + arguments + ")";
        si

        class INSTANCE: BASE, Type.Typed is
            from: Value.BASE;
            function: Symbol.Function;
            arguments: Iterable[BASE];
            type: Type.BASE => function.type;

            init(from: Value.BASE, function: Symbol.Function, arguments: Iterable[BASE]) is
                super.init();

                self.from = from;
                self.function = function;
                self.arguments = arguments;
            si

            gen_value(context: IR.CONTEXT) -> LLVM.Value is
                return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
            si

            toString() -> String =>
                "instance-call:" + type + "(" + from + ",\"" + function.name + "\"," +  arguments + ")";
        si

        class CLOSURE: BASE, Type.Typed is
            from: BASE;
            type: Type.BASE;
            arguments: Iterable[BASE];

            init(from: BASE, type: Type.BASE, arguments: Iterable[BASE]) is
                super.init();

                self.from = from;
                self.type = type;
                self.arguments = arguments;
            si

            toString() -> String =>
                "closure-call:" + type + "(" + from + "," + arguments + ")";
        si
    si

    namespace Literal is
        class INTEGER: BASE, Type.Typed is
            string: String;
            type: Type.BASE;

            init(string: String, type: Type.BASE) is
                super.init();

                self.string = string;
                self.type = type;
            si

            gen_value(context: IR.CONTEXT) -> LLVM.Value is
                return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
            si

            toString() -> String =>
                "literal:" + type + "(" + string + ")";
        si

        class STRING: BASE, Type.Typed is
            string: String;
            type: Type.BASE;

            init(string: String, type: Type.BASE) is
                super.init();

                self.string = string;
                self.type = type;
            si

            gen_value(context: IR.CONTEXT) -> LLVM.Value is
                return LLVM.CORE.LLVMConstNull(type.get_ir_type(context.type_repository));
            si

            toString() -> String =>
                "literal:" + type + "(\"" + string + "\")";
        si
    si
si
