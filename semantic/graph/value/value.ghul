namespace Semantic.Graph.Value is
    use System;

    class BASE: Object, Semantic.Type.Typed is
        has_type: bool => false;

        type: Type.BASE is
            throw new NotImplementedException(Object.dump(self) + " has no type");
        si

        init() is si
    si

    class DUMMY: BASE, Type.Typed is
        has_type: bool => type != null;
        type: Type.BASE;

        init(type: Type.BASE) is
            super.init();

            self.type = type;
        si
    si

    namespace Load is
        class SELF: BASE, Type.Typed is
            self_: Symbol.BASE;
            self_as_typed: Type.Typed => cast Type.Typed(self_);
            type: Type.BASE => self_as_typed.type;

            init(self_: Symbol.BASE) is
                super.init();

                self.self_ = self_;
            si

            toString() -> String => "self";
        si

        class LOCAL: BASE is
            init() is
                super.init();
            si

            toString() -> String => "load local";            
        si
        
        class SYMBOL: BASE, Type.Typed is
            symbol: Symbol.BASE;
            symbol_as_typed: Type.Typed => cast Type.Typed(symbol);
            type: Type.BASE => symbol_as_typed.type;
            from: BASE;

            init(from: BASE, symbol: Symbol.BASE) is
                super.init();

                self.from = from;
                self.symbol = symbol;
            si

            toString() -> String => "from " + from + " load " + symbol.name;
        si
    si

    namespace Store is
        class SYMBOL: BASE, Type.Typed is
            symbol: Symbol.BASE;
            symbol_as_typed: Type.Typed => cast Type.Typed(symbol);
            type: Type.BASE => symbol_as_typed.type;
            from: BASE;
            value: Graph.Value.BASE;

            init(from: BASE, symbol: Symbol.BASE, value: Graph.Value.BASE) is
                super.init();

                self.symbol = symbol;
                self.value = value;
            si

            toString() -> String =>
                "into " + from + " store " + symbol.name + " = " + value;
        si        
    si

    namespace Call is
        class GLOBAL: BASE, Type.Typed is
            function: Symbol.Function;
            type: Type.BASE => function.type;

            init(function: Symbol.Function) is
                super.init();

                self.function = function;
            si

            toString() -> String =>
                "global call " + function.name;
        si

        class INSTANCE: BASE, Type.Typed is
            from: Value.BASE;
            function: Symbol.Function;
            type: Type.BASE => function.type;

            init(from: Value.BASE, function: Symbol.Function) is
                super.init();

                self.from = from;
                self.function = function;
            si

            toString() -> String =>
                "from " + from + " instance call " + function.name;            
        si

        class ANON: BASE, Type.Typed is
            self_: Value.BASE;

            self_as_typed: Type.Typed => cast Type.Typed(self_);
            type: Type.BASE => self_as_typed.type;

            init(self_: Value.BASE) is
                super.init();

                self.self_ = self_;
            si
        si
    si

    namespace Literal is
        class INTEGER: BASE, Type.Typed is
            string: String;
            type: Type.BASE;

            init(string: String, type: Type.BASE) is
                super.init();

                self.string = string;
                self.type = type;
            si

            toString() -> String =>
                "literal " + string;
        si
    si
si
