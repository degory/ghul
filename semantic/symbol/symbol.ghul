namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;
    
    enum ACCESS is
        PRIVATE, PUBLIC, PROTECTED
    si

    // FIXME: shouldn't be Type.Typed, but cannot have type property and not implement this interface, or it stuffs
    // up overrides in derived classes, because of mismatch in calling convention (with/without interface selector param)
    class BASE /* : Object, Semantic.Type.Typed */ is
        location: LOCATION;
        _name: String;
        
        name: String => _name;

        type: Type.BASE is
            throw new NotImplementedException(ClassName + " has no type");
        si

        access: ACCESS is
            return ACCESS.PUBLIC;
        si

        init(location: LOCATION, name: String) is
            self.location = location;
            _name = name;
        si

        find_direct(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find direct: " + name + ": not a scope");
            return null;
        si

        find_member(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + ": not a scope");
            return null;
        si

        find_enclosing(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": not a scope");
            return null;
        si

        toString() -> String =>
            Class.Name + " " + name + " @ " + location;
    si

    class Scoped: BASE, Scope, DeclarationContext is
        _symbols: Map[String,BASE];

        init(location: LOCATION, name: String) is
            super.init(location, name);
            _symbols = new Map[String,BASE]();
        si

        find_direct(name: String) -> BASE is
            LOGGER.trace("find-symbol", 
            ClassName + " " + self.name + " find direct: " + name + "...");
            return _symbols[name];
        si

        declare(location: LOCATION, symbol: BASE) is
            var existing = find_direct(symbol.name);

            if existing != null then
                CONTAINER.instance.logger.error(location, "redefining symbol " + name + " originally defined at " + existing.location);
                CONTAINER.instance.logger.error(existing.location, "symbol " + name + " is redefined at " + location);
                return;
            fi

            _symbols[symbol.name] = symbol;
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");
            return new UNDEFINED(location, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            return declare_undefined(location, "class", name);
        si

        declare_trait(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            return declare_undefined(location, "trait", name);
        si

        declare_enum(location: LOCATION, name: String) -> Scope is
            return declare_undefined(location, "enum", name);
        si

        declare_enum_member(location: LOCATION, name: String) is
            declare_undefined(location, "enum member", name);
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            return declare_undefined(location, "function", name);
        si

        declare_variable(location: LOCATION, name: String) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String) is
            declare_undefined(location, "property", name);
        si

        declare_label(location: LOCATION, name: String) is
            declare_undefined(location, "label", name);
        si

        declare_function_group(location: LOCATION, function: Function) is
            var existing = find_direct(function.name);
            var function_group: Symbol.FUNCTION_GROUP;

            if existing != null then
                if !isa Symbol.FUNCTION_GROUP(existing) then
                    CONTAINER.instance.logger.error(location, "redefining symbol " + name + " originally defined at " + existing.location);
                    CONTAINER.instance.logger.error(existing.location, "symbol " + name + " is redefined at " + location);
                fi

                function_group = cast Symbol.FUNCTION_GROUP(existing);
            else
                function_group = new Symbol.FUNCTION_GROUP(LOCATION.dummy, function.name);
                _symbols[function.name] = function_group;
            fi

            function_group.add(function);
        si

/*
        toString() -> String is
            var result = new StringBuffer();

            result
                .append(Class.Name)
                .append(" ")
                .append(name)
                .append(" ")
                .append(location)
                .append(": ");

            for s in _symbols.Pairs do
                result
                    .append(s)
                    .append(" ");
            od

            return result;
        si
*/
        dump_stack() -> String =>
            ClassName + "\n";
    si

    class UNDEFINED: BASE, Scope, DeclarationContext, Semantic.Type.Typed is
        type: Type.BASE is throw new NotImplementedException("implement me"); si

        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            return declare_undefined(location, "class", name);
        si

        declare_trait(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            return declare_undefined(location, "trait", name);
        si

        declare_enum(location: LOCATION, name: String) -> Scope is
            return declare_undefined(location, "enum", name);
        si

        declare_enum_member(location: LOCATION, name: String) is
            declare_undefined(location, "enum member", name);
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            return declare_undefined(location, "function", name);
        si

        declare_variable(location: LOCATION, name: String) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String) is
            declare_undefined(location, "undefine", name);
        si        

        declare_label(location: LOCATION, name: String) is
            declare_undefined(location, "label", name);
        si

        dump_stack() -> String is
            return ClassName + "\n";
        si
    si

    class ScopedWithEnclosingScope: Scoped is
        _enclosing_scope: Scope;

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name);

            _enclosing_scope = enclosing_scope;
        si

        find_enclosing_only(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing only: " + name + "...");

            if _enclosing_scope != null then
                var result = _enclosing_scope.find_enclosing(name);

                if result != null then
                    LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing only: " + name + ": result is " + Object.dump(result));
                else
                    LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing only: " + name + ": no result");
                fi

                return result;
            fi

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing only: " + name + ": no enclosing scope");

            return null;
        si

        find_enclosing(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + "...");

            var result = find_direct(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": result is " + Object.dump(result));

                return result;
            else
                return find_enclosing_only(name);
            fi
        si

        dump_stack() -> String is
            var result: String = ClassName + "\n";


            if _enclosing_scope != null then
                result = result + _enclosing_scope.dump_stack();
            fi

            return result;
        si
    si

    class ScopedWithInheritedScopes: ScopedWithEnclosingScope is
        _inherited_scopes: Vector[Scope];

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name, enclosing_scope);

            _inherited_scopes = new Vector[Scope]();
        si

        find_member(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + "...");

            var result = find_direct(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            result = find_member_only(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + " no result");

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            result = find_member_only(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            result = find_enclosing_only(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + " no result");

            return null;
        si

        find_member_only(name: String) -> BASE is
            LOGGER.trace("find-symbol", 
            ClassName + " " + self.name + " find member only: " + name + "...");
            for i in _inherited_scopes do
                var result = i.find_member(name);

                if result != null then
                    LOGGER.trace("find-symbol", 
                    ClassName + " " + self.name + " find member only: " + name + ": result is " + Object.dump(result));
                    return result;
                fi
            od

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member only: " + name + " no result");

            return null;
        si
    si

    // FIXME: doesn't really have a type, not sure how to represent this:
    class NAMESPACE: ScopedWithEnclosingScope, NamespaceContext, Type.Typed is
        qualified_name: String;

        type: Type.BASE;

        init(location: LOCATION, name: String, enclosing_scope: Scope, qualified_name: String) is
            super.init(location, name, enclosing_scope);

            self.qualified_name = qualified_name;

            type = new Type.NAMED(name, self);            
        si

        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE) is
            declare(location, namespace_);
        si

        declare_class(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.CLASS(location, name, enclosing);

            declare(location, result);

            return result;
        si

        declare_trait(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.TRAIT(location, name, enclosing);

            declare(location, result);

            return result;
        si

        declare_enum(location: LOCATION, name: String) -> Scope is
            var result = new Symbol.ENUM(location, name);

            declare(location, result);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, name, enclosing);

            declare_function_group(location, result);

            return result;
        si

        declare_variable(location: LOCATION, name: String) is
            var result = new Symbol.GLOBAL_VARIABLE(location, name);

            declare(location, result);
        si

        declare_property(location: LOCATION, name: String) is
            var result = new Symbol.GLOBAL_PROPERTY(location, name);

            declare(location, result);
        si        
    si

    class ENUM: Scoped, Type.Typed is
        type: Type.BASE;

        init(location: LOCATION, name: String) is
            super.init(location, name);

            type = new Type.NAMED(name, self);
        si

        declare_enum_member(location: LOCATION, name: String) is
            var result = new Symbol.ENUM_MEMBER(location, name);

            declare(location, result);
        si
    si

    class ENUM_MEMBER: BASE, Type.Typed is
        owner: ENUM public;
        type: Type.BASE => owner.type;

        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si

    class LABEL: BASE is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si

    class CLASS: ScopedWithInheritedScopes, Type.Typed is
        type: Type.BASE;

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name, enclosing_scope);

            type = new Type.NAMED(name, self);
        si

        declare_enum(location: LOCATION, name: String) -> Scope is
            var result = new Symbol.ENUM(location, name);

            declare(location, result);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, name, enclosing);

            declare_function_group(location, result);

            return result;
        si

        declare_variable(location: LOCATION, name: String) is
            var result = new Symbol.INSTANCE_VARIABLE(location, name);

            declare(location, result);
        si

        declare_property(location: LOCATION, name: String) is
            var result = new Symbol.INSTANCE_PROPERTY(location, name);

            declare(location, result);
        si        
    si

    class TRAIT: ScopedWithInheritedScopes, Type.Typed is
        type: Type.BASE public;

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name, enclosing_scope);

            type = new Type.NAMED(name, this);
        si

        declare_enum(location: LOCATION, name: String) -> Scope is
            var result = new Symbol.ENUM(location, name);

            declare(location, result);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, name, enclosing);

            declare_function_group(location, result);

            return result;
        si

        declare_property(location: LOCATION, name: String) is
            var result = new Symbol.INSTANCE_PROPERTY(location, name);

            declare(location, result);
        si
    si

    class Function: ScopedWithEnclosingScope, Type.Typed is
        type: Type.BASE public;

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name, enclosing_scope);

            type = new Type.NAMED(name, self);
        si

        declare_variable(location: LOCATION, name: String) is
            var result = new Symbol.LOCAL_VARIABLE(location, name);

            declare(location, result);
        si
    si

    class GLOBAL_FUNCTION: Function is
        init(location: LOCATION, name: String, qualifier_scope: Scope) is
            super.init(location, name, qualifier_scope);
        si
    si

    class INSTANCE_FUNCTION: Function is
        init(location: LOCATION, name: String, qualifier_scope: Scope) is
            super.init(location, name, qualifier_scope);
        si
    si

    class FUNCTION_GROUP: BASE, Type.Typed is
        type: Type.BASE public;

        _functions: Vector[Function];

        init(location: LOCATION, name: String) is
            super.init(location, name);

            type = new Type.FUNCTION_GROUP(name, self);
            _functions = new Vector[Function]();
        si

        add(function: Function) is
            _functions.add(function);
        si

        toString() -> String =>
            Class.Name + " " + name + " @ " + location + " (" + _functions + ")";
    si

    class Variable: BASE, Type.SettableTyped is
        type: Type.BASE public;
    
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        toString() -> String =>
            Class.Name + " " + name + " @ " + location + " type: " + type;
    si

    class LOCAL_VARIABLE: Variable is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si

    class GLOBAL_VARIABLE: BASE is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si

    class INSTANCE_VARIABLE: BASE is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si

    class Property: BASE, Type.SettableTyped is
        type: Type.BASE public;

        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si

    class INSTANCE_PROPERTY: Property is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si

    class GLOBAL_PROPERTY: Property is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si    
si
