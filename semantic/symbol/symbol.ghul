namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;
    
    enum ACCESS is
        PRIVATE, PUBLIC, PROTECTED
    si

    // FIXME: shouldn't be Type.Typed, but cannot have type property and not implement this trait, or it stuffs
    // up overrides in derived classes, because of mismatch in calling convention (with/without trait selector param)
    class BASE /* : Object, Semantic.Type.Typed */ is
        location: LOCATION;
        _name: String;
        
        name: String => _name;

        /*
        type: Type.BASE is
            throw new NotImplementedException(ClassName + " has no type");
        si
        */

        access: ACCESS is
            return ACCESS.PUBLIC;
        si

        init(location: LOCATION, name: String) is
            self.location = location;
            _name = name;
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be loaded: " + self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be stored: " + self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be called: " + self);
        si
        
        find_direct(name: String) -> BASE is    
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find direct: " + name + ": not a scope");
            return null;
        si

        find_member(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + ": not a scope");
            return null;
        si

        find_enclosing(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": not a scope");
            return null;
        si

        toString() -> String =>
            Class.Name + " " + name + " @ " + location;
    si

    class Scoped: BASE, Scope, DeclarationContext is
        _symbols: Map[String,BASE] public; // FIXME: make private

        symbols: Iterable[BASE] => _symbols;

        init(location: LOCATION, name: String) is
            super.init(location, name);
            _symbols = new Map[String,BASE]();
        si

        find_direct(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find direct: " + name + "...");
            return _symbols[name];
        si

        declare(location: LOCATION, symbol: BASE) is
            var existing = find_direct(symbol.name);

            if existing != null then
                CONTAINER.instance.logger.error(location, "redefining symbol " + name + " originally defined at " + existing.location);
                CONTAINER.instance.logger.error(existing.location, "symbol " + name + " is redefined at " + location);
                return;
            fi

            _symbols[symbol.name] = symbol;
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");
            return new UNDEFINED(location, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, enclosing: Scope) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, enclosing: Scope) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_type(location: LOCATION, name: String) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String) is
            declare_undefined(location, "enum member", name);
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String) is
            declare_undefined(location, "property", name);
        si

        declare_label(location: LOCATION, name: String) is
            declare_undefined(location, "label", name);
        si

        declare_function_group(location: LOCATION, function: Function) is
            var existing = find_direct(function.name);
            var function_group: Symbol.FUNCTION_GROUP;

            if existing != null then
                if !isa Symbol.FUNCTION_GROUP(existing) then
                    CONTAINER.instance.logger.error(location, "redefining symbol " + name + " originally defined at " + existing.location);
                    CONTAINER.instance.logger.error(existing.location, "symbol " + name + " is redefined at " + location);
                fi

                function_group = cast Symbol.FUNCTION_GROUP(existing);
            else
                function_group = new Symbol.FUNCTION_GROUP(LOCATION.dummy, function.name);
                _symbols[function.name] = function_group;
            fi

            function_group.add(function);
        si

        toString() -> String is
            var result = new StringBuffer();

            result
                .append(Class.Name)
                .append(" ")
                .append(name)
                .append(" ")
                .append(location)
                .append(": ");

            for s in _symbols.Pairs do
                result
                    .append(s)
                    .append(" ");
            od

            return result;
        si

        dump_stack() -> String =>
            ClassName + "\n";
    si

    class UNDEFINED: BASE, Scope, DeclarationContext, Semantic.Type.Typed is
        type: Type.BASE is throw new NotImplementedException("implement me"); si

        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, enclosing: Scope) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, enclosing: Scope) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_type(location: LOCATION, name: String) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String) is
            declare_undefined(location, "enum member", name);
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String) is
            declare_undefined(location, "undefine", name);
        si        

        declare_label(location: LOCATION, name: String) is
            declare_undefined(location, "label", name);
        si

        dump_stack() -> String =>
            ClassName + "\n";
    si

    class ScopedWithEnclosingScope: Scoped is
        _enclosing_scope: Scope;

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name);

            _enclosing_scope = enclosing_scope;
        si

        find_enclosing_only(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing only: " + name + "...");

            if _enclosing_scope != null then
                var result = _enclosing_scope.find_enclosing(name);

                if result != null then
                    LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing only: " + name + ": result is " + Object.dump(result));
                else
                    LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing only: " + name + ": no result");
                fi

                return result;
            fi

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing only: " + name + ": no enclosing scope");

            return null;
        si

        find_enclosing(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + "...");

            var result = find_direct(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": result is " + Object.dump(result));

                return result;
            else
                return find_enclosing_only(name);
            fi
        si

        dump_stack() -> String is
            var result: String = ClassName + "\n";

            if _enclosing_scope != null then
                result = result + _enclosing_scope.dump_stack();
            fi

            return result;
        si
    si

    class ScopedWithInheritedScopes: ScopedWithEnclosingScope is
        _inherited_scopes: Vector[Scope];

        overrides_resolved: bool;

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name, enclosing_scope);

            _inherited_scopes = new Vector[Scope]();
        si

        add_inherited_scope(scope: Scope) is
            _inherited_scopes.add(scope);
        si

        resolve_overrides() is
            if overrides_resolved then
                return;
            fi

            for s in _inherited_scopes do
                let ancestor = cast ScopedWithInheritedScopes(s);

                ancestor.resolve_overrides();
            od

            for s in symbols do
                if isa FUNCTION_GROUP(s) then
                    let overriding_fg = cast FUNCTION_GROUP(s);
                
                    // FIXME: search all ancestors here and then enclosing scope
                    for overridden_fg in find_member_all(s.name) do
                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    od

                    let overridden_fg = find_enclosing_only(s.name);

                    if overridden_fg != null then
                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    fi
                fi
            od

            overrides_resolved = true;
        si

        // FIXME: callers must exclude from the results any functions that are defined in
        // an enclosing scope, rather than in this class or an ancestor
        find_member(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + "...");

            var result = find_direct(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            result = find_member_only(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member: " + name + " no result");

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            result = find_member_only(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            result = find_enclosing_only(name);

            if result != null then
                LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + ": result is " + Object.dump(result));
                return result;
            fi

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find enclosing: " + name + " no result");

            return null;
        si

        find_member_only(name: String) -> BASE is
            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member only: " + name + "...");
            for i in _inherited_scopes do
                var result = i.find_member(name);

                if result != null then
                    LOGGER.trace("find-symbol", 
                    ClassName + " " + self.name + " find member only: " + name + ": result is " + Object.dump(result));
                    return result;
                fi
            od

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member only: " + name + " no result");

            return null;
        si

        find_member_all(name: String) -> Iterable[BASE] is
            let result = new Vector[BASE]();

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member all: " + name + "...");
            for i in _inherited_scopes do
                let s = i.find_member(name);

                if s != null then
                    LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member all: " + name + ": result add " + Object.dump(result));
                    result.add(s);
                fi
            od

            LOGGER.trace("find-symbol", ClassName + " " + self.name + " find member all: " + name + " results " + result);

            return result;
        si

        toString() -> String => 
            super.toString() + ": " + _inherited_scopes;
    si

    // FIXME: doesn't really have a type, not sure how to represent this:
    class NAMESPACE: ScopedWithEnclosingScope, NamespaceContext, Type.Typed is
        qualified_name: String;

        type: Type.BASE;

        init(location: LOCATION, name: String, enclosing_scope: Scope, qualified_name: String) is
            super.init(location, name, enclosing_scope);

            self.qualified_name = qualified_name;

            type = new Type.NAMED(name, self);
            si

        find_member(name: String) -> BASE
            => find_direct(name);

        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE) is
            declare(location, namespace_);
        si

        declare_class(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.CLASS(location, name, enclosing);

            declare(location, result);

            return result;
        si

        declare_trait(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.TRAIT(location, name, enclosing);

            declare(location, result);

            return result;
        si

        declare_enum(location: LOCATION, name: String) -> Scope is
            var result = new Symbol.ENUM(location, name);

            declare(location, result);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, name, enclosing);

            declare_function_group(location, result);

            return result;
        si

        declare_variable(location: LOCATION, name: String) is
            var result = new Symbol.GLOBAL_VARIABLE(location, name);

            declare(location, result);
        si

        declare_property(location: LOCATION, name: String) is
            var result = new Symbol.GLOBAL_PROPERTY(location, name);

            declare(location, result);
        si
        
        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_namespace(self);
        si        
    si

    class ENUM: Scoped, Type.Typed is
        type: Type.BASE;

        init(location: LOCATION, name: String) is
            super.init(location, name);

            type = new Type.NAMED(name, self);
        si

        declare_enum_member(location: LOCATION, name: String) is
            var result = new Symbol.ENUM_MEMBER(location, this, name);

            declare(location, result);
        si

        find_member(name: String) -> BASE
            => find_direct(name);

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_enum(self);
        si

        dump_scope() -> String is
            var result = new StringBuffer();

            result
                .append(Class.Name)
                .append(" ")
                .append(name)
                .append(" ")
                .append(location)
                .append(": ");

            for s in _symbols.Pairs do
                result
                    .append(s)
                    .append(" ");
            od

            return result;
        si
    si

    class ENUM_MEMBER: BASE, Type.Typed is
        owner: ENUM public;
        type: Type.BASE => owner.type;

        init(location: LOCATION, owner: ENUM, name: String) is
            super.init(location, name);

            self.owner = owner;
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            var result = loader.load_enum_member(self);

            IO.Std.err.println("ENUM_MEMBER.load: " + result);

            return result;
        si
    si

    class LABEL: BASE is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si
    si

    class TYPE: Scoped, Type.Typed is
        type: Type.NAMED;

        init(location: LOCATION, name: String) is
            super.init(location, name);

            type = new Type.NAMED(name, self);
        si
    si

    class CLASS: ScopedWithInheritedScopes, Type.Typed is
        type: Type.BASE;

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name, enclosing_scope);

            type = new Type.NAMED(name, self);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_class(self);
        si

        declare_type(location: LOCATION, name: String) -> Scope is
            var result = new Symbol.TYPE(location, name);

            declare(location, result);

            return result;
        si

        declare_enum(location: LOCATION, name: String) -> Scope is
            var result = new Symbol.ENUM(location, name);

            declare(location, result);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, name, enclosing);

            declare_function_group(location, result);

            return result;
        si

        declare_variable(location: LOCATION, name: String) is
            var result = new Symbol.INSTANCE_VARIABLE(location, name);

            declare(location, result);
        si

        declare_property(location: LOCATION, name: String) is
            var result = new Symbol.INSTANCE_PROPERTY(location, name);

            declare(location, result);
        si        
    si

    class TRAIT: ScopedWithInheritedScopes, Type.Typed is
        type: Type.BASE public;

        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name, enclosing_scope);

            type = new Type.NAMED(name, this);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_trait(self);
        si        
        
        declare_enum(location: LOCATION, name: String) -> Scope is
            var result = new Symbol.ENUM(location, name);

            declare(location, result);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, name, enclosing);

            declare_function_group(location, result);

            return result;
        si

        declare_property(location: LOCATION, name: String) is
            var result = new Symbol.INSTANCE_PROPERTY(location, name);

            declare(location, result);
        si
    si

    class Function: ScopedWithEnclosingScope, Type.Typed is
        type: Type.BASE public;
        arguments: List[Type.BASE] public;

        override: Function public
            => null,
            = value
                is throw new NotImplementedException("" + self + " cannot override " + value); si
        
        init(location: LOCATION, name: String, enclosing_scope: Scope) is
            super.init(location, name, enclosing_scope);

            type = new Type.NAMED(name, self);
        si

        declare_variable(location: LOCATION, name: String) is
            var result = new Symbol.LOCAL_VARIABLE(location, name);

            declare(location, result);
        si

        toString() -> String => super.toString() + " (" + arguments + ")";
    si

    class GLOBAL_FUNCTION: Function is
        init(location: LOCATION, name: String, qualifier_scope: Scope) is
            super.init(location, name, qualifier_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);        
            return loader.load_global_function(self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            assert(from == null);
            return caller.call_global_function(self, arguments);
        si
    si

    class INSTANCE_FUNCTION: Function is
        override: Function public;

        init(location: LOCATION, name: String, qualifier_scope: Scope) is
            super.init(location, name, qualifier_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_function(from, self);
        si        

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_instance_function(from, self, arguments);
        si        
    si

    class FUNCTION_GROUP: BASE, Type.Typed is
        type: Type.BASE public;

        functions: Vector[Function];

        init(location: LOCATION, name: String) is
            super.init(location, name);

            type = new Type.FUNCTION_GROUP(name, self);
            functions = new Vector[Function]();
        si        

        add(function: Function) is
            functions.add(function);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_function_group(from, self);
        si        

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException("cannot call unresolved function overload group: " + self);
        si        
        
        find_override(function: Function) -> Function is
            var result: Function;

            for f in functions do
                if f.arguments.Length == function.arguments.Length then
                    result = f;

                    for i in 0..f.arguments.Length-1 do
                        if f.arguments[i] !~ function.arguments[i] then
                            result = null;
                            break;
                        fi
                    od

                    if result != null then
                        return result;
                    fi
                fi
            od

            return null;
        si

        merge(group: FUNCTION_GROUP) is
            for f in group.functions do
                var override = find_override(f);
/*
                assert(
                    isa INSTANCE_FUNCTION(override) == isa INSTANCE_FUNCTION(f),
                    "" + override + " cannot override " + f);
*/
                if override != null then
                    if isa INSTANCE_FUNCTION(override) then
                        if isa INSTANCE_FUNCTION(f) then
                            override.override = f;

                            CONTAINER.instance.logger
                                .info(
                                    override.location,
                                    "overrides function defined at " + f.location);
                        else
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location);
                        fi
                    else
                        if isa INSTANCE_FUNCTION(f) then
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location);

                        else
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location);
                        fi
                    fi

                    IO.Std.err.println("" + override + " overrides " + f);
                else
                    add(f);
                fi
            od
        si

        toString() -> String =>
            Class.Name + " " + name + " @ " + location + " (" + functions + ")";
    si

    class Variable: BASE, Type.SettableTyped is
        type: Type.BASE public;
    
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        toString() -> String =>
            Class.Name + " " + name + " @ " + location + " type: " + type;
    si

    class LOCAL_VARIABLE: Variable is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is            
            assert(from == null);
            return loader.load_local_variable(self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_local_variable(self, value);
        si        
    si

    class GLOBAL_VARIABLE: Variable is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_global_variable(self);
        si        

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_global_variable(self, value);
        si        
    si

    class INSTANCE_VARIABLE: Variable is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_variable(from, self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_variable(from, self, value);
        si                
    si

    class Property: BASE, Type.SettableTyped is
        type: Type.BASE public;

        init(location: LOCATION, name: String) is
            super.init(location, name);
        si        
    si

    class INSTANCE_PROPERTY: Property is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        // FIXME: something somewhere down the line needs to transform these
        // in to appropriate method calls:
        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_property(from, self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_property(from, self, value);
        si        
    si

    class GLOBAL_PROPERTY: Property is
        init(location: LOCATION, name: String) is
            super.init(location, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null, "expected from to be null but got " + from);

            return loader.load_global_property(self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null, "expected from to be null but got " + from);

            return loader.store_global_property(self, value);
        si        
    si    
si
