namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    enum ACCESS is
        PRIVATE, PUBLIC, PROTECTED
    si

    // Language Server Protocol symbol kinds.
    // Not all are applicatble to ghÅ«l:

    /*
	export const File = 1;
	export const Module = 2;
	export const Namespace = 3;
	export const Package = 4;
	export const Class = 5;
	export const Method = 6;
	export const Property = 7;
	export const Field = 8;
	export const Constructor = 9;
	export const Enum = 10;
	export const Interface = 11;
	export const Function = 12;
	export const Variable = 13;
	export const Constant = 14;
	export const String = 15;
	export const Number = 16;
	export const Boolean = 17;
	export const Array = 18;
	export const Object = 19;
	export const Key = 20;
	export const Null = 21;
	export const EnumMember = 22;
	export const Struct = 23;
	export const Event = 24;
	export const Operator = 25;
	export const TypeParameter = 26;
    */

    // FIXME: think the language server needs to declare it can
    // use the newer list below for completions as well as symbol info:
    enum COMPLETION_KIND is
        UNDEFINED = 0,
        METHOD = 2,
        FUNCTION = 3,
        CONSTRUCTOR = 4,
        FIELD = 5,
        VARIABLE = 6,
        CLASS = 7,
        INTERFACE = 8,
        MODULE = 9,
        PROPERTY = 10,
        ENUM = 13
    si

    enum SYMBOL_KIND is
        UNDEFINED = 0,
        FILE = 1,
        MODULE = 2,
        NAMESPACE = 3,
        PACKAGE = 4,
        CLASS = 5,
        METHOD = 6,
        PROPERTY = 7,
        FIELD = 8,
        CONSTRUCTOR = 9,
        ENUM = 10,
        INTERFACE = 11,
        FUNCTION = 12,
        VARIABLE = 13,
        CONSTANT = 14,
        STRING = 15,
        NUMBER = 16,
        BOOLEAN = 17,
        ARRAY = 18,
        OBJECT = 19,
        KEY = 20,
        NULL = 21,
        ENUM_MEMBER = 22,
        STRUCT = 23,
        EVENT = 24,
        OPERATOR = 25,
        TYPE_PARAMETER = 26
    si

    trait FrameOwner is
        frame: IR.Frame;
    si

    class BASE: Object, Scope is
        owner: Scope;
        location: LOCATION;
        _name: String;

        name: String => _name;

        qualified_name: String => owner.qualify(name);

        argument_names: List[String] => new String[](0);        
        arguments: List[Type.BASE] => new Type.BASE[](0);
        ancestors: List[Type.BASE] => new Type.BASE[](0);

        specialized_from: Symbol.BASE public;
        specializations: Iterable[List[Type.BASE]] => new List[Type.BASE][](0);

        access: ACCESS => ACCESS.PUBLIC;

        description: String => qualified_name;
        short_description: String => name;

        is_workspace_visible:
             bool => false;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.UNDEFINED;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.UNDEFINED;

        is_trait: bool => false;

        owners_frame: IR.Frame is
            if !owner? then
                return null;
            fi

            if !isa FrameOwner(owner) then
                throw new Exception("oops: " + owner.ClassName + " is not a FrameOwner");
            fi

            return cast FrameOwner(owner).frame;
        si

        init(location: LOCATION, owner: Scope, name: String) is
            self.location = location;
            self.owner = owner;
            _name = name;
        si

        get_ancestor(i: int) -> Type.BASE is
            throw new NotImplementedException(ClassName + " has no ancestor " + i);
        si

        qualify(name: String) -> String => qualified_name + "." + name;

        compare_type(other: Symbol.BASE) -> Type.MATCH
            => Type.MATCH.DIFFERENT;

        /*
        add_specialization(key: GENERIC_KEY) is
            IO.Std.err.println("adding specialization to " + qualified_name);
        si
        */

        specialize(type_map: Dict[String,Type.BASE]) -> BASE is
            throw new NotImplementedException(ClassName + " cannot be specialized: " + self);
        si

        create_frame(frame_factory: IR.FRAME_FACTORY) is
            throw new NotImplementedException(ClassName + " cannot have frame: " + self);
        si

        allocate(builder: IR.BUILDER, type_repository: IR.TYPE_REPOSITORY, ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) is
            throw new NotImplementedException(ClassName + " cannot be allocated: " + self);
        si

        complete_frame(type_repository: IR.TYPE_REPOSITORY) is
            throw new NotImplementedException(ClassName + " cannot complete frame: " + self);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be loaded: " + self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be stored: " + self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be called: " + self);
        si

        get_ir_type(type_repo: IR.TYPE_REPOSITORY) -> IR.Type is
            throw new System.NotImplementedException(ClassName);
        si

        find_direct(name: String) -> BASE => null;

        find_member(name: String) -> BASE => null;

        find_enclosing(name: String) -> BASE => null;

        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        find_ancestor_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        collapse_group_if_single_member() -> Symbol.BASE is
            return self;
        si

        toString() -> String =>
            ClassName + " " + name + " @ " + location;
    si

    // A GENERIC represents a particular specialization of a generic class, trait or struct - i.e. a version of that symbol
    // with actual type arguments specified for its formal type parameters, and all its member symbols' signatutes rewritten replacing
    // instances of each formal type parameter with the corresponding actual type argument  
    class GENERIC: BASE, Scope is
        type_map: Dict[String,Type.BASE];
        arguments: List[Type.BASE];
        ancestors: List[Type.BASE] => symbol.ancestors;
        symbol: ScopedWithInheritance;

        owner: Scope => symbol.owner;
        location: LOCATION => symbol.location;
        name: String => symbol.name;

        access: ACCESS => symbol.access;

        is_trait: bool => symbol.is_trait;

        description: String => qualified_name + "[" + arguments + "]";

        short_description: String is
            let result = new StringBuffer();

            result
                .append(name)
                .append('[');

            var seen_any = false;

            for a in arguments do
                if seen_any then
                    result.append(',');
                fi

                result.append(a.short_description);

                seen_any = true;
            od

            result.append(']');
        si

        symbol_kind: SYMBOL_KIND => symbol.symbol_kind;
        completion_kind: COMPLETION_KIND => symbol.completion_kind;
        // is_workspace_visible: bool => true;

        get_ancestor(i: int) -> Type.BASE
            => ancestors[i].specialize(type_map);

        =~(other: BASE) -> bool is
            if !isa GENERIC(other) then
                return false;
            fi

            let other_generic = cast GENERIC(other);

            if other_generic.symbol != symbol then
                return false;
            fi

            assert(
                other_generic.arguments.Length == arguments.Length,
                "generics with the same symbol should have same number of arguments (% vs %)"
                    % [other_generic.arguments, arguments]: Object);

            for i in 0..arguments.Length do
                if arguments[i] != other_generic.arguments[i] then
                    return false;
                fi
            od

            return true;
        si

        init(location: LOCATION, symbol: ScopedWithInheritance, arguments: List[Type.BASE]) is
            super.init(
                symbol.location,
                symbol,
                symbol.name);

            self.symbol = symbol;

            if arguments.Length != symbol.argument_names.Length then
                IoC.CONTAINER.instance.logger.error(location, "expected % type arguments" % [symbol.argument_names.Length]: Object);
            fi

            self.arguments = arguments;
            type_map = new Map[String,Type.BASE]();

            for i in 0..arguments.Length do
                type_map[symbol.argument_names[i]] = arguments[i];
            od
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return symbol.load(from, loader);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return symbol.store(from, value, loader);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return symbol.call(from, arguments, type, caller);
        si

        // given a member of the class, trait or struct that this generic wraps, we want to get a copy of it
        // with all references to formal type parameters replaced with the corresponding actual type arguments
        _specialize(member: Symbol.BASE) -> Symbol.BASE is
            if member? /* && result.owner == symbol */ then
                // result is owned by the class/trait that we wrap and so
                // needs to be specialized according to our type map

                let generic_cache = IoC.CONTAINER.instance.generic_cache;

                let key = new GENERIC_KEY(symbol, member, arguments);

                // do we already have a specialization for this symbol with
                // our actual type arguments?
                let specialized = generic_cache[key];

                if specialized == null then
                    IO.Std.err.println("not in cache, type map is: " + type_map);
                    // no pre-existing specialization found, create one:
                    specialized = member.specialize(type_map);

                    // and cache it:
                    generic_cache[key] = specialized;
                fi

                return specialized;
            else
                return null;
            fi
        si

        find_direct(name: String) -> BASE is
            return _specialize(symbol.find_direct(name));
        si

        find_member(name: String) -> BASE is
            return _specialize(symbol.find_member(name));
        si

        find_enclosing(name: String) -> BASE is
            let unspecialized = symbol.find_enclosing(name);

            if unspecialized? && unspecialized.owner == symbol then
                return _specialize(unspecialized);
            else
                return unspecialized;
            fi
        si

        // used by the language server to offer code completion suggestions - as code completion is
        // only possible from within the class/trait/struct, we do not need to specialize - the user
        // needs to see unspecialized member symbols and formal type parameters 
        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            let m = new Map[String, Symbol.BASE]();

            symbol.find_direct_matches(prefix, m);

            for p in m.Pairs do
                if !matches.contains(p.key) then
                    matches[p.key] = _specialize(p.value).collapse_group_if_single_member();
                fi
            od
        si

        // used by the language server to offer code completion suggestions - as code completion is
        // only possible from within the class/trait/struct, we do not need to specialize - the user
        // needs to see unspecialized member symbols and formal type parameters 
        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            symbol.find_ancestor_matches(prefix, matches);
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        get_ir_type(type_repo: IR.TYPE_REPOSITORY) -> IR.Type
            => type_repo.get_pointer_to_named_type(description);

        hash() -> int is
            var result = symbol.hash();

            for a in arguments do
                result = result + a.hash();
            od

            return result;
        si

        toString() -> String => qualified_name + "[" + arguments + "]";
    si

    class Scoped: BASE, Scope, DeclarationContext is
        _symbols: SYMBOL_MAP;

        symbols: Iterable[BASE] => _symbols;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
            _symbols = new SYMBOL_MAP();
        si

        resolve_overrides() is
            throw new NotImplementedException();
        si

        find_direct(name: String) -> BASE is
            return _symbols[name];
        si

        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            _symbols.find_matches(prefix, matches);
        si

        declare(location: LOCATION, symbol: BASE, symbol_definition_listener: SymbolDefinitionListener) is
            var existing = find_direct(symbol.name);

            if existing? then
                CONTAINER.instance.logger.error(location, "redefining symbol " + symbol.name + " originally defined at " + existing.location);
                CONTAINER.instance.logger.error(existing.location, "symbol " + symbol.name + " is redefined at " + location);

                return;
            fi

            if symbol_definition_listener? then
                symbol_definition_listener.add_symbol_definition(location, symbol);
            fi

            _symbols[symbol.name] = symbol;
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, self, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_struct(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "struct", name);

        declare_type(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "closure", name);

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "innate", name);

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "property", name);
        si

        declare_label(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "label", name);
        si

        declare_function_group(location: LOCATION, function: Function, symbol_definition_listener: SymbolDefinitionListener) is
            var existing = find_direct(function.name);
            var function_group: Symbol.FUNCTION_GROUP;

            if existing? then
                if !isa Symbol.FUNCTION_GROUP(existing) then
                    CONTAINER.instance.logger.error(location, "redefining symbol " + function.name + " originally defined at " + existing.location);
                    CONTAINER.instance.logger.error(existing.location, "symbol " + function.name + " is redefined at " + location);

                    return;
                fi

                function_group = cast Symbol.FUNCTION_GROUP(existing);
            else
                function_group = new Symbol.FUNCTION_GROUP(LOCATION.dummy, self, function.name);
                _symbols[function.name] = function_group;
            fi

            symbol_definition_listener.add_symbol_definition(location, function);

            function_group.add(function);
        si
    si

    class UNDEFINED: BASE, Scope, DeclarationContext, Type.Typed is
        type: Type.BASE => new Type.ANY();

        description: String => "undefined";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, self, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_struct(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "struct", name);

        declare_type(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "closure", name);

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "innate", name);

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "undefine", name);
        si

        declare_label(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "label", name);
        si
    si

    class ScopedWithEnclosingScope: Scoped is
        _enclosing_scope: Scope;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name);

            _enclosing_scope = enclosing_scope;
        si

        find_enclosing_only(name: String) -> BASE is
            if _enclosing_scope? then
                var result = _enclosing_scope.find_enclosing(name);

                return result;
            fi

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            else
                return find_enclosing_only(name);
            fi
        si

        find_enclosing_only_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            if _enclosing_scope? then
                _enclosing_scope.find_enclosing_matches(prefix, matches);
            fi
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si
    si

    class ScopedWithInheritance: ScopedWithEnclosingScope, FrameOwner is
        _ancestors: Vector[Type.BASE];
        // _specializations: Set[GENERIC_KEY];

        type: Type.BASE public;
        frame: IR.Frame protected;

        argument_names: List[String];
        ancestors: List[Type.BASE] => _ancestors;

        /*
        specializations: Iterable[List[Type.BASE]] is
            let result = new Vector[List[Type.BASE]]();

            for s in _specializations do
                if !s.arguments? || s.arguments.Length == 0 then
                    IO.Std.err.println("oops: retrieving null arguments for specialization of " + qualified_name);
                fi

                result.add(s.arguments);
            od

            return result;
        si
        */

        is_workspace_visible: bool => true;

        init(location: LOCATION, owner: Scope, name: String, argument_names: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            _ancestors = new Vector[Type.BASE]();
            // _specializations = new Set[GENERIC_KEY]();
            self.argument_names = argument_names;

            type = new Type.NAMED(self);
        si

        get_ancestor(i: int) -> Type.BASE
            => ancestors[i].specialize(new Map[String,Type.BASE]());

        add_ancestor(ancestor: Type.BASE) is
            ancestors.add(ancestor);
        si

        push_ancestor(ancestor: Type.BASE) is
            let na = new Vector[Type.BASE]();

            na.add(ancestor);
            na.add(_ancestors);

            _ancestors = na;
        si

        resolve_overrides(overriding_fg: FUNCTION_GROUP, generic_cache: GENERIC_CACHE) is
            try
                // all function groups in ancestors with same name:
                for overridden_fg in find_member_all(overriding_fg.name) do
                    if isa FUNCTION_GROUP(overridden_fg) then
                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    else
                        for f in overriding_fg.functions do
                            CONTAINER.instance.logger.error(f.location, "overriding non-function declared at " + overridden_fg.location);
                        od
                    fi
                od

                // function group in enclosing scope with same name, if any:
                let overridden_fg = find_enclosing_only(overriding_fg.name);

                if overridden_fg? then
                    if isa FUNCTION_GROUP(overridden_fg) then
                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    else
                        for f in overriding_fg.functions do
                            CONTAINER.instance.logger.error(f.location, "overriding non-function declared at " + overridden_fg.location);
                        od
                    fi

                    overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                fi
            catch e: Exception
                IO.Std.err.println("caught exception trying to resolve overrides for " + overriding_fg + "\n" + e);
            yrt
        si

        find_member(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = find_member_only(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = find_member_only(name);

            if result? then
                return result;
            fi

            result = find_enclosing_only(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_member_only(name: String) -> BASE is
            assert(ancestors?, "ancestors is null");

            for a in ancestors do
                if a? && a.scope? then
                    var result = a.scope.find_member(name);

                    if result? then
                        return result;
                    fi
                elif a? then
                    IO.Std.err.println("ancestor of " + qualified_name + " has null scope");
                    IO.Std.err.println("ancestor of " + qualified_name + " has null scope " + a);
                else
                    IO.Std.err.println("ancestor or " + qualified_name + " is null");
                fi
            od

            return null;
        si

        find_member_all(name: String) -> Iterable[BASE] is
            let result = new Vector[BASE]();

            for a in ancestors do
                if a? && a.scope? then
                    let s = a.scope.find_member(name);

                    if s? then
                        result.add(s);
                    fi
                else
                    IO.Std.err.println("something wrong with ancestors for " + qualified_name);
                fi
            od

            return result;
        si

        find_ancestor_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);

            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_member_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si

        /*
        add_specialization(key: GENERIC_KEY) is
            if !key.arguments? || key.arguments.Length == 0 then
                IO.Std.err.println("oops: adding specialization with no arguments to " + self.qualified_name);
            else
                for a in key.arguments do
                    if !a? then
                        IO.Std.err.println("oops: adding specialization with null argument to " + self.qualified_name);
                    fi
                od
            fi

            _specializations.add(key);
        si
        */
        
        get_ir_type(type_repo: IR.TYPE_REPOSITORY) -> IR.Type
            => type_repo.get_pointer_to_named_type(qualified_name);

    si

    // FIXME: doesn't really have a type, not sure how to represent this:
    class NAMESPACE: ScopedWithEnclosingScope, NamespaceContext, Type.Typed, FrameOwner is
        qualified_name: String;

        type: Type.BASE;

        description: String => "namespace " + qualified_name;
        short_description: String => "namespace " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.NAMESPACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.MODULE;

        is_workspace_visible: bool => true;

        frame: IR.Frame;

        init(location: LOCATION, name: String, enclosing_scope: Scope, qualified_name: String) is
            super.init(location, self, name, enclosing_scope);

            self.qualified_name = qualified_name;

            type = new Type.NAMED(self);
        si

        qualify(name: String) -> String => qualified_name.substring(1) + "." + name;

        find_member(name: String) -> BASE
            => find_direct(name);

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
        si

        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare(location, namespace_, symbol_definition_listener);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.CLASS(location, self, name, arguments, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TRAIT(location, self, name, arguments, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_struct(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.STRUCT(location, self, name, arguments, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.GLOBAL_VARIABLE(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.GLOBAL_PROPERTY(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_namespace(self);
        si
    si

    class ENUM_: Scoped, Type.Typed is
        _ancestor_: Type.NAMED;
        _ancestors: Type.BASE[];

        ancestors: List[Type.BASE] is
            if _ancestors == null then
                _ancestor_ = IoC.CONTAINER.instance.ghul_symbol_lookup.get_enum_type(type);

                _ancestors = [cast Type.BASE(_ancestor_)];
            fi

            return _ancestors;
        si

        get_ancestor(index: int) -> Type.BASE is
            assert(index == 0, ClassName + " has only a single ancestor");

            return _ancestor_;
        si

        type: Type.BASE;

        description: String => "enum " + qualified_name;
        short_description: String => "enum " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;
        is_workspace_visible: bool => true;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            type = new Type.NAMED(self);
        si

        compare_type(other: BASE) -> Type.MATCH is
            if self == other then
                return Type.MATCH.SAME;
            else
                return Type.MATCH.DIFFERENT;
            fi
        si

        specialize(type_map: Dict[String,Type.BASE]) -> BASE
            => self;

        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.ENUM_MEMBER(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        find_member(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = _ancestor_.find_member(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            find_ancestor_matches(prefix, matches);
        si

        find_ancestor_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            _ancestor_.scope.find_member_matches(prefix, matches);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_enum(self);
        si

        get_ir_type(type_repo: IR.TYPE_REPOSITORY) -> IR.Type
            => type_repo.get_int_type(32);
    si

    class ENUM_MEMBER: BASE, Type.Typed is
        _enum: ENUM_ => cast ENUM_(owner);

        type: Type.BASE => _enum.type;

        description: String => "enum member " + qualified_name;
        short_description: String => name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM_MEMBER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;

        qualified_name: String => owner.qualify(name);

        init(location: LOCATION, owner: ENUM_, name: String) is
            super.init(location, owner, name);

            // self.owner = owner;
        si

        specialize(type_map: Dict[String,Symbol.BASE]) -> BASE
            => self;

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            var result = loader.load_enum_member(self);

            return result;
        si
    si

    class LABEL: BASE is
        description: String => "label " + name;
        short_description: String => description;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        specialize(type_map: Dict[String,Symbol.BASE]) -> BASE
            => self;
    si

    class TYPE: Scoped, Type.SettableTyped is
        type: Type.BASE public;
        ancestor: Semantic.Scope public;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.TYPE_PARAMETER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.VARIABLE;

        description: String => name + ": " + type + " // type variable";
        short_description: String => description;

        init(location: LOCATION, owner: Scope, name: String) is
            init(location, owner, name, new Type.NAMED(self));
        si

        init(location: LOCATION, owner: Scope, name: String, type: Type.BASE) is
            super.init(location, owner, name);

            self.type = type;
        si

        find_member(name: String) -> BASE is
            if ancestor? then
                let result = ancestor.find_member(name);

                return result;
            fi
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            if ancestor? then
                ancestor.find_member_matches(prefix, matches);
            fi
        si

        compare_type(other: BASE) -> Type.MATCH is
            if self == other then
                return Type.MATCH.SAME;
            fi

            return Type.MATCH.DIFFERENT;
        si

        specialize(type_map: Dict[String,Type.BASE]) -> BASE is
            IO.Std.err.println("specialize TYPE: " + self + " " + cast word(type_map));

            let result_type = type_map[self.name];

            if result_type? then
                return new TYPE(
                    location,
                    self,
                    name,
                    result_type
                );
            fi

            return self;
        si

        get_ir_type(type_repo: IR.TYPE_REPOSITORY) -> IR.Type
            => type_repo.get_named_type(qualified_name);
    si

    class CLASS: ScopedWithInheritance, Type.Typed is
        description: String => "class " + qualified_name;
        short_description: String => "class " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.CLASS;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_class(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_type(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_variable(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.INSTANCE_VARIABLE(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.INSTANCE_PROPERTY(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        create_frame(factory: IR.FRAME_FACTORY) is
            IO.Std.err.println("create frame for: " + self + " from: " + factory);
            frame = factory.create_frame_for(self);
        si
    si

    class TRAIT: ScopedWithInheritance, Type.Typed is
        description: String => "trait " + qualified_name;
        short_description: String => "trait " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.INTERFACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.INTERFACE;

        is_trait: bool => true;

        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        declare_type(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_trait(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.INSTANCE_PROPERTY(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        create_frame(factory: IR.FRAME_FACTORY) is
            IO.Std.err.println("create frame for: " + self + " from: " + factory);
            frame = factory.create_frame_for(self);
        si
    si

    // FIXME: doesn't support inheritance
    class STRUCT: ScopedWithInheritance, Type.Typed is
        description: String => "struct " + qualified_name;
        short_description: String => "struct " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.STRUCT;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_struct(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_type(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            IO.Std.err.println("declare innate instance: " + result);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.INSTANCE_VARIABLE(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.INSTANCE_PROPERTY(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        create_frame(factory: IR.FRAME_FACTORY) is
            IO.Std.err.println("create frame for: " + self + " from: " + factory);
            frame = factory.create_frame_for(self);
        si
    si

    class CLOSURE: ScopedWithEnclosingScope, Type.Typed, FrameOwner is
        description: String => "" + type + " // closure";
        short_description: String => description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        type: Type.BASE public;

        frame: IR.Frame;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        declare_variable(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.LOCAL_VARIABLE(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.CLOSURE(location, self, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_closure(from, self);
        si
    si

    class Function: ScopedWithEnclosingScope, Type.Typed, FrameOwner is
        type: Type.BASE public;
        arguments: List[Type.BASE] public;

        argument_names: List[String] public;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        is_workspace_visible: bool => true;

        short_description: String => name + "(" + short_argument_descriptions + ") -> " + type.short_description;

        frame: IR.Frame protected;

        argument_descriptions: String is
            let result = new StringBuffer();

            for i in 0..arguments.Length do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_argument_description(i));
            od

            return result;
        si

        short_argument_descriptions: String is
            let result = new StringBuffer();

            for i in 0..arguments.Length do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_short_argument_description(i));
            od

            return result;
        si

        override: Function public
            => null,
            = value
                is throw new NotImplementedException("" + self + " cannot override " + value); si

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            type = new Type.NAMED(self);
        si

        specialize(type_map: Dict[String,Type.BASE]) -> Function is
            if type == null then
                return self;
            fi

            IO.Std.err.println("specialize Function: " + self + " " + cast word(type_map));

            let result = cast Function(clone());

            result.specialized_from = self;

            // IO.Std.err.println("set specialized from: " + qualified_name);

            result.type = type.specialize(type_map);

            result.arguments = new Vector[Type.BASE](arguments);

            for i in 0..arguments.Length do
                let a = arguments[i];

                if a? then
                    result.arguments[i] = arguments[i].specialize(type_map);
                fi
            od

            return result;
        si

        get_full_type(ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) -> Type.NAMED is
            let types = new Vector[Type.BASE](arguments.Length + 1);

            types.add(arguments);
            types.add(type);

            return ghul_symbol_lookup.get_function_type(types);
        si

        is_exact_match(arguments: List[Type.BASE], type: Type.BASE) -> bool is
            if arguments.Length != self.arguments.Length then
                return false;
            fi

            for i in 0..arguments.Length do
                if arguments[i] != self.arguments[i] then
                    return false;
                fi
            od

            if type != self.type then
                return false;
            fi

            return true;
        si

        declare_variable(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.LOCAL_VARIABLE(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.CLOSURE(location, self, name, enclosing);

            declare(location, result, null);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        get_argument_description(index: int) -> String is
            let result = new StringBuffer();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index]);

            return result;
        si

        get_short_argument_description(index: int) -> String is
            let result = new StringBuffer();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index].short_description);

            return result;
        si

        toString() -> String => qualified_name + " (" + arguments + ") -> " + type;
    si

    class INNATE_FUNCTION: Function is
        innate_name: String;
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + type + " // innate function " + innate_name;        

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope, innate_name: String) is            
            super.init(location, owner, name, qualifier_scope);

            self.innate_name = innate_name;
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_global_function(self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            assert(from == null);
            return caller.call_global_function(self, arguments, type);
        si

        create_frame(frame_factory: IR.FRAME_FACTORY) is
            frame = frame_factory.create_frame_for(self);
        si

        allocate(builder: IR.BUILDER, type_repository: IR.TYPE_REPOSITORY, ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) is
            IO.Std.err.println("would alloc global function: " + self);
        si
    si

    class GLOBAL_FUNCTION: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + type + " // global function";

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_global_function(self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            assert(from == null);
            return caller.call_global_function(self, arguments, type);
        si

        create_frame(frame_factory: IR.FRAME_FACTORY) is
            frame = frame_factory.create_frame_for(self);
        si

        allocate(builder: IR.BUILDER, type_repository: IR.TYPE_REPOSITORY, ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) is
            IO.Std.err.println("would alloc global function: " + self);
        si
    si

    class INSTANCE_FUNCTION: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + type + " // instance function";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        override: Function public;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_function(from, self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_instance_function(from, self, arguments, type);
        si

        create_frame(frame_factory: IR.FRAME_FACTORY) is
            frame = frame_factory.create_frame_for(self);
        si

        allocate(builder: IR.BUILDER, type_repository: IR.TYPE_REPOSITORY, ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) is
            IO.Std.err.println("would alloc instance function: " + self + " in frame " + owners_frame);

            let of = owners_frame;

            if !of? then
                return;
            fi

            if override? then
                IO.Std.err.println("overrides " + override.qualified_name);
            else
                IO.Std.err.println("requires new instance function slot");
                // of.alloc_instance_function(ir_type);
            fi            
        si
    si

    class FUNCTION_GROUP: BASE, Type.Typed is
        _overrides_resolved: bool;

        description: String => qualified_name + "(...) // function group";
        short_description: String => name + "(...)";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        type: Type.BASE public;

        functions: Vector[Function];

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            type = new Type.FUNCTION_GROUP(name, self);
            functions = new Vector[Function]();
        si

        specialize(type_map: Dict[String,Type.BASE]) -> FUNCTION_GROUP is
            IO.Std.err.println("specialize: " + self + " " + cast word(type_map));

            let result = cast FUNCTION_GROUP(clone());

            result.specialized_from = self;

            result.type = new Type.FUNCTION_GROUP(
                name,
                result
            );

            var any_changes = false;

            result.functions = new Vector[Function](functions);

            for i in 0..functions.Length do
                result.functions[i] = functions[i].specialize(type_map);
            od

            return result;
        si

        resolve_overrides() is
            if _overrides_resolved then
                return;
            fi

            if isa ScopedWithInheritance(owner) then
                _overrides_resolved = true;

                cast ScopedWithInheritance(owner).resolve_overrides(
                    self,
                    IoC.CONTAINER.instance.generic_cache
                );
            fi
        si

        add(function: Function) is
            functions.add(function);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_function_group(from, self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException("cannot call unresolved function overload group: " + self);
        si

        find_exact_match(arguments: List[Type.BASE], result: Type.BASE) -> Function is
            for f in functions do
                if f.is_exact_match(arguments, result) then
                    return f;
                fi
            od
        si

        find_override(function: Function) -> Function is
            var result: Function;            

            for f in functions do
                if f != function && f.arguments.Length == function.arguments.Length then
                    result = f;

                    for i in 0..f.arguments.Length do
                        if f.arguments[i] !~ function.arguments[i] then

                            result = null;
                            break;
                        fi
                    od

                    if result? then
                        /// IO.Std.err.println("*** % can override %" % [result, f]: Object);
                        return result;
                    fi
                fi
            od

            return null;
        si

        merge(group: FUNCTION_GROUP) is
            group.resolve_overrides();

            for f in group.functions do
                var override = find_override(f);
/*
                assert(
                    isa INSTANCE_FUNCTION(override) == isa INSTANCE_FUNCTION(f),
                    "" + override + " cannot override " + f);
*/
                if override? then
                    if isa INSTANCE_FUNCTION(override) then
                        if isa INSTANCE_FUNCTION(f) then
                            override.override = f;

                            /*
                            CONTAINER.instance.logger
                                .info(
                                    override.location,
                                    "overrides function defined at " + f.location);
                            */
                        else
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location + "(case 1 " + override + " hides " + f + ")");
                        fi
                    else
                        if isa INSTANCE_FUNCTION(f) then
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location + "(case 2 " + override + " hides " + f + ")");

                        else
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location + "(case 3 " + override + " hides " + f + ")");
                        fi
                    fi
                else
                    add(f);
                fi
            od
        si

        collapse_group_if_single_member() -> Symbol.BASE is
            if functions.Length == 1 then
                return functions[0];
            else
                return self;
            fi
        si

        toString() -> String =>
            ClassName + " " + name + " @ " + location + " (" + functions + ")";
    si

    class Variable: BASE, Type.SettableTyped is
        type: Type.BASE public;
        short_description: String => name + ": " + type.short_description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.VARIABLE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.VARIABLE;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        specialize(type_map: Dict[String,Type.BASE]) -> BASE is
            IO.Std.err.println("specialize: " + self + " " + cast word(type_map));

            let result = cast Variable(clone());

            result.specialized_from = self;

            if type? then
                let specialized_type = type.specialize(type_map);

                result.type = specialized_type;
            fi

            return result;
        si

        toString() -> String =>
            ClassName + " " + name + " @ " + location + " type: " + type;
    si

    class LOCAL_VARIABLE: Variable is
        description: String => name + ": " + type + " // local variable";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_local_variable(self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_local_variable(self, value);
        si

        allocate(builder: IR.BUILDER, type_repository: IR.TYPE_REPOSITORY, ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) is
            IO.Std.err.println("would alloc local variable: " + self);
        si
    si

    class GLOBAL_VARIABLE: Variable is
        description: String => qualified_name + ": " + type + " // global variable";
        is_workspace_visible: bool => true;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_global_variable(self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_global_variable(self, value);
        si

        allocate(builder: IR.BUILDER, type_repository: IR.TYPE_REPOSITORY, ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) is
            IO.Std.err.println("would alloc global variable: " + self);
        si
    si

    class INSTANCE_VARIABLE: Variable is
        description: String => qualified_name + ": " + type + " // instance variable";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FIELD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FIELD;

        is_workspace_visible: bool => true;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_variable(from, self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_variable(from, self, value);
        si

        allocate(builder: IR.BUILDER, type_repository: IR.TYPE_REPOSITORY, ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) is
            IO.Std.err.println("would alloc instance variable: " + self);
        si
    si

    class Property: BASE, Type.SettableTyped is
        type: Type.BASE public;
        short_description: String => name + ": " + type.short_description;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.PROPERTY;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.PROPERTY;

        is_workspace_visible: bool => true;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        specialize(type_map: Dict[String,Type.BASE]) -> BASE is
            IO.Std.err.println("specialize: " + self + " " + cast word(type_map));

            let result = cast Property(self.clone());

            result.specialized_from = self;

            if type? then
                result.type = type.specialize(type_map);
            fi

            return result;
        si
    si

    class INSTANCE_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // instance property";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        // FIXME: something somewhere down the line needs to transform these
        // in to appropriate method calls:
        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_property(from, self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_property(from, self, value);
        si
    si

    class GLOBAL_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // global property";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                IO.Std.err.println("expected from to be null but got " + from);
            fi
            */

            return loader.load_global_property(self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                IO.Std.err.println("expected from to be null but got " + from);
            fi
            */

            return loader.store_global_property(self, value);
        si
    si
si
