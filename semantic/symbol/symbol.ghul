namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;
    
    enum ACCESS is
        PRIVATE, PUBLIC, PROTECTED
    si

    // Language Server Protocol symbol kinds.
    // Not all are applicatble to ghÅ«l:
    /*
        Text = 1,
        Method = 2,
        Function = 3,
        Constructor = 4,
        Field = 5,
        Variable = 6,
        Class = 7,
        Interface = 8,
        Module = 9,
        Property = 10,
        Unit = 11,
        Value = 12,
        Enum = 13,
        Keyword = 14,
        Snippet = 15,
        Color = 16,
        File = 17,
        Reference = 18,
    */

    enum LSP_KIND is
        UNDEFINED = 0,
        METHOD = 2,
        FUNCTION = 3,
        CONSTRUCTOR = 4,
        FIELD = 5,
        VARIABLE = 6,
        CLASS = 7,
        INTERFACE = 8,
        MODULE = 9,
        PROPERTY = 10,
        ENUM = 13
    si

    class BASE: Object, Scope is
        owner: Scope;
        location: LOCATION;
        _name: String;
        
        name: String => _name;

        qualified_name: String => owner.qualify(name);

        access: ACCESS => ACCESS.PUBLIC;

        description: String => qualified_name;
        lsp_kind: LSP_KIND => LSP_KIND.UNDEFINED;

        init(location: LOCATION, owner: Scope, name: String) is
            self.location = location;
            self.owner = owner;
            _name = name;
        si

        qualify(name: String) -> String => qualified_name + "." + name;

        compare_type(other: Symbol.BASE) -> Type.MATCH
            => Type.MATCH.DIFFERENT;

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> BASE is
            throw new NotImplementedException(ClassName + " cannot be specialized: " + self);   
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be loaded: " + self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be stored: " + self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be called: " + self);
        si
        
        find_direct(name: String) -> BASE => null; 

        find_member(name: String) -> BASE => null;

        find_enclosing(name: String) -> BASE => null;

        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si
        
        toString() -> String =>
            ClassName + " " + name + " @ " + location;
    si

    class Scoped: BASE, Scope, DeclarationContext is
        _symbols: SYMBOL_MAP;

        symbols: Iterable[BASE] => _symbols;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
            _symbols = new SYMBOL_MAP();
        si

        resolve_overrides() is
            throw new NotImplementedException();
        si

        specialize_symbols(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) is
            Compiler.TRACE.enter("symbols " + ClassName + " " + qualified_name + "...");
        
            let new_symbols = new SYMBOL_MAP();

            for s in symbols do
                Compiler.TRACE.print("symbols " + qualified_name + " member " + s);
            
                let ss = s.specialize(specializer, type_map);

                Compiler.TRACE.print("symbols " +  qualified_name + " done " + ss);

                new_symbols[s.name] = ss;
            od

            _symbols = new_symbols;

            Compiler.TRACE.exit("symbols " + ClassName + " " + qualified_name);
        si       

        find_direct(name: String) -> BASE is
            return _symbols[name];
        si

        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            _symbols.find_matches(prefix, matches);
        si        

        declare(location: LOCATION, symbol: BASE, symbol_use_listener: SymbolUseListener) is
            var existing = find_direct(symbol.name);

            if existing != null then
                CONTAINER.instance.logger.error(location, "redefining symbol " + symbol.name + " originally defined at " + existing.location);
                CONTAINER.instance.logger.error(existing.location, "symbol " + symbol.name + " is redefined at " + location);

                IO.Std.err.println(ClassName + ": existing is: " + existing);
                IO.Std.err.println(ClassName + ": existing is: " + Object.dump(existing));

                IO.Std.err.println(ClassName + ": new is: " + symbol);
                IO.Std.err.println(ClassName + ": new is: " + Object.dump(symbol));                

                IO.Std.err.println("from: " + new Backtrace());

                return;
            fi

            if symbol_use_listener? then
                symbol_use_listener.add_symbol_use(location, symbol);
            fi
            
            _symbols[symbol.name] = symbol;
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");
            return new UNDEFINED(location, self, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_type(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "closure", name);

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "property", name);
        si

        declare_label(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "label", name);
        si

        declare_function_group(location: LOCATION, function: Function, symbol_use_listener: SymbolUseListener) is
            var existing = find_direct(function.name);
            var function_group: Symbol.FUNCTION_GROUP;

            if existing != null then
                if !isa Symbol.FUNCTION_GROUP(existing) then
                    CONTAINER.instance.logger.error(location, "redefining symbol " + function.name + " originally defined at " + existing.location);
                    CONTAINER.instance.logger.error(existing.location, "symbol " + function.name + " is redefined at " + location);

                    IO.Std.err.println(ClassName + ": existing is: " + existing);
                    IO.Std.err.println(ClassName + ": existing is: " + Object.dump(existing));                    

                    IO.Std.err.println(ClassName + ": new is: " + function);
                    IO.Std.err.println(ClassName + ": new is: " + Object.dump(function));


                    IO.Std.err.println("from: " + new Backtrace());

                    return;
                fi

                function_group = cast Symbol.FUNCTION_GROUP(existing);
            else
                function_group = new Symbol.FUNCTION_GROUP(LOCATION.dummy, self, function.name);
                _symbols[function.name] = function_group;
            fi

            symbol_use_listener.add_symbol_use(location, function);            

            function_group.add(function);
        si

        toString() -> String is
            var result = new StringBuffer();

            result
                .append(ClassName)
                .append(" ")
                .append(name)
                .append(" ")
                .append(location)
                .append(": ");

            for s in _symbols.Pairs do
                result
                    .append(s)
                    .append(" ");
            od

            return result;
        si
    si

    class UNDEFINED: BASE, Scope, DeclarationContext, Semantic.Type.Typed is
        type: Type.BASE => new Type.ANY();            

        description: String => "undefined";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, self, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_type(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "closure", name);

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "undefine", name);
        si        

        declare_label(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            declare_undefined(location, "label", name);
        si
    si

    class ScopedWithEnclosingScope: Scoped is
        _enclosing_scope: Scope;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name);

            _enclosing_scope = enclosing_scope;
        si

        find_enclosing_only(name: String) -> BASE is
            if _enclosing_scope != null then
                var result = _enclosing_scope.find_enclosing(name);

                return result;
            fi

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result != null then
                return result;
            else
                return find_enclosing_only(name);
            fi
        si

        find_enclosing_only_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            if _enclosing_scope != null then
                _enclosing_scope.find_enclosing_matches(prefix, matches);
            fi
        si        

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si        
    si

    class ScopedWithInheritance: ScopedWithEnclosingScope is
        type: Type.BASE public;
        arguments: List[String];
        actual_arguments: List[Type.BASE];
    
        ancestors: Vector[Type.NAMED];

        overrides_resolved: bool;

        already_specialized: bool public;

        blah: bool public;

        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            type = new Type.NAMED(name, self);            

            ancestors = new Vector[Type.NAMED]();
            self.arguments = arguments;
        si

        copy_for_specialize() -> ScopedWithInheritance
            => cast ScopedWithInheritance(clone());

        specialize_self(specializer: GENERIC_SPECIALIZER, arguments: Iterable[Type.BASE]) is
            if already_specialized then
                return;
            fi

            Compiler.TRACE.enter("self " + ClassName + " " + qualified_name + "...");

            assert(!already_specialized, "already specialized " + qualified_name + "[" + actual_arguments + "]");
            already_specialized = true;

            let actuals = new Vector[Type.BASE](arguments);
            actual_arguments = actuals;

            // assert(actuals.Length > 0, "does not make sense to create generic specialization of class or trait with no arguments: " + self);

            let type_map = new Map[String,Type.BASE]();

            /*
            assert(
                _arguments.Length == actuals.Length,
                "expected % actual generic type arguments, but % received"
                    % [_arguments.Length, actuals.Length]: Object);
            */

            if _arguments.Length != actuals.Length then
                IO.Std.err.println("oops: %: expected % actual generic type arguments, but % received"
                    % [self.qualified_name, _arguments.Length, actuals.Length]: Object);

                Compiler.TRACE.exit("self " + ClassName + " " + qualified_name + ", exit");            
                    
                return;
            fi

            for i in 0.._arguments.Length do
                Compiler.TRACE.print("specializing " + ClassName + " " + qualified_name + ", should map " + _arguments[i] + " to " + actuals[i]);
                type_map[_arguments[i]] = actuals[i];
            od

            specialize_ancestors(specializer, type_map);

            if _arguments.Length > 0 then
                specialize_symbols(specializer, type_map);
                assert(!overrides_resolved, "overrides already resolved: " + qualified_name + "[" + actual_arguments + "]");
            fi
            
            resolve_overrides();

            Compiler.TRACE.exit("self " + ClassName + " " + qualified_name + ", complete");            
        si        

        specialize_ancestors(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> bool is
            Compiler.TRACE.enter("ancestors " + ClassName + " " + qualified_name + "...");

            let new_ancestors = new Vector[Type.NAMED]();

            for i in 0..ancestors.Length do
                IO.Std.err.println("will specialize ancestor: " + qualified_name + "[" + actual_arguments + "] " + ancestors[i] + " using " + type_map);

                let ancestor = ancestors[i];

                if isa Type.NAMED(ancestor) then
                    let n = cast Type.NAMED(ancestor);

                    let g = n.specialized_from;

                    if g? then
                        new_ancestors[i] = cast Type.NAMED(g.specialize(specializer, type_map));
                    else
                        new_ancestors[i] = cast Type.NAMED(n.specialize(specializer, type_map));
                    fi
                fi

                IO.Std.err.println("specialize ancestor: " + qualified_name + "[" + actual_arguments + "] " + ancestors[i] + " => " + new_ancestors[i] + " because " + type_map);

                if new_ancestors[i] == null then
                    new_ancestors[i] = ancestor;
                    Compiler.TRACE.print("specializing " + ClassName + " " + qualified_name + ", ancestor " + ancestors[i] + " gave null result");
                fi
            od

            ancestors = new_ancestors;

            Compiler.TRACE.exit("ancestors " + ClassName + " " + qualified_name);
        si

        add_ancestor(ancestor: Type.NAMED) is
            ancestors.add(ancestor);
        si

        push_ancestor(ancestor: Type.NAMED) is
            let na = new Vector[Type.NAMED]();

            na.add(ancestor);
            na.add(ancestors);

            ancestors = na;
        si

        resolve_overrides() is
            if overrides_resolved then
                return;
            fi

            if ancestors? then
                for a in ancestors do                
                    if a? && a.symbol? then
                        a.symbol.resolve_overrides();
                    elif a? then                    
                        IO.Std.err.println("something fishy with ancestor of " + qualified_name + " has no symbol");
                        IO.Std.err.println("something fishy with ancestor of " + qualified_name + " has no symbol: " + a);
                    else
                        IO.Std.err.println("something fishy with ancestor of " + qualified_name + " is null");
                    fi
                od
            else
                IO.Std.err.println("oops: no ancestors: " + qualified_name);
            fi

            for s in symbols do
                if s? then
                    if isa FUNCTION_GROUP(s) then
                        _resolve_overrides(cast FUNCTION_GROUP(s));
                    fi
                else
                    IO.Std.err.println("oops: found null symbol: " + qualified_name);
                fi
            od

            overrides_resolved = true;
        si

        _resolve_overrides(overriding_fg: FUNCTION_GROUP) is
            try
                // FIXME: search all ancestors here and then enclosing scope
                for overridden_fg in find_member_all(overriding_fg.name) do
                    if isa FUNCTION_GROUP(overridden_fg) then
                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    else
                        for f in overriding_fg.functions do
                            CONTAINER.instance.logger.error(f.location, "overriding non-function declared at " + overridden_fg.location);
                        od
                    fi
                od

                let overridden_fg = find_enclosing_only(overriding_fg.name);

                if overridden_fg != null then
                    if isa FUNCTION_GROUP(overridden_fg) then
                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    else
                        for f in overriding_fg.functions do
                            CONTAINER.instance.logger.error(f.location, "overriding non-function declared at " + overridden_fg.location);
                        od
                    fi
                
                    overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                fi
            catch e: Exception
                IO.Std.err.println("caught exception trying to resolve overrides for " + overriding_fg + "\n" + e);
            yrt
        si

        compare_type(other: BASE) -> Type.MATCH is
            IO.Std.err.println("compare type: " + qualified_name + "[" + actual_arguments + "] vs " + other.qualified_name);

            if self == other then
                IO.Std.err.println("compare same: " + qualified_name + " (" + cast int(self) + ") vs " + other.qualified_name + " (" + cast int(other) + ")" );
                return Type.MATCH.SAME;
            fi

            if other == null || !isa ScopedWithInheritance(other) then
                if other? then
                    IO.Std.err.println("compare different because not class/trait: " + self.qualified_name + " (" + cast int(self) + ") vs " + other.ClassName + " " + other.qualified_name + " (" + cast int(other) + ")" );
                else
                    IO.Std.err.println("compare different because null: " + self.qualified_name + " (" + cast int(self) + ") vs null (" + cast int(other) + ")" );
                fi
                return Type.MATCH.DIFFERENT;
            fi

            let other_scoped_with_inheritance = cast ScopedWithInheritance(other);

            if qualified_name =~ other.qualified_name then
                IO.Std.err.println("DIRECT MATCH POSSIBLE");
            fi

            IO.Std.err.println("compare type: "
                + qualified_name + " (" + cast int(self) + ") [" + actual_arguments + "] vs "
                + other.qualified_name + " (" + cast int(other) + ") [" + other_scoped_with_inheritance.actual_arguments + "]");

            if other_scoped_with_inheritance.convertable_to(self) then
                IO.Std.err.println("compare convertable to: " + self.qualified_name + " (" + cast int(self) + ") vs " + other.qualified_name + " (" + cast int(other) + ")" );
                return Type.MATCH.CONVERTABLE;
            fi

            var sb = new StringBuffer();

            for a in other_scoped_with_inheritance.ancestors do
                if a == null || a.symbol == null then
                    IO.Std.err.println("oops: ancestor is borked: " + a);
                fi

                if sb.Length > 0 then
                    sb.append(", ");
                fi

                let sa = a.symbol;

                sb.append("" + sa.qualified_name);

                if isa ScopedWithInheritance(sa) then
                    let ca = cast ScopedWithInheritance(sa);

                    sb
                        .append("[")
                        .append(ca.actual_arguments)
                        .append("]");
                fi
            od

            if sb.Length > 0 then
                IO.Std.err.println("will consider ancestors: " + sb);
            fi

            for a in other_scoped_with_inheritance.ancestors do
                if a? && a.symbol? then

                    let match = self.compare_type(a.symbol);

                    if match < Type.MATCH.DIFFERENT then
                        IO.Std.err.println("compare assignable to: " + self.qualified_name + " (" + cast int(self) + ") vs " + other.qualified_name + " (" + cast int(other) + ")" );
                    
                        return cast Type.MATCH(cast int(match) + 1);
                    fi
                fi
            od

            IO.Std.err.println(
                "compare different because no common ancestor: " + qualified_name + "[" + actual_arguments + "] (" + cast int(self) + ") vs "
                + other.qualified_name + "[" + other_scoped_with_inheritance.actual_arguments + "] (" + cast int(other) + ")" );
            return Type.MATCH.DIFFERENT;            
        si

        convertable_to(other: ScopedWithInheritance) -> bool is
            let de_tuple = other.find_member("__de_tuple");

            if de_tuple? && isa FUNCTION_GROUP(de_tuple) then   
                let de_tuple_function_group = cast FUNCTION_GROUP(de_tuple);

                let de_tuple_function = de_tuple_function_group.find_exact_match(new Type.BASE[](0), self.type);
            fi
        si

        // FIXME: callers must exclude from the results any functions that are defined in
        // an enclosing scope, rather than in this class or an ancestor
        find_member(name: String) -> BASE is
            var result = find_direct(name);

            if result != null then
                return result;
            fi

            result = find_member_only(name);

            if result != null then
                return result;
            fi

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result != null then
                return result;
            fi

            result = find_member_only(name);

            if result != null then
                return result;
            fi

            result = find_enclosing_only(name);

            if result != null then
                return result;
            fi

            return null;
        si

        find_member_only(name: String) -> BASE is
            assert(ancestors != null, "oops: " + ClassName + ": ancestors is null");

            for a in ancestors do
                if a? && a.scope? then
                    var result = a.scope.find_member(name);

                    if result != null then
                        return result;
                    fi
                elif a? then
                    IO.Std.err.println("ancestor of " + qualified_name + " has null scope");
                    IO.Std.err.println("ancestor of " + qualified_name + " has null scope " + a);
                else
                    IO.Std.err.println("ancestor or " + qualified_name + " is null");
                fi
            od

            return null;
        si

        find_member_all(name: String) -> Iterable[BASE] is
            let result = new Vector[BASE]();

            for a in ancestors do
                if a? && a.scope? then
                    let s = a.scope.find_member(name);

                    if s? then
                        result.add(s);
                    fi
                else
                    IO.Std.err.println("something wrong with ancestors for " + qualified_name);
                fi
            od

            return result;
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);

            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od            
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_member_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);            
        si
    si

    // FIXME: doesn't really have a type, not sure how to represent this:
    class NAMESPACE: ScopedWithEnclosingScope, NamespaceContext, Type.Typed is
        qualified_name: String;

        type: Type.BASE;

        description: String => "namespace " + qualified_name;
        lsp_kind: LSP_KIND => LSP_KIND.MODULE;        

        init(location: LOCATION, name: String, enclosing_scope: Scope, qualified_name: String) is
            super.init(location, self, name, enclosing_scope);

            self.qualified_name = qualified_name;
            
            type = new Type.NAMED(name, self);
        si

        qualify(name: String) -> String => qualified_name.substring(1) + "." + name;

        find_member(name: String) -> BASE
            => find_direct(name);

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
        si 

        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE, symbol_use_listener: SymbolUseListener) is
            declare(location, namespace_, symbol_use_listener);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.CLASS(location, self, name, arguments, enclosing);

            declare(location, result, symbol_use_listener);

            return result;
        si

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.TRAIT(location, self, name, arguments, enclosing);

            declare(location, result, symbol_use_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.ENUM(location, self, name);

            declare(location, result, symbol_use_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_use_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            var result = new Symbol.GLOBAL_VARIABLE(location, self, name);

            declare(location, result, symbol_use_listener);
        si

        declare_property(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            var result = new Symbol.GLOBAL_PROPERTY(location, self, name);

            declare(location, result, symbol_use_listener);
        si
        
        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_namespace(self);
        si        
    si

    class ENUM: Scoped, Type.Typed is
        type: Type.BASE;

        description: String => "enum " + qualified_name;
        lsp_kind: LSP_KIND => LSP_KIND.ENUM;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            type = new Type.NAMED(name, self);
        si

        compare_type(other: BASE) -> Type.MATCH is
            if self == other then
                return Type.MATCH.SAME;
            else
                return Type.MATCH.DIFFERENT;
            fi
        si

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> BASE
            => self;

        declare_enum_member(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            var result = new Symbol.ENUM_MEMBER(location, self, name);

            declare(location, result, symbol_use_listener);
        si

        find_member(name: String) -> BASE
            => find_direct(name);

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_enum(self);
        si
    si

    class ENUM_MEMBER: BASE, Type.Typed is
        _enum: ENUM => cast ENUM(owner);

        type: Type.BASE => _enum.type;

        description: String => "enum member " + qualified_name;
        lsp_kind: LSP_KIND => LSP_KIND.ENUM;        

        qualified_name: String => owner.qualify(name);

        init(location: LOCATION, owner: ENUM, name: String) is
            super.init(location, owner, name);

            // self.owner = owner;
        si

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Symbol.BASE]) -> BASE
            => self;        

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            var result = loader.load_enum_member(self);

            return result;
        si
    si

    class LABEL: BASE is
        description: String => "label " + name;
    
        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        specialize(type_map: Dict[String,Symbol.BASE]) -> BASE
            => self;        
    si

    class TYPE: Scoped, Type.Typed is
        type: Type.BASE public;

        description: String => name + ": " + type + " // type variable";

        init(location: LOCATION, owner: Scope, name: String) is
            init(location, owner, name, new Type.NAMED(name, self));
        si

        init(location: LOCATION, owner: Scope, name: String, type: Type.BASE) is
            super.init(location, owner, name);

            self.type = type;
        si        

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> BASE is
            let result_type = type_map[self.name];

            if result_type? then
                return new TYPE(
                    location,
                    self,
                    name,
                    result_type
                );
            else
                let specialized_type = type.specialize(specializer);

                if specialized_type !~ type then
                    return new TYPE(
                        location,
                        owner,
                        name,
                        specialized_type
                    );
                fi
            fi

            return self;    
        si
    si

    class CLASS: ScopedWithInheritance, Type.Typed is
        description: String => "class " + qualified_name;
        lsp_kind: LSP_KIND => LSP_KIND.CLASS;        

        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is        
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_class(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_type(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name);

            declare(location, result, symbol_use_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.ENUM(location, self, name);

            declare(location, result, symbol_use_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_use_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            var result = new Symbol.INSTANCE_VARIABLE(location, self, name);
         
            declare(location, result, symbol_use_listener);
        si

        declare_property(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            var result = new Symbol.INSTANCE_PROPERTY(location, self, name);

            declare(location, result, symbol_use_listener);
        si        
    si

    class TRAIT: ScopedWithInheritance, Type.Typed is
        description: String => "trait " + qualified_name;
        lsp_kind: LSP_KIND => LSP_KIND.INTERFACE;        
    
        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        declare_type(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name);

            declare(location, result, symbol_use_listener);

            return result;
        si        

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_trait(self);
        si        

        // FIXME: most of these can be folded into ClassAndTraitBase:
        
        declare_enum(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.ENUM(location, self, name);

            declare(location, result, symbol_use_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.INSTANCE_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_use_listener);

            return result;
        si

        declare_property(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            var result = new Symbol.INSTANCE_PROPERTY(location, self, name);

            declare(location, result, symbol_use_listener);
        si
    si

    class CLOSURE: ScopedWithEnclosingScope, Type.Typed is
        description: String => "" + type + " // closure";
        lsp_kind: LSP_KIND => LSP_KIND.FUNCTION;        
    
        type: Type.BASE public;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        declare_variable(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            var result = new Symbol.LOCAL_VARIABLE(location, self, name);

            declare(location, result, symbol_use_listener);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.CLOSURE(location, self, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_closure(from, self);
        si

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> CLOSURE is   
            let result = cast CLOSURE(clone());

            result.specialize_symbols(specializer, type_map);

            result.type = type.specialize(specializer, type_map);

            return result;
        si
    si

    class Function: ScopedWithEnclosingScope, Type.Typed is
        type: Type.BASE public;
        arguments: List[Type.BASE] public;
        lsp_kind: LSP_KIND => LSP_KIND.FUNCTION;        

        override: Function public
            => null,
            = value
                is throw new NotImplementedException("" + self + " cannot override " + value); si
        
        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            type = new Type.NAMED(name, self);
        si

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> Function is
            Compiler.TRACE.enter("specialize " + ClassName + " " + qualified_name);

            if type == null then
                Compiler.TRACE.exit("specialize " + ClassName + " " + qualified_name + ": oops"); 
            
                IO.Std.err.println("oops: cannot specialize function with no type: " + self.qualified_name);

                return self;
            fi

            let result = cast Function(clone());

            result.specialize_symbols(specializer, type_map);

            result.type = type.specialize(specializer, type_map);

            result.arguments = new Vector[Type.BASE](arguments);

            for i in 0..arguments.Length do
                let a = arguments[i];

                if a? then
                    result.arguments[i] = arguments[i].specialize(specializer, type_map);
                else
                    Compiler.TRACE.exit("specialize " + ClassName + " " + qualified_name + ": oops"); 

                    IO.Std.err.println("oops: cannot specialize null argument #" + i + " for " + qualified_name);
                    return self;
                fi
            od

            Compiler.TRACE.exit("specialize " + ClassName + " " + qualified_name + "(" + arguments + ") -> " + type + " to " + qualified_name + "(" + result.arguments + ") -> " + result.type); 

            return result;
        si

        is_exact_match(arguments: List[Type.BASE], type: Type.BASE) -> bool is
            if arguments.Length != self.arguments.Length then
                return false;
            fi

            for i in 0..arguments.Length do
                if arguments[i] != self.arguments[i] then
                    return false;
                fi
            od

            if type != self.type then
                return false;
            fi

            return true;
        si

        declare_variable(location: LOCATION, name: String, symbol_use_listener: SymbolUseListener) is
            var result = new Symbol.LOCAL_VARIABLE(location, self, name);

            declare(location, result, symbol_use_listener);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.CLOSURE(location, self, name, enclosing);

            declare(location, result, null);

            return result;
        si        

        declare_function(location: LOCATION, name: String, enclosing: Scope, symbol_use_listener: SymbolUseListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_use_listener);

            return result;
        si

        toString() -> String => super.toString() + " (" + arguments + ")";
    si

    class GLOBAL_FUNCTION: Function is
        description: String => qualified_name + "(" + arguments + ") -> " + type + " // global function";
    
        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);        
            return loader.load_global_function(self);
        si

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            assert(from == null);
            return caller.call_global_function(self, arguments);
        si
    si

    class INSTANCE_FUNCTION: Function is
        description: String => qualified_name + "(" + arguments + ") -> " + type + " // instance function";
        lsp_kind: LSP_KIND => LSP_KIND.METHOD;        
    
        override: Function public;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_function(from, self);
        si        

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_instance_function(from, self, arguments);
        si        
    si

    class FUNCTION_GROUP: BASE, Type.Typed is
        description: String => qualified_name + "(...) -> " + type + " // function group";
        lsp_kind: LSP_KIND => LSP_KIND.FUNCTION;        
        
        type: Type.BASE public;

        functions: Vector[Function];

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            type = new Type.FUNCTION_GROUP(name, self);
            functions = new Vector[Function]();
        si        

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> FUNCTION_GROUP is
            let result = cast FUNCTION_GROUP(clone());

            result.type = new Type.FUNCTION_GROUP(
                name,
                result
            );

            var any_changes = false;

            result.functions = new Vector[Function](functions);

            for i in 0..functions.Length do
                result.functions[i] = functions[i].specialize(specializer, type_map);
                IO.Std.err.println("specialized function...");
                IO.Std.err.println(functions[i].qualified_name + "(" + functions[i].arguments + ") -> " + functions[i].type);
                IO.Std.err.println(result.functions[i].qualified_name + "(" + result.functions[i].arguments + ") -> " + result.functions[i].type);
            od

            return result;
        si

        add(function: Function) is
            functions.add(function);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_function_group(from, self);
        si        

        call(from: Graph.Value.BASE, arguments: Iterable[Graph.Value.BASE], caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException("cannot call unresolved function overload group: " + self);
        si

        find_exact_match(arguments: List[Type.BASE], result: Type.BASE) -> Function is
            for f in functions do
                if f.is_exact_match(arguments, result) then    
                    return f;
                fi
            od
        si
        
        find_override(function: Function) -> Function is
            var result: Function;

            for f in functions do
                if f.arguments.Length == function.arguments.Length then
                    result = f;

                    for i in 0..f.arguments.Length do
                        if f.arguments[i] !~ function.arguments[i] then
                            result = null;
                            break;
                        fi
                    od

                    if result != null then
                        return result;
                    fi
                fi
            od

            return null;
        si

        merge(group: FUNCTION_GROUP) is
            for f in group.functions do
                var override = find_override(f);
/*
                assert(
                    isa INSTANCE_FUNCTION(override) == isa INSTANCE_FUNCTION(f),
                    "" + override + " cannot override " + f);
*/
                if override != null then
                    if isa INSTANCE_FUNCTION(override) then
                        if isa INSTANCE_FUNCTION(f) then
                            override.override = f;

                            /*
                            CONTAINER.instance.logger
                                .info(
                                    override.location,
                                    "overrides function defined at " + f.location);
                            */
                        else
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location);
                        fi
                    else
                        if isa INSTANCE_FUNCTION(f) then
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location);

                        else
                            CONTAINER.instance.logger
                                .warn(
                                    override.location,
                                    "hides function defined at " + f.location);
                        fi
                    fi
                else
                    add(f);
                fi
            od
        si

        toString() -> String =>
            ClassName + " " + name + " @ " + location + " (" + functions + ")";
    si

    class Variable: BASE, Type.SettableTyped is
        type: Type.BASE public;
        lsp_kind: LSP_KIND => LSP_KIND.VARIABLE;        
    
        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> BASE is
            let result = cast Variable(clone());

            if type != null then
                let specialized_type = type.specialize(specializer, type_map);

                result.type = specialized_type;
            fi

            return result;
        si

        toString() -> String =>
            ClassName + " " + name + " @ " + location + " type: " + type;
    si

    class LOCAL_VARIABLE: Variable is
        description: String => name + ": " + type + " // local variable";
    
        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is            
            assert(from == null);
            return loader.load_local_variable(self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_local_variable(self, value);
        si        
    si

    class GLOBAL_VARIABLE: Variable is
        description: String => qualified_name + ": " + type + " // global variable";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_global_variable(self);
        si        

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_global_variable(self, value);
        si        
    si

    class INSTANCE_VARIABLE: Variable is
        description: String => qualified_name + ": " + type + " // instance variable";
        lsp_kind: LSP_KIND => LSP_KIND.FIELD;        

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_variable(from, self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_variable(from, self, value);
        si                
    si

    class Property: BASE, Type.SettableTyped is
        type: Type.BASE public;
        lsp_kind: LSP_KIND => LSP_KIND.PROPERTY;        

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        specialize(specializer: GENERIC_SPECIALIZER, type_map: Dict[String,Type.BASE]) -> BASE is
            Compiler.TRACE.enter("specialize property " + qualified_name + " from " + type_map);
        
            let result = cast Property(self.clone());

            if type != null then
                result.type = type.specialize(specializer, type_map);
                Compiler.TRACE.print("result " + qualified_name + " is " + result.type);
            else
                Compiler.TRACE.print("property " + qualified_name + " has no type");                
            fi

            Compiler.TRACE.exit("specialize property " + qualified_name);

            return result;
        si                
    si

    class INSTANCE_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // instance property";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        // FIXME: something somewhere down the line needs to transform these
        // in to appropriate method calls:
        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_property(from, self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_property(from, self, value);
        si        
    si

    class GLOBAL_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // global property";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                IO.Std.err.println("expected from to be null but got " + from);
            fi
            */

            return loader.load_global_property(self);
        si

        store(from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                IO.Std.err.println("expected from to be null but got " + from);
            fi
            */

            return loader.store_global_property(self, value);
        si        
    si    
si
