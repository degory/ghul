namespace Semantic is
    use System;
    use Generic;

    use Logging;
    use Source;

    class OVERLOAD_RESOLVER is
        _logger: Logger;

        init(logger: Logger) is
            super.init();

            _logger = logger;
        si

        resolve(
            location: LOCATION,
            group: Symbol.FUNCTION_GROUP,
            arguments: List[Type.BASE]
        ) -> Symbol.Function
        is
            try
                return _resolve(location, group, arguments);
            catch e: Exception
                IO.Std.err.println("something went wrong resolving overload: " + group);
                return null;
            yrt
        si

        _resolve(
            location: LOCATION,
            group: Symbol.FUNCTION_GROUP,
            arguments: List[Type.BASE]
        ) -> Symbol.Function
        is
            if group == null || group.functions == null || arguments == null then
                return null;
            fi

            let best_score = Type.MATCH.DIFFERENT;
            var result: Symbol.Function;

            for f in group.functions do
                /*
                IO.Std.err.println("try function: " + f);

                IO.Std.err.println("arguments is:   " + cast int(arguments));
                IO.Std.err.println("f.arguments is: " + cast int(f.arguments));
                */
                if f.arguments.Length == 0 && arguments.Length == 0 then
                    // IO.Std.err.println("no arguments, assuming it's right: " + f);
                    return f;
                elif f.arguments.Length == arguments.Length then
                    // IO.Std.err.println("argument counts match, calculate score: " + f);
                    var score = Type.MATCH.SAME;

                    for i in 0..f.arguments.Length do
                        // IO.Std.err.println("compare argument " + i + ": " + f.arguments[i] + " assignable from " + arguments[i] + "?");

                        var match: Type.MATCH;

                        if f.arguments[i]? && arguments[i]? then
                            match = f.arguments[i].compare(arguments[i]);

                            // IO.Std.err.println("match score is: " + cast int(match));

                            if match == Type.MATCH.DIFFERENT then
                                // IO.Std.err.println("not compatible, give up");
                            
                                score = Type.MATCH.DIFFERENT;
                                break;
                            fi
                        else
                            match = Type.MATCH.ASSIGNABLE;
                        fi

                        score = cast Type.MATCH(cast int(score) + cast int(match));

                        // IO.Std.err.println("cumulative score is: " + score);
                    od

                    if score < best_score then
                        best_score = score;
                        result = f;
                        // IO.Std.err.println("best score yet, best match is: " + result);
                    fi
                else
                    // IO.Std.err.println("cannot match: " + f);
                fi
            od

            if result? then
                // IO.Std.err.println("result is: " + result);
                return result;
            fi

            let tried = new StringBuffer();

            for f in group.functions do
                if f.arguments.Length == arguments.Length then
                    if tried.Length > 0 then
                        tried.append(", ");
                    fi

                    tried
                        .append(f.qualified_name)
                        .append("(")
                        .append(f.arguments)
                        .append(")");
                fi
            od

            if tried.Length > 0 then
                _logger.error(location, "no overload found for " + group.name + "(" + arguments + "), tried " + tried);
            else
                _logger.error(location, "no overload found for " + group.name + "(" + arguments + ")");
            fi

            return null;
        si        
    si
si