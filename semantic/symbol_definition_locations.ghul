namespace Semantic is
    use System;
    use Generic;

    use Source;

    trait SymbolDefinitionListener is
        add_symbol_definition(location: LOCATION, symbol: Symbol.BASE);
    si

    class SYMBOL_DEFINITION_LOCATIONS: Object, SymbolDefinitionListener is
        _symbol_use_listener: SymbolUseListener;

        _symbol_definition_map: Dict[String,List[Symbol.BASE]];
        _workspace_definition_map: Dict[String,List[Symbol.BASE]];

        init(symbol_use_listener: SymbolUseListener) is
            _symbol_use_listener = symbol_use_listener;

            clear();
        si

        clear() is
            IO.Std.err.println("clear symbol definition locations...");
            _symbol_definition_map = new Map[String,List[Symbol.BASE]]();
            _workspace_definition_map = new Map[String,List[Symbol.BASE]]();
        si

        add_symbol_definition(location: LOCATION, symbol: Symbol.BASE) is
            if symbol? && symbol.location.file_name !~ "internal" && !symbol.name.startsWith("__") then
                get_symbol_list_for_file_name(location.file_name).add(symbol);

                _symbol_use_listener.add_symbol_use(location, symbol);
            fi
        si

        find_definitions_from_file(file_name: String, workspace_search: bool) -> Iterable[Symbol.BASE] is
            IO.Std.err.println("find definitions for file: " + file_name);

            if workspace_search then
                return get_workspace_list_for_file_name(file_name);
            else
                return get_symbol_list_for_file_name(file_name);
            fi
        si

        get_symbol_list_for_file_name(file_name: String) -> List[Symbol.BASE] is
            var result = _symbol_definition_map[file_name];

            if result == null then
                result = new Vector[Symbol.BASE]();

                _symbol_definition_map[file_name] = result;
            fi

            return result;
        si

        get_workspace_list_for_file_name(file_name: String) -> List[Symbol.BASE] is
            var result = _workspace_definition_map[file_name];

            if result == null then
                IO.Std.err.println("workspace list for file " + file_name + " is empty");
                result = new Vector[Symbol.BASE]();

                _workspace_definition_map[file_name] = result;

                for symbol in get_symbol_list_for_file_name(file_name) do
                    if symbol.is_workspace_visible then
                        IO.Std.err.println("add workspace visible symbol: " + symbol.qualified_name);
                        result.add(symbol);
                    else
                        IO.Std.err.println("skip non-workspace visible symbol: " + symbol.qualified_name);
                    fi
                od                
            fi

            IO.Std.err.println("workspace list for file " + file_name + " is populated");

            return result;
        si        
    si
si
