namespace Semantic is
    use System;
    use Generic;
    use IoC;
    use Logging;
    use Source;

    trait Scope is
        find_direct(name: String) -> Symbol.BASE;
        find_member(name: String) -> Symbol.BASE;
        find_enclosing(name: String) -> Symbol.BASE;
    si

    trait DeclarationContext is
        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope) -> Scope;
        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope) -> Scope;
        declare_type(location: LOCATION, name: String) -> Scope;
        declare_enum(location: LOCATION, name: String) -> Scope;
        declare_enum_member(location: LOCATION, name: String);
        declare_closure(location: LOCATION, name: String, enclosing: Scope) -> Scope;
        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope;
        declare_variable(location: LOCATION, name: String);
        declare_property(location: LOCATION, name: String);
        declare_label(location: LOCATION, name: String);
    si

    trait NamespaceContext is
        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE);
    si

    class USE_SCOPE : Object, Scope  is
        _enclosing: Scope;
        _used_symbols: SortedMap[String,Symbol.BASE];
        _used_scopes: Vector[Scope];

        init(enclosing: Scope) is
            _enclosing = enclosing;
            _used_symbols = new SortedMap[String,Symbol.BASE]();
            _used_scopes = new Vector[Scope]();
        si

        _find_direct(name: String) -> Symbol.BASE is
            var result = _used_symbols[name];

            if result != null then
                return result;
            fi

            for scope in _used_scopes do
                result = scope.find_direct(name);
                if result != null then
                    return result;
                fi
            od

            return null;
        si

        find_member(name: String) -> Symbol.BASE is
            throw new NotImplementedException("cannot search for member " + name + " in use scope");
        si

        find_direct(name: String) -> Symbol.BASE is
            var result = _find_direct(name);

            if result==null && _enclosing!=null then
                result = _enclosing.find_direct(name);
            fi

            return result;
        si

        find_enclosing(name: String) -> Symbol.BASE is
            var result = _find_direct(name);

            if result==null && _enclosing!=null then
                result = _enclosing.find_enclosing(name);
            fi

            return result;
        si

        add_scope(scope: Scope) is
            _used_scopes.add(scope);
        si

        add_symbol(symbol: Symbol.BASE) is
            _used_symbols[symbol.name] = symbol;
        si

        toString() -> String is
            return 
            ClassName + "\n" + _used_symbols + "\n" + _used_scopes;
        si
    si

    class BLOCK_SCOPE : Object , /* implements */ Scope, DeclarationContext  is
        _enclosing: Scope;
        _symbols: Dict[String,Symbol.BASE];

        init() is
            init(null);
        si

        init(enclosing: Scope) is
            self._enclosing = enclosing;
            _symbols = new SortedMap[String,Symbol.BASE]();
        si

        find_direct(name: String) -> Symbol.BASE =>
            _symbols[name];

        find_member(name: String) -> Symbol.BASE is
            throw new NotImplementedException("cannot search for member " + name + " in block scope");
        si

        find_enclosing(name: String) -> Symbol.BASE is
            var result = find_direct(name);

            if result != null then
                return result;
            elif _enclosing != null then
                return _enclosing.find_enclosing(name);
            else
                return null;
            fi
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> Scope is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");
            
            return new Symbol.UNDEFINED(location, name);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_type(location: LOCATION, name: String) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String) is
            declare_undefined(location, "enum member", name);
        si

        declare_function(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            declare_undefined(location, "function", name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE) is
            declare_undefined(location, "namespace", name);
        si

        declare_label(location: LOCATION, name: String) is
            var label = new Symbol.LABEL(location, name);
            declare(location, label);
        si

        declare_variable(location: LOCATION, name: String) is
            var variable = new Symbol.LOCAL_VARIABLE(location, name);
            declare(location, variable);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope) -> Scope is
            var closure = new Symbol.CLOSURE(location, name, enclosing);

            declare(location, closure);

            return closure;
        si        

        declare_property(location: LOCATION, name: String) is
            declare_undefined(location, "property", name);
        si        

        declare(location: LOCATION, symbol: Symbol.BASE) is
            var name = symbol.name;
            var existing = find_direct(symbol.name);
            
            if existing != null then
                CONTAINER.instance.logger.error(location, "redefining symbol " + name + " originally defined at " + existing.location);
                CONTAINER.instance.logger.error(existing.location, "symbol " + name + " is redefined at " + location);

                IO.Std.err.println(ClassName + ": existing is: " + existing);
                IO.Std.err.println(ClassName + ": existing is: " + Object.dump(existing));

                IO.Std.err.println(ClassName + ": new is: " + symbol);
                IO.Std.err.println(ClassName + ": new is: " + Object.dump(symbol));
            fi
            
            _symbols[name] = symbol;
        si

        toString() -> String =>
            self.ClassName + " " + _symbols;
    si
si
