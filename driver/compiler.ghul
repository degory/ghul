namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;

    class COMPILER is
        container: CONTAINER;
        logger: Logger;

        legacy_object_file_name_generator: LEGACY_OBJECT_FILE_NAME_GENERATOR;

        work_items: Vector[WORK_ITEM];

        passes: Vector[Pass];

        generated_source_files: Vector[String];

        init() is
            container = IoC.CONTAINER.instance;
            logger = container.logger;

            legacy_object_file_name_generator = new LEGACY_OBJECT_FILE_NAME_GENERATOR();            
            
            work_items = new Vector[WORK_ITEM]();
            generated_source_files = new Vector[String]();

            passes = new Vector[Pass]();

            add_pass("declare-symbols", (wi: WORK_ITEM) is declare_symbols_pass(wi); si);
            add_pass("resolve-uses", (wi: WORK_ITEM) is resolve_uses_pass(wi); si);
            add_pass("resolve-type-expressions", (wi: WORK_ITEM) is resolve_type_expressions_pass(wi); si);            
            add_pass("resolve-ancestors", (wi: WORK_ITEM) is resolve_ancestors_pass(wi); si);
            add_pass("resolve-overrides", (wi: WORK_ITEM) is resolve_overrides_pass(wi); si);
            add_pass("experiments", (wi: WORK_ITEM) is experiments_pass(wi); si);
            add_pass("write-objects", (wi: WORK_ITEM) is write_objects_pass(wi); si);
        si

        add_pass(description: String, apply: WORK_ITEM -> void) is
            passes.add(new PASS(description, apply));
        si

        parse_and_queue(path: String, reader: IO.Reader, build_flags: BUILD_FLAGS) is
            queue(
                parse(path, reader, build_flags)
            );
        si

        queue(work_item: WORK_ITEM) is
            work_items.add(work_item);
        si

        queue(work_items: Iterable[WORK_ITEM]) is
            self.work_items.add(work_items);
        si

        parse(path: String, reader: IO.Reader, build_flags: BUILD_FLAGS) -> Iterable[WORK_ITEM] is
            IO.Std.err.println("parse: " + path);

            let result = new Vector[WORK_ITEM]();

            let tokenizer = new Lexical.TOKENIZER(
                logger,
                path,
                reader
            );

            let context = new Syntax.Parser.CONTEXT(
                tokenizer,
                logger
            );

            while !context.is_end_of_file do
                var definition = container.definition_parser.parse(context);

                IO.Std.err.println("parse: " + path + ", read definition");
                
                if definition? then
                    result.add(
                        new WORK_ITEM(
                            build_flags,
                            legacy_object_file_name_generator.new_object_file_name_for(path),
                            definition
                        )
                    );
                fi
            od

            IO.Std.err.println("parse: " + path + ", work items: " + result);

            return result;
        si     

        build() is
            for pass in passes do
                for i in work_items do

                    if i.build_flags.dump_tree then
                        IO.Std.err.println(i.definition);
                    fi

                    pass.apply(i);

                    if i.build_flags.dump_tree then
                        IO.Std.err.println(i.definition);
                    fi                    
                od
            od

            work_items.clear();
        si

        declare_symbols_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            container
                .expand_namespaces
                .apply(definition);

            if flags.want_experiments then
                container
                    .rewrite_structured_types_as_classes
                    .apply(definition);

                container
                    .rewrite_properties_as_functions
                    .apply(definition);

                container
                    .declare_symbols
                    .apply(definition);
            fi
        si

        resolve_uses_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;
            
            if flags.want_experiments then
                container
                    .resolve_uses
                    .apply(definition);

                container
                    .set_parents
                    .apply(definition);
            fi
        si

        resolve_ancestors_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_experiments then
                container
                    .resolve_ancestors
                    .apply(definition);                    
            fi
        si

        resolve_type_expressions_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_experiments then
                container
                    .resolve_type_expressions
                    .apply(definition);                    
            fi
        si        

        resolve_overrides_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_experiments then
                container
                    .resolve_overrides
                    .apply(definition);                    
            fi
        si

        experiments_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_experiments then
                container
                    .resolve_explicit_variable_types
                    .apply(definition);

                container
                    .infer_types
                    .apply(definition);
            fi
        si            

        write_objects_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            var printer: Syntax.Process.Printer.BASE;

            if flags.want_legacy then
                printer = container.legacy_printer;
            else
                printer = container.ghul_printer;
            fi

            printer.print(definition);

            if flags.want_legacy then
                generated_source_files.add(work_item.legacy_object_file_name);
                
                var writer = IO.File.openCreate(work_item.legacy_object_file_name);

                writer.print(printer.result);

                writer.close();
            fi
        si

        build(work_item: WORK_ITEM) is
        si
    si
si