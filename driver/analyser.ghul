namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    trait CommandHandler is
        handle(reader: IO.Reader, writer: IO.Writer);
    si

    trait WorkItemLookup is
        file_names: Iterable[String];
        find_work_item(file_name: String) -> WORK_ITEM;
    si

    class ANALYSER is
        _symbol_table: Semantic.SYMBOL_TABLE;
        _compiler: COMPILER;

        _command_map: Dict[String,CommandHandler];
        _despatcher: COMMAND_DESPATCHER;

        init(
            compiler: COMPILER,
            symbol_table: Semantic.SYMBOL_TABLE,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS,
            completer: Syntax.Process.COMPLETER,
            signature_help: Syntax.Process.SIGNATURE_HELP,
            reader: IO.Reader,
            writer: IO.Writer,
            build_flags: BUILD_FLAGS
        ) is
            IO.Std.err.println("ghūl: analyser starting up...");

            _compiler = compiler;
            _symbol_table = symbol_table;

            _command_map = new Map[String,CommandHandler]();

            _despatcher = new COMMAND_DESPATCHER(reader, writer);

            build_flags.want_legacy = false;
            build_flags.want_experiments = true;

            let watchdog = new WATCHDOG();

            let file_edited_handler = new FILE_EDITED_HANDLER(watchdog, compiler, build_flags);
            let analyse_handler = new ANALYSE_HANDLER(watchdog, compiler, symbol_table, file_edited_handler, file_edited_handler);
            let hover_handler = new HOVER_HANDLER(watchdog, symbol_use_locations);
            let find_definition_handler = new FIND_DEFINITION_HANDLER(watchdog, symbol_use_locations);
            let completion_handler = new COMPLETION_HANDLER(watchdog, completer, file_edited_handler);
            let signature_handler = new SIGNATURE_HANDLER(watchdog, signature_help, file_edited_handler);
            let symbols_handler = new SYMBOLS_HANDLER(watchdog, symbol_definition_locations, file_edited_handler);
            let references_handler = new REFERENCES_HANDLER(watchdog, symbol_use_locations);
            let restart_handler = new RESTART_HANDLER();

            _despatcher.add_handler(
                "EDIT", file_edited_handler
            );

            _despatcher.add_handler(
                "ANALYSE", analyse_handler
            );

            _despatcher.add_handler(
                "HOVER", hover_handler
            );

            _despatcher.add_handler(
                "DEFINITION", find_definition_handler
            );

            _despatcher.add_handler(
                "COMPLETE", completion_handler
            );

            _despatcher.add_handler(
                "SIGNATURE", signature_handler
            );

            _despatcher.add_handler(
                "SYMBOLS", symbols_handler
            );

            _despatcher.add_handler(
                "REFERENCES", references_handler
            );

            _despatcher.add_handler(
                "RESTART", restart_handler
            );
        si

        run() is
            do
                if !_despatcher.poll() then
                    IO.Std.err.println("ghūl: exiting");
                    return;
                fi
            od
        si
    si
    
    class WATCHDOG is
        limit: int static => 30;
        
        _count: int;

        init() is si

        request_restart() is
            native.sleep(2);
            _count = limit;
        si
        
        increment(writer: IO.Writer) is
            _count = _count + 1;

            if _count > limit then
                IO.Std.err.println("watchdog count exceedes threshold: requesting restart...");
                IO.Std.err.flush();

                writer.println("RESTART");
                writer.print("" + cast char(12));
                writer.flush();
            fi
        si
    si

    class COMMAND_DESPATCHER is
        _reader: IO.Reader;
        _writer: IO.Writer;
        _command_map: Dict[String,CommandHandler];

        _listening: bool;

        init(reader: IO.Reader, writer: IO.Writer) is
            _reader = reader;
            _writer = writer;

            _command_map = new Map[String,CommandHandler]();
        si

        add_handler(command_name: String, command_handler: CommandHandler) is
            assert(_command_map[command_name] == null, "replacing command handler for " + command_name);

            _command_map[command_name] = command_handler;
        si

        poll() -> bool is
            if !_listening then
                IO.Std.err.println("ghūl: send LISTEN to " + _writer);

                _writer.println("LISTEN");
                _writer.print("" + cast char(12));
                _writer.flush();

                _listening = true;
            fi

            if !_reader.isAtEnd() then
                let command = _reader.readLine();

                while command.startsWith('\014') do
                    command = command.substring(1);
                od                

                let handler = _command_map[command];

                if handler? then
                    handler.handle(_reader, _writer);

                    return true;
                else
                    IO.Std.err.println("ghūl: no handler found for command: '" + command + "' in " + _command_map);

                    for c in command do
                        IO.Std.err.println("ghūl: int " + cast int(c) + ", char '" + c + "'");
                    od
                fi
            else
                IO.Std.err.println("ghūl: reader is at end");
            fi

            IO.Std.err.flush();

            return false;
        si

        restart(writer: IO.Writer) is
            writer.flush();

            let executable_path = System.Arguments.ProgramArguments[0];

            let p = new Util.Process();

            p.spawn(
                executable_path,
                Arguments.ProgramArguments,
                Arguments.ProgramEnvironment
            );
        si
    si

    class HOVER_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG, 
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            self._watchdog = watchdog;
            self._symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.readLine();
            let line = reader.readLine().toInt();
            let column = reader.readLine().toInt();

            try
                let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);

                if symbol? then
                    writer.println("HOVER");
                    writer.println(symbol.description);
                else
                    writer.println("HOVER");
                fi
            catch e: Exception
                IO.Std.err.println(e);
                _watchdog.request_restart();

                writer.println("HOVER");
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si
    si

    class FIND_DEFINITION_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            self._watchdog = watchdog;
            self._symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.readLine();
            let line = reader.readLine().toInt();
            let column = reader.readLine().toInt();

            try
                let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);

                if symbol? then
                    writer.println("DEFINITION");
                    writer.println("" + symbol.location.file_name);
                    writer.println("" + symbol.location.start_line);
                    writer.println("" + symbol.location.start_column);
                    writer.println("" + symbol.location.end_line);
                    writer.println("" + symbol.location.end_column);
                else
                    writer.println("DEFINITION");
                fi

            catch e: Exception
                IO.Std.err.println(e);
                _watchdog.request_restart();

                writer.println("DEFINITION");
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si
    si

    class FILE_EDITED_HANDLER: Object, CommandHandler, WorkItemLookup, Iterable[WORK_ITEM] is
        _watchdog: WATCHDOG;
        _compiler: COMPILER;
        _work_items: Map[String,WORK_ITEM];
        _build_flags: BUILD_FLAGS;

        file_names: Iterable[String] => _work_items.Keys;

        Iterator: Generic.Iterator[WORK_ITEM]
            => _work_items.Iterator;

        init(
            watchdog: WATCHDOG,
            compiler: COMPILER,
            build_flags: BUILD_FLAGS)
        is
            _watchdog = watchdog;
            _compiler = compiler;
            _work_items = new Map[String,WORK_ITEM]();
            _build_flags = build_flags;
        si

        find_work_item(path: String) -> WORK_ITEM =>
            _work_items[path];

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.readLine();

            writer.println("DIAG PARSE");

            try
                _work_items[path] =
                    _compiler.parse(path, reader, _build_flags);
            catch e: Exception
                IO.Std.err.println(e);

                _watchdog.request_restart();
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si
    si

    class ANALYSE_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _compiler: COMPILER;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _work_item_source: Iterable[WORK_ITEM];
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            compiler: COMPILER,
            symbol_table: Semantic.SYMBOL_TABLE,
            work_item_source: Iterable[WORK_ITEM],
            work_item_lookup: WorkItemLookup
        ) is
            _watchdog = watchdog;
            _compiler = compiler;
            _symbol_table = symbol_table;
            _work_item_source = work_item_source;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            writer.println("DIAG ANALYSIS");

            let uris = reader.readLine().split('\t');

            let gc_is_disabled = false;

            try
                if uris.Length >= 1 && uris[0] =~ "all" then
                    for i in _work_item_source do
                        i.build_flags.want_infer_types = true;
                    od
                else
                    let count = 0;

                    for i in _work_item_source do
                        i.build_flags.want_infer_types = false;
                    od

                    for uri in uris do
                        let i = _work_item_lookup.find_work_item(uri);

                        if i? then
                            count = count + 1;
                            i.build_flags.want_infer_types = true;
                        fi
                    od

                    if count == 1 then
                        gc_is_disabled = true;
                        native.GC_disable();
                    fi                
                fi

                _compiler.clear_symbols();  

                _compiler.queue(_work_item_source);

                _compiler.build();

                writer.print("" + cast char(12));
                writer.println("ANALYSED");

            catch e: Exception
                IO.Std.err.println(e);

                _watchdog.request_restart();

                writer.print("" + cast char(12));
                writer.println("ANALYSED");
            finally
                _compiler.clear_queue();

                writer.print("" + cast char(12));
                writer.flush();

                if gc_is_disabled then
                    native.GC_enable();
                    native.GC_collect_a_little();                   
                fi
    
                IO.Std.err.println("heap size: % KB" % [format_thousands(cast long(native.GC_get_heap_size()) / 1024L)]: Object);
            yrt

            _watchdog.increment(writer);
        si

        format_thousands(value: long) -> String is
            let result = new StringBuffer();

            result.append(value / 1000L);
            result.append(',');
            result.append(cast int(value % 1000L), 10, 3, '0');

            return result;
        si
    si

    class COMPLETION_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _completer: Syntax.Process.COMPLETER;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            completer: Syntax.Process.COMPLETER,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _completer = completer;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            var written_any = false;

            try
                let path = reader.readLine();
                let target_line = reader.readLine().toInt();
                let target_column = reader.readLine().toInt();

                let results = find_completions(path, target_line, target_column);

                writer.println("COMPLETION");

                written_any = true;

                if results? then
                    for symbol in results do
                        writer.println("%\t%\t%" % [symbol.name, symbol.completion_kind, symbol.description]: Object);
                    od
                fi
            catch e: Exception
                IO.Std.err.println(e);
                _watchdog.request_restart();

                if !written_any then                    
                    writer.println("COMPLETION");
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si

        find_completions(path: String, target_line: int, target_column: int) -> Iterable[Semantic.Symbol.BASE] is
            let i = _work_item_lookup.find_work_item(path);

            return _completer.find_completions(i.definition, target_line, target_column);
        si
    si

    class SIGNATURE_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;        
        _signature_help: Syntax.Process.SIGNATURE_HELP;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,            
            signature_help: Syntax.Process.SIGNATURE_HELP,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _signature_help = signature_help;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            var written_any = false;

            try
                let path = reader.readLine();
                let target_line = reader.readLine().toInt();
                let target_column = reader.readLine().toInt();

                let results = find_signatures(path, target_line, target_column);

                writer.println("SIGNATURE");

                written_any = true;

                if results? then
                    writer.println("" + results.best_result_index);
                    writer.println("" + results.current_parameter_index);
                    for symbol in results.results do
                        let line = get_function_doc_for(symbol);
                        writer.println(line);
                    od
                fi
            catch e: Exception
                IO.Std.err.println(e);
                _watchdog.request_restart();

                if !written_any then
                    writer.println("SIGNATURE");
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si

        get_function_doc_for(function: Semantic.Symbol.Function) -> String is
            let result = new StringBuffer();

            result
                .append(function.short_description);

            for i in 0..function.arguments.Length do
                result
                    .append('\t')
                    .append(function.get_short_argument_description(i));
            od

            return result;
        si

        find_signatures(path: String, target_line: int, target_column: int) -> Semantic.OVERLOAD_MATCHES_RESULT is
            let i = _work_item_lookup.find_work_item(path);

            return _signature_help.find_signatures(i.definition, target_line, target_column);
        si
    si

    class SYMBOLS_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;        
        _symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,        
            symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _symbol_definition_locations = symbol_definition_locations;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            var written_any = false;

            try
                let path = reader.readLine();

                writer.println("SYMBOLS");

                if path? && path.Length > 0 then
                    write_symbol_list_for_file(writer, path, _symbol_definition_locations.find_definitions_from_file(path, false));
                else
                    for i in _work_item_lookup.file_names do
                        if i? && i.Length > 0 then
                            write_symbol_list_for_file(writer, i, _symbol_definition_locations.find_definitions_from_file(i, true));
                        fi
                    od
                fi
            catch e: Exception
                IO.Std.err.println(e);

                if !written_any then
                    writer.println("SYMBOLS");
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si

        write_symbol_list_for_file(writer: IO.Writer, path: String, symbols: Iterable[Semantic.Symbol.BASE]) is
            writer.println(path);

            if symbols? then
                for symbol in symbols do
                    writer.println(
                        get_symbol_info_for(symbol)
                    );
                od
            fi
        si

        get_symbol_info_for(symbol: Semantic.Symbol.BASE) -> String is
            let result = new StringBuffer();

            let qualified_name = symbol.qualified_name;

            let qualifier = qualified_name.substring(0, qualified_name.Length - symbol.name.Length - 1);

            result
                .append(symbol.name)
                .append('\t')
                .append(cast int(symbol.symbol_kind))
                .append('\t')
                .append(symbol.location.start_line)
                .append('\t')
                .append(symbol.location.start_column)
                .append('\t')
                .append(symbol.location.end_line)
                .append('\t')
                .append(symbol.location.end_column)
                .append('\t')
                .append(qualifier);

            return result;
        si
    si

    class REFERENCES_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            _watchdog = _watchdog;
            _symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            var written_any = false;

            try
                let path = reader.readLine();
                let line = reader.readLine().toInt();
                let column = reader.readLine().toInt();

                writer.println("REFERENCES");

                written_any = true;

                let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);

                if symbol? then
                    IO.Std.err.println("references look for " + symbol.qualified_name);

                    let locations = _symbol_use_locations.find_references_to_symbol(symbol);

                    write_location_list(writer, locations);
                fi
            catch e: Exception
                IO.Std.err.println(e);

                if !written_any then
                    writer.println("REFERENCES");                    
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si

        write_location_list(writer: IO.Writer, locations: Iterable[LOCATION]) is
            for location in locations do
                writer.println(
                    format_location(location)
                );
            od
        si

        format_location(location: LOCATION) -> String is
            let result = new StringBuffer();

            result
                .append(location.file_name)
                .append('\t')
                .append(location.start_line)
                .append('\t')
                .append(location.start_column)
                .append('\t')
                .append(location.end_line)
                .append('\t')
                .append(location.end_column);

            return result;
        si
    si

    class RESTART_HANDLER: Object, CommandHandler is
        init() is si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            try
                writer.flush();

                let executable_path = System.Arguments.ProgramArguments[0];

                let p = new Util.Process();

                p.spawn(
                    executable_path,
                    Arguments.ProgramArguments,
                    Arguments.ProgramEnvironment
                );
            catch e: Exception
                IO.Std.err.println(e);

                writer.print("" + cast char(12));
                writer.println("EXCEPT");
                writer.println(e);
            yrt

            writer.print("" + cast char(12));
            writer.flush();
        si
    si
si