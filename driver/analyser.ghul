namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;

    trait CommandHandler is
        handle(reader: IO.Reader, writer: IO.Writer);
    si    

    trait WorkItemLookup is
        find_work_item(file_name: String) -> WORK_ITEM;
    si

    class ANALYSER is
        _symbol_table: Semantic.SYMBOL_TABLE;
        _compiler: COMPILER;

        _command_map: Dict[String,CommandHandler];
        _despatcher: COMMAND_DESPATCHER;

        init(
            compiler: COMPILER,
            symbol_table: Semantic.SYMBOL_TABLE,
            symbol_locations: Semantic.SYMBOL_LOCATIONS,
            reader: IO.Reader,
            writer: IO.Writer,
            build_flags: BUILD_FLAGS
        ) is
            IO.Std.err.println("analyser starting up...");
            _compiler = compiler;
            _symbol_table = symbol_table;

            _command_map = new Map[String,CommandHandler]();            

            _despatcher = new COMMAND_DESPATCHER(reader, writer);

            build_flags.want_legacy = false;
            build_flags.want_experiments = true;

            let file_edited_handler = new FILE_EDITED_HANDLER(compiler, build_flags);
            let analyse_requested_handler = new ANALYSE_REQUESTED_HANDLER(compiler, symbol_table, file_edited_handler);
            let hover_requested_handler = new HOVER_REQUESTED_HANDLER(symbol_locations);
            let find_definition_handler = new FIND_DEFINITION_HANDLER(symbol_locations);

            _despatcher.add_handler(
                "EDIT", file_edited_handler
            );

            _despatcher.add_handler(
                "ANALYSE", analyse_requested_handler
            );

            _despatcher.add_handler(
                "HOVER", hover_requested_handler
            );            

            _despatcher.add_handler(
                "DEFINITION", find_definition_handler
            );                        
        si

        run() is
            do
                if !_despatcher.poll() then
                    IO.Std.err.println("exiting");
                    return;
                fi
            od
        si
    si

    class COMMAND_DESPATCHER is
        _reader: IO.Reader;
        _writer: IO.Writer;
        _command_map: Dict[String,CommandHandler];

        _listening: bool;

        init(reader: IO.Reader, writer: IO.Writer) is
            _reader = reader;
            _writer = writer;

            _command_map = new Map[String,CommandHandler]();
        si

        add_handler(command_name: String, command_handler: CommandHandler) is
            assert(_command_map[command_name] == null, "replacing command handler for " + command_name);

            _command_map[command_name] = command_handler;
        si

        poll() -> bool is
            if !_listening then
                IO.Std.err.println("send LISTEN to " + _writer);

                _writer.println("LISTEN");
                _writer.print("" + cast char(12));
                _writer.flush();

                _listening = true;
            fi

            if !_reader.isAtEnd() then
                let command = _reader.readLine();
                let handler = _command_map[command];

                if handler? then
                    IO.Std.err.println("despatch command " + command + " to handler: " + handler);

                    handler.handle(_reader, _writer);

                    return true;
                else
                    IO.Std.err.println("no handler found for command: '" + command + "' in " + _command_map);

                    for c in command do
                        IO.Std.err.println("int " + cast int(c) + ", char '" + c + "'");
                    od
                fi
            else
                IO.Std.err.println("reader is at end");
            fi

            return false;
        si
    si

    class HOVER_REQUESTED_HANDLER: Object, CommandHandler is
        _symbol_locations: Semantic.SYMBOL_LOCATIONS;

        init(
            symbol_locations: Semantic.SYMBOL_LOCATIONS
        )
        is
            self._symbol_locations = symbol_locations;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.readLine();
            let line = reader.readLine().toInt();
            let column = reader.readLine().toInt();

            try
                let symbol = _symbol_locations.find_definition_from_use(path, line, column);

                if symbol? then
                    writer.println("HOVER");
                    writer.println(symbol.description);

                    writer.println("" + symbol.location.file_name);
                    writer.println("" + symbol.location.start_line);
                    writer.println("" + symbol.location.start_column);
                    writer.println("" + symbol.location.end_line);
                    writer.println("" + symbol.location.end_column);
                else
                    IO.Std.err.println("nothing found for hover");                
                    writer.println("HOVER");
                fi

            catch e: Exception
                IO.Std.err.println(e);

                writer.print("" + cast char(12));
                writer.println("EXCEPT");
                writer.println(e);
            yrt

            writer.print("" + cast char(12));
            writer.flush();
        si        
    si

    class FIND_DEFINITION_HANDLER: Object, CommandHandler is
        _symbol_locations: Semantic.SYMBOL_LOCATIONS;

        init(
            symbol_locations: Semantic.SYMBOL_LOCATIONS
        )
        is
            self._symbol_locations = symbol_locations;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.readLine();
            let line = reader.readLine().toInt();
            let column = reader.readLine().toInt();

            try
                let symbol = _symbol_locations.find_definition_from_use(path, line, column);

                if symbol? then
                    IO.Std.err.println("definition result is: " + symbol.qualified_name);
                
                    writer.println("DEFINITION");
                    writer.println("" + symbol.location.file_name);
                    writer.println("" + symbol.location.start_line);
                    writer.println("" + symbol.location.start_column);
                    writer.println("" + symbol.location.end_line);
                    writer.println("" + symbol.location.end_column);
                else
                    IO.Std.err.println("nothing found for definition");                
                    writer.println("DEFINITION"); 
                fi

            catch e: Exception
                IO.Std.err.println(e);

                writer.print("" + cast char(12));
                writer.println("EXCEPT");
                writer.println(e);
            yrt

            writer.print("" + cast char(12));
            writer.flush();
        si        
    si    

    class FILE_EDITED_HANDLER: Object, CommandHandler, Iterable[WORK_ITEM] is
        _compiler: COMPILER;
        _work_items: Map[String,WORK_ITEM];
        _build_flags: BUILD_FLAGS;

        Iterator: Iterator[WORK_ITEM]
            => _work_items.Iterator;
    
        init(
            compiler: COMPILER,
            build_flags: BUILD_FLAGS)
        is
            _compiler = compiler;
            _work_items = new Map[String,WORK_ITEM]();
            _build_flags = build_flags;
        si
        
        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            IO.Std.err.println("file edited handler...");
            let path = reader.readLine();
            IO.Std.err.println("file edited: " + path);

            writer.println("DIAG PARSE");

            try
                _work_items[path] =
                    _compiler.parse(path, reader, _build_flags);

                IO.Std.err.println("completed parse");
            catch e: Exception
                IO.Std.err.println(e);

                writer.print("" + cast char(12));
                writer.println("EXCEPT");
                writer.println(e);
            yrt

            writer.print("" + cast char(12));
            writer.flush();
        si

        // toString() -> String =>
        //    ClassName + ": " + _work_items;
    si

    class ANALYSE_REQUESTED_HANDLER: Object, CommandHandler is
        _compiler: COMPILER;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _work_item_source: Iterable[WORK_ITEM];

        init(compiler: COMPILER, symbol_table: Semantic.SYMBOL_TABLE, work_item_source: Iterable[WORK_ITEM]) is
            _compiler = compiler;
            _symbol_table = symbol_table;
            _work_item_source = work_item_source;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IO.Std.err.println("Analyse requested..."); 

            writer.println("DIAG ANALYSIS");

            try
                _compiler.clear_symbols();

/*
                for i in _work_item_source do
                    IO.Std.err.println("will queue " + i.legacy_object_file_name);
                od
*/
                _compiler.queue(_work_item_source);

                // IO.Std.err.println("build: " + _work_item_source);

                _compiler.build();                

                writer.print("" + cast char(12));                
                writer.println("ANALYSED");

            catch e: Exception
                IO.Std.err.println(e);

                writer.print("" + cast char(12));               
                writer.println("EXCEPT");
                writer.println(e);                
            finally
                _compiler.clear_queue();                
            yrt

            writer.print("" + cast char(12));
            writer.flush();
        si
    si   
si