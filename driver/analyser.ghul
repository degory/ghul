namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;

    trait CommandHandler is
        handle(reader: IO.Reader, writer: IO.Writer);
    si    

    class ANALYSER is
        _compiler: COMPILER;

        _command_map: Dict[String,CommandHandler];
        _despatcher: COMMAND_DESPATCHER;

        init(
            compiler: COMPILER,
            reader: IO.Reader,
            writer: IO.Writer,
            build_flags: BUILD_FLAGS
        ) is
            IO.Std.err.println("analyser starting up...");
            _compiler = compiler;
            _command_map = new Map[String,CommandHandler]();            
            _despatcher = new COMMAND_DESPATCHER(reader, writer);

            let file_edited_handler = new FILE_EDITED_HANDLER(compiler, build_flags);
            let analyse_requested_handler = new ANALYSE_REQUESTED_HANDLER(compiler, file_edited_handler);

            _despatcher.add_handler(
                "EDIT", file_edited_handler
            );

            _despatcher.add_handler(
                "ANALYSE", analyse_requested_handler
            );
        si

        run() is
            do
                IO.Std.err.println("analyser running...");
            
                if !_despatcher.poll() then
                    return;
                fi
            od
        si
    si

    class COMMAND_DESPATCHER is
        _reader: IO.Reader;
        _writer: IO.Writer;
        _command_map: Dict[String,CommandHandler];

        init(reader: IO.Reader, writer: IO.Writer) is
            _reader = reader;
            _writer = writer;

            _command_map = new Map[String,CommandHandler]();
        si

        add_handler(command_name: String, command_handler: CommandHandler) is
            assert(_command_map[command_name] == null, "replacing command handler for " + command_name);

            _command_map[command_name] = command_handler;
        si

        poll() -> bool is
            if !_reader.isAtEnd() then
                IO.Std.err.println("command despatcher poll...");
            
                let command = _reader.readLine();

                IO.Std.err.println("command despatcher: " + command);                

                let handler = _command_map[command];

                if handler? then
                    IO.Std.err.println("despatch command " + command + " to handler: " + handler);
                    handler.handle(_reader, _writer);

                    return true;
                else
                    IO.Std.err.println("no handler found for command: " + command);
                fi
            fi
        si
    si

    class ANALYSE_REQUESTED_HANDLER: Object, CommandHandler is
        _compiler: COMPILER;
        _work_item_source: Iterable[WORK_ITEM];

        init(compiler: COMPILER, work_item_source: Iterable[WORK_ITEM]) is
            _compiler = compiler;
            _work_item_source = work_item_source;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IO.Std.err.println("queue work items...");

            writer.println("DIAG");

            _compiler.queue(_work_item_source);

            IO.Std.err.println("build...");

            _compiler.build();

            writer.print("" + cast char(12));
            writer.flush();
            IO.Std.err.println("analyse done");            
        si
    si

    class FILE_EDITED_HANDLER: Object, CommandHandler, Iterable[WORK_ITEM] is
        _compiler: COMPILER;
        _work_items: Map[String,Iterable[WORK_ITEM]];
        _build_flags: BUILD_FLAGS;

        Iterator: Iterator[WORK_ITEM] is
            let result = new Vector[WORK_ITEM]();

            for list in _work_items do
                for item in list do
                    result.add(item);
                od
            od

            return result.Iterator;
        si
    
        init(
            compiler: COMPILER,
            build_flags: BUILD_FLAGS)
        is
            _compiler = compiler;
            _work_items = new Map[String,Iterable[WORK_ITEM]]();
            _build_flags = build_flags;
        si
        
        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            IO.Std.err.println("file edited handler...");
            let path = reader.readLine();
            IO.Std.err.println("file edited: " + path);

            writer.println("CLEAR");
            writer.println(path);
 
            writer.print("" + cast char(12));

            writer.println("DIAG");

            _work_items[path] =
                _compiler.parse(path, reader, _build_flags);

            writer.print("" + cast char(12));
            writer.flush();

            IO.Std.err.println("have some work items: " + _work_items[path]);
        si
    si
si