namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;

    trait CommandHandler is
        handle(reader: IO.Reader, writer: IO.Writer) -> bool;
    si    

    class ANALYSER is
        _symbol_table: Semantic.SYMBOL_TABLE;
        _compiler: COMPILER;

        _command_map: Dict[String,CommandHandler];
        _despatcher: COMMAND_DESPATCHER;

        init(
            compiler: COMPILER,
            symbol_table: Semantic.SYMBOL_TABLE,
            reader: IO.Reader,
            writer: IO.Writer,
            build_flags: BUILD_FLAGS
        ) is
            IO.Std.err.println("analyser starting up...");
            _compiler = compiler;
            _symbol_table = symbol_table;

            _command_map = new Map[String,CommandHandler]();            

            _despatcher = new COMMAND_DESPATCHER(reader, writer);

            build_flags.want_legacy = false;
            build_flags.want_experiments = true;

            let file_edited_handler = new FILE_EDITED_HANDLER(compiler, build_flags);
            let analyse_requested_handler = new ANALYSE_REQUESTED_HANDLER(compiler, symbol_table, file_edited_handler);

            _despatcher.add_handler(
                "EDIT", file_edited_handler
            );

            _despatcher.add_handler(
                "ANALYSE", analyse_requested_handler
            );
        si

        run() is
            do
                if !_despatcher.poll() then
                    IO.Std.err.println("exiting");
                    return;
                fi
            od
        si
    si

    class COMMAND_DESPATCHER is
        _reader: IO.Reader;
        _writer: IO.Writer;
        _command_map: Dict[String,CommandHandler];

        init(reader: IO.Reader, writer: IO.Writer) is
            _reader = reader;
            _writer = writer;

            _command_map = new Map[String,CommandHandler]();
        si

        add_handler(command_name: String, command_handler: CommandHandler) is
            assert(_command_map[command_name] == null, "replacing command handler for " + command_name);

            _command_map[command_name] = command_handler;
        si

        poll() -> bool is
            if !_reader.isAtEnd() then
                IO.Std.err.println("command despatcher poll...");
            
                let command = _reader.readLine();

                IO.Std.err.println("command despatcher: " + command);                

                let handler = _command_map[command];

                if handler? then
                    IO.Std.err.println("despatch command " + command + " to handler: " + handler);
                    return handler.handle(_reader, _writer);
                else
                    IO.Std.err.println("no handler found for command: " + command);
                fi
            fi

            return false;
        si
    si

    class FILE_EDITED_HANDLER: Object, CommandHandler, Iterable[WORK_ITEM] is
        _compiler: COMPILER;
        _work_items: Map[String,WORK_ITEM];
        _build_flags: BUILD_FLAGS;

        Iterator: Iterator[WORK_ITEM]
            => _work_items.Iterator;
    
        init(
            compiler: COMPILER,
            build_flags: BUILD_FLAGS)
        is
            _compiler = compiler;
            _work_items = new Map[String,WORK_ITEM]();
            _build_flags = build_flags;
        si
        
        handle(reader: IO.Reader, writer: IO.Writer) -> bool is
            var success = false;

            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            IO.Std.err.println("file edited handler...");
            let path = reader.readLine();
            IO.Std.err.println("file edited: " + path);

            writer.println("DIAG CLEAR");
            writer.println(path);
 
            writer.print("" + cast char(12));

            writer.println("DIAG PARSE");

            try
                _work_items[path] =
                    _compiler.parse(path, reader, _build_flags);

                success = true;
            catch e: Exception
                IO.Std.err.println(e);
                writer.println("EXCEPT");
                writer.println(e);
            yrt

            writer.print("" + cast char(12));
            writer.flush();

            if success then
                IO.Std.err.println("have some work items: " + _work_items[path]);
            else
                IO.Std.err.println("failed - restart required");
            fi

            return success;
        si
    si

    class ANALYSE_REQUESTED_HANDLER: Object, CommandHandler is
        _compiler: COMPILER;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _work_item_source: Iterable[WORK_ITEM];

        init(compiler: COMPILER, symbol_table: Semantic.SYMBOL_TABLE, work_item_source: Iterable[WORK_ITEM]) is
            _compiler = compiler;
            _symbol_table = symbol_table;
            _work_item_source = work_item_source;
        si

        handle(reader: IO.Reader, writer: IO.Writer) -> bool is
            var success = false;

            IO.Std.err.println("Analyse requested...");

            writer.println("DIAG ANALYSE");

            try
                _compiler.clear_symbols();

                for i in _work_item_source do
                    IO.Std.err.println("will queue " + i.legacy_object_file_name);
                od

                _compiler.queue(_work_item_source);

                IO.Std.err.println("build: " + _work_item_source);

                _compiler.build();

                success = true;
            catch e: Exception
                IO.Std.err.println(e);
                writer.println("EXCEPT");
                writer.println(e);                
            finally
                _compiler.clear_queue();                
            yrt

            writer.print("" + cast char(12));
            writer.flush();

            if success then
                IO.Std.err.println("analyse done");   
            else
                IO.Std.err.println("failed - restart required");
            fi

            return success;
        si
    si   
si