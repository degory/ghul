namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;

    class Main is
        init() is
            try 
                if Arguments.ProgramArguments.Length == 1 then
                    IO.Std.out.println("ghul build " + Source.BUILD.number);
                    IO.Std.out.flush();
                    native.exit(0);
                fi

                if Arguments.ProgramArguments.Length >= 2 && Arguments.ProgramArguments[1] =~ "-A" then
                    IO.Std.err.println("Want analysis");

                    native.exit(0);
                fi

                let container = IoC.CONTAINER.instance;
                let logger = container.logger;

                let legacy_compiler_flags = new LEGACY_COMPILER_FLAGS();
                let flags = new BUILD_FLAGS();
                let compiler = new COMPILER();
                let output_file_name_generator = new OUTPUT_FILE_NAME_GENERATOR();

                var output: String;       
            
                IO.Std.err.FlushOnPrintln = true;

                let args = Arguments.ProgramArguments.Iterator;

                let legacy_source_files = new Vector[String]();

                args.nextElement();

                for s in args do
                    if s =~ "-L" then
                        flags.want_legacy = true;
                    elif s =~ "-G" then
                        flags.want_legacy = false;
                    elif s =~ "-E" then
                        flags.ignore_errors = true;
                    elif s =~ "-X" then
                        flags.want_experiments = true;
                    elif s =~ "-D" then
                        flags.dump_tree = true;
                    elif s =~ "-T" then
                        logger.enable_trace = true;
                        logger.trace_channels.add(args.nextElement().split(','));
                    elif s =~ "-P" then
                        flags.enabled_passes = args.nextElement().split(',');
                    elif s =~ "-o" then
                        output_file_name_generator.force(args.nextElement().trim());
                    elif SOURCE_FILE_CATEGORIZER.is_legacy(s) then
                        output_file_name_generator.seen_file(s);
                        legacy_source_files.add(s);
                    elif SOURCE_FILE_CATEGORIZER.is_ghul(s) then
                        output_file_name_generator.seen_file(s);
                        compiler.parse_and_queue(s, IO.File.openRead(s), flags.copy());
                    fi
                od

                let to_build = new Vector[String](["/usr/bin/lc"]);

                compiler.build();

                to_build.add(compiler.generated_source_files);

                to_build.add(legacy_source_files);

                /*
                if logger.any_errors then
                    IO.Std.err.println("FAILED");                    
                else
                    IO.Std.err.println("success");
                fi
                */

                IO.Std.err.flush();

                if flags.ignore_errors || !logger.any_errors then
                    if to_build.Length > 1 then
                        to_build.add(legacy_compiler_flags.flags);

                        to_build.add("-o");
                        to_build.add(output_file_name_generator.result);

                        let process = new Util.Process();

                        let result = process.run("/usr/bin/lc", to_build.Array, Arguments.ProgramEnvironment, true);

                        if result == 0 then
                            for f in compiler.generated_source_files do
                                if f.endsWith(".lo") then
                                    IO.File.deleteQuiet(f);
                                fi
                            od
                        fi

                        native.exit(result);
                    else
                        native.exit(0);
                    fi
                else
                    native.exit(1);
                fi
            catch e: Exception
                IO.Std.err.println(e);
                native.exit(1);
            yrt
        si
    si
si

