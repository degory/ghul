namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;
    
    class BUILD_FLAGS is
        is_legacy: bool public;
        want_legacy: bool public;
        want_experiments: bool public;
        dump_tree: bool public;
        ignore_errors: bool public;

        enabled_passes: Iterable[String] public;

        init() is
        si

        copy() -> BUILD_FLAGS is
            return cast BUILD_FLAGS(clone());
        si
    si

    class WORK_ITEM is
        build_flags: BUILD_FLAGS;
        legacy_object_file_name: String;
        definition: Syntax.Tree.Definition.NODE ;

        init(
            build_flags: BUILD_FLAGS,
            legacy_object_file_name: String,
            definition: Syntax.Tree.Definition.NODE
        )
        is
            self.build_flags = build_flags;
            self.legacy_object_file_name = legacy_object_file_name;
            self.definition = definition;
        si
    si

    class Pass is
        _description: String;

        init(
            description: String
        )
        is
            self._description = description;
        si

        apply(work_item: WORK_ITEM) is
            throw new NotImplementedException();
        si

        hash() -> int => _description.hash();

        toString() -> String is
            return _description;
        si
    si

    class PASS: Pass is
        _apply: WORK_ITEM -> void;

        init(
            description: String,
            apply: WORK_ITEM -> void
        )
        is
            super.init(description);
            self._apply = apply;
        si

        apply(work_item: WORK_ITEM) is
            _apply(work_item);
        si
    si
    
    class SOURCE_FILE_CATEGORIZER is
        is_legacy(file_name: String) -> bool static is
            return file_name.endsWith(".l");
        si

        is_ghul(file_name: String) -> bool static is
            return file_name.endsWith(".ghul");
        si
    si

    class LEGACY_OBJECT_FILE_NAME_GENERATOR is
        _object_number: SortedMap[String,int];

        init() is
            _object_number = new SortedMap[String,int]();
        si

        new_object_file_name_for(file_name: String) -> String is
            if !SOURCE_FILE_CATEGORIZER.is_ghul(file_name) then
                throw new Exception("not a ghul source file: " + file_name);
            fi

            let result = file_name.substring(0, file_name.Length - 5);
            let on = _object_number[result];
            _object_number[result] = on + 1;
            
            return result + "." + on + ".lo";
        si
    si

    class LEGACY_COMPILER_FLAGS is
        _flags: Vector[String];

        flags: Iterable[String] => _flags;

        init() is
            _flags = new Vector[String]();
            
            let env = Util.ProgramEnvironment.Map["LFLAGS"];

            if !(env?) || env =~ "" then
                IO.Std.err.println("No LFLAGS set");
       
                return;
            fi

            for f in env.split(' ') do
                let flag = f.trim();
                if flag !~ "" then
                    _flags.add(flag);
                fi
            od

            let t = new StringBuffer();

            for f in _flags do
                t
                    .append("\'")
                    .append(f)
                    .append("\' '");
            od

            IO.Std.err.println("LFLAGS is: " + flags); 
        si
    si

    class COMPILER is
        container: CONTAINER;
        logger: LOGGER;

        legacy_object_file_name_generator: LEGACY_OBJECT_FILE_NAME_GENERATOR;

        symbol_table: Semantic.SYMBOL_TABLE;
        namespaces: Semantic.NAMESPACES;

        work_items: Vector[WORK_ITEM];

        passes: Vector[Pass];

        results: Vector[String];

        init() is
            container = IoC.CONTAINER.instance;
            logger = container.logger;

            legacy_object_file_name_generator = new LEGACY_OBJECT_FILE_NAME_GENERATOR();

            symbol_table = new Semantic.SYMBOL_TABLE(logger);
            namespaces = new Semantic.NAMESPACES(logger, symbol_table);

            work_items = new Vector[WORK_ITEM]();
            results = new Vector[String]();

            passes = new Vector[Pass]();

            add_pass("declare-symbols", (wi: WORK_ITEM) is declare_symbols_pass(wi); si);
            add_pass("resolve-uses", (wi: WORK_ITEM) is resolve_uses_pass(wi); si);
            add_pass("resolve-type-expressions", (wi: WORK_ITEM) is resolve_type_expressions_pass(wi); si);            
            add_pass("resolve-ancestors", (wi: WORK_ITEM) is resolve_ancestors_pass(wi); si);
            add_pass("resolve-overrides", (wi: WORK_ITEM) is resolve_overrides_pass(wi); si);
            add_pass("experiments", (wi: WORK_ITEM) is experiments_pass(wi); si);
            add_pass("write-objects", (wi: WORK_ITEM) is write_objects_pass(wi); si);
        si

        add_pass(description: String, apply: WORK_ITEM -> void) is
            passes.add(new PASS(description, apply));
        si

        parse(path: String, build_flags: BUILD_FLAGS ) is
            let tokenizer = new Lexical.TOKENIZER(
                path,
                IO.File.openRead(path)
            );

            let context = new Syntax.Parser.CONTEXT(
                tokenizer,
                logger
            );

            while !context.is_end_of_file do
                var definition = container.definition_parser.parse(context);

                logger._trace("parse", "parsed " + path + " as " + definition);

                if definition? then
                    work_items.add(
                        new WORK_ITEM(
                            build_flags,
                            legacy_object_file_name_generator.new_object_file_name_for(path),
                            definition
                        )
                    );
                fi
            od
        si     

        build() -> Iterable[String] is
            for pass in passes do
                logger._trace("pass", "start pass " + pass);
                for i in work_items do
                    logger._trace("pass", "running pass " + pass + " on " + i.definition.location);

                    if i.build_flags.dump_tree then
                        IO.Std.err.println(i.definition);
                    fi

                    pass.apply(i);

                    logger._trace("pass", "completed pass " + pass + " on " + i.definition.location);

                    if i.build_flags.dump_tree then
                        IO.Std.err.println(i.definition);
                    fi                    
                od

                logger._trace("pass", "completed pass " + pass);                
            od

            return results;
        si

        declare_symbols_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            new Syntax.Process.EXPAND_NAMESPACES()
                .apply(definition);

            if flags.want_experiments then
                /*
                new Syntax.Process.REWRITE_OPERATORS_AS_CALLS()
                    .apply(definition);

                new Syntax.Process.REWRITE_STRUCTURED_TYPES_AS_CLASSES()
                    .apply(definition);
                */

                new Syntax.Process.REWRITE_PROPERTIES_AS_FUNCTIONS()
                    .apply(definition);

                new Syntax.Process.DECLARE_SYMBOLS(logger, symbol_table, namespaces)
                    .apply(definition);
            fi
        si

        resolve_uses_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;
            
            if flags.want_experiments then
                new Syntax.Process.RESOLVE_USES(logger, symbol_table, namespaces)
                    .apply(definition);

                new Syntax.Process.SET_PARENTS()
                    .apply(definition);
            fi
        si

        resolve_ancestors_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_experiments then
                new Syntax.Process.RESOLVE_ANCESTORS(logger, symbol_table, namespaces)
                    .apply(definition);                    
            fi
        si

        resolve_type_expressions_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_experiments then
                new Syntax.Process.RESOLVE_TYPE_EXPRESSIONS(logger, symbol_table, namespaces)
                    .apply(definition);                    
            fi
        si        

        resolve_overrides_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_experiments then
                new Syntax.Process.RESOLVE_OVERRIDES(logger, symbol_table, namespaces)
                    .apply(definition);                    
            fi
        si

        experiments_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_experiments then
                /*
                new Syntax.Process.RESOLVE_EXPLICIT_VARIABLE_TYPES(logger, symbol_table, namespaces)
                    .apply(definition);
                */
                
                new Syntax.Process.INFER_TYPES(logger, symbol_table, namespaces)
                    .apply(definition);
            fi
        si            

        write_objects_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            var printer: Syntax.Process.Printer.BASE;

            if flags.want_legacy then
                printer = new Syntax.Process.Printer.LEGACY(logger);
            else
                printer = new Syntax.Process.Printer.GHUL();
            fi

            printer.print(definition);

            if flags.want_legacy then
                results.add(work_item.legacy_object_file_name);
                
                var writer = IO.File.openCreate(work_item.legacy_object_file_name);

                writer.print(printer.result);

                writer.close();
            fi
        si

        build(work_item: WORK_ITEM) is
        si
    si

    class OUTPUT_FILE_NAME_GENERATOR is
        _current: String;

        result: String is
            if _current? then
                return _current;
            else
                return "binary";
            fi
        si

        init() is
        si

        force(path: String) is
            _current = path;
        si

        seen_file(path: String) is
            if _current? then
                return;
            fi

            var extensions = [".l", ".ghul"];

            for e in extensions do
                if path.endsWith(e) then
                    _current = path.substring(0, path.Length - e.Length);
                    return;
                fi
            od      
        si
    si

    class Main is
        init() is
            try 
                if Arguments.ProgramArguments.Length == 1 then
                    IO.Std.out.println("ghul build " + Source.BUILD.number);
                    IO.Std.out.flush();
                    native.exit(0);
                fi

                let container = IoC.CONTAINER.instance;
                let logger = container.logger;

                let legacy_compiler_flags = new LEGACY_COMPILER_FLAGS();
                let flags = new BUILD_FLAGS();
                let compiler = new COMPILER();
                let output_file_name_generator = new OUTPUT_FILE_NAME_GENERATOR();

                var output: String;       
            
                IO.Std.err.FlushOnPrintln = true;

                let args = Arguments.ProgramArguments.Iterator;

                let legacy_source_files = new Vector[String]();

                args.nextElement();

                for s in args do
                    if s =~ "-L" then
                        flags.want_legacy = true;
                    elif s =~ "-G" then
                        flags.want_legacy = false;
                    elif s =~ "-E" then
                        flags.ignore_errors = true;
                    elif s =~ "-X" then
                        flags.want_experiments = true;
                    elif s =~ "-D" then
                        flags.dump_tree = true;
                    elif s =~ "-T" then
                        LOGGER.enable_trace = true;
                        logger.trace_channels.add(args.nextElement().split(','));
                    elif s =~ "-P" then
                        flags.enabled_passes = args.nextElement().split(',');
                    elif s =~ "-o" then
                        output_file_name_generator.force(args.nextElement().trim());
                    elif SOURCE_FILE_CATEGORIZER.is_legacy(s) then
                        output_file_name_generator.seen_file(s);
                        legacy_source_files.add(s);
                    elif SOURCE_FILE_CATEGORIZER.is_ghul(s) then
                        output_file_name_generator.seen_file(s);
                        compiler.parse(s, flags.copy());
                    fi
                od

                let to_build = new Vector[String](["/usr/bin/lc"]);

                let compiler_generated_source_files = compiler.build();

                to_build.add(compiler_generated_source_files);

                to_build.add(legacy_source_files);

                if logger.any_errors then
                    IO.Std.err.println("FAILED");                    
                else
                    IO.Std.err.println("success");
                fi

                IO.Std.err.flush();

                if flags.ignore_errors || !logger.any_errors then
                    if to_build.Length > 1 then
                        to_build.add(legacy_compiler_flags.flags);

                        to_build.add("-o");
                        to_build.add(output_file_name_generator.result);

                        let process = new Util.Process();

                        let result = process.run("/usr/bin/lc", to_build.Array, Arguments.ProgramEnvironment, true);

                        if result == 0 then
                            for f in compiler_generated_source_files do
                                if f.endsWith(".lo") then
                                    IO.File.deleteQuiet(f);
                                fi
                            od
                        fi

                        native.exit(result);
                    else
                        native.exit(0);
                    fi
                else
                    native.exit(1);
                fi
            catch e: Exception
                IO.Std.err.println(e);
                native.exit(1);
            yrt
        si
    si
si

