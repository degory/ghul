namespace Ghul is
    // no type_expression
    class void is
    si

    // Boolean/bit
    class bool is
    si

    true: bool;
    false: bool;

    // 8 bit bytes
    class byte is
    si

    class ubyte is
    si

    // 16 bit shorts
    class short is
    si 

    class ushort is
    si

    // 32 bit integers
    class int is
    si

    class uint is
    si

    // 64 bit longs
    class long is
    si

    class ulong is
    si

    // natural machine words (pointer sized, 32 or 64 bit):
    class word is
    si

    class uword is
    si

    // unicode character (probably 32 bit unsigned opaque):
    class char is
    si

    class REFERENCE[E] is
        value: E => null, = value is si
    si

    class ARRAY[E] is
        length: int => null;

        [index: int]: E
            => null,
            = value is si
    si

    class POINTER[E] is
        value: E => null, = value is si
    si

    class TUPLE_0 is
    si
    
    class TUPLE_1[T0] is
        item_0: T0;
    si

    class TUPLE_2[T0,T1] is
        item_0: T0;
        item_1: T1;
    si

    class TUPLE_3[T0,T1,T2] is
        item_0: T0;
        item_1: T1;
        item_2: T2;
    si    

    class TUPLE_4[T0,T1,T2,T3] is
        item_0: T0;
        item_1: T1;
        item_2: T2;
        item_3: T3;
    si    

    class TUPLE_5[T0,T1,T2,T3,T4] is
        item_0: T0;
        item_1: T1;
        item_2: T2;
        item_3: T3;
        item_4: T4;
    si    
    
    class TUPLE_6[T0,T1,T2,T3,T4,T5] is
        item_0: T0;
        item_1: T1;
        item_2: T2;
        item_3: T3;
        item_4: T4;
        item_5: T5;
    si   

    class TUPLE_7[T0,T1,T2,T3,T4,T5,T6] is
        item_0: T0;
        item_1: T1;
        item_2: T2;
        item_3: T3;
        item_4: T4;
        item_5: T5;
        item_6: T6;
    si    

    class TUPLE_8[T0,T1,T2,T3,T4,T5,T6,T7] is
        item_0: T0;
        item_1: T1;
        item_2: T2;
        item_3: T3;
        item_4: T4;
        item_5: T5;
        item_6: T6;
        item_7: T7;
    si        

    class TUPLE_9[T0,T1,T2,T3,T4,T5,T6,T7,T8] is
        item_0: T0;
        item_1: T1;
        item_2: T2;
        item_3: T3;
        item_4: T4;
        item_5: T5;
        item_6: T6;
        item_7: T7;
        item_8: T8;
    si        

    class TUPLE_10[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9] is
        item_0: T0;
        item_1: T1;
        item_2: T2;
        item_3: T3;
        item_4: T4;
        item_5: T5;
        item_6: T6;
        item_7: T7;
        item_8: T8;
        item_9: T9;
    si            

    class FUNCTION_0[TR] is
        call() -> TR => null;
    si

    class FUNCTION_1[T0,TR] is
        call(a0: T0) -> TR => null;
    si
    
    class FUNCTION_2[T0,T1,TR] is
        call(
            a0: T0,
            a1: T1
        ) -> TR => null;
    si

    class FUNCTION_3[T0,T1,T2,TR] is
        call(
            a0: T0,
            a1: T1,
            a2: T2
        ) -> TR => null;
    si    

    class FUNCTION_4[T0,T1,T2,T3,TR] is
        call(
            a0: T0,
            a1: T1,
            a2: T2,
            a3: T3
        ) -> TR => null;
    si    

    class FUNCTION_5[T0,T1,T2,T3,T4,TR] is
        call(
            a0: T0,
            a1: T1,
            a2: T2,
            a3: T3,
            a4: T4
        ) -> TR => null;
    si        

    class FUNCTION_6[T0,T1,T2,T3,T4,T5,TR] is
        call(
            a0: T0,
            a1: T1,
            a2: T2,
            a3: T3,
            a4: T4,
            a5: T5
        ) -> TR => null;
    si        
    
    class FUNCTION_7[T0,T1,T2,T3,T4,T5,T6,TR] is
        call(
            a0: T0,
            a1: T1,
            a2: T2,
            a3: T3,
            a4: T4,
            a5: T5,
            a6: T6
        ) -> TR => null;
    si        

    class FUNCTION_8[T0,T1,T2,T3,T4,T5,T6,T7,TR] is
        call(
            a0: T0,
            a1: T1,
            a2: T2,
            a3: T3,
            a4: T4,
            a5: T5,
            a6: T6,
            a7: T7
        ) -> TR => null;
    si        

    class FUNCTION_9[T0,T1,T2,T3,T4,T5,T6,T7,T8,TR] is
        call(
            a0: T0,
            a1: T1,
            a2: T2,
            a3: T3,
            a4: T4,
            a5: T5,
            a6: T6,
            a7: T7,
            a8: T8
        ) -> TR => null;
    si            

    class FUNCTION_10[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,TR] is
        call(
            a0: T0,
            a1: T1,
            a2: T2,
            a3: T3,
            a4: T4,
            a5: T5,
            a6: T6,
            a7: T7,
            a8: T8,
            a9: T9
        ) -> TR => null;
    si                

    class String is
    si

    class Object is
        clone() -> Object;
    si

    assert(condition: bool);
    assert(condition: bool, message: String);

    !(a: bool) -> bool;
    &&(a: bool, b: bool) -> bool;
    ||(a: bool, b: bool) -> bool;

    -(a: byte) -> byte;
    +(a: byte, b: byte) -> byte;
    -(a: byte, b: byte) -> byte;
    *(a: byte, b: byte) -> byte;
    /(a: byte, b: byte) -> byte;

    +(a: ubyte, b: ubyte) -> ubyte;
    -(a: ubyte, b: ubyte) -> ubyte;
    *(a: ubyte, b: ubyte) -> ubyte;
    /(a: ubyte, b: ubyte) -> ubyte;

    -(a: short) -> short;
    +(a: short, b: short) -> short;
    -(a: short, b: short) -> short;
    *(a: short, b: short) -> short;
    /(a: short, b: short) -> short;

    +(a: ushort, b: ushort) -> ushort;
    -(a: ushort, b: ushort) -> ushort;
    *(a: ushort, b: ushort) -> ushort;
    /(a: ushort, b: ushort) -> ushort;

    -(a: int) -> int;
    +(a: int, b: int) -> int;
    -(a: int, b: int) -> int;
    *(a: int, b: int) -> int;
    /(a: int, b: int) -> int;

    // FIXME: need to map all relational operations to >
    >(a: int, b: int) -> bool;
    <(a: int, b: int) -> bool;
    =~(a: int, b: int) -> bool;
    !~(a: int, b: int) -> bool;

    +(a: uint, b: uint) -> uint;
    -(a: uint, b: uint) -> uint;
    *(a: uint, b: uint) -> uint;
    /(a: uint, b: uint) -> uint;

    -(a: long) -> long;
    +(a: long, b: long) -> long;
    -(a: long, b: long) -> long;
    *(a: long, b: long) -> long;
    /(a: long, b: long) -> long;
    
    +(a: ulong, b: ulong) -> ulong;
    -(a: ulong, b: ulong) -> ulong;
    *(a: ulong, b: ulong) -> ulong;
    /(a: ulong, b: ulong) -> ulong;

    -(a: word) -> word;
    +(a: word, b: word) -> word;
    -(a: word, b: word) -> word;
    *(a: word, b: word) -> word;
    /(a: word, b: word) -> word;

    +(a: uword, b: uword) -> uword;
    -(a: uword, b: uword) -> uword;
    *(a: uword, b: uword) -> uword;
    /(a: uword, b: uword) -> uword;    
si

namespace System is
    class Object is
    si

    class String is
        +(s: String) -> String;
    si

    class StringBuffer: String is
    si

    class Enum[T] is
    si

    class Exception is
    si
    
    class NotImplementedException is
    si
si

namespace Generic is
    trait Iterable[T] is
    si

    trait Iterator[T] is
    si

    trait List[T] is
        Length: int => 0;

        add(v: T);

        [index: int]: T
            => null,
            = value is si
    si

    class Vector[T]: List[T], Iterator[T] is
        Length: int => 0;

        add(v: T);

        [index: int]: T
            => null,
            = value is si
    si

    trait Dict[K,V] is
        [index: K]: V
            => null,
            = value is si    
    si

    class Map[K,V]: Dict[K,V] is
        [index: K]: V
            => null,
            = value is si    
    si

    class SortedMap[K,V]: Dict[K,V] is
        [index: K]: V
            => null,
            = value is si    
    si

    class Pair[K,V] is
        key: K;
        value: V;
    si
si

namespace IO is
    use System;

    class Reader is si

    class Writer is si

    namespace Std is
       class err is
           println(s: String);
       si
    si
si
