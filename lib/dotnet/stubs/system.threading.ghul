namespace System.Threading is
    @IL.stub()
    @IL.name("class ['System.Threading']System.Threading.Monitor")
    class Monitor: System.Object is
        @IL.name("Enter")
        enter(obj: System.Object) static;

        @IL.name("Enter")
        enter(obj: System.Object, lock_taken: bool ref) static;

        @IL.name("Exit")
        exit(obj: System.Object) static;

        @IL.name("TryEnter")
        try_enter(obj: System.Object) -> bool static;

        @IL.name("TryEnter")
        try_enter(obj: System.Object, lock_taken: bool ref) static;

        @IL.name("TryEnter")
        try_enter(obj: System.Object, milliseconds_timeout: int) -> bool static;

        @IL.name("TryEnter")
        try_enter(obj: System.Object, timeout: System.TimeSpan) -> bool static;

        @IL.name("TryEnter")
        try_enter(obj: System.Object, milliseconds_timeout: int, lock_taken: bool ref) static;

        @IL.name("TryEnter")
        try_enter(obj: System.Object, timeout: System.TimeSpan, lock_taken: bool ref) static;

        @IL.name("IsEntered")
        is_entered(obj: System.Object) -> bool static;

        @IL.name("Wait")
        wait(obj: System.Object, milliseconds_timeout: int, exit_context: bool) -> bool static;

        @IL.name("Wait")
        wait(obj: System.Object, timeout: System.TimeSpan, exit_context: bool) -> bool static;

        @IL.name("Wait")
        wait(obj: System.Object, milliseconds_timeout: int) -> bool static;

        @IL.name("Wait")
        wait(obj: System.Object, timeout: System.TimeSpan) -> bool static;

        @IL.name("Wait")
        wait(obj: System.Object) -> bool static;

        @IL.name("Pulse")
        pulse(obj: System.Object) static;

        @IL.name("PulseAll")
        pulse_all(obj: System.Object) static;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name.read("get_LockContentionCount") 
        lock_contention_count: long static;

    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.Thread")
    class Thread: System.Runtime.ConstrainedExecution.CriticalFinalizerObject is
        @IL.name("AllocateDataSlot")
        allocate_data_slot() -> System.LocalDataStoreSlot static;

        @IL.name("AllocateNamedDataSlot")
        allocate_named_data_slot(name: System.String) -> System.LocalDataStoreSlot static;

        @IL.name("GetNamedDataSlot")
        get_named_data_slot(name: System.String) -> System.LocalDataStoreSlot static;

        @IL.name("FreeNamedDataSlot")
        free_named_data_slot(name: System.String) static;

        @IL.name("GetData")
        get_data(slot: System.LocalDataStoreSlot) -> System.Object static;

        @IL.name("SetData")
        set_data(slot: System.LocalDataStoreSlot, data: System.Object) static;

        @IL.name("SetApartmentState")
        set_apartment_state(state: System.Threading.ApartmentState);

        @IL.name("TrySetApartmentState")
        try_set_apartment_state(state: System.Threading.ApartmentState) -> bool;

        @IL.name("GetCompressedStack")
        get_compressed_stack() -> System.Threading.CompressedStack;

        @IL.name("SetCompressedStack")
        set_compressed_stack(stack: System.Threading.CompressedStack);

        @IL.name("GetDomain")
        get_domain() -> System.AppDomain static;

        @IL.name("GetDomainID")
        get_domain_i_d() -> int static;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("Join")
        join();

        @IL.name("Join")
        join(timeout: System.TimeSpan) -> bool;

        @IL.name("MemoryBarrier")
        memory_barrier() static;

        @IL.name("Sleep")
        sleep(timeout: System.TimeSpan) static;

        @IL.name("VolatileRead")
        volatile_read(address: ubyte ref) -> ubyte static;

        @IL.name("VolatileRead")
        volatile_read(address: System.Double ref) -> System.Double static;

        @IL.name("VolatileRead")
        volatile_read(address: short ref) -> short static;

        @IL.name("VolatileRead")
        volatile_read(address: int ref) -> int static;

        @IL.name("VolatileRead")
        volatile_read(address: long ref) -> long static;

        @IL.name("VolatileRead")
        volatile_read(address: word ref) -> word static;

        @IL.name("VolatileRead")
        volatile_read(address: System.Object ref) -> System.Object static;

        @IL.name("VolatileRead")
        volatile_read(address: byte ref) -> byte static;

        @IL.name("VolatileRead")
        volatile_read(address: System.Single ref) -> System.Single static;

        @IL.name("VolatileRead")
        volatile_read(address: ushort ref) -> ushort static;

        @IL.name("VolatileRead")
        volatile_read(address: uint ref) -> uint static;

        @IL.name("VolatileRead")
        volatile_read(address: ulong ref) -> ulong static;

        @IL.name("VolatileRead")
        volatile_read(address: uword ref) -> uword static;

        @IL.name("VolatileWrite")
        volatile_write(address: ubyte ref, value: ubyte) static;

        @IL.name("VolatileWrite")
        volatile_write(address: System.Double ref, value: System.Double) static;

        @IL.name("VolatileWrite")
        volatile_write(address: short ref, value: short) static;

        @IL.name("VolatileWrite")
        volatile_write(address: int ref, value: int) static;

        @IL.name("VolatileWrite")
        volatile_write(address: long ref, value: long) static;

        @IL.name("VolatileWrite")
        volatile_write(address: word ref, value: word) static;

        @IL.name("VolatileWrite")
        volatile_write(address: System.Object ref, value: System.Object) static;

        @IL.name("VolatileWrite")
        volatile_write(address: byte ref, value: byte) static;

        @IL.name("VolatileWrite")
        volatile_write(address: System.Single ref, value: System.Single) static;

        @IL.name("VolatileWrite")
        volatile_write(address: ushort ref, value: ushort) static;

        @IL.name("VolatileWrite")
        volatile_write(address: uint ref, value: uint) static;

        @IL.name("VolatileWrite")
        volatile_write(address: ulong ref, value: ulong) static;

        @IL.name("VolatileWrite")
        volatile_write(address: uword ref, value: uword) static;

        @IL.name("Start")
        start(parameter: System.Object);

        @IL.name("Start")
        start();

        @IL.name("Sleep")
        sleep(milliseconds_timeout: int) static;

        @IL.name("SpinWait")
        spin_wait(iterations: int) static;

        @IL.name("Yield")
        yield() -> bool static;

        @IL.name("GetApartmentState")
        get_apartment_state() -> System.Threading.ApartmentState;

        @IL.name("DisableComObjectEagerCleanup")
        disable_com_object_eager_cleanup();

        @IL.name("Interrupt")
        interrupt();

        @IL.name("Join")
        join(milliseconds_timeout: int) -> bool;

        @IL.name("GetCurrentProcessorId")
        get_current_processor_id() -> int static;

        @IL.name("Abort")
        abort();

        @IL.name("Abort")
        abort(state_info: System.Object);

        @IL.name("ResetAbort")
        reset_abort() static;

        @IL.name("Suspend")
        suspend();

        @IL.name("Resume")
        resume();

        @IL.name("BeginCriticalRegion")
        begin_critical_region() static;

        @IL.name("EndCriticalRegion")
        end_critical_region() static;

        @IL.name("BeginThreadAffinity")
        begin_thread_affinity() static;

        @IL.name("EndThreadAffinity")
        end_thread_affinity() static;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name(".ctor")
        init(start: System.Threading.ThreadStart);
        @IL.name(".ctor")
        init(start: System.Threading.ThreadStart, max_stack_size: int);
        @IL.name(".ctor")
        init(start: System.Threading.ParameterizedThreadStart);
        @IL.name(".ctor")
        init(start: System.Threading.ParameterizedThreadStart, max_stack_size: int);
        @IL.name.read("get_ManagedThreadId") 
        managed_thread_id: int;

        @IL.name.read("get_IsAlive") 
        is_alive: bool;

        @IL.name.read("get_IsBackground") @IL.name.assign("set_IsBackground") 
        is_background: bool;

        @IL.name.read("get_IsThreadPoolThread") 
        is_thread_pool_thread: bool;

        @IL.name.read("get_Priority") @IL.name.assign("set_Priority") 
        priority: System.Threading.ThreadPriority;

        @IL.name.read("get_ThreadState") 
        thread_state: System.Threading.ThreadState;

        @IL.name.read("get_CurrentCulture") @IL.name.assign("set_CurrentCulture") 
        current_culture: System.Globalization.CultureInfo;

        @IL.name.read("get_CurrentUICulture") @IL.name.assign("set_CurrentUICulture") 
        current_u_i_culture: System.Globalization.CultureInfo;

        @IL.name.read("get_CurrentThread") 
        current_thread: System.Threading.Thread static;

        @IL.name.read("get_ExecutionContext") 
        execution_context: System.Threading.ExecutionContext;

        @IL.name.read("get_Name") @IL.name.assign("set_Name") 
        name: System.String;

        @IL.name.read("get_ApartmentState") @IL.name.assign("set_ApartmentState") 
        apartment_state: System.Threading.ApartmentState;

    si
    @IL.stub()
    @IL.name("class ['System.Threading.ThreadPool']System.Threading.ThreadPool")
    class ThreadPool: System.Object is
        @IL.name("SetMaxThreads")
        set_max_threads(worker_threads: int, completion_port_threads: int) -> bool static;

        @IL.name("GetMaxThreads")
        get_max_threads(worker_threads: int ref, completion_port_threads: int ref) static;

        @IL.name("SetMinThreads")
        set_min_threads(worker_threads: int, completion_port_threads: int) -> bool static;

        @IL.name("GetMinThreads")
        get_min_threads(worker_threads: int ref, completion_port_threads: int ref) static;

        @IL.name("GetAvailableThreads")
        get_available_threads(worker_threads: int ref, completion_port_threads: int ref) static;

        @IL.name("UnsafeQueueNativeOverlapped")
        unsafe_queue_native_overlapped(overlapped: System.Threading.NativeOverlapped ptr) -> bool static;

        @IL.name("BindHandle")
        bind_handle(os_handle: word) -> bool static;

        @IL.name("BindHandle")
        bind_handle(os_handle: System.Runtime.InteropServices.SafeHandle) -> bool static;

        @IL.name("RegisterWaitForSingleObject")
        register_wait_for_single_object(wait_object: System.Threading.WaitHandle, call_back: System.Threading.WaitOrTimerCallback, state: System.Object, milliseconds_time_out_interval: uint, execute_only_once: bool) -> System.Threading.RegisteredWaitHandle static;

        @IL.name("UnsafeRegisterWaitForSingleObject")
        unsafe_register_wait_for_single_object(wait_object: System.Threading.WaitHandle, call_back: System.Threading.WaitOrTimerCallback, state: System.Object, milliseconds_time_out_interval: uint, execute_only_once: bool) -> System.Threading.RegisteredWaitHandle static;

        @IL.name("RegisterWaitForSingleObject")
        register_wait_for_single_object(wait_object: System.Threading.WaitHandle, call_back: System.Threading.WaitOrTimerCallback, state: System.Object, milliseconds_time_out_interval: int, execute_only_once: bool) -> System.Threading.RegisteredWaitHandle static;

        @IL.name("UnsafeRegisterWaitForSingleObject")
        unsafe_register_wait_for_single_object(wait_object: System.Threading.WaitHandle, call_back: System.Threading.WaitOrTimerCallback, state: System.Object, milliseconds_time_out_interval: int, execute_only_once: bool) -> System.Threading.RegisteredWaitHandle static;

        @IL.name("RegisterWaitForSingleObject")
        register_wait_for_single_object(wait_object: System.Threading.WaitHandle, call_back: System.Threading.WaitOrTimerCallback, state: System.Object, milliseconds_time_out_interval: long, execute_only_once: bool) -> System.Threading.RegisteredWaitHandle static;

        @IL.name("UnsafeRegisterWaitForSingleObject")
        unsafe_register_wait_for_single_object(wait_object: System.Threading.WaitHandle, call_back: System.Threading.WaitOrTimerCallback, state: System.Object, milliseconds_time_out_interval: long, execute_only_once: bool) -> System.Threading.RegisteredWaitHandle static;

        @IL.name("RegisterWaitForSingleObject")
        register_wait_for_single_object(wait_object: System.Threading.WaitHandle, call_back: System.Threading.WaitOrTimerCallback, state: System.Object, timeout: System.TimeSpan, execute_only_once: bool) -> System.Threading.RegisteredWaitHandle static;

        @IL.name("UnsafeRegisterWaitForSingleObject")
        unsafe_register_wait_for_single_object(wait_object: System.Threading.WaitHandle, call_back: System.Threading.WaitOrTimerCallback, state: System.Object, timeout: System.TimeSpan, execute_only_once: bool) -> System.Threading.RegisteredWaitHandle static;

        @IL.name("QueueUserWorkItem")
        queue_user_work_item(call_back: System.Threading.WaitCallback) -> bool static;

        @IL.name("QueueUserWorkItem")
        queue_user_work_item(call_back: System.Threading.WaitCallback, state: System.Object) -> bool static;

        // queue_user_work_item[TState](call_back: Ghul.ACTION_1[TState], state: TState, prefer_local: bool) -> bool static;

        // unsafe_queue_user_work_item[TState](call_back: Ghul.ACTION_1[TState], state: TState, prefer_local: bool) -> bool static;

        @IL.name("UnsafeQueueUserWorkItem")
        unsafe_queue_user_work_item(call_back: System.Threading.WaitCallback, state: System.Object) -> bool static;

        @IL.name("UnsafeQueueUserWorkItem")
        unsafe_queue_user_work_item(call_back: System.Threading.IThreadPoolWorkItem, prefer_local: bool) -> bool static;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name.read("get_ThreadCount") 
        thread_count: int static;

        @IL.name.read("get_CompletedWorkItemCount") 
        completed_work_item_count: long static;

        @IL.name.read("get_PendingWorkItemCount") 
        pending_work_item_count: long static;

    si
    @IL.stub()
    @IL.name("valuetype ['System.Threading.Thread']System.Threading.CancellationToken")
    struct CancellationToken is
    si
    @IL.stub()
    @IL.name("valuetype ['System.Threading.Thread']System.Threading.ApartmentState")
    struct ApartmentState is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.CompressedStack")
    class CompressedStack: System.Object,System.Runtime.Serialization.ISerializable is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.ThreadStart")
    class ThreadStart: System.MulticastDelegate,System.Cloneable,System.Runtime.Serialization.ISerializable is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.ParameterizedThreadStart")
    class ParameterizedThreadStart: System.MulticastDelegate,System.Cloneable,System.Runtime.Serialization.ISerializable is
    si
    @IL.stub()
    @IL.name("valuetype ['System.Threading.Thread']System.Threading.ThreadPriority")
    struct ThreadPriority is
    si
    @IL.stub()
    @IL.name("valuetype ['System.Threading.Thread']System.Threading.ThreadState")
    struct ThreadState is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.ExecutionContext")
    class ExecutionContext: System.Object,System.IDisposable,System.Runtime.Serialization.ISerializable is
    si
    @IL.stub()
    @IL.name("valuetype ['System.Threading.Thread']System.Threading.NativeOverlapped")
    struct NativeOverlapped is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.WaitHandle")
    class WaitHandle: System.MarshalByRefObject,System.IDisposable is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.WaitOrTimerCallback")
    class WaitOrTimerCallback: System.MulticastDelegate,System.Cloneable,System.Runtime.Serialization.ISerializable is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.RegisteredWaitHandle")
    class RegisteredWaitHandle: System.MarshalByRefObject is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.WaitCallback")
    class WaitCallback: System.MulticastDelegate,System.Cloneable,System.Runtime.Serialization.ISerializable is
    si
    @IL.stub()
    @IL.name("class ['System.Threading.Thread']System.Threading.IThreadPoolWorkItem")
    trait IThreadPoolWorkItem is
    si
si
