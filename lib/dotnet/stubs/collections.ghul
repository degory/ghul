namespace Collections is
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IComparer`1")
    trait Comparer[T] is
        @IL.name("Compare")
        compare(x: T, y: T) -> int;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IEqualityComparer`1")
    trait EqualityComparer[T] is
        @IL.name("Equals")
        equals(x: T, y: T) -> bool;

        @IL.name("GetHashCode")
        get_hash_code(obj: T) -> int;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IEnumerable`1")
    trait Iterable[T] is
        @IL.name.read("GetEnumerator")
        iterator: Collections.Iterator[T];
    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.IEnumerator")
    trait MoveNext is
        @IL.name("MoveNext")
        move_next() -> bool;

        // @IL.name("Reset")
        // reset();
    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IEnumerator`1")
    trait Iterator[T]: System.IDisposable,Collections.MoveNext is
        @IL.name.read("get_Current") 
        current: T;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IReadOnlyCollection`1")
    trait Bag[T]: Collections.Iterable[T] is
        @IL.name.read("get_Count") 
        count: int;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.ICollection`1")
    trait MutableBag[T]: Collections.Iterable[T] is
        @IL.name("Add")
        add(item: T);

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int);

        @IL.name("Remove")
        remove(item: T) -> bool;

        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_IsReadOnly") 
        is_read_only: bool;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IReadOnlyList`1")
    trait List[T]: Collections.Bag[T],Collections.Iterable[T] is
        @IL.name.read("get_Item") 
        [index: int]: T,;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IList`1")
    trait MutableList[T]: Collections.MutableBag[T],Collections.Iterable[T] is
        @IL.name("IndexOf")
        index_of(item: T) -> int;

        @IL.name("Insert")
        insert(index: int, item: T);

        @IL.name("RemoveAt")
        remove_at(index: int);

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [index: int]: T, = value;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.List`1")
    class LIST[T]: System.Object,Collections.MutableList[T],Collections.MutableBag[T],Collections.Iterable[T],Collections.List[T],Collections.Bag[T] is
        @IL.name("Add")
        add(item: T);

        @IL.name("AddRange")
        add_range(collection: Collections.Iterable[T]);

        @IL.name("BinarySearch")
        binary_search(index: int, count: int, item: T, comparer: Collections.Comparer[T]) -> int;

        @IL.name("BinarySearch")
        binary_search(item: T) -> int;

        @IL.name("BinarySearch")
        binary_search(item: T, comparer: Collections.Comparer[T]) -> int;

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(item: T) -> bool;

        // convert_all[TOutput](converter: System.Converter[T,TOutput]) -> Collections.LIST[TOutput];

        @IL.name("CopyTo")
        copy_to(array: T[]);

        @IL.name("CopyTo")
        copy_to(index: int, array: T[], array_index: int, count: int);

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int);

        @IL.name("Exists")
        exists(match: Ghul.PREDICATE[T]) -> bool;

        @IL.name("Find")
        find(match: Ghul.PREDICATE[T]) -> T;

        @IL.name("FindAll")
        find_all(match: Ghul.PREDICATE[T]) -> Collections.LIST[T];

        @IL.name("FindIndex")
        find_index(match: Ghul.PREDICATE[T]) -> int;

        @IL.name("FindIndex")
        find_index(start_index: int, match: Ghul.PREDICATE[T]) -> int;

        @IL.name("FindIndex")
        find_index(start_index: int, count: int, match: Ghul.PREDICATE[T]) -> int;

        @IL.name("FindLast")
        find_last(match: Ghul.PREDICATE[T]) -> T;

        @IL.name("FindLastIndex")
        find_last_index(match: Ghul.PREDICATE[T]) -> int;

        @IL.name("FindLastIndex")
        find_last_index(start_index: int, match: Ghul.PREDICATE[T]) -> int;

        @IL.name("FindLastIndex")
        find_last_index(start_index: int, count: int, match: Ghul.PREDICATE[T]) -> int;

        @IL.name("ForEach")
        for_each(action: Ghul.ACTION_1[T]);

        @IL.name.read("GetEnumerator")
        iterator: Collections.LIST_ITERATOR[T];
        @IL.name("GetRange")
        get_range(index: int, count: int) -> Collections.LIST[T];

        @IL.name("IndexOf")
        index_of(item: T) -> int;

        @IL.name("IndexOf")
        index_of(item: T, index: int) -> int;

        @IL.name("IndexOf")
        index_of(item: T, index: int, count: int) -> int;

        @IL.name("Insert")
        insert(index: int, item: T);

        @IL.name("InsertRange")
        insert_range(index: int, collection: Collections.Iterable[T]);

        @IL.name("LastIndexOf")
        last_index_of(item: T) -> int;

        @IL.name("LastIndexOf")
        last_index_of(item: T, index: int) -> int;

        @IL.name("LastIndexOf")
        last_index_of(item: T, index: int, count: int) -> int;

        @IL.name("Remove")
        remove(item: T) -> bool;

        @IL.name("RemoveAll")
        remove_all(match: Ghul.PREDICATE[T]) -> int;

        @IL.name("RemoveAt")
        remove_at(index: int);

        @IL.name("RemoveRange")
        remove_range(index: int, count: int);

        @IL.name("Reverse")
        reverse();

        @IL.name("Reverse")
        reverse(index: int, count: int);

        @IL.name("Sort")
        sort();

        @IL.name("Sort")
        sort(comparer: Collections.Comparer[T]);

        @IL.name("Sort")
        sort(index: int, count: int, comparer: Collections.Comparer[T]);

        @IL.name("Sort")
        sort(comparison: System.Comparison[T]);

        @IL.name("ToArray")
        to_array() -> T[];

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("TrueForAll")
        true_for_all(match: Ghul.PREDICATE[T]) -> bool;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[T]);
        @IL.name.read("get_Capacity") @IL.name.assign("set_Capacity") 
        capacity: int;

        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [index: int]: T, = value;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator")
    struct LIST_ITERATOR[T]: Collections.Iterator[T],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name.read("get_Current") 
        current: T;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IReadOnlyDictionary`2")
    trait Map[TKey,TValue]: Collections.Bag[Collections.PAIR[TKey,TValue]],Collections.Iterable[Collections.PAIR[TKey,TValue]] is
        @IL.name("ContainsKey")
        contains_key(key: TKey) -> bool;

        @IL.name("TryGetValue")
        try_get_value(key: TKey, value: TValue ref) -> bool;

        @IL.name.read("get_Item") 
        [key: TKey]: TValue,;

        @IL.name.read("get_Keys") 
        keys: Collections.Iterable[TKey];

        @IL.name.read("get_Values") 
        values: Collections.Iterable[TValue];

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IDictionary`2")
    trait MutableMap[TKey,TValue]: Collections.MutableBag[Collections.PAIR[TKey,TValue]],Collections.Iterable[Collections.PAIR[TKey,TValue]] is
        @IL.name("ContainsKey")
        contains_key(key: TKey) -> bool;

        @IL.name("Add")
        add(key: TKey, value: TValue);

        @IL.name("Remove")
        remove(key: TKey) -> bool;

        @IL.name("TryGetValue")
        try_get_value(key: TKey, value: TValue ref) -> bool;

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [key: TKey]: TValue, = value;

        @IL.name.read("get_Keys") 
        keys: Collections.MutableBag[TKey];

        @IL.name.read("get_Values") 
        values: Collections.MutableBag[TValue];

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.Dictionary`2")
    class MAP[TKey,TValue]: System.Object,Collections.MutableMap[TKey,TValue],Collections.MutableBag[Collections.PAIR[TKey,TValue]],Collections.Iterable[Collections.PAIR[TKey,TValue]],Collections.Map[TKey,TValue],Collections.Bag[Collections.PAIR[TKey,TValue]],System.Runtime.Serialization.ISerializable,System.Runtime.Serialization.IDeserializationCallback is
        @IL.name("Add")
        add(value: PAIR[TKey, TValue]);

        @IL.name("Add")
        add(key: TKey, value: TValue);

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(value: PAIR[TKey, TValue]) -> bool;

        @IL.name("ContainsKey")
        contains_key(key: TKey) -> bool;

        @IL.name("ContainsValue")
        contains_value(value: TValue) -> bool;

        @IL.name("CopyTo")
        copy_to(array: ARRAY[PAIR[TKey,TValue]], index: int);

        @IL.name.read("GetEnumerator")
        iterator: Collections.MAP_ITERATOR[TKey,TValue];
        @IL.name("GetObjectData")
        get_object_data(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext);

        @IL.name("OnDeserialization")
        on_deserialization(sender: System.Object);

        @IL.name("Remove")
        remove(value: PAIR[TKey,TValue]) -> bool;

        @IL.name("Remove")
        remove(key: TKey) -> bool;

        @IL.name("Remove")
        remove(key: TKey, value: TValue ref) -> bool;

        @IL.name("TryGetValue")
        try_get_value(key: TKey, value: TValue ref) -> bool;

        @IL.name("TryAdd")
        try_add(key: TKey, value: TValue) -> bool;

        @IL.name("EnsureCapacity")
        ensure_capacity(capacity: int) -> int;

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("TrimExcess")
        trim_excess(capacity: int);

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(comparer: Collections.EqualityComparer[TKey]);
        @IL.name(".ctor")
        init(capacity: int, comparer: Collections.EqualityComparer[TKey]);
        @IL.name(".ctor")
        init(dictionary: Collections.MutableMap[TKey,TValue]);
        @IL.name(".ctor")
        init(dictionary: Collections.MutableMap[TKey,TValue], comparer: Collections.EqualityComparer[TKey]);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[Collections.PAIR[TKey,TValue]]);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[Collections.PAIR[TKey,TValue]], comparer: Collections.EqualityComparer[TKey]);
        @IL.name.read("get_Comparer") 
        comparer: Collections.EqualityComparer[TKey];

        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Keys") 
        keys: Collections.KEY_COLLECTION[TKey,TValue];

        @IL.name.read("get_Values") 
        values: Collections.VALUE_COLLECTION[TKey,TValue];

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [key: TKey]: TValue, = value;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.KeyValuePair`2")
    struct PAIR[TKey,TValue] is
        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Deconstruct")
        deconstruct(key: TKey ref, value: TValue ref);

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name(".ctor")
        init(key: TKey, value: TValue);
        @IL.name.read("get_Key") 
        key: TKey;

        @IL.name.read("get_Value") 
        value: TValue;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.Dictionary`2/KeyCollection")
    class KEY_COLLECTION[TKey,TValue]: System.Object,Collections.MutableBag[TKey],Collections.Iterable[TKey],Collections.Bag[TKey] is
        @IL.name.read("GetEnumerator")
        iterator: Collections.KEY_ITERATOR[TKey,TValue];

        @IL.name("Add")
        add(key: TKey);

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(key: TKey) -> bool;

        @IL.name("CopyTo")
        copy_to(array: TKey[], index: int);

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name("Remove")
        remove(key: TKey) -> bool;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init(dictionary: Collections.MAP[TKey,TValue]);
        @IL.name.read("get_Count") 
        count: int;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.Dictionary`2/ValueCollection")
    class VALUE_COLLECTION[TKey,TValue]: System.Object,Collections.MutableBag[TValue],Collections.Iterable[TValue],Collections.Bag[TValue] is
        @IL.name.read("GetEnumerator")
        iterator: Collections.VALUE_ITERATOR[TKey,TValue];

        @IL.name("Add")
        add(value: TValue);

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(value: TValue) -> bool;

        @IL.name("CopyTo")
        copy_to(array: TValue[], index: int);

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name("Remove")
        remove(value: TValue);

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init(dictionary: Collections.MAP[TKey,TValue]);
        @IL.name.read("get_Count") 
        count: int;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.Dictionary`2/KeyCollection/Enumerator")
    struct KEY_ITERATOR[TKey,TValue]: Collections.Iterator[TKey],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name.read("get_Current") 
        current: TKey;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.Dictionary`2/ValueCollection/Enumerator")
    struct VALUE_ITERATOR[TKey,TValue]: Collections.Iterator[TValue],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name.read("get_Current") 
        current: TValue;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.Dictionary`2/Enumerator")
    struct MAP_ITERATOR[TKey,TValue]: Collections.Iterator[Collections.PAIR[TKey,TValue]],System.IDisposable,Collections.MoveNext is
        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Dispose")
        dispose();

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name.read("get_Current") 
        current: Collections.PAIR[TKey,TValue];

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IReadOnlySet`1")
    trait Set[T]: Collections.Bag[T],Collections.Iterable[T] is
        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsSubsetOf")
        is_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Collections.Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Collections.Iterable[T]) -> bool;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.ISet`1")
    trait MutableSet[T]: Collections.MutableBag[T],Collections.Iterable[T] is
        @IL.name("Add")
        add(item: T) -> bool;

        @IL.name("UnionWith")
        union_with(other: Collections.Iterable[T]);

        @IL.name("IntersectWith")
        intersect_with(other: Collections.Iterable[T]);

        @IL.name("ExceptWith")
        except_with(other: Collections.Iterable[T]);

        @IL.name("SymmetricExceptWith")
        symmetric_except_with(other: Collections.Iterable[T]);

        @IL.name("IsSubsetOf")
        is_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Collections.Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Collections.Iterable[T]) -> bool;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.HashSet`1")
    class SET[T]: System.Object,Collections.MutableBag[T],Collections.Iterable[T],Collections.MutableSet[T],Collections.Bag[T],Collections.Set[T],System.Runtime.Serialization.ISerializable,System.Runtime.Serialization.IDeserializationCallback is
        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("Remove")
        remove(item: T) -> bool;

        @IL.name.read("GetEnumerator")
        iterator: Collections.SET_ITERATOR[T];
        @IL.name("GetObjectData")
        get_object_data(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext);

        @IL.name("OnDeserialization")
        on_deserialization(sender: System.Object);

        @IL.name("Add")
        add(item: T) -> bool;

        @IL.name("TryGetValue")
        try_get_value(equal_value: T, actual_value: T ref) -> bool;

        @IL.name("UnionWith")
        union_with(other: Collections.Iterable[T]);

        @IL.name("IntersectWith")
        intersect_with(other: Collections.Iterable[T]);

        @IL.name("ExceptWith")
        except_with(other: Collections.Iterable[T]);

        @IL.name("SymmetricExceptWith")
        symmetric_except_with(other: Collections.Iterable[T]);

        @IL.name("IsSubsetOf")
        is_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Collections.Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Collections.Iterable[T]) -> bool;

        @IL.name("CopyTo")
        copy_to(array: T[]);

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int);

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int, count: int);

        @IL.name("RemoveWhere")
        remove_where(match: Ghul.PREDICATE[T]) -> int;

        @IL.name("EnsureCapacity")
        ensure_capacity(capacity: int) -> int;

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("CreateSetComparer")
        create_set_comparer() -> Collections.EqualityComparer[Collections.SET[T]] static;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(comparer: Collections.EqualityComparer[T]);
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[T]);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[T], comparer: Collections.EqualityComparer[T]);
        @IL.name(".ctor")
        init(capacity: int, comparer: Collections.EqualityComparer[T]);
        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Comparer") 
        comparer: Collections.EqualityComparer[T];

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.HashSet`1/Enumerator")
    struct SET_ITERATOR[T]: Collections.Iterator[T],System.IDisposable,Collections.MoveNext is
        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Dispose")
        dispose();

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name.read("get_Current") 
        current: T;

    si
si
