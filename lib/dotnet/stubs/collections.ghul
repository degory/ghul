namespace Collections is
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.ObjectModel.Collection`1")
    class CollectionBase[T]: System.Object,Collections.MutableList[T],Collections.MutableBag[T],Collections.Iterable[T],Collections.List[T],Collections.Bag[T] is
        @IL.name("Add")
        add(item: T);

        @IL.name("Clear")
        clear();

        @IL.name("CopyTo")
        copy_to(array: T[], index: int);

        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name.read("GetEnumerator")
        iterator: Collections.Iterator[T];
        @IL.name("IndexOf")
        index_of(item: T) -> int;

        @IL.name("Insert")
        insert(index: int, item: T);

        @IL.name("Remove")
        remove(item: T) -> bool;

        @IL.name("RemoveAt")
        remove_at(index: int);

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(list: Collections.MutableList[T]);
        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [index: int]: T, = value;

    si

    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IComparer`1")
    trait Comparer[T] is
        @IL.name("Compare")
        compare(x: T, y: T) -> int;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IEqualityComparer`1")
    trait EqualityComparer[T] is
        @IL.name("Equals")
        equals(x: T, y: T) -> bool;

        @IL.name("GetHashCode")
        get_hash_code(obj: T) -> int;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IEnumerable`1")
    trait Iterable[T] is
        @IL.name.read("GetEnumerator")
        iterator: Collections.Iterator[T];
    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.IEnumerator")
    trait MoveNext is
        @IL.name("MoveNext")
        move_next() -> bool;
    si

    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.IEnumerable")
    trait NonGenericIterable is
        @IL.name.read("GetEnumerator")
        iterator: System.Object;
    si

    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IEnumerator`1")
    trait Iterator[IT]: System.IDisposable,Collections.MoveNext is
        @IL.name.read("get_Current") 
        current: IT;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IReadOnlyCollection`1")
    trait Bag[BT]: Collections.Iterable[BT] is
        @IL.name.read("get_Count") 
        count: int;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.ICollection`1")
    trait MutableBag[MBT]: Collections.Iterable[MBT] is
        @IL.name("Add")
        add(item: MBT);

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(item: MBT) -> bool;

        @IL.name("CopyTo")
        copy_to(array: MBT[], array_index: int);

        @IL.name("Remove")
        remove(item: MBT) -> bool;

        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_IsReadOnly") 
        is_read_only: bool;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IReadOnlyList`1")
    trait List[LT]: Collections.Bag[LT],Collections.Iterable[LT] is
        @IL.name.read("get_Item") 
        [index: int]: LT,;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IList`1")
    trait MutableList[MLT]: Collections.MutableBag[MLT],Collections.Iterable[MLT] is
        @IL.name("IndexOf")
        index_of(item: MLT) -> int;

        @IL.name("Insert")
        insert(index: int, item: MLT);

        @IL.name("RemoveAt")
        remove_at(index: int);

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [index: int]: MLT, = value;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.List`1")
    class LIST[CLT]: System.Object,Collections.MutableList[CLT],Collections.MutableBag[CLT],Collections.Iterable[CLT],Collections.List[CLT],Collections.Bag[CLT] is
        @IL.name.read("get_IsReadOnly")
        is_read_only: bool;

        @IL.name("Add")
        add(item: CLT);

        @IL.name("AddRange")
        add_range(collection: Collections.Iterable[CLT]);

        @IL.name("BinarySearch")
        binary_search(index: int, count: int, item: CLT, comparer: Collections.Comparer[CLT]) -> int;

        @IL.name("BinarySearch")
        binary_search(item: CLT) -> int;

        @IL.name("BinarySearch")
        binary_search(item: CLT, comparer: Collections.Comparer[CLT]) -> int;

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(item: CLT) -> bool;

        // convert_all[TOutput](converter: System.Converter[CLT,TOutput]) -> Collections.LIST[TOutput];

        @IL.name("CopyTo")
        copy_to(array: CLT[]);

        @IL.name("CopyTo")
        copy_to(index: int, array: CLT[], array_index: int, count: int);

        @IL.name("CopyTo")
        copy_to(array: CLT[], array_index: int);

        @IL.name("Exists")
        exists(match: Ghul.PREDICATE[CLT]) -> bool;

        @IL.name("Find")
        find(match: Ghul.PREDICATE[CLT]) -> CLT;

        @IL.name("FindAll")
        find_all(match: Ghul.PREDICATE[CLT]) -> Collections.LIST[CLT];

        @IL.name("FindIndex")
        find_index(match: Ghul.PREDICATE[CLT]) -> int;

        @IL.name("FindIndex")
        find_index(start_index: int, match: Ghul.PREDICATE[CLT]) -> int;

        @IL.name("FindIndex")
        find_index(start_index: int, count: int, match: Ghul.PREDICATE[CLT]) -> int;

        @IL.name("FindLast")
        find_last(match: Ghul.PREDICATE[CLT]) -> CLT;

        @IL.name("FindLastIndex")
        find_last_index(match: Ghul.PREDICATE[CLT]) -> int;

        @IL.name("FindLastIndex")
        find_last_index(start_index: int, match: Ghul.PREDICATE[CLT]) -> int;

        @IL.name("FindLastIndex")
        find_last_index(start_index: int, count: int, match: Ghul.PREDICATE[CLT]) -> int;

        @IL.name("ForEach")
        for_each(action: Ghul.ACTION_1[CLT]);

        @IL.name.read("GetEnumerator")
        iterator: Collections.LIST_ITERATOR[CLT];
        @IL.name("GetRange")
        get_range(index: int, count: int) -> Collections.LIST[CLT];

        @IL.name("IndexOf")
        index_of(item: CLT) -> int;

        @IL.name("IndexOf")
        index_of(item: CLT, index: int) -> int;

        @IL.name("IndexOf")
        index_of(item: CLT, index: int, count: int) -> int;

        @IL.name("Insert")
        insert(index: int, item: CLT);

        @IL.name("InsertRange")
        insert_range(index: int, collection: Collections.Iterable[CLT]);

        @IL.name("LastIndexOf")
        last_index_of(item: CLT) -> int;

        @IL.name("LastIndexOf")
        last_index_of(item: CLT, index: int) -> int;

        @IL.name("LastIndexOf")
        last_index_of(item: CLT, index: int, count: int) -> int;

        @IL.name("Remove")
        remove(item: CLT) -> bool;

        @IL.name("RemoveAll")
        remove_all(match: Ghul.PREDICATE[CLT]) -> int;

        @IL.name("RemoveAt")
        remove_at(index: int);

        @IL.name("RemoveRange")
        remove_range(index: int, count: int);

        @IL.name("Reverse")
        reverse();

        @IL.name("Reverse")
        reverse(index: int, count: int);

        @IL.name("Sort")
        sort();

        @IL.name("Sort")
        sort(comparer: Collections.Comparer[CLT]);

        @IL.name("Sort")
        sort(index: int, count: int, comparer: Collections.Comparer[CLT]);

        @IL.name("Sort")
        sort(comparison: System.Comparison[CLT]);

        @IL.name("ToArray")
        to_array() -> CLT[];

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("TrueForAll")
        true_for_all(match: Ghul.PREDICATE[CLT]) -> bool;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[CLT]);
        @IL.name.read("get_Capacity") @IL.name.assign("set_Capacity") 
        capacity: int;

        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [index: int]: CLT, = value;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator")
    struct LIST_ITERATOR[T]: Collections.Iterator[T],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name.read("get_Current") 
        current: T;

    si
    @IL.stub()
    @IL.name("class [System.Collections]System.Collections.Generic.Stack`1")
    class STACK[T]: System.Object,Collections.Iterable[T],Collections.Bag[T] is
        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int);

        @IL.name.read("GetEnumerator")
        iterator: Collections.STACK_ITERATOR[T];
        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("Peek")
        peek() -> T;

        @IL.name("TryPeek")
        try_peek(result: T ref) -> bool;

        @IL.name("Pop")
        pop() -> T;

        @IL.name("TryPop")
        try_pop(result: T ref) -> bool;

        @IL.name("Push")
        push(item: T);

        @IL.name("ToArray")
        to_array() -> T[];

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[T]);
        @IL.name.read("get_Count") 
        count: int;

    si
    @IL.stub()
    @IL.name("valuetype [System.Collections]System.Collections.Generic.Stack`1/Enumerator")
    struct STACK_ITERATOR[T]: Collections.Iterator[T],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name.read("get_Current") 
        current: T;

    si

    @IL.stub()
    @IL.name("class [System.Collections]System.Collections.Generic.Queue`1")
    class QUEUE[T]: System.Object,Collections.Iterable[T],Collections.Bag[T] is
        @IL.name("Clear")
        clear();

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int);

        @IL.name("Enqueue")
        enqueue(item: T);

        @IL.name.read("GetEnumerator")
        iterator: Collections.QUEUE_ITERATOR[T];
        @IL.name("Dequeue")
        dequeue() -> T;

        @IL.name("TryDequeue")
        try_dequeue(result: T ref) -> bool;

        @IL.name("Peek")
        peek() -> T;

        @IL.name("TryPeek")
        try_peek(result: T ref) -> bool;

        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("ToArray")
        to_array() -> T[];

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[T]);
        @IL.name.read("get_Count") 
        count: int;

    si
    @IL.stub()
    @IL.name("class [System.Collections]System.Collections.Generic.Queue`1/Enumerator")
    struct QUEUE_ITERATOR[T]: Collections.Iterator[T],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name.read("get_Current") 
        current: T;

    si

    @IL.stub()
    @IL.name("class [System]System.Collections.Generic.SortedList`2")
    class SORTED_LIST[TKey,TValue]: System.Object,Collections.MutableMap[TKey,TValue],Collections.MutableBag[Collections.Pair[TKey,TValue]],Collections.Iterable[Collections.Pair[TKey,TValue]],Collections.Map[TKey,TValue],Collections.Bag[Collections.Pair[TKey,TValue]] is
        @IL.name("Add")
        add(key: TKey, value: TValue);

        @IL.name("Clear")
        clear();

        @IL.name("ContainsKey")
        contains_key(key: TKey) -> bool;

        @IL.name("ContainsValue")
        contains_value(value: TValue) -> bool;

        @IL.name.read("GetEnumerator")
        iterator: Collections.Iterator[Collections.Pair[TKey,TValue]];
        @IL.name("IndexOfKey")
        index_of_key(key: TKey) -> int;

        @IL.name("IndexOfValue")
        index_of_value(value: TValue) -> int;

        @IL.name("TryGetValue")
        try_get_value(key: TKey, value: TValue ref) -> bool;

        @IL.name("RemoveAt")
        remove_at(index: int);

        @IL.name("Remove")
        remove(key: TKey) -> bool;

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(comparer: Collections.Comparer[TKey]);
        @IL.name(".ctor")
        init(capacity: int, comparer: Collections.Comparer[TKey]);
        @IL.name(".ctor")
        init(dictionary: Collections.MutableMap[TKey,TValue]);
        @IL.name(".ctor")
        init(dictionary: Collections.MutableMap[TKey,TValue], comparer: Collections.Comparer[TKey]);
        @IL.name.read("get_Capacity") @IL.name.assign("set_Capacity") 
        capacity: int;

        @IL.name.read("get_Comparer") 
        comparer: Collections.Comparer[TKey];

        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Keys") 
        keys: Collections.MutableList[TKey];

        @IL.name.read("get_Values") 
        values: Collections.MutableList[TValue];

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [key: TKey]: TValue, = value;

    si

    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IReadOnlyDictionary`2")
    trait Map[TKey,TValue]: Collections.Bag[Collections.Pair[TKey,TValue]],Collections.Iterable[Collections.Pair[TKey,TValue]] is
        @IL.name("ContainsKey")
        contains_key(key: TKey) -> bool;

        @IL.name("TryGetValue")
        try_get_value(key: TKey, value: TValue ref) -> bool;

        @IL.name.read("get_Item") 
        [key: TKey]: TValue,;

        @IL.name.read("get_Keys") 
        keys: Collections.Iterable[TKey];

        @IL.name.read("get_Values") 
        values: Collections.Iterable[TValue];

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IDictionary`2")
    trait MutableMap[TKey,TValue]: Collections.MutableBag[Collections.Pair[TKey,TValue]],Collections.Iterable[Collections.Pair[TKey,TValue]] is
        @IL.name("ContainsKey")
        contains_key(key: TKey) -> bool;

        @IL.name("Add")
        add(key: TKey, value: TValue);

        @IL.name("Remove")
        remove(key: TKey) -> bool;

        @IL.name("TryGetValue")
        try_get_value(key: TKey, value: TValue ref) -> bool;

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [key: TKey]: TValue, = value;

        @IL.name.read("get_Keys") 
        keys: Collections.MutableBag[TKey];

        @IL.name.read("get_Values") 
        values: Collections.MutableBag[TValue];

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.Dictionary`2")
    class MAP[TKey,TValue]: System.Object,Collections.MutableMap[TKey,TValue],Collections.MutableBag[Collections.Pair[TKey,TValue]],Collections.Iterable[Collections.Pair[TKey,TValue]],Collections.Map[TKey,TValue],Collections.Bag[Collections.Pair[TKey,TValue]],System.Runtime.Serialization.ISerializable,System.Runtime.Serialization.IDeserializationCallback is
        @IL.name.read("get_IsReadOnly")
        is_read_only: bool;

        @IL.name("Add")
        add(value: Pair[TKey, TValue]);

        @IL.name("Add")
        add(key: TKey, value: TValue);

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(value: Pair[TKey, TValue]) -> bool;

        @IL.name("ContainsKey")
        contains_key(key: TKey) -> bool;

        @IL.name("ContainsValue")
        contains_value(value: TValue) -> bool;

        @IL.name("CopyTo")
        copy_to(array: Pair[TKey,TValue][], index: int);

        @IL.name.read("GetEnumerator")
        iterator: Collections.MAP_ITERATOR[TKey,TValue];
        @IL.name("GetObjectData")
        get_object_data(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext);

        @IL.name("OnDeserialization")
        on_deserialization(sender: System.Object);

        @IL.name("Remove")
        remove(value: Pair[TKey,TValue]) -> bool;

        @IL.name("Remove")
        remove(key: TKey) -> bool;

        @IL.name("Remove")
        remove(key: TKey, value: TValue ref) -> bool;

        @IL.name("TryGetValue")
        try_get_value(key: TKey, value: TValue ref) -> bool;

        @IL.name("TryAdd")
        try_add(key: TKey, value: TValue) -> bool;

        @IL.name("EnsureCapacity")
        ensure_capacity(capacity: int) -> int;

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("TrimExcess")
        trim_excess(capacity: int);

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(comparer: Collections.EqualityComparer[TKey]);
        @IL.name(".ctor")
        init(capacity: int, comparer: Collections.EqualityComparer[TKey]);
        @IL.name(".ctor")
        init(dictionary: Collections.MutableMap[TKey,TValue]);
        @IL.name(".ctor")
        init(dictionary: Collections.MutableMap[TKey,TValue], comparer: Collections.EqualityComparer[TKey]);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[Collections.Pair[TKey,TValue]]);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[Collections.Pair[TKey,TValue]], comparer: Collections.EqualityComparer[TKey]);
        @IL.name.read("get_Comparer") 
        comparer: Collections.EqualityComparer[TKey];

        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Keys") 
        keys: Collections.KEY_COLLECTION[TKey,TValue];

        @IL.name.read("get_Values") 
        values: Collections.VALUE_COLLECTION[TKey,TValue];

        @IL.name.read("get_Item") @IL.name.assign("set_Item") 
        [key: TKey]: TValue, = value;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.KeyValuePair`2")
    struct Pair[TKey,TValue] is
        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Deconstruct")
        deconstruct(key: TKey ref, value: TValue ref);

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name(".ctor")
        init(key: TKey, value: TValue);
        @IL.name.read("get_Key") 
        key: TKey;

        @IL.name.read("get_Value") 
        value: TValue;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.Dictionary`2/KeyCollection")
    class KEY_COLLECTION[TKey,TValue]: System.Object,Collections.MutableBag[TKey],Collections.Iterable[TKey],Collections.Bag[TKey] is
        @IL.name.read("GetEnumerator")
        iterator: Collections.KEY_ITERATOR[TKey,TValue];

        @IL.name("Add")
        add(key: TKey);

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(key: TKey) -> bool;

        @IL.name("CopyTo")
        copy_to(array: TKey[], index: int);

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("Remove")
        remove(key: TKey) -> bool;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init(dictionary: Collections.MAP[TKey,TValue]);
        @IL.name.read("get_Count") 
        count: int;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.Dictionary`2/ValueCollection")
    class VALUE_COLLECTION[TKey,TValue]: System.Object,Collections.MutableBag[TValue],Collections.Iterable[TValue],Collections.Bag[TValue] is
        @IL.name.read("GetEnumerator")
        iterator: Collections.VALUE_ITERATOR[TKey,TValue];

        @IL.name("Add")
        add(value: TValue);

        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(value: TValue) -> bool;

        @IL.name("CopyTo")
        copy_to(array: TValue[], index: int);

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("Remove")
        remove(value: TValue) -> bool;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init(dictionary: Collections.MAP[TKey,TValue]);
        @IL.name.read("get_Count") 
        count: int;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.Dictionary`2/KeyCollection/Enumerator")
    struct KEY_ITERATOR[TKey,TValue]: Collections.Iterator[TKey],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name.read("get_Current") 
        current: TKey;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.Dictionary`2/ValueCollection/Enumerator")
    struct VALUE_ITERATOR[TKey,TValue]: Collections.Iterator[TValue],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name.read("get_Current") 
        current: TValue;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Collections.Generic.Dictionary`2/Enumerator")
    struct MAP_ITERATOR[TKey,TValue]: Collections.Iterator[Collections.Pair[TKey,TValue]],System.IDisposable,Collections.MoveNext is
        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Dispose")
        dispose();

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name.read("get_Current") 
        current: Collections.Pair[TKey,TValue];

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.IReadOnlySet`1")
    trait Set[T]: Collections.Bag[T],Collections.Iterable[T] is
        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsSubsetOf")
        is_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Collections.Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Collections.Iterable[T]) -> bool;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Collections.Generic.ISet`1")
    trait MutableSet[T]: Collections.MutableBag[T],Collections.Iterable[T] is
        // @IL.name("Add")
        // add(item: T);

        @IL.name("UnionWith")
        union_with(other: Collections.Iterable[T]);

        @IL.name("IntersectWith")
        intersect_with(other: Collections.Iterable[T]);

        @IL.name("ExceptWith")
        except_with(other: Collections.Iterable[T]);

        @IL.name("SymmetricExceptWith")
        symmetric_except_with(other: Collections.Iterable[T]);

        @IL.name("IsSubsetOf")
        is_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Collections.Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Collections.Iterable[T]) -> bool;

    si
    @IL.stub()
    @IL.name("class [System.Core]System.Collections.Generic.HashSet`1")
    class SET[T]: System.Object,Collections.MutableBag[T],Collections.Iterable[T],Collections.MutableSet[T],Collections.Bag[T],Collections.Set[T],System.Runtime.Serialization.ISerializable,System.Runtime.Serialization.IDeserializationCallback is
        @IL.name("Clear")
        clear();

        @IL.name("Contains")
        contains(item: T) -> bool;

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int);

        @IL.name("Remove")
        remove(item: T) -> bool;

        @IL.name.read("GetEnumerator")
        iterator: Collections.SET_ITERATOR[T];
        @IL.name("GetObjectData")
        get_object_data(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext);

        @IL.name("OnDeserialization")
        on_deserialization(sender: System.Object);

        @IL.name("Add")
        add(item: T) -> bool;

        @IL.name("TryGetValue")
        try_get_value(equal_value: T, actual_value: T ref) -> bool;

        @IL.name("UnionWith")
        union_with(other: Collections.Iterable[T]);

        @IL.name("IntersectWith")
        intersect_with(other: Collections.Iterable[T]);

        @IL.name("ExceptWith")
        except_with(other: Collections.Iterable[T]);

        @IL.name("SymmetricExceptWith")
        symmetric_except_with(other: Collections.Iterable[T]);

        @IL.name("IsSubsetOf")
        is_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSubsetOf")
        is_proper_subset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsSupersetOf")
        is_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("IsProperSupersetOf")
        is_proper_superset_of(other: Collections.Iterable[T]) -> bool;

        @IL.name("Overlaps")
        overlaps(other: Collections.Iterable[T]) -> bool;

        @IL.name("SetEquals")
        set_equals(other: Collections.Iterable[T]) -> bool;

        @IL.name("CopyTo")
        copy_to(array: T[]);

        @IL.name("CopyTo")
        copy_to(array: T[], array_index: int, count: int);

        @IL.name("RemoveWhere")
        remove_where(match: Ghul.PREDICATE[T]) -> int;

        @IL.name("EnsureCapacity")
        ensure_capacity(capacity: int) -> int;

        @IL.name("TrimExcess")
        trim_excess();

        @IL.name("CreateSetComparer")
        create_set_comparer() -> Collections.EqualityComparer[Collections.SET[T]] static;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init();
        @IL.name(".ctor")
        init(comparer: Collections.EqualityComparer[T]);
        @IL.name(".ctor")
        init(capacity: int);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[T]);
        @IL.name(".ctor")
        init(collection: Collections.Iterable[T], comparer: Collections.EqualityComparer[T]);
        @IL.name(".ctor")
        init(capacity: int, comparer: Collections.EqualityComparer[T]);
        @IL.name.read("get_Count") 
        count: int;

        @IL.name.read("get_Comparer") 
        comparer: Collections.EqualityComparer[T];

    si
    @IL.stub()
    @IL.name("valuetype [System.Core]System.Collections.Generic.HashSet`1/Enumerator")
    struct SET_ITERATOR[T]: Collections.Iterator[T],System.IDisposable,Collections.MoveNext is
        @IL.name("Dispose")
        dispose();

        @IL.name("MoveNext")
        move_next() -> bool;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type2;

        @IL.name.read("get_Current") 
        current: T;

    si
si
