namespace System.Threading.Tasks is
    @IL.stub()
    @IL.name("class [mscorlib]System.Threading.Tasks.Task")
    class Task_0: System.Object,System.IAsyncResult,System.IDisposable is
        @IL.name("WaitAny")
        wait_any(tasks: System.Threading.Tasks.Task_0[]) -> int static;

        @IL.name("WaitAny")
        wait_any(tasks: System.Threading.Tasks.Task_0[], timeout: System.TimeSpan) -> int static;

        @IL.name("WaitAny")
        wait_any(tasks: System.Threading.Tasks.Task_0[], cancellation_token: System.Threading.CancellationToken) -> int static;

        @IL.name("WaitAny")
        wait_any(tasks: System.Threading.Tasks.Task_0[], milliseconds_timeout: int) -> int static;

        @IL.name("WaitAny")
        wait_any(tasks: System.Threading.Tasks.Task_0[], milliseconds_timeout: int, cancellation_token: System.Threading.CancellationToken) -> int static;

        // from_result[TResult](result: TResult) -> System.Threading.Tasks.Task[TResult] static;

        @IL.name("FromException")
        from_exception(exception: System.Exception) -> System.Threading.Tasks.Task_0 static;

        // from_exception[TResult](exception: System.Exception) -> System.Threading.Tasks.Task[TResult] static;

        @IL.name("FromCanceled")
        from_canceled(cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task_0 static;

        // from_canceled[TResult](cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task[TResult] static;

        @IL.name("Run")
        run(action: Ghul.ACTION_0) -> System.Threading.Tasks.Task_0 static;

        @IL.name("Run")
        run(action: Ghul.ACTION_0, cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task_0 static;

        // run[TResult](function: Ghul.FUNCTION_0[TResult]) -> System.Threading.Tasks.Task[TResult] static;

        // run[TResult](function: Ghul.FUNCTION_0[TResult], cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task[TResult] static;

        @IL.name("Run")
        run(function: Ghul.FUNCTION_0[System.Threading.Tasks.Task_0]) -> System.Threading.Tasks.Task_0 static;

        @IL.name("Run")
        run(function: Ghul.FUNCTION_0[System.Threading.Tasks.Task_0], cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task_0 static;

        // run[TResult](function: Ghul.FUNCTION_0[System.Threading.Tasks.Task[TResult]]) -> System.Threading.Tasks.Task[TResult] static;

        // run[TResult](function: Ghul.FUNCTION_0[System.Threading.Tasks.Task[TResult]], cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task[TResult] static;

        @IL.name("Delay")
        delay(delay: System.TimeSpan) -> System.Threading.Tasks.Task_0 static;

        @IL.name("Delay")
        delay(delay: System.TimeSpan, cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task_0 static;

        @IL.name("Delay")
        delay(milliseconds_delay: int) -> System.Threading.Tasks.Task_0 static;

        @IL.name("Delay")
        delay(milliseconds_delay: int, cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task_0 static;

        @IL.name("WhenAll")
        when_all(tasks: Collections.Iterable[System.Threading.Tasks.Task_0]) -> System.Threading.Tasks.Task_0 static;

        @IL.name("WhenAll")
        when_all(tasks: System.Threading.Tasks.Task_0[]) -> System.Threading.Tasks.Task_0 static;

        // when_all[TResult](tasks: Collections.Iterable[System.Threading.Tasks.Task[TResult]]) -> System.Threading.Tasks.Task[TResult[]] static;

        // when_all[TResult](tasks: System.Threading.Tasks.Task[TResult][]) -> System.Threading.Tasks.Task[TResult[]] static;

        @IL.name("WhenAny")
        when_any(tasks: System.Threading.Tasks.Task_0[]) -> System.Threading.Tasks.Task[System.Threading.Tasks.Task_0] static;

        @IL.name("WhenAny")
        when_any(tasks: Collections.Iterable[System.Threading.Tasks.Task_0]) -> System.Threading.Tasks.Task[System.Threading.Tasks.Task_0] static;

        // when_any[TResult](tasks: System.Threading.Tasks.Task[TResult][]) -> System.Threading.Tasks.Task[System.Threading.Tasks.Task[TResult]] static;

        // when_any[TResult](tasks: Collections.Iterable[System.Threading.Tasks.Task[TResult]]) -> System.Threading.Tasks.Task[System.Threading.Tasks.Task[TResult]] static;

        @IL.name("GetAwaiter")
        get_awaiter() -> System.Runtime.CompilerServices.TaskAwaiter;

        @IL.name("ConfigureAwait")
        configure_await(continue_on_captured_context: bool) -> System.Runtime.CompilerServices.ConfiguredTaskAwaitable;

        @IL.name("Yield")
        yield() -> System.Runtime.CompilerServices.YieldAwaitable static;

        @IL.name("Wait")
        wait();

        @IL.name("Wait")
        wait(timeout: System.TimeSpan) -> bool;

        @IL.name("Wait")
        wait(cancellation_token: System.Threading.CancellationToken);

        @IL.name("Wait")
        wait(milliseconds_timeout: int) -> bool;

        @IL.name("Wait")
        wait(milliseconds_timeout: int, cancellation_token: System.Threading.CancellationToken) -> bool;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_1[System.Threading.Tasks.Task_0]) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_1[System.Threading.Tasks.Task_0], cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_1[System.Threading.Tasks.Task_0], scheduler: System.Threading.Tasks.TaskScheduler) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_1[System.Threading.Tasks.Task_0], continuation_options: System.Threading.Tasks.TaskContinuationOptions) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_1[System.Threading.Tasks.Task_0], cancellation_token: System.Threading.CancellationToken, continuation_options: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_2[System.Threading.Tasks.Task_0,System.Object], state: System.Object) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_2[System.Threading.Tasks.Task_0,System.Object], state: System.Object, cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_2[System.Threading.Tasks.Task_0,System.Object], state: System.Object, scheduler: System.Threading.Tasks.TaskScheduler) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_2[System.Threading.Tasks.Task_0,System.Object], state: System.Object, continuation_options: System.Threading.Tasks.TaskContinuationOptions) -> System.Threading.Tasks.Task_0;

        @IL.name("ContinueWith")
        continue_with(continuation_action: Ghul.ACTION_2[System.Threading.Tasks.Task_0,System.Object], state: System.Object, cancellation_token: System.Threading.CancellationToken, continuation_options: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) -> System.Threading.Tasks.Task_0;

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_1[System.Threading.Tasks.Task_0,TResult]) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_1[System.Threading.Tasks.Task_0,TResult], cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_1[System.Threading.Tasks.Task_0,TResult], scheduler: System.Threading.Tasks.TaskScheduler) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_1[System.Threading.Tasks.Task_0,TResult], continuation_options: System.Threading.Tasks.TaskContinuationOptions) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_1[System.Threading.Tasks.Task_0,TResult], cancellation_token: System.Threading.CancellationToken, continuation_options: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_2[System.Threading.Tasks.Task_0,System.Object,TResult], state: System.Object) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_2[System.Threading.Tasks.Task_0,System.Object,TResult], state: System.Object, cancellation_token: System.Threading.CancellationToken) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_2[System.Threading.Tasks.Task_0,System.Object,TResult], state: System.Object, scheduler: System.Threading.Tasks.TaskScheduler) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_2[System.Threading.Tasks.Task_0,System.Object,TResult], state: System.Object, continuation_options: System.Threading.Tasks.TaskContinuationOptions) -> System.Threading.Tasks.Task[TResult];

        // continue_with[TResult](continuation_function: Ghul.FUNCTION_2[System.Threading.Tasks.Task_0,System.Object,TResult], state: System.Object, cancellation_token: System.Threading.CancellationToken, continuation_options: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) -> System.Threading.Tasks.Task[TResult];

        @IL.name("WaitAll")
        wait_all(tasks: System.Threading.Tasks.Task_0[]) static;

        @IL.name("WaitAll")
        wait_all(tasks: System.Threading.Tasks.Task_0[], timeout: System.TimeSpan) -> bool static;

        @IL.name("WaitAll")
        wait_all(tasks: System.Threading.Tasks.Task_0[], milliseconds_timeout: int) -> bool static;

        @IL.name("WaitAll")
        wait_all(tasks: System.Threading.Tasks.Task_0[], cancellation_token: System.Threading.CancellationToken) static;

        @IL.name("WaitAll")
        wait_all(tasks: System.Threading.Tasks.Task_0[], milliseconds_timeout: int, cancellation_token: System.Threading.CancellationToken) -> bool static;

        @IL.name("Start")
        start();

        @IL.name("Start")
        start(scheduler: System.Threading.Tasks.TaskScheduler);

        @IL.name("RunSynchronously")
        run_synchronously();

        @IL.name("RunSynchronously")
        run_synchronously(scheduler: System.Threading.Tasks.TaskScheduler);

        @IL.name("Dispose")
        dispose();

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name(".ctor")
        init(action: Ghul.ACTION_0);
        @IL.name(".ctor")
        init(action: Ghul.ACTION_0, cancellation_token: System.Threading.CancellationToken);
        @IL.name(".ctor")
        init(action: Ghul.ACTION_0, creation_options: System.Threading.Tasks.TaskCreationOptions);
        @IL.name(".ctor")
        init(action: Ghul.ACTION_0, cancellation_token: System.Threading.CancellationToken, creation_options: System.Threading.Tasks.TaskCreationOptions);
        @IL.name(".ctor")
        init(action: Ghul.ACTION_1[System.Object], state: System.Object);
        @IL.name(".ctor")
        init(action: Ghul.ACTION_1[System.Object], state: System.Object, cancellation_token: System.Threading.CancellationToken);
        @IL.name(".ctor")
        init(action: Ghul.ACTION_1[System.Object], state: System.Object, creation_options: System.Threading.Tasks.TaskCreationOptions);
        @IL.name(".ctor")
        init(action: Ghul.ACTION_1[System.Object], state: System.Object, cancellation_token: System.Threading.CancellationToken, creation_options: System.Threading.Tasks.TaskCreationOptions);
        @IL.name.read("get_Id") 
        id: int;

        @IL.name.read("get_CurrentId") 
        current_id: System.Nullable[int] static;

        @IL.name.read("get_Exception") 
        exception: System.AggregateException;

        @IL.name.read("get_Status") 
        status: System.Threading.Tasks.TaskStatus;

        @IL.name.read("get_IsCanceled") 
        is_canceled: bool;

        @IL.name.read("get_IsCompleted") 
        is_completed: bool;

        @IL.name.read("get_IsCompletedSuccessfully") 
        is_completed_successfully: bool;

        @IL.name.read("get_CreationOptions") 
        creation_options: System.Threading.Tasks.TaskCreationOptions;

        @IL.name.read("get_AsyncState") 
        async_state: System.Object;

        @IL.name.read("get_Factory") 
        factory: System.Threading.Tasks.TaskFactory static;

        @IL.name.read("get_CompletedTask") 
        completed_task: System.Threading.Tasks.Task_0 static;

        @IL.name.read("get_IsFaulted") 
        is_faulted: bool;

    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Threading.Tasks.ValueTask")
    struct ValueTask_0: System.Equatable[System.Threading.Tasks.ValueTask_0] is
        @IL.name("GetHashCode")
        get_hash_code() -> int;

        @IL.name("Equals")
        equals(obj: System.Object) -> bool;

        @IL.name("Equals")
        equals(other: System.Threading.Tasks.ValueTask_0) -> bool;

        @IL.name("AsTask")
        as_task() -> System.Threading.Tasks.Task_0;

        @IL.name("Preserve")
        preserve() -> System.Threading.Tasks.ValueTask_0;

        @IL.name("GetAwaiter")
        get_awaiter() -> System.Runtime.CompilerServices.ValueTaskAwaiter;

        @IL.name("ConfigureAwait")
        configure_await(continue_on_captured_context: bool) -> System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable;

        @IL.name("ToString")
        to_string() -> System.String;

        @IL.name("GetType")
        get_type() -> System.Type;

        @IL.name(".ctor")
        init(task: System.Threading.Tasks.Task_0);
        @IL.name(".ctor")
        init(source: System.Threading.Tasks.Sources.IValueTaskSource, token: short);
        @IL.name.read("get_IsCompleted") 
        is_completed: bool;

        @IL.name.read("get_IsCompletedSuccessfully") 
        is_completed_successfully: bool;

        @IL.name.read("get_IsFaulted") 
        is_faulted: bool;

        @IL.name.read("get_IsCanceled") 
        is_canceled: bool;

    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Threading.Tasks.Task`1")
    class Task[TResult]: System.Threading.Tasks.Task_0,System.IAsyncResult,System.IDisposable is
    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Threading.Tasks.ValueTask`1")
    struct ValueTask[TResult]: System.Equatable[System.Threading.Tasks.ValueTask[TResult]] is
    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Threading.Tasks.TaskScheduler")
    class TaskScheduler: System.Object is
    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Threading.Tasks.TaskContinuationOptions")
    struct TaskContinuationOptions is
    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Threading.Tasks.TaskCreationOptions")
    struct TaskCreationOptions is
    si
    @IL.stub()
    @IL.name("valuetype [mscorlib]System.Threading.Tasks.TaskStatus")
    struct TaskStatus is
    si
    @IL.stub()
    @IL.name("class [mscorlib]System.Threading.Tasks.TaskFactory")
    class TaskFactory: System.Object is
    si
si
