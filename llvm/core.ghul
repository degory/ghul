namespace LLVM is
    class CORE is
        LLVMInitializeCore(r: PassRegistry) native;

        /** Deallocate and destroy all ManagedStatic variables.
            @see llvm::llvm_shutdown
            @see ManagedStatic */
        LLVMShutdown() native;

        /*===-- Error handling ----------------------------------------------------===*/

        LLVMCreateMessage(message: char ptr) -> char ptr native;
        LLVMDisposeMessage(message: char ptr) native;

        /**
        * @defgroup LLVMCCoreContext Contexts
        *
        * Contexts are execution states for the core LLVM IR system.
        *
        * Most types are tied to a context instance. Multiple contexts can
        * exist simultaneously. A single context is not thread safe. However,
        * different contexts can execute on different threads simultaneously.
        *
        * @{
        */

        // typedef void (*LLVMDiagnosticHandler)(LLVMDiagnosticInfoRef, void *);
        // typedef void (*LLVMYieldCallback)(LLVMContextRef, void *);

        /**
        * Create a new context.
        *
        * Every call to this function should be paired with a call to
        * LLVMContextDispose() or the context will leak memory.
        */
        LLVMContextCreate() -> Context native;

        /**
        * Obtain the global context instance.
        */
        LLVMGetGlobalContext() -> Context native;

        /**
        * Set the diagnostic handler for this context.
        */

        LLVMContextSetDiagnosticHandler(
            context: Context,
            handler: (DiagnosticInfo, char ptr) -> void
        ) native;

        /**
        * Get the diagnostic handler of this context.
        */
        LLVMContextGetDiagnosticHandler(c: Context) -> (DiagnosticInfo, char ptr) -> void native;

        /**
        * Get the diagnostic context of this context.
        */
        LLVMContextGetDiagnosticContext(c: Context) -> char ptr native;

        /**
        * Set the yield callback function for this context.
        *
        * @see Context::setYieldCallback()
        */

        /*
        LLVMContextSetYieldCallback(Context C, YieldCallback Callback,
                                        void *OpaqueHandle);
        */
        /**
        * Destroy a context instance.
        *
        * This should be called for every call to LLVMContextCreate() or memory
        * will be leaked.
        */
        LLVMContextDispose(c: Context) native;

        /**
        * Return a string representation of the DiagnosticInfo. Use
        * LLVMDisposeMessage to free the string.
        *
        * @see DiagnosticInfo::print()
        */
        LLVMGetDiagInfoDescription(di: DiagnosticInfo) -> char ptr native;

        /**
        * Return an enum LLVMDiagnosticSeverity.
        *
        * @see DiagnosticInfo::getSeverity()
        */
        LLVMGetDiagInfoSeverity(di: DiagnosticInfo) -> DiagnosticSeverity native;

        LLVMGetMDKindIDInContext(c: Context, name: char ptr,
                                        len: int) -> int native;

        LLVMGetMDKindID(name: char ptr, len: int) -> int native;

        /**
        * Return an unique id given the name of a enum attribute,
        * or 0 if no attribute by that name exists.
        *
        * See http://llvm.org/docs/LangRef.html#parameter-attributes
        * and http://llvm.org/docs/LangRef.html#function-attributes
        * for the list of available attributes.
        *
        * NB: Attribute names and/or id are subject to change without
        * going through the C API deprecation cycle.
        */
        LLVMGetEnumAttributeKindForName(name: char ptr, len: long) -> int native;
        LLVMGetLastEnumAttributeKind() -> int native;

        /**
        * Create an enum attribute.
        */
        LLVMCreateEnumAttribute(c: Context, kind_id: int, val: long) -> Attribute native;

        /**
        * Get the unique id corresponding to the enum attribute
        * passed as argument.
        */
        LLVMGetEnumAttributeKind(a: Attribute) -> int native;

        /**
        * Get the enum attribute's value. 0 is returned if none exists.
        */
        LLVMGetEnumAttributeValue(a: Attribute) -> long native;

        /**
        * Create a string attribute.
        */
        LLVMCreateStringAttribute(c: Context,
                                k: char ptr, k_length: int,
                                v: char ptr, v_length: int) -> Attribute native;

        /**
        * Get the string attribute's kind.
        */
        LLVMGetStringAttributeKind(a: Attribute, length: int ptr) -> char ptr native;

        /**
        * Get the string attribute's value.
        */
        LLVMGetStringAttributeValue(a: Attribute, length: int ptr) -> char ptr native;

        /**
        * Check for the different types of attributes.
        */
        LLVMIsEnumAttribute(a: Attribute) -> Bool native;
        LLVMIsStringAttribute(a: Attribute) -> Bool native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreModule Modules
        *
        * Modules represent the top-level structure in an LLVM program. An LLVM
        * module is effectively a translation unit or a collection of
        * translation units merged together.
        *
        * @{
        */

        /**
        * Create a new, empty module in the global context.
        *
        * This is equivalent to calling LLVMModuleCreateWithNameInContext with
        * LLVMGetGlobalContext() as the context parameter.
        *
        * Every invocation should be paired with LLVMDisposeModule() or memory
        * will be leaked.
        */
        LLVMModuleCreateWithName(module_id: char ptr) -> Module native;

        /**
        * Create a new, empty module in a specific context.
        *
        * Every invocation should be paired with LLVMDisposeModule() or memory
        * will be leaked.
        */
        LLVMModuleCreateWithNameInContext(module_id: char ptr,
                                                        c: Context) -> Module native;
        /**
        * Return an exact copy of the specified module.
        */
        LLVMCloneModule(m: Module) -> Module native;

        /**
        * Destroy a module instance.
        *
        * This must be called for every created module or memory will be
        * leaked.
        */
        LLVMDisposeModule(m: Module) native;

        /**
        * Obtain the identifier of a module.
        *
        * @param M Module to obtain identifier of
        * @param Len Out parameter which holds the length of the returned string.
        * @return The identifier of M.
        * @see Module::getModuleIdentifier()
        */
        LLVMGetModuleIdentifier(m: Module, len: long ptr) -> char ptr native;

        /**
        * Set the identifier of a module to a string Ident with length Len.
        *
        * @param M The module to set identifier
        * @param Ident The string to set M's identifier to
        * @param Len Length of Ident
        * @see Module::setModuleIdentifier()
        */
        LLVMSetModuleIdentifier(m: Module, ident: char ptr, len: long) native;

        /**
        * Obtain the data layout for a module.
        *
        * @see Module::getDataLayoutStr()
        *
        * LLVMGetDataLayout is DEPRECATED, as the name is not only incorrect,
        * but match the name of another method on the module. Prefer the use
        * of LLVMGetDataLayoutStr, which is not ambiguous.
        */
        LLVMGetDataLayoutStr(m: Module) -> char ptr native;
        // const char *LLVMGetDataLayout(Module M);

        /**
        * Set the data layout for a module.
        *
        * @see Module::setDataLayout()
        */
        LLVMSetDataLayout(m: Module, data_layout_string: char ptr) native;

        /**
        * Obtain the target triple for a module.
        *
        * @see Module::getTargetTriple()
        */
        LLVMGetTarget(module: Module) -> char ptr native;

        /**
        * Set the target triple for a module.
        *
        * @see Module::setTargetTriple()
        */
        LLVMSetTarget(m: Module, triple: char ptr) native;

        /**
        * Dump a representation of a module to stderr.
        *
        * @see Module::dump()
        */
        LLVMDumpModule(module: Module) native;

        /**
        * Print a representation of a module to a file. The ErrorMessage needs to be
        * disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.
        *
        * @see Module::print()
        */
        LLVMPrintModuleToFile(module: Module, file_name: char ptr,
                                    error_message: char ptr ptr) -> Bool native;

        /**
        * Return a string representation of the module. Use
        * LLVMDisposeMessage to free the string.
        *
        * @see Module::print()
        */
        LLVMPrintModuleToString(m: Module) -> char ptr native;

        /**
        * Set inline assembly for a module.
        *
        * @see Module::setModuleInlineAsm()
        */
        LLVMSetModuleInlineAsm(m: Module, asm: char ptr) native;

        /**
        * Obtain the context to which this module is associated.
        *
        * @see Module::getContext()
        */
        LLVMGetModuleContext(m: Module) -> Context native;

        /**
        * Obtain a Type from a module by its registered name.
        */
        LLVMGetTypeByName(m: Module, name: char ptr) -> Type native;

        /**
        * Obtain the number of operands for named metadata in a module.
        *
        * @see llvm::Module::getNamedMetadata()
        */
        LLVMGetNamedMetadataNumOperands(m: Module, name: char ptr) -> int native;

        /**
        * Obtain the named metadata operands for a module.
        *
        * The passed LLVMValueRef pointer should refer to an array of
        * LLVMValueRef at least LLVMGetNamedMetadataNumOperands long. This
        * array will be populated with the LLVMValueRef instances. Each
        * instance corresponds to a llvm::MDNode.
        *
        * @see llvm::Module::getNamedMetadata()
        * @see llvm::MDNode::getOperand()
        */
        LLVMGetNamedMetadataOperands(m: Module, name: char ptr,
                                        dest: Value ptr) native;
        /**
        * Add an operand to named metadata.
        *
        * @see llvm::Module::getNamedMetadata()
        * @see llvm::MDNode::addOperand()
        */
        LLVMAddNamedMetadataOperand(m: Module, name: char ptr,
                                        val: Value) native;

        /**
        * Add a function to a module under a specified name.
        *
        * @see llvm::Function::Create()
        */
        LLVMAddFunction(m: Module, name: char ptr,
                                    type: Type) -> Value native;

        /**
        * Obtain a Function value from a Module by its name.
        *
        * The returned value corresponds to a llvm::Function value.
        *
        * @see llvm::Module::getFunction()
        */
        LLVMGetNamedFunction(module: Module, name: char ptr) -> Value native;

        /**
        * Obtain an iterator to the first Function in a Module.
        *
        * @see llvm::Module::begin()
        */
        LLVMGetFirstFunction(module: Module) -> Value native;

        /**
        * Obtain an iterator to the last Function in a Module.
        *
        * @see llvm::Module::end()
        */
        LLVMGetLastFunction(module: Module) -> Value native;

        /**
        * Advance a Function iterator to the next Function.
        *
        * Returns NULL if the iterator was already at the end and there are no more
        * functions.
        */
        LLVMGetNextFunction(function: Value) -> Value native;

        /**
        * Decrement a Function iterator to the previous Function.
        *
        * Returns NULL if the iterator was already at the beginning and there are
        * no previous functions.
        */
        LLVMGetPreviousFunction(function: Value) -> Value native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreType Types
        *
        * Types represent the type of a value.
        *
        * Types are associated with a context instance. The context internally
        * deduplicates types so there is only 1 instance of a specific type
        * alive at a time. In other words, a unique type is shared among all
        * consumers within a context.
        *
        * A Type in the C API corresponds to llvm::Type.
        *
        * Types have the following hierarchy:
        *
        *   types:
        *     integer type
        *     real type
        *     function type
        *     sequence types:
        *       array type
        *       pointer type
        *       vector type
        *     void type
        *     label type
        *     opaque type
        *
        * @{
        */

        /**
        * Obtain the enumerated type of a Type instance.
        *
        * @see llvm::Type:getTypeID()
        */
        LLVMGetTypeKind(type: Type) -> TypeKind native;

        /**
        * Whether the type has a known size.
        *
        * Things that don't have a size are abstract types, labels, and void.
        *
        * @see llvm::Type::isSized()
        */
        LLVMTypeIsSized(type: Type) -> Bool native;

        /**
        * Obtain the context to which this type instance is associated.
        *
        * @see llvm::Type::getContext()
        */
        LLVMGetTypeContext(type: Type) -> Context native;

        /**
        * Dump a representation of a type to stderr.
        *
        * @see llvm::Type::dump()
        */
        LLVMDumpType(type: Type) native;

        /**
        * Return a string representation of the type. Use
        * LLVMDisposeMessage to free the string.
        *
        * @see llvm::Type::print()
        */
        LLVMPrintTypeToString(type: Type) -> char ptr native; 

        /**
        * @defgroup LLVMCCoreTypeInt Integer Types
        *
        * Functions in this section operate on integer types.
        *
        * @{
        */

        /**
        * Obtain an integer type from a context with specified bit width.
        */
        LLVMInt1TypeInContext(c: Context) -> Type native;
        LLVMInt8TypeInContext(c: Context) -> Type native;
        LLVMInt16TypeInContext(c: Context) -> Type native;
        LLVMInt32TypeInContext(c: Context) -> Type native;
        LLVMInt64TypeInContext(c: Context) -> Type native;
        LLVMInt128TypeInContext(c: Context) -> Type native;
        LLVMIntTypeInContext(c: Context, num_bits: int) -> Type native;

        /**
        * Obtain an integer type from the global context with a specified bit
        * width.
        */
        LLVMInt1Type() -> Type native;
        LLVMInt8Type() -> Type native;
        LLVMInt16Type() -> Type native;
        LLVMInt32Type() -> Type native;
        LLVMInt64Type() -> Type native;
        LLVMInt128Type() -> Type native;
        LLVMIntType(num_bits: int) -> Type native;
        LLVMGetIntTypeWidth(int_type: Type) -> int native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreTypeFloat Floating Point Types
        *
        * @{
        */

        /**
        * Obtain a 16-bit floating point type from a context.
        */
        LLVMHalfTypeInContext(c: Context) -> Type native;

        /**
        * Obtain a 32-bit floating point type from a context.
        */
        LLVMFloatTypeInContext(c: Context) -> Type native;

        /**
        * Obtain a 64-bit floating point type from a context.
        */
        LLVMDoubleTypeInContext(c: Context) -> Type native;

        /**
        * Obtain a 80-bit floating point type (X87) from a context.
        */
        LLVMX86FP80TypeInContext(c: Context) -> Type native;

        /**
        * Obtain a 128-bit floating point type (112-bit mantissa) from a
        * context.
        */
        LLVMFP128TypeInContext(c: Context) -> Type native;

        /**
        * Obtain a 128-bit floating point type (two 64-bits) from a context.
        */
        LLVMPPCFP128TypeInContext(c: Context) -> Type native;

        /**
        * Obtain a floating point type from the global context.
        *
        * These map to the functions in this group of the same name.
        */
        LLVMHalfType() -> Type native;
        LLVMFloatType() -> Type native;
        LLVMDoubleType() -> Type native;
        LLVMX86FP80Type() -> Type native;
        LLVMFP128Type() -> Type native;
        LLVMPPCFP128Type() -> Type native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreTypeFunction Function Types
        *
        * @{
        */

        /**
        * Obtain a function type consisting of a specified signature.
        *
        * The function is defined as a tuple of a return Type, a list of
        * parameter types, and whether the function is variadic.
        */
        LLVMFunctionType(return_type: Type,
                                    param_type: Type ptr, param_count: int,
                                    is_var_arg: Bool) -> Type native;

        /**
        * Returns whether a function type is variadic.
        */
        LLVMIsFunctionVarArg(function_type: Type) -> Bool native;

        /**
        * Obtain the Type this function Type returns.
        */
        LLVMGetReturnType(function_type: Type) -> Type native;

        /**
        * Obtain the number of parameters this function accepts.
        */
        LLVMCountParamTypes(function_type: Type) -> int native;

        /**
        * Obtain the types of a function's parameters.
        *
        * The Dest parameter should point to a pre-allocated array of
        * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the
        * first LLVMCountParamTypes() entries in the array will be populated
        * with LLVMTypeRef instances.
        *
        * @param FunctionTy The function type to operate on.
        * @param Dest Memory address of an array to be filled with result.
        */
        LLVMGetParamTypes(function_type: Type, dest: Type ptr) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreTypeStruct Structure Types
        *
        * These functions relate to LLVMTypeRef instances.
        *
        * @see llvm::StructType
        *
        * @{
        */

        /**
        * Create a new structure type in a context.
        *
        * A structure is specified by a list of inner elements/types and
        * whether these can be packed together.
        *
        * @see llvm::StructType::create()
        */
        LLVMStructTypeInContext(c: Context, element_types: Type ptr,
                                            element_count: int, packed: Bool) -> Type native;

        /**
        * Create a new structure type in the global context.
        *
        * @see llvm::StructType::create()
        */
        LLVMStructType(element_types: Type ptr, element_count: int,
                                packed: Bool) -> Type native;

        /**
        * Create an empty structure in a context having a specified name.
        *
        * @see llvm::StructType::create()
        */
        LLVMStructCreateNamed(context: Context, name: char ptr) -> Type native;

        /**
        * Obtain the name of a structure.
        *
        * @see llvm::StructType::getName()
        */
        LLVMGetStructName(struct_type: Type) -> char ptr native;

        /**
        * Set the contents of a structure type.
        *
        * @see llvm::StructType::setBody()
        */
        LLVMStructSetBody(struct_type: Type, element_types: Type ptr,
                            element_count: int, packed: Bool) native;

        /**
        * Get the number of elements defined inside the structure.
        *
        * @see llvm::StructType::getNumElements()
        */
        LLVMCountStructElementTypes(struct_type: Type) -> int native;

        /**
        * Get the elements within a structure.
        *
        * The function is passed the address of a pre-allocated array of
        * LLVMTypeRef at least LLVMCountStructElementTypes() long. After
        * invocation, this array will be populated with the structure's
        * elements. The objects in the destination array will have a lifetime
        * of the structure type itself, which is the lifetime of the context it
        * is contained in.
        */
        LLVMGetStructElementTypes(struct_type: Type, dest: Type ptr) native;

        /**
        * Get the type of the element at a given index in the structure.
        *
        * @see llvm::StructType::getTypeAtIndex()
        */
        LLVMStructGetTypeAtIndex(struct_type: Type, index: int) -> Type native;

        /**
        * Determine whether a structure is packed.
        *
        * @see llvm::StructType::isPacked()
        */
        LLVMIsPackedStruct(struct_type: Type) -> Bool native;

        /**
        * Determine whether a structure is opaque.
        *
        * @see llvm::StructType::isOpaque()
        */
        LLVMIsOpaqueStruct(struct_type: Type) -> Bool native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreTypeSequential Sequential Types
        *
        * Sequential types represents "arrays" of types. This is a super class
        * for array, vector, and pointer types.
        *
        * @{
        */

        /**
        * Obtain the type of elements within a sequential type.
        *
        * This works on array, vector, and pointer types.
        *
        * @see llvm::SequentialType::getElementType()
        */
        LLVMGetElementType(type: Type) -> Type native;

        /**
        * Returns type's subtypes
        *
        * @see llvm::Type::subtypes()
        */
        LLVMGetSubtypes(type: Type, arr: Type ptr) native;

        /**
        *  Return the number of types in the derived type.
        *
        * @see llvm::Type::getNumContainedTypes()
        */
        LLVMGetNumContainedTypes(type: Type) -> int native;

        /**
        * Create a fixed size array type that refers to a specific type.
        *
        * The created type will exist in the context that its element type
        * exists in.
        *
        * @see llvm::ArrayType::get()
        */
        LLVMArrayType(element_type: Type, element_count: int) -> Type native;

        /**
        * Obtain the length of an array type.
        *
        * This only works on types that represent arrays.
        *
        * @see llvm::ArrayType::getNumElements()
        */
        LLVMGetArrayLength(array_type: Type) -> int native;

        /**
        * Create a pointer type that points to a defined type.
        *
        * The created type will exist in the context that its pointee type
        * exists in.
        *
        * @see llvm::PointerType::get()
        */
        LLVMPointerType(element_type: Type, address_space: int) -> Type native;

        /**
        * Obtain the address space of a pointer type.
        *
        * This only works on types that represent pointers.
        *
        * @see llvm::PointerType::getAddressSpace()
        */
        LLVMGetPointerAddressSpace(pointer_type: Type) -> int native;

        /**
        * Create a vector type that contains a defined type and has a specific
        * number of elements.
        *
        * The created type will exist in the context thats its element type
        * exists in.
        *
        * @see llvm::VectorType::get()
        */
        LLVMVectorType(element_type: Type, element_count: int) -> Type native;

        /**
        * Obtain the number of elements in a vector type.
        *
        * This only works on types that represent vectors.
        *
        * @see llvm::VectorType::getNumElements()
        */
        LLVMGetVectorSize(vector_type: Type) -> int native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreTypeOther Other Types
        *
        * @{
        */

        /**
        * Create a void type in a context.
        */
        LLVMVoidTypeInContext(c: Context) -> Type native;

        /**
        * Create a label type in a context.
        */
        LLVMLabelTypeInContext(c: Context) -> Type native;

        /**
        * Create a X86 MMX type in a context.
        */
        LLVMX86MMXTypeInContext(c: Context) -> Type native;

        /**
        * These are similar to the above functions except they operate on the
        * global context.
        */
        LLVMVoidType() -> Type native;
        LLVMLabelType() -> Type native;
        LLVMX86MMXType() -> Type native;

        /**
        * @}
        */

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValues Values
        *
        * The bulk of LLVM's object model consists of values, which comprise a very
        * rich type hierarchy.
        *
        * LLVMValueRef essentially represents llvm::Value. There is a rich
        * hierarchy of classes within this type. Depending on the instance
        * obtained, not all APIs are available.
        *
        * Callers can determine the type of an LLVMValueRef by calling the
        * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These
        * functions are defined by a macro, so it isn't obvious which are
        * available by looking at the Doxygen source code. Instead, look at the
        * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list
        * of value names given. These value names also correspond to classes in
        * the llvm::Value hierarchy.
        *
        * @{
        */


        /**
        * @defgroup LLVMCCoreValueGeneral General APIs
        *
        * Functions in this section work on all LLVMValueRef instances,
        * regardless of their sub-type. They correspond to functions available
        * on llvm::Value.
        *
        * @{
        */

        /**
        * Obtain the type of a value.
        *
        * @see llvm::Value::getType()
        */
        LLVMTypeOf(value: Value) -> Type native;

        /**
        * Obtain the enumerated type of a Value instance.
        *
        * @see llvm::Value::getValueID()
        */
        LLVMGetValueKind(value: Value) -> TypeKind native;

        /**
        * Obtain the string name of a value.
        *
        * @see llvm::Value::getName()
        */
        LLVMGetValueName(value: Value) -> char ptr native;

        /**
        * Set the string name of a value.
        *
        * @see llvm::Value::setName()
        */
        LLVMSetValueName(value: Value, name: char ptr) native;

        /**
        * Dump a representation of a value to stderr.
        *
        * @see llvm::Value::dump()
        */
        LLVMDumpValue(value: Value) native;

        /**
        * Return a string representation of the value. Use
        * LLVMDisposeMessage to free the string.
        *
        * @see llvm::Value::print()
        */
        LLVMPrintValueToString(value: Value) -> char ptr native;

        /**
        * Replace all uses of a value with another one.
        *
        * @see llvm::Value::replaceAllUsesWith()
        */
        LLVMReplaceAllUsesWith(old_value: Value, new_value: Value) native;

        /**
        * Determine whether the specified value instance is constant.
        */
        LLVMIsConstant(value: Value) -> Bool native;

        /**
        * Determine whether a value instance is undefined.
        */
        LLVMIsUndef(value: Value) -> Bool native;

        LLVMIsAMDNode(value: Value) -> Value native;
        LLVMIsAMDString(value: Value) -> Value native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueUses Usage
        *
        * This module defines functions that allow you to inspect the uses of a
        * LLVMValueRef.
        *
        * It is possible to obtain an LLVMUseRef for any LLVMValueRef instance.
        * Each LLVMUseRef (which corresponds to a llvm::Use instance) holds a
        * llvm::User and llvm::Value.
        *
        * @{
        */

        /**
        * Obtain the first use of a value.
        *
        * Uses are obtained in an iterator fashion. First, call this function
        * to obtain a reference to the first use. Then, call LLVMGetNextUse()
        * on that instance and all subsequently obtained instances until
        * LLVMGetNextUse() returns NULL.
        *
        * @see llvm::Value::use_begin()
        */
        LLVMGetFirstUse(value: Value) -> Use native;

        /**
        * Obtain the next use of a value.
        *
        * This effectively advances the iterator. It returns NULL if you are on
        * the final use and no more are available.
        */
        LLVMGetNextUse(use_: Use) -> Use native;

        /**
        * Obtain the user value for a user.
        *
        * The returned value corresponds to a llvm::User type.
        *
        * @see llvm::Use::getUser()
        */
        LLVMGetUser(use_: Use) -> Value native;

        /**
        * Obtain the value this use corresponds to.
        *
        * @see llvm::Use::get().
        */
        LLVMGetUsedValue(use_: Use) -> Value native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueUser User value
        *
        * Function in this group pertain to LLVMValueRef instances that descent
        * from llvm::User. This includes constants, instructions, and
        * operators.
        *
        * @{
        */

        /**
        * Obtain an operand at a specific index in a llvm::User value.
        *
        * @see llvm::User::getOperand()
        */
        LLVMGetOperand(value: Value, index: int) -> Value native;

        /**
        * Obtain the use of an operand at a specific index in a llvm::User value.
        *
        * @see llvm::User::getOperandUse()
        */
        LLVMGetOperandUse(value: Value, index: int) -> Use native;

        /**
        * Set an operand at a specific index in a llvm::User value.
        *
        * @see llvm::User::setOperand()
        */
        LLVMSetOperand(user: Value, index: int, value: Value) native;

        /**
        * Obtain the number of operands in a llvm::User value.
        *
        * @see llvm::User::getNumOperands()
        */
        LLVMGetNumOperands(value: Value) -> int native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueConstant Constants
        *
        * This section contains APIs for interacting with LLVMValueRef that
        * correspond to llvm::Constant instances.
        *
        * These functions will work for any LLVMValueRef in the llvm::Constant
        * class hierarchy.
        *
        * @{
        */

        /**
        * Obtain a constant value referring to the null instance of a type.
        *
        * @see llvm::Constant::getNullValue()
        */
        LLVMConstNull(type: Type) -> Value native; /* all zeroes */

        /**
        * Obtain a constant value referring to the instance of a type
        * consisting of all ones.
        *
        * This is only valid for integer types.
        *
        * @see llvm::Constant::getAllOnesValue()
        */
        LLVMConstAllOnes(type: Type) -> Value native;

        /**
        * Obtain a constant value referring to an undefined value of a type.
        *
        * @see llvm::UndefValue::get()
        */
        LLVMGetUndef(type: Type) -> Value native;

        /**
        * Determine whether a value instance is null.
        *
        * @see llvm::Constant::isNullValue()
        */
        LLVMIsNull(value: Value) -> Bool native;

        /**
        * Obtain a constant that is a constant pointer pointing to NULL for a
        * specified type.
        */
        LLVMConstPointerNull(type: Type) -> Value native;

        /**
        * @defgroup LLVMCCoreValueConstantScalar Scalar constants
        *
        * Functions in this group model LLVMValueRef instances that correspond
        * to constants referring to scalar types.
        *
        * For integer types, the LLVMTypeRef parameter should correspond to a
        * llvm::IntegerType instance and the returned LLVMValueRef will
        * correspond to a llvm::ConstantInt.
        *
        * For floating point types, the LLVMTypeRef returned corresponds to a
        * llvm::ConstantFP.
        *
        * @{
        */

        /**
        * Obtain a constant value for an integer type.
        *
        * The returned value corresponds to a llvm::ConstantInt.
        *
        * @see llvm::ConstantInt::get()
        *
        * @param IntTy Integer type to obtain value of.
        * @param N The value the returned instance should refer to.
        * @param SignExtend Whether to sign extend the produced value.
        */

        // FIXME: n shoud be 'long long'
        LLVMConstInt(int_type: Type, n: long,
                                sign_extend: Bool) -> Value native;

        /**
        * Obtain a constant value for an integer of arbitrary precision.
        *
        * @see llvm::ConstantInt::get()
        */
        LLVMConstIntOfArbitraryPrecision(int_type: Type,
                                                    num_words: int,
                                                    words: long ptr);

        /**
        * Obtain a constant value for an integer parsed from a string.
        *
        * A similar API, LLVMConstIntOfStringAndSize is also available. If the
        * string's length is available, it is preferred to call that function
        * instead.
        *
        * @see llvm::ConstantInt::get()
        */
        LLVMConstIntOfString(int_type: Type, text: char ptr,
                                        radix: char) -> Value native;

        /**
        * Obtain a constant value for an integer parsed from a string with
        * specified length.
        *
        * @see llvm::ConstantInt::get()
        */
        LLVMConstIntOfStringAndSize(int_type: Type, text: char ptr,
                                                len: int, radix: char) -> Value native;

        /**
        * Obtain a constant value referring to a double floating point value.
        */
        // LLVMValueRef LLVMConstReal(LLVMTypeRef RealTy, double N);

        /**
        * Obtain a constant for a floating point value parsed from a string.
        *
        * A similar API, LLVMConstRealOfStringAndSize is also available. It
        * should be used if the input string's length is known.
        */
        LLVMConstRealOfString(real_type: Type, text: char ptr) -> Value native;

        /**
        * Obtain a constant for a floating point value parsed from a string.
        */
        LLVMConstRealOfStringAndSize(real_type: Type, text: char ptr,
                                                len: int) -> Value native;

        /**
        * Obtain the zero extended value for an integer constant value.
        *
        * @see llvm::ConstantInt::getZExtValue()
        */
        LLVMConstIntGetZExtValue(value: Value) -> long native;

        /**
        * Obtain the sign extended value for an integer constant value.
        *
        * @see llvm::ConstantInt::getSExtValue()
        */
        LLVMConstIntGetSExtValue(value: Value) -> long native;

        /**
        * Obtain the double value for an floating point constant value.
        * losesInfo indicates if some precision was lost in the conversion.
        *
        * @see llvm::ConstantFP::getDoubleValue
        */
        // double LLVMConstRealGetDouble(LLVMValueRef ConstantVal, Bool *losesInfo);

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueConstantComposite Composite Constants
        *
        * Functions in this group operate on composite constants.
        *
        * @{
        */

        /**
        * Create a ConstantDataSequential and initialize it with a string.
        *
        * @see llvm::ConstantDataArray::getString()
        */
        LLVMConstStringInContext(context: Context, str: char ptr,
                                            length: int, dont_null_terminate: Bool) -> Value native;

        /**
        * Create a ConstantDataSequential with string content in the global context.
        *
        * This is the same as LLVMConstStringInContext except it operates on the
        * global context.
        *
        * @see LLVMConstStringInContext()
        * @see llvm::ConstantDataArray::getString()
        */
        LLVMConstString(str: char ptr, length: int,
                                    dont_null_terminate: Bool) -> Value native;

        /**
        * Returns true if the specified constant is an array of i8.
        *
        * @see ConstantDataSequential::getAsString()
        */
        LLVMIsConstantString(value: Value) -> Bool native;

        /**
        * Get the given constant data sequential as a string.
        *
        * @see ConstantDataSequential::getAsString()
        */
        LLVMGetAsString(c: Value, length: int ptr) -> char ptr native;

        /**
        * Create an anonymous ConstantStruct with the specified values.
        *
        * @see llvm::ConstantStruct::getAnon()
        */
        LLVMConstStructInContext(c: Context,
                                            values: Value ptr,
                                            count: int, packed: Bool) -> Value native;

        /**
        * Create a ConstantStruct in the global Context.
        *
        * This is the same as LLVMConstStructInContext except it operates on the
        * global Context.
        *
        * @see LLVMConstStructInContext()
        */
        LLVMConstStruct(values: Value ptr, count: int,
                                    packed: Bool) -> Value native;

        /**
        * Create a ConstantArray from values.
        *
        * @see llvm::ConstantArray::get()
        */
        LLVMConstArray(element_type: Type,
                                    values: Value ptr, length: int) -> Value native;

        /**
        * Create a non-anonymous ConstantStruct from values.
        *
        * @see llvm::ConstantStruct::get()
        */
        LLVMConstNamedStruct(struct_type: Type,
                                        values: Value ptr,
                                        count: int) -> Value native;

        /**
        * Get an element at specified index as a constant.
        *
        * @see ConstantDataSequential::getElementAsConstant()
        */
        LLVMGetElementAsConstant(value: Value, index: int) -> Value native;

        /**
        * Create a ConstantVector from values.
        *
        * @see llvm::ConstantVector::get()
        */
        LLVMConstVector(values: Value ptr, size: int) -> Value native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueConstantExpressions Constant Expressions
        *
        * Functions in this group correspond to APIs on llvm::ConstantExpr.
        *
        * @see llvm::ConstantExpr.
        *
        * @{
        */
        LLVMGetConstOpcode(value: Value) -> OpCode native;
        LLVMAlignOf(type: Type) -> Value native;
        LLVMSizeOf(type: Type) -> Value native;
        LLVMConstNeg(ConstantVal: Value) -> Value native;
        LLVMConstNSWNeg(ConstantVal: Value) -> Value native;
        LLVMConstNUWNeg(ConstantVal: Value) -> Value native;
        LLVMConstFNeg(ConstantVal: Value) -> Value native;
        LLVMConstNot(ConstantVal: Value) -> Value native;
        LLVMConstAdd(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstNSWAdd(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstNUWAdd(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstFAdd(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstSub(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstNSWSub(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstNUWSub(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstFSub(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstMul(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstNSWMul(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstNUWMul(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstFMul(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstUDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstExactUDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstSDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstExactSDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstFDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstURem(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstSRem(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstFRem(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstAnd(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstOr(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstXor(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstICmp(Predicate: IntPredicate, LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstFCmp(Predicate: RealPredicate, LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstShl(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstLShr(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstAShr(LHSConstant: Value, RHSConstant: Value) -> Value native;
        LLVMConstGEP(ConstantVal: Value, ConstantIndices: Value ptr, NumIndices: int) -> Value native;
        LLVMConstInBoundsGEP(ConstantVal: Value, ConstantIndices: Value ptr, NumIndices: int) -> Value native;
        LLVMConstTrunc(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstSExt(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstZExt(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstFPTrunc(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstFPExt(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstUIToFP(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstSIToFP(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstFPToUI(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstFPToSI(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstPtrToInt(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstIntToPtr(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstBitCast(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstAddrSpaceCast(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstZExtOrBitCast(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstSExtOrBitCast(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstTruncOrBitCast(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstPointerCast(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstIntCast(ConstantVal: Value, to_type: Type, isSigned: Bool) -> Value native;
        LLVMConstFPCast(ConstantVal: Value, to_type: Type) -> Value native;
        LLVMConstSelect(ConstantCondition: Value, ConstantIfTrue: Value, ConstantIfFalse: Value) -> Value native;
        LLVMConstExtractElement(VectorConstant: Value, IndexConstant: Value) -> Value native;
        LLVMConstInsertElement(VectorConstant: Value, ElementValueConstant: Value, IndexConstant: Value) -> Value native;
        LLVMConstShuffleVector(VectorAConstant: Value, VectorBConstant: Value, MaskConstant: Value) -> Value native;
        LLVMConstExtractValue(AggConstant: Value, IdxList: int ptr, NumIdx: int) -> Value native;
        LLVMConstInsertValue(AggConstant: Value, ElementValueConstant: Value, IdxList: int ptr, NumIdx: int) -> Value native;

        LLVMConstInlineAsm(type: Type, asm_string: char ptr, constraints: char ptr, has_side_effects: Bool, is_align_stack: Bool) -> Value native;

        LLVMBlockAddress(f: Value, basic_block: BasicBlock) -> Value native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueConstantGlobals Global Values
        *
        * This group contains functions that operate on global values. Functions in
        * this group relate to functions in the llvm::GlobalValue class tree.
        *
        * @see llvm::GlobalValue
        *
        * @{
        */

        LLVMGetGlobalParent(global: Value) -> Module native;
        LLVMIsDeclaration(global: Value) -> Bool native;
        LLVMGetLinkage(global: Value) -> Linkage native;
        LLVMSetLinkage(global: Value, linkage: Linkage);
        LLVMGetSection(global: Value) -> char ptr native;
        LLVMSetSection(global: Value, section: char ptr) native;
        LLVMGetVisibility(global: Value) -> Visibility native;
        LLVMSetVisibility(global: Value, visibility: Visibility) native;
        LLVMGetDLLStorageClass(global: Value) -> DLLStorageClass native;
        LLVMSetDLLStorageClass(global: Value, storage_class: DLLStorageClass) native;
        LLVMHasUnnamedAddr(global: Value) -> bool native;
        LLVMSetUnnamedAddr(global: Value, has_unnamed_addr: Bool) native;

        /**
        * @defgroup LLVMCCoreValueWithAlignment Values with alignment
        *
        * Functions in this group only apply to values with alignment, i.e.
        * global variables, load and store instructions.
        */

        /**
        * Obtain the preferred alignment of the value.
        * @see llvm::AllocaInst::getAlignment()
        * @see llvm::LoadInst::getAlignment()
        * @see llvm::StoreInst::getAlignment()
        * @see llvm::GlobalValue::getAlignment()
        */
        LLVMGetAlignment(value: Value) -> int native;

        /**
        * Set the preferred alignment of the value.
        * @see llvm::AllocaInst::setAlignment()
        * @see llvm::LoadInst::setAlignment()
        * @see llvm::StoreInst::setAlignment()
        * @see llvm::GlobalValue::setAlignment()
        */
        LLVMSetAlignment(value: Value, bytes: int) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables
        *
        * This group contains functions that operate on global variable values.
        *
        * @see llvm::GlobalVariable
        *
        * @{
        */
        LLVMAddGlobal(module: Module, type: Type, name: char ptr) -> Value native;
        LLVMAddGlobalInAddressSpace(module: Module, type: Type, name: char ptr, address_space: int) -> Value native;
        LLVMGetNamedGlobal(module: Module, name: char ptr) -> Value native;
        LLVMGetFirstGlobal(module: Module) -> Value native;
        LLVMGetLastGlobal(module: Module) -> Value native;
        LLVMGetNextGlobal(global_var: Value) -> Value native;
        LLVMGetPreviousGlobal(global_var: Value) -> Value native;
        LLVMDeleteGlobal(global_var: Value) native;
        LLVMGetInitializer(global_var: Value) -> Value native;
        LLVMSetInitializer(global_var: Value, value: Value) native;
        LLVMIsThreadLocal(global_var: Value) -> Bool native;
        LLVMSetThreadLocal(global_var: Value, is_thread_local: Bool);
        LLVMIsGlobalConstant(global_var: Value) -> Bool native;
        LLVMSetGlobalConstant(global_var: Value, is_constant: Bool) native;
        LLVMGetThreadLocalMode(global_var: Value) -> ThreadLocalMode native; 
        LLVMSetThreadLocalMode(global_var: Value, mode: ThreadLocalMode) native;
        LLVMIsExternallyInitialized(global_var: Value) -> Bool native;
        LLVMSetExternallyInitialized(global_var: Value, is_externally_initialized: Bool) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCoreValueConstantGlobalAlias Global Aliases
        *
        * This group contains function that operate on global alias values.
        *
        * @see llvm::GlobalAlias
        *
        * @{
        */
        LLVMAddAlias(module: Module, type: Type, aliasee: Value, name: char ptr) -> Value native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueFunction Function values
        *
        * Functions in this group operate on LLVMValueRef instances that
        * correspond to llvm::Function instances.
        *
        * @see llvm::Function
        *
        * @{
        */

        /**
        * Remove a function from its containing module and deletes it.
        *
        * @see llvm::Function::eraseFromParent()
        */
        LLVMDeleteFunction(function: Value) native;

        /**
        * Check whether the given function has a personality function.
        *
        * @see llvm::Function::hasPersonalityFn()
        */
        LLVMHasPersonalityFn(function: Value) -> Bool native;

        /**
        * Obtain the personality function attached to the function.
        *
        * @see llvm::Function::getPersonalityFn()
        */
        LLVMGetPersonalityFn(function: Value) -> Value native;

        /**
        * Set the personality function attached to the function.
        *
        * @see llvm::Function::setPersonalityFn()
        */
        LLVMSetPersonalityFn(function: Value, personality_function: Value) native;

        /**
        * Obtain the ID number from a function instance.
        *
        * @see llvm::Function::getIntrinsicID()
        */
        LLVMGetIntrinsicID(function: Value) -> int native;

        /**
        * Obtain the calling function of a function.
        *
        * The returned value corresponds to the LLVMCallConv enumeration.
        *
        * @see llvm::Function::getCallingConv()
        */
        LLVMGetFunctionCallConv(function: Value) -> int native;

        /**
        * Set the calling convention of a function.
        *
        * @see llvm::Function::setCallingConv()
        *
        * @param Fn Function to operate on
        * @param CC LLVMCallConv to set calling convention to
        */
        LLVMSetFunctionCallConv(function: Value, calling_convention: int) native;

        /**
        * Obtain the name of the garbage collector to use during code
        * generation.
        *
        * @see llvm::Function::getGC()
        */
        LLVMGetGC(function: Value) -> char ptr native;

        /**
        * Define the garbage collector to use during code generation.
        *
        * @see llvm::Function::setGC()
        */
        LLVMSetGC(function: Value, name: char ptr) native;

        /**
        * Add an attribute to a function.
        *
        * @see llvm::Function::addAttribute()
        */
        LLVMAddAttributeAtIndex(function: Value, index: AttributeIndex, attribute: Attribute) native;
        LLVMGetAttributeCountAtIndex(function: Value, index: AttributeIndex) -> int native;
        LLVMGetAttributesAtIndex(function: Value, index: AttributeIndex, attributes: Attribute ptr) native;
        LLVMGetEnumAttributeAtIndex(function: Value, index: AttributeIndex, kind_id: int) -> Attribute native;
        LLVMGetStringAttributeAtIndex(function: Value, index: AttributeIndex, key: char ptr, key_len: int) -> Attribute native;
        LLVMRemoveEnumAttributeAtIndex(function: Value, index: AttributeIndex, kind_id: int) native;
        LLVMRemoveStringAttributeAtIndex(function: Value, index: AttributeIndex, key: char ptr, key_len: int) native;

        /**
        * Add a target-dependent attribute to a function
        * @see llvm::AttrBuilder::addAttribute()
        */
        LLVMAddTargetDependentFunctionAttr(function: Value, attribute: char ptr, value: char ptr) native;

        /**
        * @defgroup LLVMCCoreValueFunctionParameters Function Parameters
        *
        * Functions in this group relate to arguments/parameters on functions.
        *
        * Functions in this group expect LLVMValueRef instances that correspond
        * to llvm::Function instances.
        *
        * @{
        */

        /**
        * Obtain the number of parameters in a function.
        *
        * @see llvm::Function::arg_size()
        */
        LLVMCountParams(function: Value) -> int native;

        /**
        * Obtain the parameters in a function.
        *
        * The takes a pointer to a pre-allocated array of LLVMValueRef that is
        * at least LLVMCountParams() long. This array will be filled with
        * LLVMValueRef instances which correspond to the parameters the
        * function receives. Each LLVMValueRef corresponds to a llvm::Argument
        * instance.
        *
        * @see llvm::Function::arg_begin()
        */
        LLVMGetParams(function: Value, params: Value ptr) native;

        /**
        * Obtain the parameter at the specified index.
        *
        * Parameters are indexed from 0.
        *
        * @see llvm::Function::arg_begin()
        */
        LLVMGetParam(function: Value, index: int) -> Value native;

        /**
        * Obtain the function to which this argument belongs.
        *
        * Unlike other functions in this group, this one takes an LLVMValueRef
        * that corresponds to a llvm::Attribute.
        *
        * The returned LLVMValueRef is the llvm::Function to which this
        * argument belongs.
        */
        LLVMGetParamParent(inst: Value) -> Value native;

        /**
        * Obtain the first parameter to a function.
        *
        * @see llvm::Function::arg_begin()
        */
        LLVMGetFirstParam(function: Value) -> Value native;

        /**
        * Obtain the last parameter to a function.
        *
        * @see llvm::Function::arg_end()
        */
        LLVMGetLastParam(function: Value) -> Value native;

        /**
        * Obtain the next parameter to a function.
        *
        * This takes an LLVMValueRef obtained from LLVMGetFirstParam() (which is
        * actually a wrapped iterator) and obtains the next parameter from the
        * underlying iterator.
        */
        LLVMGetNextParam(arg: Value) -> Value native;

        /**
        * Obtain the previous parameter to a function.
        *
        * This is the opposite of LLVMGetNextParam().
        */
        LLVMGetPreviousParam(arg: Value) -> Value native;

        /**
        * Set the alignment for a function parameter.
        *
        * @see llvm::Argument::addAttr()
        * @see llvm::AttrBuilder::addAlignmentAttr()
        */
        LLVMSetParamAlignment(arg: Value, align: int) native;

        /**
        * @}
        */

        /**
        * @}
        */

        /**
        * @}
        */

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueMetadata Metadata
        *
        * @{
        */

        /**
        * Obtain a MDString value from a context.
        *
        * The returned instance corresponds to the llvm::MDString class.
        *
        * The instance is specified by string data of a specified length. The
        * string content is copied, so the backing memory can be freed after
        * this function returns.
        */
        LLVMMDStringInContext(context: Context, str: char ptr, length: int) -> Value native;

        /**
        * Obtain a MDString value from the global context.
        */
        LLVMMDString(str: char ptr, length: int) -> Value native;

        /**
        * Obtain a MDNode value from a context.
        *
        * The returned value corresponds to the llvm::MDNode class.
        */
        LLVMMDNodeInContext(context: Context, values: Value ptr, count: int) -> Value native;

        /**
        * Obtain a MDNode value from the global context.
        */
        LLVMMDNode(values: Value ptr, count: int) -> Value native;

        /**
        * Obtain a Metadata as a Value.
        */
        LLVMMetadataAsValue(context: Context, metadata: Metadata) -> Value native;

        /**
        * Obtain a Value as a Metadata.
        */
        LLVMValueAsMetadata(value: Value) -> Metadata native;

        /**
        * Obtain the underlying string from a MDString value.
        *
        * @param V Instance to obtain string from.
        * @param Length Memory address which will hold length of returned string.
        * @return String data in MDString.
        */
        LLVMGetMDString(value: Value, length: int ptr) -> char ptr native;

        /**
        * Obtain the number of operands from an MDNode value.
        *
        * @param V MDNode to get number of operands from.
        * @return Number of operands of the MDNode.
        */
        LLVMGetMDNodeNumOperands(value: Value) -> int native;

        /**
        * Obtain the given MDNode's operands.
        *
        * The passed LLVMValueRef pointer should point to enough memory to hold all of
        * the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as
        * LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the
        * MDNode's operands.
        *
        * @param V MDNode to get the operands from.
        * @param Dest Destination array for operands.
        */
        LLVMGetMDNodeOperands(value: Value, destination: Value ptr) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueBasicBlock Basic Block
        *
        * A basic block represents a single entry single exit section of code.
        * Basic blocks contain a list of instructions which form the body of
        * the block.
        *
        * Basic blocks belong to functions. They have the type of label.
        *
        * Basic blocks are themselves values. However, the C API models them as
        * LLVMBasicBlockRef.
        *
        * @see llvm::BasicBlock
        *
        * @{
        */

        /**
        * Convert a basic block instance to a value type.
        */
        LLVMBasicBlockAsValue(basic_block: BasicBlock) -> Value native;

        /**
        * Determine whether an LLVMValueRef is itself a basic block.
        */
        LLVMValueIsBasicBlock(value: Value) -> Bool native;

        /**
        * Convert an LLVMValueRef to an LLVMBasicBlockRef instance.
        */
        LLVMValueAsBasicBlock(value: Value) -> BasicBlock native;

        /**
        * Obtain the string name of a basic block.
        */
        LLVMGetBasicBlockName(basic_block: BasicBlock) -> char ptr native;

        /**
        * Obtain the function to which a basic block belongs.
        *
        * @see llvm::BasicBlock::getParent()
        */
        LLVMGetBasicBlockParent(basic_block: BasicBlock) -> Value native;

        /**
        * Obtain the terminator instruction for a basic block.
        *
        * If the basic block does not have a terminator (it is not well-formed
        * if it doesn't), then NULL is returned.
        *
        * The returned LLVMValueRef corresponds to a llvm::TerminatorInst.
        *
        * @see llvm::BasicBlock::getTerminator()
        */
        LLVMGetBasicBlockTerminator(basic_block: BasicBlock) -> Value native;

        /**
        * Obtain the number of basic blocks in a function.
        *
        * @param Fn Function value to operate on.
        */
        LLVMCountBasicBlocks(function: Value) -> int native;

        /**
        * Obtain all of the basic blocks in a function.
        *
        * This operates on a function value. The BasicBlocks parameter is a
        * pointer to a pre-allocated array of LLVMBasicBlockRef of at least
        * LLVMCountBasicBlocks() in length. This array is populated with
        * LLVMBasicBlockRef instances.
        */
        LLVMGetBasicBlocks(function: Value, basic_blocks: BasicBlock ptr) native;

        /**
        * Obtain the first basic block in a function.
        *
        * The returned basic block can be used as an iterator. You will likely
        * eventually call into LLVMGetNextBasicBlock() with it.
        *
        * @see llvm::Function::begin()
        */
        LLVMGetFirstBasicBlock(function: Value) -> BasicBlock native;

        /**
        * Obtain the last basic block in a function.
        *
        * @see llvm::Function::end()
        */
        LLVMGetLastBasicBlock(function: Value) -> BasicBlock native;

        /**
        * Advance a basic block iterator.
        */
        LLVMGetNextBasicBlock(basic_block: BasicBlock) -> BasicBlock native;

        /**
        * Go backwards in a basic block iterator.
        */
        LLVMGetPreviousBasicBlock(basic_block: BasicBlock) -> BasicBlock native;

        /**
        * Obtain the basic block that corresponds to the entry point of a
        * function.
        *
        * @see llvm::Function::getEntryBlock()
        */
        LLVMGetEntryBasicBlock(function: Value) -> BasicBlock native;

        /**
        * Append a basic block to the end of a function.
        *
        * @see llvm::BasicBlock::Create()
        */
        LLVMAppendBasicBlockInContext(context: Context, function: Value, name: char ptr) -> BasicBlock native;

        /**
        * Append a basic block to the end of a function using the global
        * context.
        *
        * @see llvm::BasicBlock::Create()
        */
        LLVMAppendBasicBlock(function: Value, name: char ptr) -> BasicBlock;

        /**
        * Insert a basic block in a function before another basic block.
        *
        * The function to add to is determined by the function of the
        * passed basic block.
        *
        * @see llvm::BasicBlock::Create()
        */
        LLVMInsertBasicBlockInContext(context: Context, basic_block: BasicBlock, name: char ptr) -> BasicBlock;

        /**
        * Insert a basic block in a function using the global context.
        *
        * @see llvm::BasicBlock::Create()
        */
        LLVMInsertBasicBlock(insert_before: BasicBlock, name: char ptr) -> BasicBlock;

        /**
        * Remove a basic block from a function and delete it.
        *
        * This deletes the basic block from its containing function and deletes
        * the basic block itself.
        *
        * @see llvm::BasicBlock::eraseFromParent()
        */
        LLVMDeleteBasicBlock(basic_block: BasicBlock) native;

        /**
        * Remove a basic block from a function.
        *
        * This deletes the basic block from its containing function but keep
        * the basic block alive.
        *
        * @see llvm::BasicBlock::removeFromParent()
        */
        LLVMRemoveBasicBlockFromParent(basic_block: BasicBlock) native;

        /**
        * Move a basic block to before another one.
        *
        * @see llvm::BasicBlock::moveBefore()
        */
        LLVMMoveBasicBlockBefore(basic_block: BasicBlock, move_position: BasicBlock) native;

        /**
        * Move a basic block to after another one.
        *
        * @see llvm::BasicBlock::moveAfter()
        */
        LLVMMoveBasicBlockAfter(basic_block: BasicBlock, move_position: BasicBlock) native;

        /**
        * Obtain the first instruction in a basic block.
        *
        * The returned LLVMValueRef corresponds to a llvm::Instruction
        * instance.
        */
        LLVMGetFirstInstruction(basic_block: BasicBlock) -> Value native;

        /**
        * Obtain the last instruction in a basic block.
        *
        * The returned LLVMValueRef corresponds to an LLVM:Instruction.
        */
        LLVMGetLastInstruction(basic_block: BasicBlock) -> Value native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueInstruction Instructions
        *
        * Functions in this group relate to the inspection and manipulation of
        * individual instructions.
        *
        * In the C++ API, an instruction is modeled by llvm::Instruction. This
        * class has a large number of descendents. llvm::Instruction is a
        * llvm::Value and in the C API, instructions are modeled by
        * LLVMValueRef.
        *
        * This group also contains sub-groups which operate on specific
        * llvm::Instruction types, e.g. llvm::CallInst.
        *
        * @{
        */

        /**
        * Determine whether an instruction has any metadata attached.
        */
        LLVMHasMetadata(value: Value) -> int native;

        /**
        * Return metadata associated with an instruction value.
        */
        LLVMGetMetadata(value: Value, kind_id: int) -> Value native;

        /**
        * Set metadata associated with an instruction value.
        */
        LLVMSetMetadata(value: Value, kind_id: int, node: Value) native;

        /**
        * Obtain the basic block to which an instruction belongs.
        *
        * @see llvm::Instruction::getParent()
        */
        LLVMGetInstructionParent(instruction: Value) -> BasicBlock native;

        /**
        * Obtain the instruction that occurs after the one specified.
        *
        * The next instruction will be from the same basic block.
        *
        * If this is the last instruction in a basic block, NULL will be
        * returned.
        */
        LLVMGetNextInstruction(instruction: Value) -> Value native;

        /**
        * Obtain the instruction that occurred before this one.
        *
        * If the instruction is the first instruction in a basic block, NULL
        * will be returned.
        */
        LLVMGetPreviousInstruction(instruction: Value) -> Value native;

        /**
        * Remove and delete an instruction.
        *
        * The instruction specified is removed from its containing building
        * block but is kept alive.
        *
        * @see llvm::Instruction::removeFromParent()
        */
        LLVMInstructionRemoveFromParent(instruction: Value) native;

        /**
        * Remove and delete an instruction.
        *
        * The instruction specified is removed from its containing building
        * block and then deleted.
        *
        * @see llvm::Instruction::eraseFromParent()
        */
        LLVMInstructionEraseFromParent(instruction: Value) native;

        /**
        * Obtain the code opcode for an individual instruction.
        *
        * @see llvm::Instruction::getOpCode()
        */
        LLVMGetInstructionOpcode(instruction: Value) -> OpCode native;

        /**
        * Obtain the predicate of an instruction.
        *
        * This is only valid for instructions that correspond to llvm::ICmpInst
        * or llvm::ConstantExpr whose opcode is llvm::Instruction::ICmp.
        *
        * @see llvm::ICmpInst::getPredicate()
        */
        LLVMGetICmpPredicate(instruction: Value) -> IntPredicate native;

        /**
        * Obtain the float predicate of an instruction.
        *
        * This is only valid for instructions that correspond to llvm::FCmpInst
        * or llvm::ConstantExpr whose opcode is llvm::Instruction::FCmp.
        *
        * @see llvm::FCmpInst::getPredicate()
        */
        LLVMGetFCmpPredicate(instruction: Value) -> RealPredicate native;

        /**
        * Create a copy of 'this' instruction that is identical in all ways
        * except the following:
        *   * The instruction has no parent
        *   * The instruction has no name
        *
        * @see llvm::Instruction::clone()
        */
        LLVMInstructionClone(instruction: Value) -> Value native;

        /**
        * @defgroup LLVMCCoreValueInstructionCall Call Sites and Invocations
        *
        * Functions in this group apply to instructions that refer to call
        * sites and invocations. These correspond to C++ types in the
        * llvm::CallInst class tree.
        *
        * @{
        */

        /**
        * Obtain the argument count for a call instruction.
        *
        * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
        * llvm::InvokeInst.
        *
        * @see llvm::CallInst::getNumArgOperands()
        * @see llvm::InvokeInst::getNumArgOperands()
        */
        LLVMGetNumArgOperands(instruction: Value) -> int native;

        /**
        * Set the calling convention for a call instruction.
        *
        * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
        * llvm::InvokeInst.
        *
        * @see llvm::CallInst::setCallingConv()
        * @see llvm::InvokeInst::setCallingConv()
        */
        LLVMSetInstructionCallConv(instruction: Value, calling_convention: int) native;

        /**
        * Obtain the calling convention for a call instruction.
        *
        * This is the opposite of LLVMSetInstructionCallConv(). Reads its
        * usage.
        *
        * @see LLVMSetInstructionCallConv()
        */
        LLVMGetInstructionCallConv(instruction: Value) -> int native;

        LLVMSetInstrParamAlignment(instruction: Value, index: int, align: int) native;

        LLVMAddCallSiteAttribute(call_site: Value, index: AttributeIndex, attribute: Attribute) native;
        LLVMGetCallSiteAttributeCount(call_site: Value, index: AttributeIndex) -> int native;
        LLVMGetCallSiteAttributes(call_site: Value, index: AttributeIndex, attributes: Attribute ptr) native;
        LLVMGetCallSiteEnumAttribute(call_site: Value, index: AttributeIndex, kind_id: int) -> Attribute native;
        LLVMGetCallSiteStringAttribute(call_site: Value, index: AttributeIndex, key: char ptr, key_length: int) -> Attribute native;
        LLVMRemoveCallSiteEnumAttribute(call_site: Value, index: AttributeIndex, kind_id: int) native;
        LLVMRemoveCallSiteStringAttribute(call_site: Value, index: AttributeIndex, key: char ptr, key_length: int) native;

        /**
        * Obtain the pointer to the function invoked by this instruction.
        *
        * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
        * llvm::InvokeInst.
        *
        * @see llvm::CallInst::getCalledValue()
        * @see llvm::InvokeInst::getCalledValue()
        */
        LLVMGetCalledValue(instruction: Value) -> Value native;

        /**
        * Obtain whether a call instruction is a tail call.
        *
        * This only works on llvm::CallInst instructions.
        *
        * @see llvm::CallInst::isTailCall()
        */
        LLVMIsTailCall(call_instruction: Value) -> Bool native;

        /**
        * Set whether a call instruction is a tail call.
        *
        * This only works on llvm::CallInst instructions.
        *
        * @see llvm::CallInst::setTailCall()
        */
        LLVMSetTailCall(call_instruction: Value, is_tail_call: Bool) native;

        /**
        * Return the normal destination basic block.
        *
        * This only works on llvm::InvokeInst instructions.
        *
        * @see llvm::InvokeInst::getNormalDest()
        */
        LLVMGetNormalDest(invoke_instruction: Value) -> BasicBlock native;

        /**
        * Return the unwind destination basic block.
        *
        * This only works on llvm::InvokeInst instructions.
        *
        * @see llvm::InvokeInst::getUnwindDest()
        */
        LLVMGetUnwindDest(invoke_instruction: Value) -> BasicBlock native;

        /**
        * Set the normal destination basic block.
        *
        * This only works on llvm::InvokeInst instructions.
        *
        * @see llvm::InvokeInst::setNormalDest()
        */
        LLVMSetNormalDest(invoke_instruction: Value, basic_block: BasicBlock) native;

        /**
        * Set the unwind destination basic block.
        *
        * This only works on llvm::InvokeInst instructions.
        *
        * @see llvm::InvokeInst::setUnwindDest()
        */
        LLVMSetUnwindDest(invoke_instruction: Value, basic_block: BasicBlock) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueInstructionTerminator Terminators
        *
        * Functions in this group only apply to instructions that map to
        * llvm::TerminatorInst instances.
        *
        * @{
        */

        /**
        * Return the number of successors that this terminator has.
        *
        * @see llvm::TerminatorInst::getNumSuccessors
        */
        LLVMGetNumSuccessors(terminator: Value) -> int native;

        /**
        * Return the specified successor.
        *
        * @see llvm::TerminatorInst::getSuccessor
        */
        LLVMGetSuccessor(terminator: Value, i: int) -> BasicBlock native;

        /**
        * Update the specified successor to point at the provided block.
        *
        * @see llvm::TerminatorInst::setSuccessor
        */
        LLVMSetSuccessor(terminator: Value, i: int, basic_block: BasicBlock) native;

        /**
        * Return if a branch is conditional.
        *
        * This only works on llvm::BranchInst instructions.
        *
        * @see llvm::BranchInst::isConditional
        */
        LLVMIsConditional(branch: Value) -> Bool native;

        /**
        * Return the condition of a branch instruction.
        *
        * This only works on llvm::BranchInst instructions.
        *
        * @see llvm::BranchInst::getCondition
        */
        LLVMGetCondition(branch: Value) -> Value native;

        /**
        * Set the condition of a branch instruction.
        *
        * This only works on llvm::BranchInst instructions.
        *
        * @see llvm::BranchInst::setCondition
        */
        LLVMSetCondition(branch: Value, condition: Value) native;

        /**
        * Obtain the default destination basic block of a switch instruction.
        *
        * This only works on llvm::SwitchInst instructions.
        *
        * @see llvm::SwitchInst::getDefaultDest()
        */
        LLVMGetSwitchDefaultDest(switch_instruction: Value) -> BasicBlock native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueInstructionAlloca Allocas
        *
        * Functions in this group only apply to instructions that map to
        * llvm::AllocaInst instances.
        *
        * @{
        */

        /**
        * Obtain the type that is being allocated by the alloca instruction.
        */
        LLVMGetAllocatedType(alloca: Value) -> Type native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueInstructionGetElementPointer GEPs
        *
        * Functions in this group only apply to instructions that map to
        * llvm::GetElementPtrInst instances.
        *
        * @{
        */

        /**
        * Check whether the given GEP instruction is inbounds.
        */
        LLVMIsInBounds(gep: Value) -> Bool native;

        /**
        * Set the given GEP instruction to be inbounds or not.
        */
        LLVMSetIsInBounds(gep: Value, in_bounds: Bool) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueInstructionPHINode PHI Nodes
        *
        * Functions in this group only apply to instructions that map to
        * llvm::PHINode instances.
        *
        * @{
        */

        /**
        * Add an incoming value to the end of a PHI list.
        */
        LLVMAddIncoming(phi_node: Value, incoming_values: Value ptr,
                            incoming_blocks: BasicBlock ptr, count: int) native;

        /**
        * Obtain the number of incoming basic blocks to a PHI node.
        */
        LLVMCountIncoming(phi_node: Value) -> int;

        /**
        * Obtain an incoming value to a PHI node as an LLVMValueRef.
        */
        LLVMGetIncomingValue(phi_node: Value, index: int) -> Value native;

        /**
        * Obtain an incoming value to a PHI node as an LLVMBasicBlockRef.
        */
        LLVMGetIncomingBlock(phi_node: Value, index: int) -> BasicBlock native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreValueInstructionExtractValue ExtractValue
        * @defgroup LLVMCCoreValueInstructionInsertValue InsertValue
        *
        * Functions in this group only apply to instructions that map to
        * llvm::ExtractValue and llvm::InsertValue instances.
        *
        * @{
        */

        /**
        * Obtain the number of indices.
        * NB: This also works on GEP.
        */
        LLVMGetNumIndices(instruction: Value) -> int native;

        /**
        * Obtain the indices as an array.
        */
        LLVMGetIndices(instruction: Value) -> int ptr;

        /**
        * @}
        */

        /**
        * @}
        */

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreInstructionBuilder Instruction Builders
        *
        * An instruction builder represents a point within a basic block and is
        * the exclusive means of building instructions using the C interface.
        *
        * @{
        */

        LLVMCreateBuilderInContext(context: Context) -> Builder native;
        LLVMCreateBuilder() -> Builder native;
        LLVMPositionBuilder(builder: Builder, block: BasicBlock, instruction: Value) native;
        LLVMPositionBuilderBefore(builder: Builder, instruction: Value) native;
        LLVMPositionBuilderAtEnd(builder: Builder, block: BasicBlock) native;
        LLVMGetInsertBlock(builder: Builder) -> BasicBlock native;
        LLVMClearInsertionPosition(builder: Builder) native;
        LLVMInsertIntoBuilder(builder: Builder, instruction: Value) native;
        LLVMInsertIntoBuilderWithName(builder: Builder, instruction: Value, name: char ptr) native;
        LLVMDisposeBuilder(builder: Builder) native;

        /* Metadata */
        LLVMSetCurrentDebugLocation(builder: Builder, location: Value) native;
        LLVMGetCurrentDebugLocation(builder: Builder) -> Value native;
        LLVMSetInstDebugLocation(builder: Builder, instruction: Value) native;

        /* Terminators */
        LLVMBuildRetVoid(builder: Builder) -> Value native;
        LLVMBuildRet(builder: Builder, value: Value) -> Value native;
        LLVMBuildAggregateRet(builder: Builder, values: Value ptr, number: int) -> Value native;
        LLVMBuildBr(builder: Builder, dest: BasicBlock) -> Value native;
        LLVMBuildCondBr(builder: Builder, if_: Value, then_: BasicBlock, else_: BasicBlock) -> Value native;
        LLVMBuildSwitch(builder: Builder, value: Value, else_: BasicBlock, number_cases: int) -> Value native;
        LLVMBuildIndirectBr(builder: Builder, address: Value, num_destinations: int) -> Value native;
        LLVMBuildInvoke(builder: Builder, function: Value, arguments: Value ptr, number_args: int, then_: BasicBlock, catch_: BasicBlock, name: char ptr) -> Value native;
        LLVMBuildLandingPad(builder: Builder, type: Type, personality_function: Value, number_clauses: int, name: char ptr) -> Value native;
        LLVMBuildResume(builder: Builder, exn: Value) -> Value native;
        LLVMBuildUnreachable(builder: Builder) -> Value native;

        /* Add a case to the switch instruction */
        LLVMAddCase(switch: Value, on_value: Value, dest: BasicBlock) native;

        /* Add a destination to the indirectbr instruction */
        LLVMAddDestination(indirect_branch: Value, dest: BasicBlock) native;

        /* Get the number of clauses on the landingpad instruction */
        LLVMGetNumClauses(landing_pad: Value) -> int native;

        /* Get the value of the clause at idnex Idx on the landingpad instruction */
        LLVMGetClause(landing_pad: Value, index: int) -> Value native;

        /* Add a catch or filter clause to the landingpad instruction */
        LLVMAddClause(landing_pad: Value, clause: Value) native;

        /* Get the 'cleanup' flag in the landingpad instruction */
        LLVMIsCleanup(landing_pad: Value) -> Bool native;

        /* Set the 'cleanup' flag in the landingpad instruction */
        LLVMSetCleanup(landing_pad: Value, is_cleanup: Bool) native;

        /* Arithmetic */
        LLVMBuildAdd(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildNSWAdd(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildNUWAdd(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildFAdd(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildSub(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildNSWSub(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildNUWSub(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildFSub(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildMul(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildNSWMul(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildNUWMul(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildFMul(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildUDiv(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildExactUDiv(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildSDiv(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildExactSDiv(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildFDiv(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildURem(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildSRem(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildFRem(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildShl(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildLShr(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildAShr(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildAnd(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildOr(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildXor(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildBinOp(builder: Builder, op: OpCode, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildNeg(builder: Builder, value: Value, name: char ptr) -> Value native;
        LLVMBuildNSWNeg(builder: Builder, value: Value, name: char ptr) -> Value native;
        LLVMBuildNUWNeg(builder: Builder, value: Value, name: char ptr) -> Value native;
        LLVMBuildFNeg(builder: Builder, value: Value, name: char ptr) -> Value native;
        LLVMBuildNot(builder: Builder, value: Value, name: char ptr) -> Value native;

        /* Memory */
        LLVMBuildMalloc(builder: Builder, type: Type, name: char ptr) -> Value native;
        LLVMBuildArrayMalloc(builder: Builder, type: Type, value: Value, name: char ptr) -> Value native;
        LLVMBuildAlloca(builder: Builder, type: Type, name: char ptr) -> Value native;
        LLVMBuildArrayAlloca(builder: Builder, type: Type, value: Value, name: char ptr) -> Value native;
        LLVMBuildFree(builder: Builder, pointer: Value) -> Value native;
        LLVMBuildLoad(builder: Builder, pointer: Value, name: char ptr) -> Value native;
        LLVMBuildStore(builder: Builder, value: Value, pointer: Value) -> Value native;
        LLVMBuildGEP(builder: Builder, pointer: Value, indexes: Value ptr, number_indexes: int, name: char ptr) -> Value native;
        LLVMBuildInBoundsGEP(builder: Builder, pointer: Value, indexes: Value ptr, number_indexes: int, name: char ptr) -> Value native;
        LLVMBuildStructGEP(builder: Builder, pointer: Value, index: int, name: char ptr) -> Value native;
        LLVMBuildGlobalString(builder: Builder, str: char ptr, name: char ptr) -> Value native;
        LLVMBuildGlobalStringPtr(builder: Builder, str: char ptr, name: char ptr);
        LLVMGetVolatile(memory_access_instruction: Value) -> Bool native;
        LLVMSetVolatile(memory_access_instruction: Value, is_volatile: Bool) native;
        LLVMGetOrdering(memory_access_instruction: Value) -> AtomicOrdering native;
        LLVMSetOrdering(memory_access_instruction: Value, ordering: AtomicOrdering) native;

        /* Casts */
        LLVMBuildTrunc(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildZExt(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildSExt(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildFPToUI(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildFPToSI(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildUIToFP(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildSIToFP(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildFPTrunc(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildFPExt(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildPtrToInt(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildIntToPtr(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildBitCast(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildAddrSpaceCast(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildZExtOrBitCast(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildSExtOrBitCast(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildTruncOrBitCast(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildCast(builder: Builder, op: OpCode, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildPointerCast(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildIntCast(builder: Builder, value: Value, /*Signed cast!*/ desination_type: Type, name: char ptr) -> Value native;
        LLVMBuildFPCast(builder: Builder, value: Value, desination_type: Type, name: char ptr) -> Value native;

        /* Comparisons */
        LLVMBuildICmp(builder: Builder, op: IntPredicate, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildFCmp(builder: Builder, op: RealPredicate, left: Value, right: Value, name: char ptr) -> Value native;

        /* Miscellaneous instructions */
        LLVMBuildPhi(builder: Builder, type: Type, name: char ptr) -> Value native;
        LLVMBuildCall(builder: Builder, function: Value, arguments: Value ptr, number_args: int, name: char ptr) -> Value native;

        LLVMBuildSelect(builder: Builder, if_: Value, then_: Value, else_: Value, name: char ptr) -> Value native;
        LLVMBuildVAArg(builder: Builder, list: Value, type: Type, name: char ptr) -> Value native;

        LLVMBuildShuffleVector(builder: Builder, vector_1: Value, vector_2: Value, mask: Value, name: char ptr) -> Value native;
        
        LLVMBuildExtractValue(builder: Builder, agg_value: Value, index: int, name: char ptr) -> Value native;
        LLVMBuildInsertValue(builder: Builder, agg_value: Value, element_value: Value, index: int, name: char ptr) -> Value native;

        LLVMBuildIsNull(builder: Builder, value: Value, name: char ptr) -> Value native;
        LLVMBuildIsNotNull(builder: Builder, value: Value, name: char ptr) -> Value native;
        LLVMBuildPtrDiff(builder: Builder, left: Value, right: Value, name: char ptr) -> Value native;
        LLVMBuildFence(builder: Builder, ordering: AtomicOrdering, single_thread: Bool, name: char ptr) -> Value native;
        LLVMBuildAtomicRMW(builder: Builder, op: AtomicRMWBinOp, pointer: Value, value: Value, ordering: AtomicOrdering, single_thread: Bool) -> Value native;
        LLVMBuildAtomicCmpXchg(
            builder: Builder, pointer: Value, compare: Value, new_: Value, success_ordering: AtomicOrdering, failure_ordering: AtomicOrdering, single_thread: Bool) -> Value native;

        LLVMIsAtomicSingleThread(atomic_instruction: Value) -> Bool native;
        LLVMSetAtomicSingleThread(atomic_instruction: Value, single_thread: Bool) native;

        LLVMGetCmpXchgSuccessOrdering(compare_exchange_instruction: Value) -> AtomicOrdering native;
        LLVMSetCmpXchgSuccessOrdering(compare_exchange_instruction: Value, ordering: AtomicOrdering) native;
        LLVMGetCmpXchgFailureOrdering(compare_exchange_instruction: Value) -> AtomicOrdering native;
        LLVMSetCmpXchgFailureOrdering(compare_exchange_instruction: Value, ordering: AtomicOrdering) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreModuleProvider Module Providers
        *
        * @{
        */

        /**
        * Changes the type of M so it can be passed to FunctionPassManagers and the
        * JIT.  They take ModuleProviders for historical reasons.
        */
        LLVMCreateModuleProviderForExistingModule(module: Module) -> ModuleProvider native;

        /**
        * Destroys the module M.
        */
        LLVMDisposeModuleProvider(module_provider: ModuleProvider) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreMemoryBuffers Memory Buffers
        *
        * @{
        */

        LLVMCreateMemoryBufferWithContentsOfFile(path: char ptr,
                                                        out_mem_buf: MemoryBuffer ptr,
                                                        out_message: char ptr ptr) -> Bool native;

        LLVMCreateMemoryBufferWithSTDIN(out_mem_buf: MemoryBuffer ptr, out_message: char ptr ptr) -> Bool native;

        LLVMCreateMemoryBufferWithMemoryRange(input_data: char ptr,
                                                                input_data_length: long,
                                                                buffer_name: char ptr,
                                                                requires_null_terminator: Bool) -> MemoryBuffer native;

        LLVMCreateMemoryBufferWithMemoryRangeCopy(input_data: char ptr,
                                                                    input_data_length: long,
                                                                    buffer_name: char ptr) -> MemoryBuffer native;

        LLVMGetBufferStart(memory_buffer: MemoryBuffer) -> char ptr native;
        LLVMGetBufferSize(memory_buffer: MemoryBuffer) -> long native;
        LLVMDisposeMemoryBuffer(memory_buffer: MemoryBuffer) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCorePassRegistry Pass Registry
        *
        * @{
        */

        /** Return the global pass registry, for use with initialization functions.
            @see llvm::PassRegistry::getPassRegistry */
        LLVMGetGlobalPassRegistry() -> PassRegistry native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCorePassManagers Pass Managers
        *
        * @{
        */

        /** Constructs a new whole-module pass pipeline. This type of pipeline is
            suitable for link-time optimization and whole-module transformations.
            @see llvm::PassManager::PassManager */
        LLVMCreatePassManager() -> PassManager native;

        /** Constructs a new function-by-function pass pipeline over the module
            provider. It does not take ownership of the module provider. This type of
            pipeline is suitable for code generation and JIT compilation tasks.
            @see llvm::FunctionPassManager::FunctionPassManager */
        LLVMCreateFunctionPassManagerForModule(module: Module) -> PassManager native;

        /** Deprecated: Use LLVMCreateFunctionPassManagerForModule instead. */
        LLVMCreateFunctionPassManager(module_provider: ModuleProvider) -> PassManager native;

        /** Initializes, executes on the provided module, and finalizes all of the
            passes scheduled in the pass manager. Returns 1 if any of the passes
            modified the module, 0 otherwise.
            @see llvm::PassManager::run(Module&) */
        LLVMRunPassManager(pass_manager: PassManager, module: Module) -> Bool native;

        /** Initializes all of the function passes scheduled in the function pass
            manager. Returns 1 if any of the passes modified the module, 0 otherwise.
            @see llvm::FunctionPassManager::doInitialization */
        LLVMInitializeFunctionPassManager(function_pass_manager: PassManager) -> Bool native;

        /** Executes all of the function passes scheduled in the function pass manager
            on the provided function. Returns 1 if any of the passes modified the
            function, false otherwise.
            @see llvm::FunctionPassManager::run(Function&) */
        LLVMRunFunctionPassManager(function_pass_manager: PassManager, function: Value) -> Bool native;

        /** Finalizes all of the function passes scheduled in in the function pass
            manager. Returns 1 if any of the passes modified the module, 0 otherwise.
            @see llvm::FunctionPassManager::doFinalization */
        LLVMFinalizeFunctionPassManager(function_pass_manager: PassManager) -> Bool native;

        /** Frees the memory of a pass pipeline. For function pipelines, does not free
            the module provider.
            @see llvm::PassManagerBase::~PassManagerBase. */
        LLVMDisposePassManager(pass_manager: PassManager) native;

        /**
        * @}
        */

        /**
        * @defgroup LLVMCCoreThreading Threading
        *
        * Handle the structures needed to make LLVM safe for multithreading.
        *
        * @{
        */

        /** Deprecated: Multi-threading can only be enabled/disabled with the compile
            time define LLVM_ENABLE_THREADS.  This function always returns
            LLVMIsMultithreaded(). */
        LLVMStartMultithreaded() -> Bool native;

        /** Deprecated: Multi-threading can only be enabled/disabled with the compile
            time define LLVM_ENABLE_THREADS. */
        LLVMStopMultithreaded() native;

        /** Check whether LLVM is executing in thread-safe mode or not.
            @see llvm::llvm_is_multithreaded */
        LLVMIsMultithreaded() -> Bool native;
    si
si
