namespace LLVM is

enum OpCode is
    /* Terminator Instructions */
    Ret            = 1,
    Br             = 2,
    Switch         = 3,
    IndirectBr     = 4,
    Invoke         = 5,
    /* removed 6 due to API changes */
    Unreachable    = 7,

    /* Standard Binary Operators */
    Add            = 8,
    FAdd           = 9,
    Sub            = 10,
    FSub           = 11,
    Mul            = 12,
    FMul           = 13,
    UDiv           = 14,
    SDiv           = 15,
    FDiv           = 16,
    URem           = 17,
    SRem           = 18,
    FRem           = 19,

    /* Logical Operators */
    Shl            = 20,
    LShr           = 21,
    AShr           = 22,
    And            = 23,
    Or             = 24,
    Xor            = 25,

    /* Memory Operators */
    Alloca         = 26,
    Load           = 27,
    Store          = 28,
    GetElementPtr  = 29,

    /* Cast Operators */
    Trunc          = 30,
    ZExt           = 31,
    SExt           = 32,
    FPToUI         = 33,
    FPToSI         = 34,
    UIToFP         = 35,
    SIToFP         = 36,
    FPTrunc        = 37,
    FPExt          = 38,
    PtrToInt       = 39,
    IntToPtr       = 40,
    BitCast        = 41,
    AddrSpaceCast  = 60,

    /* Other Operators */
    ICmp           = 42,
    FCmp           = 43,
    PHI            = 44,
    Call           = 45,
    Select         = 46,
    UserOp1        = 47,
    UserOp2        = 48,
    VAArg          = 49,
    ExtractElement = 50,
    InsertElement  = 51,
    ShuffleVector  = 52,
    ExtractValue   = 53,
    InsertValue    = 54,

    /* Atomic operators */
    Fence          = 55,
    AtomicCmpXchg  = 56,
    AtomicRMW      = 57,

    /* Exception Handling Operators */
    Resume         = 58,
    LandingPad     = 59,
    CleanupRet     = 61,
    CatchRet       = 62,
    CatchPad       = 63,
    CleanupPad     = 64,
    CatchSwitch    = 65
si

enum TypeKind is
    Void,        /**< type with no size */
    Half,        /**< 16 bit floating point type */
    Float,       /**< 32 bit floating point type */
    Double,      /**< 64 bit floating point type */
    X86_FP80,    /**< 80 bit floating point type (X87) */
    FP128,       /**< 128 bit floating point type (112-bit mantissa)*/
    PPC_FP128,   /**< 128 bit floating point type (two 64-bits) */
    Label,       /**< Labels */
    Integer,     /**< Arbitrary bit width integers */
    Function,    /**< Functions */
    Struct,      /**< Structures */
    Array,       /**< Arrays */
    Pointer,     /**< Pointers */
    Vector,      /**< SIMD 'packed' format, or other vector type */
    Metadata,    /**< Metadata */
    X86_MMX,     /**< X86 MMX */
    Token        /**< Tokens */
si

enum Linkage is
    External,    /**< Externally visible function */
    AvailableExternally,
    LinkOnceAny, /**< Keep one copy of function when linking (inline)*/
    LinkOnceODR, /**< Same, but only replaced by something
                              equivalent. */
    LinkOnceODRAutoHide, /**< Obsolete */
    WeakAny,     /**< Keep one copy of function when linking (weak) */
    WeakODR,     /**< Same, but only replaced by something
                              equivalent. */
    Appending,   /**< Special purpose, only applies to global arrays */
    Internal,    /**< Rename collisions when linking (static
                                  functions) */
    Private,     /**< Like Internal, but omit from symbol table */
    DLLImport,   /**< Obsolete */
    DLLExport,   /**< Obsolete */
    ExternalWeak,/**< ExternalWeak linkage description */
    Ghost,       /**< Obsolete */
    Common,      /**< Tentative definitions */
    LinkerPrivate, /**< Like Private, but linker removes. */
    LinkerPrivateWeak /**< Like LinkerPrivate, but is weak. */
si

enum Visibility is
    Default,  /**< The GV is visible */
    Hidden,   /**< The GV is hidden */
    Protected /**< The GV is protected */
si

enum DLLStorageClass is
    Default   = 0,
    DLLImport = 1, /**< Function to be imported from DLL. */
    DLLExport = 2  /**< Function to be accessible from DLL. */
si

enum CallConv is
    C           = 0,
    Fast        = 8,
    Cold        = 9,
    WebKitJS    = 12,
    AnyReg      = 13,
    X86Stdcall  = 64,
    X86Fastcall = 65
si

enum ValueKind is
    Argument,
    BasicBlock,
    MemoryUse,
    MemoryDef,
    MemoryPhi,

    Function,
    GlobalAlias,
    GlobalIFunc,
    GlobalVariable,
    BlockAddress,
    ConstantExpr,
    ConstantArray,
    ConstantStruct,
    ConstantVector,

    UndefValue,
    ConstantAggregateZero,
    ConstantDataArray,
    ConstantDataVector,
    ConstantInt,
    ConstantFP,
    ConstantPointerNull,
    ConstantTokenNone,

    MetadataAsValue,
    InlineAsm,

    Instruction,
si

enum IntPredicate is
    EQ = 32, /**< equal */
    NE,      /**< not equal */
    UGT,     /**< unsigned greater than */
    UGE,     /**< unsigned greater or equal */
    ULT,     /**< unsigned less than */
    ULE,     /**< unsigned less or equal */
    SGT,     /**< signed greater than */
    SGE,     /**< signed greater or equal */
    SLT,     /**< signed less than */
    SLE      /**< signed less or equal */
si

enum RealPredicate is
    False, /**< Always false (always folded) */
    OEQ,            /**< True if ordered and equal */
    OGT,            /**< True if ordered and greater than */
    OGE,            /**< True if ordered and greater than or equal */
    OLT,            /**< True if ordered and less than */
    OLE,            /**< True if ordered and less than or equal */
    ONE,            /**< True if ordered and operands are unequal */
    ORD,            /**< True if ordered (no nans) */
    UNO,            /**< True if unordered: isnan(X) | isnan(Y) */
    UEQ,            /**< True if unordered or equal */
    UGT,            /**< True if unordered or greater than */
    UGE,            /**< True if unordered, greater than, or equal */
    ULT,            /**< True if unordered or less than */
    ULE,            /**< True if unordered, less than, or equal */
    UNE,            /**< True if unordered or not equal */
    True   /**< Always true (always folded) */
si

enum LandingPadClauseTy is
    Catch,    /**< A catch clause   */
    Filter    /**< A filter clause  */
si

enum ThreadLocalMode is
    NotThreadLocal = 0,
    GeneralDynamic,
    LocalDynamic,
    InitialExec,
    LocalExec
si

enum AtomicOrdering is
    NotAtomic = 0, /**< A load or store which is not atomic */
    Unordered = 1, /**< Lowest level of atomicity, guarantees
                                        somewhat sane results, lock free. */
    Monotonic = 2, /**< guarantees that if you take all the
                                        operations affecting a specific address,
                                        a consistent ordering exists */
    Acquire = 4, /**< Acquire provides a barrier of the sort
                                      necessary to acquire a lock to access other
                                      memory with normal loads and stores. */
    Release = 5, /**< Release is similar to Acquire, but with
                                      a barrier of the sort necessary to release
                                      a lock. */
    AcquireRelease = 6, /**< provides both an Acquire and a
                                            Release barrier (for fences and
                                            operations which both read and write
                                              memory). */
    SequentiallyConsistent = 7 /**< provides Acquire semantics
                                                    for loads and Release
                                                    semantics for stores.
                                                    Additionally, it guarantees
                                                    that a total ordering exists
                                                    between all
                                                    SequentiallyConsistent
                                                    operations. */
si

enum AtomicRMWBinOp is
    Xchg, /**< Set the new value and return the one old */
    Add, /**< Add a value and return the old one */
    Sub, /**< Subtract a value and return the old one */
    And, /**< And a value and return the old one */
    Nand, /**< Not-And a value and return the old one */
    Or, /**< OR a value and return the old one */
    Xor, /**< Xor a value and return the old one */
    Max, /**< Sets the value if it's greater than the
                             original using a signed comparison and return
                             the old one */
    Min, /**< Sets the value if it's Smaller than the
                             original using a signed comparison and return
                             the old one */
    UMax, /**< Sets the value if it's greater than the
                             original using an unsigned comparison and return
                             the old one */
    UMin /**< Sets the value if it's greater than the
                             original using an unsigned comparison  and return
                             the old one */
si

enum DiagnosticSeverity is
    Error,
    Warning,
    Remark,
    Note
si

/**
 * Attribute index are either LLVMAttributeReturnIndex,
 * LLVMAttributeFunctionIndex or a parameter number from 1 to N.
 */
enum AttributeIndex is
    Return = 0U,
    // ISO C restricts enumerator values to range of 'int'
    // (4294967295 is too large)
    // Function = ~0U,
    Function = -1,
si

class CORE is

    LLVMInitializeCore(r: PassRegistry) native;

    /** Deallocate and destroy all ManagedStatic variables.
        @see llvm::llvm_shutdown
        @see ManagedStatic */
    LLVMShutdown() native;

    /*===-- Error handling ----------------------------------------------------===*/

    LLVMCreateMessage(message: char ptr) -> char ptr native;
    LLVMDisposeMessage(message: char ptr) native;

    /**
    * @defgroup LLVMCCoreContext Contexts
    *
    * Contexts are execution states for the core LLVM IR system.
    *
    * Most types are tied to a context instance. Multiple contexts can
    * exist simultaneously. A single context is not thread safe. However,
    * different contexts can execute on different threads simultaneously.
    *
    * @{
    */

    // typedef void (*LLVMDiagnosticHandler)(LLVMDiagnosticInfoRef, void *);
    // typedef void (*LLVMYieldCallback)(LLVMContextRef, void *);

    /**
    * Create a new context.
    *
    * Every call to this function should be paired with a call to
    * LLVMContextDispose() or the context will leak memory.
    */
    LLVMContextCreate() -> Context native;

    /**
    * Obtain the global context instance.
    */
    LLVMGetGlobalContext() -> Context native;

    /**
    * Set the diagnostic handler for this context.
    */

    LLVMContextSetDiagnosticHandler(
      c Context,
      handler: (DiagnosticInfo, char ptr) -> void
    ) native;

    /**
    * Get the diagnostic handler of this context.
    */
    LLVMContextGetDiagnosticHandler(c: Context) -> (DiagnosticInfo, char ptr) -> void native;

    /**
    * Get the diagnostic context of this context.
    */
    LLVMContextGetDiagnosticContext(c: Context) -> char ptr native;

    /**
    * Set the yield callback function for this context.
    *
    * @see Context::setYieldCallback()
    */

    /*
    LLVMContextSetYieldCallback(Context C, YieldCallback Callback,
                                    void *OpaqueHandle);
    */
    /**
    * Destroy a context instance.
    *
    * This should be called for every call to LLVMContextCreate() or memory
    * will be leaked.
    */
    LLVMContextDispose(c: Context) native;

    /**
    * Return a string representation of the DiagnosticInfo. Use
    * LLVMDisposeMessage to free the string.
    *
    * @see DiagnosticInfo::print()
    */
    LLVMGetDiagInfoDescription(di: DiagnosticInfo) -> char ptr native;

    /**
    * Return an enum LLVMDiagnosticSeverity.
    *
    * @see DiagnosticInfo::getSeverity()
    */
    LLVMGetDiagInfoSeverity(di: DiagnosticInfo) -> DiagnosticSeverity native;

    LLVMGetMDKindIDInContext(c: Context, name: char ptr,
                                      len: int) -> int native;

    LLVMGetMDKindID(name: char ptr, len: int) -> int native;

    /**
    * Return an unique id given the name of a enum attribute,
    * or 0 if no attribute by that name exists.
    *
    * See http://llvm.org/docs/LangRef.html#parameter-attributes
    * and http://llvm.org/docs/LangRef.html#function-attributes
    * for the list of available attributes.
    *
    * NB: Attribute names and/or id are subject to change without
    * going through the C API deprecation cycle.
    */
    LLVMGetEnumAttributeKindForName(name: char ptr, len: long) -> int native;
    LLVMGetLastEnumAttributeKind() -> int native;

    /**
    * Create an enum attribute.
    */
    LLVMCreateEnumAttribute(c: Context, kind_id: int, val: long) -> Attribute native;

    /**
    * Get the unique id corresponding to the enum attribute
    * passed as argument.
    */
    LLVMGetEnumAttributeKind(a: Attribute) -> int native;

    /**
    * Get the enum attribute's value. 0 is returned if none exists.
    */
    LLVMGetEnumAttributeValue(a: Attribute) -> long native;

    /**
    * Create a string attribute.
    */
    LLVMCreateStringAttribute(c: Context,
                              k: char ptr, k_length: int,
                              v: char ptr, v_length: int) -> Attribute native;

    /**
    * Get the string attribute's kind.
    */
    LLVMGetStringAttributeKind(a: Attribute, length: int ptr) -> char ptr native;

    /**
    * Get the string attribute's value.
    */
    LLVMGetStringAttributeValue(a: Attribute, length: int ptr) -> char ptr native;

    /**
    * Check for the different types of attributes.
    */
    LLVMIsEnumAttribute(a: Attribute) -> Bool native;
    LLVMIsStringAttribute(a: Attribute) -> Bool native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreModule Modules
    *
    * Modules represent the top-level structure in an LLVM program. An LLVM
    * module is effectively a translation unit or a collection of
    * translation units merged together.
    *
    * @{
    */

    /**
    * Create a new, empty module in the global context.
    *
    * This is equivalent to calling LLVMModuleCreateWithNameInContext with
    * LLVMGetGlobalContext() as the context parameter.
    *
    * Every invocation should be paired with LLVMDisposeModule() or memory
    * will be leaked.
    */
    LLVMModuleCreateWithName(module_id: char ptr) -> Module native;

    /**
    * Create a new, empty module in a specific context.
    *
    * Every invocation should be paired with LLVMDisposeModule() or memory
    * will be leaked.
    */
    LLVMModuleCreateWithNameInContext(module_id: char ptr,
                                                    c: Context) -> Module native;
    /**
    * Return an exact copy of the specified module.
    */
    LLVMCloneModule(m: Module) -> Module native;

    /**
    * Destroy a module instance.
    *
    * This must be called for every created module or memory will be
    * leaked.
    */
    LLVMDisposeModule(m: Module) native;

    /**
    * Obtain the identifier of a module.
    *
    * @param M Module to obtain identifier of
    * @param Len Out parameter which holds the length of the returned string.
    * @return The identifier of M.
    * @see Module::getModuleIdentifier()
    */
    LLVMGetModuleIdentifier(m: Module, len: long ptr) -> char ptr native;

    /**
    * Set the identifier of a module to a string Ident with length Len.
    *
    * @param M The module to set identifier
    * @param Ident The string to set M's identifier to
    * @param Len Length of Ident
    * @see Module::setModuleIdentifier()
    */
    LLVMSetModuleIdentifier(m: Module, ident: char ptr, len: long) native;

    /**
    * Obtain the data layout for a module.
    *
    * @see Module::getDataLayoutStr()
    *
    * LLVMGetDataLayout is DEPRECATED, as the name is not only incorrect,
    * but match the name of another method on the module. Prefer the use
    * of LLVMGetDataLayoutStr, which is not ambiguous.
    */
    LLVMGetDataLayoutStr(m: Module) -> char ptr native;
    // const char *LLVMGetDataLayout(LLVMModuleRef M);

    /**
    * Set the data layout for a module.
    *
    * @see Module::setDataLayout()
    */
    LLVMSetDataLayout(m: Module, data_layout_string: char ptr) native;

    /**
    * Obtain the target triple for a module.
    *
    * @see Module::getTargetTriple()
    */
    LLVMGetTarget(module: Module) -> char ptr native;

    /**
    * Set the target triple for a module.
    *
    * @see Module::setTargetTriple()
    */
    LLVMSetTarget(m: Module, triple: char ptr) native;

    /**
    * Dump a representation of a module to stderr.
    *
    * @see Module::dump()
    */
    LLVMDumpModule(module: Module) native;

    /**
    * Print a representation of a module to a file. The ErrorMessage needs to be
    * disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.
    *
    * @see Module::print()
    */
    LLVMPrintModuleToFile(module: Module, file_name: char ptr,
                                  error_message: char ptr ptr) -> Bool native;

    /**
    * Return a string representation of the module. Use
    * LLVMDisposeMessage to free the string.
    *
    * @see Module::print()
    */
    LLVMPrintModuleToString(m: Module) -> char ptr native;

    /**
    * Set inline assembly for a module.
    *
    * @see Module::setModuleInlineAsm()
    */
    LLVMSetModuleInlineAsm(m: Module, asm: char ptr) native;

    /**
    * Obtain the context to which this module is associated.
    *
    * @see Module::getContext()
    */
    LLVMGetModuleContext(m: Module) -> Context native;

    /**
    * Obtain a Type from a module by its registered name.
    */
    LLVMGetTypeByName(m: Module, name: char ptr) -> Type native;

    /**
    * Obtain the number of operands for named metadata in a module.
    *
    * @see llvm::Module::getNamedMetadata()
    */
    LLVMGetNamedMetadataNumOperands(m: Module, name: char ptr) -> int native;

    /**
    * Obtain the named metadata operands for a module.
    *
    * The passed LLVMValueRef pointer should refer to an array of
    * LLVMValueRef at least LLVMGetNamedMetadataNumOperands long. This
    * array will be populated with the LLVMValueRef instances. Each
    * instance corresponds to a llvm::MDNode.
    *
    * @see llvm::Module::getNamedMetadata()
    * @see llvm::MDNode::getOperand()
    */
    LLVMGetNamedMetadataOperands(m: Module, name: char ptr,
                                      dest: Value ptr) native;
    /**
    * Add an operand to named metadata.
    *
    * @see llvm::Module::getNamedMetadata()
    * @see llvm::MDNode::addOperand()
    */
    LLVMAddNamedMetadataOperand(m: Module, name: char ptr,
                                    val: Value) native;

    /**
    * Add a function to a module under a specified name.
    *
    * @see llvm::Function::Create()
    */
    LLVMAddFunction(m: Module, name: char ptr,
                                type: Type) -> Value native;

    /**
    * Obtain a Function value from a Module by its name.
    *
    * The returned value corresponds to a llvm::Function value.
    *
    * @see llvm::Module::getFunction()
    */
    LLVMGetNamedFunction(module: Module, name: char ptr) -> Value native;

    /**
    * Obtain an iterator to the first Function in a Module.
    *
    * @see llvm::Module::begin()
    */
    LLVMGetFirstFunction(module: Module) -> Value native;

    /**
    * Obtain an iterator to the last Function in a Module.
    *
    * @see llvm::Module::end()
    */
    LLVMGetLastFunction(module: Module) -> Value native;

    /**
    * Advance a Function iterator to the next Function.
    *
    * Returns NULL if the iterator was already at the end and there are no more
    * functions.
    */
    LLVMGetNextFunction(function: Value) -> Value native;

    /**
    * Decrement a Function iterator to the previous Function.
    *
    * Returns NULL if the iterator was already at the beginning and there are
    * no previous functions.
    */
    LLVMGetPreviousFunction(function: Value) -> Value native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreType Types
    *
    * Types represent the type of a value.
    *
    * Types are associated with a context instance. The context internally
    * deduplicates types so there is only 1 instance of a specific type
    * alive at a time. In other words, a unique type is shared among all
    * consumers within a context.
    *
    * A Type in the C API corresponds to llvm::Type.
    *
    * Types have the following hierarchy:
    *
    *   types:
    *     integer type
    *     real type
    *     function type
    *     sequence types:
    *       array type
    *       pointer type
    *       vector type
    *     void type
    *     label type
    *     opaque type
    *
    * @{
    */

    /**
    * Obtain the enumerated type of a Type instance.
    *
    * @see llvm::Type:getTypeID()
    */
    LLVMGetTypeKind(type: Type) -> TypeKind native;

    /**
    * Whether the type has a known size.
    *
    * Things that don't have a size are abstract types, labels, and void.
    *
    * @see llvm::Type::isSized()
    */
    LLVMTypeIsSized(type: Type) -> Bool native;

    /**
    * Obtain the context to which this type instance is associated.
    *
    * @see llvm::Type::getContext()
    */
    LLVMGetTypeContext(type: Type) -> Context native;

    /**
    * Dump a representation of a type to stderr.
    *
    * @see llvm::Type::dump()
    */
    LLVMDumpType(type: Type) native;

    /**
    * Return a string representation of the type. Use
    * LLVMDisposeMessage to free the string.
    *
    * @see llvm::Type::print()
    */
    LLVMPrintTypeToString(type: Type) -> char ptr native; 

    /**
    * @defgroup LLVMCCoreTypeInt Integer Types
    *
    * Functions in this section operate on integer types.
    *
    * @{
    */

    /**
    * Obtain an integer type from a context with specified bit width.
    */
    LLVMInt1TypeInContext(c: Context) -> Type native;
    LLVMInt8TypeInContext(c: Context) -> Type native;
    LLVMInt16TypeInContext(c: Context) -> Type native;
    LLVMInt32TypeInContext(c: Context) -> Type native;
    LLVMInt64TypeInContext(c: Context) -> Type native;
    LLVMInt128TypeInContext(c: Context) -> Type native;
    LLVMIntTypeInContext(c: Context, num_bits: int) -> Type native;

    /**
    * Obtain an integer type from the global context with a specified bit
    * width.
    */
    LLVMInt1Type() -> Type native;
    LLVMInt8Type() -> Type native;
    LLVMInt16Type() -> Type native;
    LLVMInt32Type() -> Type native;
    LLVMInt64Type() -> Type native;
    LLVMInt128Type() -> Type native;
    LLVMIntType(num_bits: int) -> Type native;
    LLVMGetIntTypeWidth(int_type: Type) -> int native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreTypeFloat Floating Point Types
    *
    * @{
    */

    /**
    * Obtain a 16-bit floating point type from a context.
    */
    LLVMHalfTypeInContext(c: Context) -> Type native;

    /**
    * Obtain a 32-bit floating point type from a context.
    */
    LLVMFloatTypeInContext(c: Context) -> Type native;

    /**
    * Obtain a 64-bit floating point type from a context.
    */
    LLVMDoubleTypeInContext(c: Context) -> Type native;

    /**
    * Obtain a 80-bit floating point type (X87) from a context.
    */
    LLVMX86FP80TypeInContext(c: Context) -> Type native;

    /**
    * Obtain a 128-bit floating point type (112-bit mantissa) from a
    * context.
    */
    LLVMFP128TypeInContext(c: Context) -> Type native;

    /**
    * Obtain a 128-bit floating point type (two 64-bits) from a context.
    */
    LLVMPPCFP128TypeInContext(c: Context) -> Type native;

    /**
    * Obtain a floating point type from the global context.
    *
    * These map to the functions in this group of the same name.
    */
    LLVMHalfType() -> Type native;
    LLVMFloatType() -> Type native;
    LLVMDoubleType() -> Type native;
    LLVMX86FP80Type() -> Type native;
    LLVMFP128Type() -> Type native;
    LLVMPPCFP128Type() -> Type native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreTypeFunction Function Types
    *
    * @{
    */

    /**
    * Obtain a function type consisting of a specified signature.
    *
    * The function is defined as a tuple of a return Type, a list of
    * parameter types, and whether the function is variadic.
    */
    LLVMFunctionType(return_type: Type,
                                param_type: Type ptr, param_count: int,
                                is_var_arg: Bool) -> Type native;

    /**
    * Returns whether a function type is variadic.
    */
    LLVMIsFunctionVarArg(function_type: Type) -> Bool native;

    /**
    * Obtain the Type this function Type returns.
    */
    LLVMGetReturnType(function_type: Type) -> Type native;

    /**
    * Obtain the number of parameters this function accepts.
    */
    LLVMCountParamTypes(function_type: Type) -> int native;

    /**
    * Obtain the types of a function's parameters.
    *
    * The Dest parameter should point to a pre-allocated array of
    * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the
    * first LLVMCountParamTypes() entries in the array will be populated
    * with LLVMTypeRef instances.
    *
    * @param FunctionTy The function type to operate on.
    * @param Dest Memory address of an array to be filled with result.
    */
    LLVMGetParamTypes(function_type: Type, dest: Type ptr) native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreTypeStruct Structure Types
    *
    * These functions relate to LLVMTypeRef instances.
    *
    * @see llvm::StructType
    *
    * @{
    */

    /**
    * Create a new structure type in a context.
    *
    * A structure is specified by a list of inner elements/types and
    * whether these can be packed together.
    *
    * @see llvm::StructType::create()
    */
    LLVMStructTypeInContext(c: Context, element_types: Type ptr,
                                        element_count: int, packed: Bool) -> Type native;

    /**
    * Create a new structure type in the global context.
    *
    * @see llvm::StructType::create()
    */
    LLVMStructType(element_types: Type ptr, element_count: int,
                              packed: Bool) -> Type native;

    /**
    * Create an empty structure in a context having a specified name.
    *
    * @see llvm::StructType::create()
    */
    LLVMStructCreateNamed(context: Context, name: char ptr) -> Type native;

    /**
    * Obtain the name of a structure.
    *
    * @see llvm::StructType::getName()
    */
    LLVMGetStructName(struct_type: Type) -> char ptr native;

    /**
    * Set the contents of a structure type.
    *
    * @see llvm::StructType::setBody()
    */
    LLVMStructSetBody(struct_type: Type, element_types: Type ptr,
                          element_count: int, packed: Bool) native;

    /**
    * Get the number of elements defined inside the structure.
    *
    * @see llvm::StructType::getNumElements()
    */
    LLVMCountStructElementTypes(struct_type: Type) -> int native;

    /**
    * Get the elements within a structure.
    *
    * The function is passed the address of a pre-allocated array of
    * LLVMTypeRef at least LLVMCountStructElementTypes() long. After
    * invocation, this array will be populated with the structure's
    * elements. The objects in the destination array will have a lifetime
    * of the structure type itself, which is the lifetime of the context it
    * is contained in.
    */
    LLVMGetStructElementTypes(struct_type: Type, dest: Type ptr) native;

    /**
    * Get the type of the element at a given index in the structure.
    *
    * @see llvm::StructType::getTypeAtIndex()
    */
    LLVMStructGetTypeAtIndex(struct_type: Type, index: int) -> Type native;

    /**
    * Determine whether a structure is packed.
    *
    * @see llvm::StructType::isPacked()
    */
    LLVMIsPackedStruct(struct_type: Type) -> Bool native;

    /**
    * Determine whether a structure is opaque.
    *
    * @see llvm::StructType::isOpaque()
    */
    LLVMIsOpaqueStruct(struct_type: Type) -> Bool native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreTypeSequential Sequential Types
    *
    * Sequential types represents "arrays" of types. This is a super class
    * for array, vector, and pointer types.
    *
    * @{
    */

    /**
    * Obtain the type of elements within a sequential type.
    *
    * This works on array, vector, and pointer types.
    *
    * @see llvm::SequentialType::getElementType()
    */
    LLVMGetElementType(type: Type) -> Type native;

    /**
    * Returns type's subtypes
    *
    * @see llvm::Type::subtypes()
    */
    LLVMGetSubtypes(type: Type, arr: Type ptr) native;

    /**
    *  Return the number of types in the derived type.
    *
    * @see llvm::Type::getNumContainedTypes()
    */
    LLVMGetNumContainedTypes(type: Type) -> int native;

    /**
    * Create a fixed size array type that refers to a specific type.
    *
    * The created type will exist in the context that its element type
    * exists in.
    *
    * @see llvm::ArrayType::get()
    */
    LLVMArrayType(element_type: Type, element_count: int) -> Type native;

    /**
    * Obtain the length of an array type.
    *
    * This only works on types that represent arrays.
    *
    * @see llvm::ArrayType::getNumElements()
    */
    LLVMGetArrayLength(array_type: Type) -> int native;

    /**
    * Create a pointer type that points to a defined type.
    *
    * The created type will exist in the context that its pointee type
    * exists in.
    *
    * @see llvm::PointerType::get()
    */
    LLVMPointerType(element_type: Type, address_space: int) -> Type native;

    /**
    * Obtain the address space of a pointer type.
    *
    * This only works on types that represent pointers.
    *
    * @see llvm::PointerType::getAddressSpace()
    */
    LLVMGetPointerAddressSpace(pointer_type: Type) -> int native;

    /**
    * Create a vector type that contains a defined type and has a specific
    * number of elements.
    *
    * The created type will exist in the context thats its element type
    * exists in.
    *
    * @see llvm::VectorType::get()
    */
    LLVMVectorType(element_type: Type, element_count: Count) -> Type native;

    /**
    * Obtain the number of elements in a vector type.
    *
    * This only works on types that represent vectors.
    *
    * @see llvm::VectorType::getNumElements()
    */
    LLVMGetVectorSize(vector_type: Type) -> int native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreTypeOther Other Types
    *
    * @{
    */

    /**
    * Create a void type in a context.
    */
    LLVMVoidTypeInContext(c: Context) -> Type native;

    /**
    * Create a label type in a context.
    */
    LLVMLabelTypeInContext(c: Context) -> Type native;

    /**
    * Create a X86 MMX type in a context.
    */
    LLVMX86MMXTypeInContext(c: Context) -> Type native;

    /**
    * These are similar to the above functions except they operate on the
    * global context.
    */
    LLVMVoidType() -> Type native;
    LLVMLabelType() -> Type native;
    LLVMX86MMXType() -> Type native;

    /**
    * @}
    */

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValues Values
    *
    * The bulk of LLVM's object model consists of values, which comprise a very
    * rich type hierarchy.
    *
    * LLVMValueRef essentially represents llvm::Value. There is a rich
    * hierarchy of classes within this type. Depending on the instance
    * obtained, not all APIs are available.
    *
    * Callers can determine the type of an LLVMValueRef by calling the
    * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These
    * functions are defined by a macro, so it isn't obvious which are
    * available by looking at the Doxygen source code. Instead, look at the
    * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list
    * of value names given. These value names also correspond to classes in
    * the llvm::Value hierarchy.
    *
    * @{
    */


    /**
    * @defgroup LLVMCCoreValueGeneral General APIs
    *
    * Functions in this section work on all LLVMValueRef instances,
    * regardless of their sub-type. They correspond to functions available
    * on llvm::Value.
    *
    * @{
    */

    /**
    * Obtain the type of a value.
    *
    * @see llvm::Value::getType()
    */
    LLVMTypeOf(value: Value) -> Type native;

    /**
    * Obtain the enumerated type of a Value instance.
    *
    * @see llvm::Value::getValueID()
    */
    LLVMGetValueKind(value: Value) -> TypeKind native;

    /**
    * Obtain the string name of a value.
    *
    * @see llvm::Value::getName()
    */
    LLVMGetValueName(value: Value) -> char ptr native;

    /**
    * Set the string name of a value.
    *
    * @see llvm::Value::setName()
    */
    LLVMSetValueName(value: Value, name: char ptr) native;

    /**
    * Dump a representation of a value to stderr.
    *
    * @see llvm::Value::dump()
    */
    LLVMDumpValue(value: Value) native;

    /**
    * Return a string representation of the value. Use
    * LLVMDisposeMessage to free the string.
    *
    * @see llvm::Value::print()
    */
    LLVMPrintValueToString(value: Value) -> char ptr native;

    /**
    * Replace all uses of a value with another one.
    *
    * @see llvm::Value::replaceAllUsesWith()
    */
    LLVMReplaceAllUsesWith(old_value: Value, new_value: Value) native;

    /**
    * Determine whether the specified value instance is constant.
    */
    LLVMIsConstant(value: Value) -> Bool native;

    /**
    * Determine whether a value instance is undefined.
    */
    LLVMIsUndef(value: Value) -> Bool native;

    LLVMIsAMDNode(value: Value) -> Value native;
    LLVMIsAMDString(value: Value) -> Value native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValueUses Usage
    *
    * This module defines functions that allow you to inspect the uses of a
    * LLVMValueRef.
    *
    * It is possible to obtain an LLVMUseRef for any LLVMValueRef instance.
    * Each LLVMUseRef (which corresponds to a llvm::Use instance) holds a
    * llvm::User and llvm::Value.
    *
    * @{
    */

    /**
    * Obtain the first use of a value.
    *
    * Uses are obtained in an iterator fashion. First, call this function
    * to obtain a reference to the first use. Then, call LLVMGetNextUse()
    * on that instance and all subsequently obtained instances until
    * LLVMGetNextUse() returns NULL.
    *
    * @see llvm::Value::use_begin()
    */
    LLVMGetFirstUse(value: Value) -> Use native;

    /**
    * Obtain the next use of a value.
    *
    * This effectively advances the iterator. It returns NULL if you are on
    * the final use and no more are available.
    */
    LLVMGetNextUse(use_: Use) -> Use native;

    /**
    * Obtain the user value for a user.
    *
    * The returned value corresponds to a llvm::User type.
    *
    * @see llvm::Use::getUser()
    */
    LLVMGetUser(use_: Use) -> Value native;

    /**
    * Obtain the value this use corresponds to.
    *
    * @see llvm::Use::get().
    */
    LLVMGetUsedValue(use_: Use) -> Value native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValueUser User value
    *
    * Function in this group pertain to LLVMValueRef instances that descent
    * from llvm::User. This includes constants, instructions, and
    * operators.
    *
    * @{
    */

    /**
    * Obtain an operand at a specific index in a llvm::User value.
    *
    * @see llvm::User::getOperand()
    */
    LLVMGetOperand(value: Value, index: int) -> Value native;

    /**
    * Obtain the use of an operand at a specific index in a llvm::User value.
    *
    * @see llvm::User::getOperandUse()
    */
    LLVMGetOperandUse(value: Value, index: int) -> Use native;

    /**
    * Set an operand at a specific index in a llvm::User value.
    *
    * @see llvm::User::setOperand()
    */
    LLVMSetOperand(user: Value, index: int, value: Value) native;

    /**
    * Obtain the number of operands in a llvm::User value.
    *
    * @see llvm::User::getNumOperands()
    */
    LLVMGetNumOperands(value: Value) -> int native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValueConstant Constants
    *
    * This section contains APIs for interacting with LLVMValueRef that
    * correspond to llvm::Constant instances.
    *
    * These functions will work for any LLVMValueRef in the llvm::Constant
    * class hierarchy.
    *
    * @{
    */

    /**
    * Obtain a constant value referring to the null instance of a type.
    *
    * @see llvm::Constant::getNullValue()
    */
    LLVMConstNull(type: Type) -> Value native; /* all zeroes */

    /**
    * Obtain a constant value referring to the instance of a type
    * consisting of all ones.
    *
    * This is only valid for integer types.
    *
    * @see llvm::Constant::getAllOnesValue()
    */
    LLVMConstAllOnes(type: Type) -> Value native;

    /**
    * Obtain a constant value referring to an undefined value of a type.
    *
    * @see llvm::UndefValue::get()
    */
    LLVMGetUndef(type: Type) -> Value native;

    /**
    * Determine whether a value instance is null.
    *
    * @see llvm::Constant::isNullValue()
    */
    LLVMIsNull(value: Value) -> Bool native;

    /**
    * Obtain a constant that is a constant pointer pointing to NULL for a
    * specified type.
    */
    LLVMConstPointerNull(type: Type) -> Value native;

    /**
    * @defgroup LLVMCCoreValueConstantScalar Scalar constants
    *
    * Functions in this group model LLVMValueRef instances that correspond
    * to constants referring to scalar types.
    *
    * For integer types, the LLVMTypeRef parameter should correspond to a
    * llvm::IntegerType instance and the returned LLVMValueRef will
    * correspond to a llvm::ConstantInt.
    *
    * For floating point types, the LLVMTypeRef returned corresponds to a
    * llvm::ConstantFP.
    *
    * @{
    */

    /**
    * Obtain a constant value for an integer type.
    *
    * The returned value corresponds to a llvm::ConstantInt.
    *
    * @see llvm::ConstantInt::get()
    *
    * @param IntTy Integer type to obtain value of.
    * @param N The value the returned instance should refer to.
    * @param SignExtend Whether to sign extend the produced value.
    */

    // FIXME: n shoud be 'long long'
    LLVMConstInt(int_type: Type, n: long,
                            sign_extend: Bool) -> Value native;

    /**
    * Obtain a constant value for an integer of arbitrary precision.
    *
    * @see llvm::ConstantInt::get()
    */
    LLVMConstIntOfArbitraryPrecision(int_type: Type,
                                                num_words: int,
                                                words: long ptr);

    /**
    * Obtain a constant value for an integer parsed from a string.
    *
    * A similar API, LLVMConstIntOfStringAndSize is also available. If the
    * string's length is available, it is preferred to call that function
    * instead.
    *
    * @see llvm::ConstantInt::get()
    */
    LLVMConstIntOfString(int_type: Type, text: char ptr,
                                    radix: char) -> Value native;

    /**
    * Obtain a constant value for an integer parsed from a string with
    * specified length.
    *
    * @see llvm::ConstantInt::get()
    */
    LLVMConstIntOfStringAndSize(int_type: Type, text: char ptr,
                                            len: int, radix: char) -> Value native;

    /**
    * Obtain a constant value referring to a double floating point value.
    */
    // LLVMValueRef LLVMConstReal(LLVMTypeRef RealTy, double N);

    /**
    * Obtain a constant for a floating point value parsed from a string.
    *
    * A similar API, LLVMConstRealOfStringAndSize is also available. It
    * should be used if the input string's length is known.
    */
    LLVMConstRealOfString(real_type: Type, text: char ptr) -> Value native;

    /**
    * Obtain a constant for a floating point value parsed from a string.
    */
    LLVMConstRealOfStringAndSize(real_type: Type, text: char ptr,
                                             len: int) -> Value native;

    /**
    * Obtain the zero extended value for an integer constant value.
    *
    * @see llvm::ConstantInt::getZExtValue()
    */
    LLVMConstIntGetZExtValue(value: Value) -> long native;

    /**
    * Obtain the sign extended value for an integer constant value.
    *
    * @see llvm::ConstantInt::getSExtValue()
    */
    LLVMConstIntGetSExtValue(value: Value) -> long native;

    /**
    * Obtain the double value for an floating point constant value.
    * losesInfo indicates if some precision was lost in the conversion.
    *
    * @see llvm::ConstantFP::getDoubleValue
    */
    // double LLVMConstRealGetDouble(LLVMValueRef ConstantVal, LLVMBool *losesInfo);

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValueConstantComposite Composite Constants
    *
    * Functions in this group operate on composite constants.
    *
    * @{
    */

    /**
    * Create a ConstantDataSequential and initialize it with a string.
    *
    * @see llvm::ConstantDataArray::getString()
    */
    LLVMConstStringInContext(context: Context, str: char ptr,
                                        length: int, dont_null_terminate: Bool) -> Value native;

    /**
    * Create a ConstantDataSequential with string content in the global context.
    *
    * This is the same as LLVMConstStringInContext except it operates on the
    * global context.
    *
    * @see LLVMConstStringInContext()
    * @see llvm::ConstantDataArray::getString()
    */
    LLVMConstString(str: char ptr, length: int,
                                dont_null_terminate: Bool) -> Value native;

    /**
    * Returns true if the specified constant is an array of i8.
    *
    * @see ConstantDataSequential::getAsString()
    */
    LLVMIsConstantString(value: Value) -> Bool native;

    /**
    * Get the given constant data sequential as a string.
    *
    * @see ConstantDataSequential::getAsString()
    */
    LLVMGetAsString(c: Value, length: int ptr) -> char ptr native;

    /**
    * Create an anonymous ConstantStruct with the specified values.
    *
    * @see llvm::ConstantStruct::getAnon()
    */
    LLVMConstStructInContext(c: Context,
                                        values: Value ptr,
                                        count: int, packed: Bool) -> Value native;

    /**
    * Create a ConstantStruct in the global Context.
    *
    * This is the same as LLVMConstStructInContext except it operates on the
    * global Context.
    *
    * @see LLVMConstStructInContext()
    */
    LLVMConstStruct(values: Value ptr, count: int,
                                packed: Bool) -> Value native;

    /**
    * Create a ConstantArray from values.
    *
    * @see llvm::ConstantArray::get()
    */
    LLVMConstArray(element_type: Type,
                                values: Value ptr, length: int) -> Value native;

    /**
    * Create a non-anonymous ConstantStruct from values.
    *
    * @see llvm::ConstantStruct::get()
    */
    LLVMConstNamedStruct(struct_type: Type,
                                    values: Value ptr,
                                    count: int) -> Value native;

    /**
    * Get an element at specified index as a constant.
    *
    * @see ConstantDataSequential::getElementAsConstant()
    */
    LLVMGetElementAsConstant(value: Value, index: int) -> Value native;

    /**
    * Create a ConstantVector from values.
    *
    * @see llvm::ConstantVector::get()
    */
    LLVMConstVector(values: Value ptr, size: int) -> Value native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValueConstantExpressions Constant Expressions
    *
    * Functions in this group correspond to APIs on llvm::ConstantExpr.
    *
    * @see llvm::ConstantExpr.
    *
    * @{
    */
    LLVMGetConstOpcode(value: Value) -> OpCode native;
    LLVMAlignOf(type: Type) -> Value native;
    LLVMSizeOf(type: Type) -> Value native;
    LLVMConstNeg(ConstantVal: Value) -> Value native;
    LLVMConstNSWNeg(ConstantVal: Value) -> Value native;
    LLVMConstNUWNeg(ConstantVal: Value) -> Value native;
    LLVMConstFNeg(ConstantVal: Value) -> Value native;
    LLVMConstNot(ConstantVal: Value) -> Value native;
    LLVMConstAdd(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstNSWAdd(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstNUWAdd(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstFAdd(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstSub(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstNSWSub(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstNUWSub(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstFSub(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstMul(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstNSWMul(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstNUWMul(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstFMul(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstUDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstExactUDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstSDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstExactSDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstFDiv(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstURem(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstSRem(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstFRem(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstAnd(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstOr(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstXor(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstICmp(Predicate: IntPredicate, LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstFCmp(Predicate: RealPredicate, LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstShl(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstLShr(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstAShr(LHSConstant: Value, RHSConstant: Value) -> Value native;
    LLVMConstGEP(ConstantVal: Value, ConstantIndices: Value ptr, NumIndices: int) -> Value native;
    LLVMConstInBoundsGEP(ConstantVal: Value, ConstantIndices: Value ptr, NumIndices: int) -> Value native;
    LLVMConstTrunc(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstSExt(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstZExt(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstFPTrunc(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstFPExt(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstUIToFP(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstSIToFP(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstFPToUI(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstFPToSI(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstPtrToInt(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstIntToPtr(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstBitCast(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstAddrSpaceCast(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstZExtOrBitCast(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstSExtOrBitCast(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstTruncOrBitCast(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstPointerCast(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstIntCast(ConstantVal: Value, to_type: Type, isSigned: Bool) -> Value native;
    LLVMConstFPCast(ConstantVal: Value, to_type: Type) -> Value native;
    LLVMConstSelect(ConstantCondition: Value, ConstantIfTrue: Value, ConstantIfFalse: Value) -> Value native;
    LLVMConstExtractElement(VectorConstant: Value, IndexConstant: Value) -> Value native;
    LLVMConstInsertElement(VectorConstant: Value, ElementValueConstant: Value, IndexConstant: Value) -> Value native;
    LLVMConstShuffleVector(VectorAConstant: Value, VectorBConstant: Value, MaskConstant: Value) -> Value native;
    LLVMConstExtractValue(AggConstant: Value, IdxList: int ptr, NumIdx: int) -> Value native;
    LLVMConstInsertValue(AggConstant: Value, ElementValueConstant: Value, IdxList: int ptr, NumIdx: int) -> Value native;

    LLVMConstInlineAsm(type: Type, asm_string: char ptr, constraints: char ptr, has_side_effects: Bool, is_align_stack: Bool) -> Value native;

    LLVMBlockAddress(f: Value, basic_block: BasicBlock) -> Value native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValueConstantGlobals Global Values
    *
    * This group contains functions that operate on global values. Functions in
    * this group relate to functions in the llvm::GlobalValue class tree.
    *
    * @see llvm::GlobalValue
    *
    * @{
    */

    LLVMGetGlobalParent(global: Value) -> Module native;
    LLVMIsDeclaration(global: Value) -> Bool native;
    LLVMGetLinkage(global: Value) -> Linkage native;
    LLVMSetLinkage(global: Value, linkage: Linkage);
    LLVMGetSection(global: Value) -> char ptr native;
    LLVMSetSection(global: Value, section: char ptr) native;
    LLVMGetVisibility(global: Value) -> Visibility native;
    LLVMSetVisibility(global: Value, visibility: Visibility) native;
    LLVMGetDLLStorageClass(global: Value) -> DLLStorageClass native;
    LLVMSetDLLStorageClass(global: Value, storage_class: DLLStorageClass) native;
    LLVMHasUnnamedAddr(global: Value) -> bool native;
    LLVMSetUnnamedAddr(global: Value, has_unnamed_addr: Bool) native;

    /**
    * @defgroup LLVMCCoreValueWithAlignment Values with alignment
    *
    * Functions in this group only apply to values with alignment, i.e.
    * global variables, load and store instructions.
    */

    /**
    * Obtain the preferred alignment of the value.
    * @see llvm::AllocaInst::getAlignment()
    * @see llvm::LoadInst::getAlignment()
    * @see llvm::StoreInst::getAlignment()
    * @see llvm::GlobalValue::getAlignment()
    */
    LLVMGetAlignment(value: Value) -> int native;

    /**
    * Set the preferred alignment of the value.
    * @see llvm::AllocaInst::setAlignment()
    * @see llvm::LoadInst::setAlignment()
    * @see llvm::StoreInst::setAlignment()
    * @see llvm::GlobalValue::setAlignment()
    */
    LLVMSetAlignment(value: Value, bytes: int) native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables
    *
    * This group contains functions that operate on global variable values.
    *
    * @see llvm::GlobalVariable
    *
    * @{
    */
    LLVMAddGlobal(module: Module, type: Type, name: char ptr) -> Value native;
    LLVMAddGlobalInAddressSpace(module: Module, type: Type, name: char ptr, address_space: int) -> Value native;
    LLVMGetNamedGlobal(module: Module, name: char ptr) -> Value native;
    LLVMGetFirstGlobal(module: Module) -> Value native;
    LLVMGetLastGlobal(module: Module) -> Value native;
    LLVMGetNextGlobal(global_var: Value) -> Value native;
    LLVMGetPreviousGlobal(global_var: Value) -> Value native;
    LLVMDeleteGlobal(global_var: Value) native;
    LLVMGetInitializer(global_var: Value) -> Value native;
    LLVMSetInitializer(global_var: Value, value: Value) native;
    LLVMIsThreadLocal(global_var: Value) -> Bool native;
    LLVMSetThreadLocal(global_var: Value, is_thread_local: Bool);
    LLVMIsGlobalConstant(global_var: Value) -> Bool native;
    LLVMSetGlobalConstant(global_var: Value, is_constant: Bool) native;
    LLVMGetThreadLocalMode(global_var: Value) -> ThreadLocalMode native; 
    LLVMSetThreadLocalMode(global_var: Value, mode: ThreadLocalMode) native;
    LLVMIsExternallyInitialized(global_var: Value) -> Bool native;
    LLVMSetExternallyInitialized(global_var: Value, is_externally_initialized: Bool) native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCoreValueConstantGlobalAlias Global Aliases
    *
    * This group contains function that operate on global alias values.
    *
    * @see llvm::GlobalAlias
    *
    * @{
    */
    LLVMAddAlias(module: Module, type: Type, aliasee: Value, name: char ptr) -> Value native;

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValueFunction Function values
    *
    * Functions in this group operate on LLVMValueRef instances that
    * correspond to llvm::Function instances.
    *
    * @see llvm::Function
    *
    * @{
    */

    /**
    * Remove a function from its containing module and deletes it.
    *
    * @see llvm::Function::eraseFromParent()
    */
    LLVMDeleteFunction(function: Value) native;

    /**
    * Check whether the given function has a personality function.
    *
    * @see llvm::Function::hasPersonalityFn()
    */
    LLVMHasPersonalityFn(function: Value) -> Bool native;

    /**
    * Obtain the personality function attached to the function.
    *
    * @see llvm::Function::getPersonalityFn()
    */
    LLVMGetPersonalityFn(function: Value) -> Value native;

    /**
    * Set the personality function attached to the function.
    *
    * @see llvm::Function::setPersonalityFn()
    */
    LLVMSetPersonalityFn(function: Value, personality_function: Value) native;

    /**
    * Obtain the ID number from a function instance.
    *
    * @see llvm::Function::getIntrinsicID()
    */
    LLVMGetIntrinsicID(function: Value) -> int native;

    /**
    * Obtain the calling function of a function.
    *
    * The returned value corresponds to the LLVMCallConv enumeration.
    *
    * @see llvm::Function::getCallingConv()
    */
    LLVMGetFunctionCallConv(function: Value) -> int native;

    /**
    * Set the calling convention of a function.
    *
    * @see llvm::Function::setCallingConv()
    *
    * @param Fn Function to operate on
    * @param CC LLVMCallConv to set calling convention to
    */
    LLVMSetFunctionCallConv(function: Value, calling_convention: int) native;

    /**
    * Obtain the name of the garbage collector to use during code
    * generation.
    *
    * @see llvm::Function::getGC()
    */
    LLVMGetGC(function: Value) -> char ptr native;

    /**
    * Define the garbage collector to use during code generation.
    *
    * @see llvm::Function::setGC()
    */
    LLVMSetGC(function: Value, name: char ptr) native;

    /**
    * Add an attribute to a function.
    *
    * @see llvm::Function::addAttribute()
    */
    LLVMAddAttributeAtIndex(function: Value, index: AttributeIndex, attribute: Attribute) native;
    LLVMGetAttributeCountAtIndex(function: Value, index: AttributeIndex) -> int native;
    LLVMGetAttributesAtIndex(function: Value, index: AttributeIndex, attributes: Attribute ptr) native;
    LLVMGetEnumAttributeAtIndex(function: Value, index: AttributeIndex, kind_id: int) -> Attribute native;
    LLVMGetStringAttributeAtIndex(function: Value, index: AttributeIndex, key: char ptr, key_len: int) -> Attribute native;
    LLVMRemoveEnumAttributeAtIndex(function: Value, index: AttributeIndex, kind_id: int) native;
    LLVMRemoveStringAttributeAtIndex(function: Value, index: AttributeIndex, key: char ptr, key_len: int) native;

    /**
    * Add a target-dependent attribute to a function
    * @see llvm::AttrBuilder::addAttribute()
    */
    LLVMAddTargetDependentFunctionAttr(function: Value, attribute: char ptr, value: char ptr) native;

    /**
    * @defgroup LLVMCCoreValueFunctionParameters Function Parameters
    *
    * Functions in this group relate to arguments/parameters on functions.
    *
    * Functions in this group expect LLVMValueRef instances that correspond
    * to llvm::Function instances.
    *
    * @{
    */

    /**
    * Obtain the number of parameters in a function.
    *
    * @see llvm::Function::arg_size()
    */
    LLVMCountParams(function: Value) -> int native;

    /**
    * Obtain the parameters in a function.
    *
    * The takes a pointer to a pre-allocated array of LLVMValueRef that is
    * at least LLVMCountParams() long. This array will be filled with
    * LLVMValueRef instances which correspond to the parameters the
    * function receives. Each LLVMValueRef corresponds to a llvm::Argument
    * instance.
    *
    * @see llvm::Function::arg_begin()
    */
    LLVMGetParams(function: Value, params: Value ptr) native;

    /**
    * Obtain the parameter at the specified index.
    *
    * Parameters are indexed from 0.
    *
    * @see llvm::Function::arg_begin()
    */
    LLVMGetParam(function: Value, index: int) -> Value native;

    /**
    * Obtain the function to which this argument belongs.
    *
    * Unlike other functions in this group, this one takes an LLVMValueRef
    * that corresponds to a llvm::Attribute.
    *
    * The returned LLVMValueRef is the llvm::Function to which this
    * argument belongs.
    */
    LLVMGetParamParent(inst: Value) -> Value native;

    /**
    * Obtain the first parameter to a function.
    *
    * @see llvm::Function::arg_begin()
    */
    LLVMGetFirstParam(function: Value) -> Value native;

    /**
    * Obtain the last parameter to a function.
    *
    * @see llvm::Function::arg_end()
    */
    LLVMGetLastParam(function: Value) -> Value native;

    /**
    * Obtain the next parameter to a function.
    *
    * This takes an LLVMValueRef obtained from LLVMGetFirstParam() (which is
    * actually a wrapped iterator) and obtains the next parameter from the
    * underlying iterator.
    */
    LLVMGetNextParam(arg: Value) -> Value native;

    /**
    * Obtain the previous parameter to a function.
    *
    * This is the opposite of LLVMGetNextParam().
    */
    LLVMGetPreviousParam(arg: Value) -> Value native;

    /**
    * Set the alignment for a function parameter.
    *
    * @see llvm::Argument::addAttr()
    * @see llvm::AttrBuilder::addAlignmentAttr()
    */
    LLVMSetParamAlignment(arg: Value, align: int) native;

    /**
    * @}
    */

    /**
    * @}
    */

    /**
    * @}
    */

    /**
    * @}
    */

    /**
    * @defgroup LLVMCCoreValueMetadata Metadata
    *
    * @{
    */

    /**
    * Obtain a MDString value from a context.
    *
    * The returned instance corresponds to the llvm::MDString class.
    *
    * The instance is specified by string data of a specified length. The
    * string content is copied, so the backing memory can be freed after
    * this function returns.
    */
    LLVMMDStringInContext(context: Context, str: char ptr, length: int) -> Value native;

    /**
    * Obtain a MDString value from the global context.
    */
    LLVMMDString(str: char ptr, length: int) -> Value native;

    /**
    * Obtain a MDNode value from a context.
    *
    * The returned value corresponds to the llvm::MDNode class.
    */
    LLVMMDNodeInContext(context: Context, values: Value ptr, count: int) -> Value native;

    /**
    * Obtain a MDNode value from the global context.
    */
    LLVMMDNode(values: Value ptr, count: int) -> Value native;

    /**
    * Obtain a Metadata as a Value.
    */
    LLVMMetadataAsValue(context: Context, metadata: Metadata) -> Value native;

    /**
    * Obtain a Value as a Metadata.
    */
    LLVMValueAsMetadata(value: Value) -> Metadata native;

    /**
    * Obtain the underlying string from a MDString value.
    *
    * @param V Instance to obtain string from.
    * @param Length Memory address which will hold length of returned string.
    * @return String data in MDString.
    */
    LLVMGetMDString(value: Value, length: int ptr) -> char ptr native;

    /**
    * Obtain the number of operands from an MDNode value.
    *
    * @param V MDNode to get number of operands from.
    * @return Number of operands of the MDNode.
    */
    LLVMGetMDNodeNumOperands(value: Value) -> int native;

/**
 * Obtain the given MDNode's operands.
 *
 * The passed LLVMValueRef pointer should point to enough memory to hold all of
 * the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as
 * LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the
 * MDNode's operands.
 *
 * @param V MDNode to get the operands from.
 * @param Dest Destination array for operands.
 */
void LLVMGetMDNodeOperands(value: Value, LLVMValueRef *Dest);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueBasicBlock Basic Block
 *
 * A basic block represents a single entry single exit section of code.
 * Basic blocks contain a list of instructions which form the body of
 * the block.
 *
 * Basic blocks belong to functions. They have the type of label.
 *
 * Basic blocks are themselves values. However, the C API models them as
 * LLVMBasicBlockRef.
 *
 * @see llvm::BasicBlock
 *
 * @{
 */

/**
 * Convert a basic block instance to a value type.
 */
LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB);

/**
 * Determine whether an LLVMValueRef is itself a basic block.
 */
LLVMBool LLVMValueIsBasicBlock(value: Value);

/**
 * Convert an LLVMValueRef to an LLVMBasicBlockRef instance.
 */
LLVMBasicBlockRef LLVMValueAsBasicBlock(value: Value);

/**
 * Obtain the string name of a basic block.
 */
const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB);

/**
 * Obtain the function to which a basic block belongs.
 *
 * @see llvm::BasicBlock::getParent()
 */
LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB);

/**
 * Obtain the terminator instruction for a basic block.
 *
 * If the basic block does not have a terminator (it is not well-formed
 * if it doesn't), then NULL is returned.
 *
 * The returned LLVMValueRef corresponds to a llvm::TerminatorInst.
 *
 * @see llvm::BasicBlock::getTerminator()
 */
LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB);

/**
 * Obtain the number of basic blocks in a function.
 *
 * @param Fn Function value to operate on.
 */
unsigned LLVMCountBasicBlocks(function: Value);

/**
 * Obtain all of the basic blocks in a function.
 *
 * This operates on a function value. The BasicBlocks parameter is a
 * pointer to a pre-allocated array of LLVMBasicBlockRef of at least
 * LLVMCountBasicBlocks() in length. This array is populated with
 * LLVMBasicBlockRef instances.
 */
void LLVMGetBasicBlocks(function: Value, LLVMBasicBlockRef *BasicBlocks);

/**
 * Obtain the first basic block in a function.
 *
 * The returned basic block can be used as an iterator. You will likely
 * eventually call into LLVMGetNextBasicBlock() with it.
 *
 * @see llvm::Function::begin()
 */
LLVMBasicBlockRef LLVMGetFirstBasicBlock(function: Value);

/**
 * Obtain the last basic block in a function.
 *
 * @see llvm::Function::end()
 */
LLVMBasicBlockRef LLVMGetLastBasicBlock(function: Value);

/**
 * Advance a basic block iterator.
 */
LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB);

/**
 * Go backwards in a basic block iterator.
 */
LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB);

/**
 * Obtain the basic block that corresponds to the entry point of a
 * function.
 *
 * @see llvm::Function::getEntryBlock()
 */
LLVMBasicBlockRef LLVMGetEntryBasicBlock(function: Value);

/**
 * Append a basic block to the end of a function.
 *
 * @see llvm::BasicBlock::Create()
 */
LLVMBasicBlockRef LLVMAppendBasicBlockInContext(context: Context,
                                                function: Value,
                                                const char *Name);

/**
 * Append a basic block to the end of a function using the global
 * context.
 *
 * @see llvm::BasicBlock::Create()
 */
LLVMBasicBlockRef LLVMAppendBasicBlock(function: Value, const char *Name);

/**
 * Insert a basic block in a function before another basic block.
 *
 * The function to add to is determined by the function of the
 * passed basic block.
 *
 * @see llvm::BasicBlock::Create()
 */
LLVMBasicBlockRef LLVMInsertBasicBlockInContext(context: Context,
                                                LLVMBasicBlockRef BB,
                                                const char *Name);

/**
 * Insert a basic block in a function using the global context.
 *
 * @see llvm::BasicBlock::Create()
 */
LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB,
                                       const char *Name);

/**
 * Remove a basic block from a function and delete it.
 *
 * This deletes the basic block from its containing function and deletes
 * the basic block itself.
 *
 * @see llvm::BasicBlock::eraseFromParent()
 */
void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB);

/**
 * Remove a basic block from a function.
 *
 * This deletes the basic block from its containing function but keep
 * the basic block alive.
 *
 * @see llvm::BasicBlock::removeFromParent()
 */
void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB);

/**
 * Move a basic block to before another one.
 *
 * @see llvm::BasicBlock::moveBefore()
 */
void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos);

/**
 * Move a basic block to after another one.
 *
 * @see llvm::BasicBlock::moveAfter()
 */
void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos);

/**
 * Obtain the first instruction in a basic block.
 *
 * The returned LLVMValueRef corresponds to a llvm::Instruction
 * instance.
 */
LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB);

/**
 * Obtain the last instruction in a basic block.
 *
 * The returned LLVMValueRef corresponds to an LLVM:Instruction.
 */
LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstruction Instructions
 *
 * Functions in this group relate to the inspection and manipulation of
 * individual instructions.
 *
 * In the C++ API, an instruction is modeled by llvm::Instruction. This
 * class has a large number of descendents. llvm::Instruction is a
 * llvm::Value and in the C API, instructions are modeled by
 * LLVMValueRef.
 *
 * This group also contains sub-groups which operate on specific
 * llvm::Instruction types, e.g. llvm::CallInst.
 *
 * @{
 */

/**
 * Determine whether an instruction has any metadata attached.
 */
int LLVMHasMetadata(value: Value);

/**
 * Return metadata associated with an instruction value.
 */
LLVMValueRef LLVMGetMetadata(value: Value, unsigned KindID);

/**
 * Set metadata associated with an instruction value.
 */
void LLVMSetMetadata(value: Value, unsigned KindID, LLVMValueRef Node);

/**
 * Obtain the basic block to which an instruction belongs.
 *
 * @see llvm::Instruction::getParent()
 */
LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst);

/**
 * Obtain the instruction that occurs after the one specified.
 *
 * The next instruction will be from the same basic block.
 *
 * If this is the last instruction in a basic block, NULL will be
 * returned.
 */
LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst);

/**
 * Obtain the instruction that occurred before this one.
 *
 * If the instruction is the first instruction in a basic block, NULL
 * will be returned.
 */
LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst);

/**
 * Remove and delete an instruction.
 *
 * The instruction specified is removed from its containing building
 * block but is kept alive.
 *
 * @see llvm::Instruction::removeFromParent()
 */
void LLVMInstructionRemoveFromParent(LLVMValueRef Inst);

/**
 * Remove and delete an instruction.
 *
 * The instruction specified is removed from its containing building
 * block and then deleted.
 *
 * @see llvm::Instruction::eraseFromParent()
 */
void LLVMInstructionEraseFromParent(LLVMValueRef Inst);

/**
 * Obtain the code opcode for an individual instruction.
 *
 * @see llvm::Instruction::getOpCode()
 */
LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst);

/**
 * Obtain the predicate of an instruction.
 *
 * This is only valid for instructions that correspond to llvm::ICmpInst
 * or llvm::ConstantExpr whose opcode is llvm::Instruction::ICmp.
 *
 * @see llvm::ICmpInst::getPredicate()
 */
LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst);

/**
 * Obtain the float predicate of an instruction.
 *
 * This is only valid for instructions that correspond to llvm::FCmpInst
 * or llvm::ConstantExpr whose opcode is llvm::Instruction::FCmp.
 *
 * @see llvm::FCmpInst::getPredicate()
 */
LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst);

/**
 * Create a copy of 'this' instruction that is identical in all ways
 * except the following:
 *   * The instruction has no parent
 *   * The instruction has no name
 *
 * @see llvm::Instruction::clone()
 */
LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst);

/**
 * @defgroup LLVMCCoreValueInstructionCall Call Sites and Invocations
 *
 * Functions in this group apply to instructions that refer to call
 * sites and invocations. These correspond to C++ types in the
 * llvm::CallInst class tree.
 *
 * @{
 */

/**
 * Obtain the argument count for a call instruction.
 *
 * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
 * llvm::InvokeInst.
 *
 * @see llvm::CallInst::getNumArgOperands()
 * @see llvm::InvokeInst::getNumArgOperands()
 */
unsigned LLVMGetNumArgOperands(LLVMValueRef Instr);

/**
 * Set the calling convention for a call instruction.
 *
 * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
 * llvm::InvokeInst.
 *
 * @see llvm::CallInst::setCallingConv()
 * @see llvm::InvokeInst::setCallingConv()
 */
void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned CC);

/**
 * Obtain the calling convention for a call instruction.
 *
 * This is the opposite of LLVMSetInstructionCallConv(). Reads its
 * usage.
 *
 * @see LLVMSetInstructionCallConv()
 */
unsigned LLVMGetInstructionCallConv(LLVMValueRef Instr);

void LLVMSetInstrParamAlignment(LLVMValueRef Instr, unsigned index,
                                unsigned Align);

void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx,
                              attribute: Attribute);
unsigned LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx);
void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx,
                               LLVMAttributeRef *Attrs);
LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C,
                                              LLVMAttributeIndex Idx,
                                              unsigned KindID);
LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C,
                                                LLVMAttributeIndex Idx,
                                                const char *K, unsigned KLen);
void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx,
                                     unsigned KindID);
void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx,
                                       const char *K, unsigned KLen);

/**
 * Obtain the pointer to the function invoked by this instruction.
 *
 * This expects an LLVMValueRef that corresponds to a llvm::CallInst or
 * llvm::InvokeInst.
 *
 * @see llvm::CallInst::getCalledValue()
 * @see llvm::InvokeInst::getCalledValue()
 */
LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr);

/**
 * Obtain whether a call instruction is a tail call.
 *
 * This only works on llvm::CallInst instructions.
 *
 * @see llvm::CallInst::isTailCall()
 */
LLVMBool LLVMIsTailCall(LLVMValueRef CallInst);

/**
 * Set whether a call instruction is a tail call.
 *
 * This only works on llvm::CallInst instructions.
 *
 * @see llvm::CallInst::setTailCall()
 */
void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall);

/**
 * Return the normal destination basic block.
 *
 * This only works on llvm::InvokeInst instructions.
 *
 * @see llvm::InvokeInst::getNormalDest()
 */
LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst);

/**
 * Return the unwind destination basic block.
 *
 * This only works on llvm::InvokeInst instructions.
 *
 * @see llvm::InvokeInst::getUnwindDest()
 */
LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst);

/**
 * Set the normal destination basic block.
 *
 * This only works on llvm::InvokeInst instructions.
 *
 * @see llvm::InvokeInst::setNormalDest()
 */
void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B);

/**
 * Set the unwind destination basic block.
 *
 * This only works on llvm::InvokeInst instructions.
 *
 * @see llvm::InvokeInst::setUnwindDest()
 */
void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionTerminator Terminators
 *
 * Functions in this group only apply to instructions that map to
 * llvm::TerminatorInst instances.
 *
 * @{
 */

/**
 * Return the number of successors that this terminator has.
 *
 * @see llvm::TerminatorInst::getNumSuccessors
 */
unsigned LLVMGetNumSuccessors(LLVMValueRef Term);

/**
 * Return the specified successor.
 *
 * @see llvm::TerminatorInst::getSuccessor
 */
LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned i);

/**
 * Update the specified successor to point at the provided block.
 *
 * @see llvm::TerminatorInst::setSuccessor
 */
void LLVMSetSuccessor(LLVMValueRef Term, unsigned i, LLVMBasicBlockRef block);

/**
 * Return if a branch is conditional.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::isConditional
 */
LLVMBool LLVMIsConditional(LLVMValueRef Branch);

/**
 * Return the condition of a branch instruction.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::getCondition
 */
LLVMValueRef LLVMGetCondition(LLVMValueRef Branch);

/**
 * Set the condition of a branch instruction.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::setCondition
 */
void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond);

/**
 * Obtain the default destination basic block of a switch instruction.
 *
 * This only works on llvm::SwitchInst instructions.
 *
 * @see llvm::SwitchInst::getDefaultDest()
 */
LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionAlloca Allocas
 *
 * Functions in this group only apply to instructions that map to
 * llvm::AllocaInst instances.
 *
 * @{
 */

/**
 * Obtain the type that is being allocated by the alloca instruction.
 */
LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionGetElementPointer GEPs
 *
 * Functions in this group only apply to instructions that map to
 * llvm::GetElementPtrInst instances.
 *
 * @{
 */

/**
 * Check whether the given GEP instruction is inbounds.
 */
LLVMBool LLVMIsInBounds(LLVMValueRef GEP);

/**
 * Set the given GEP instruction to be inbounds or not.
 */
void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionPHINode PHI Nodes
 *
 * Functions in this group only apply to instructions that map to
 * llvm::PHINode instances.
 *
 * @{
 */

/**
 * Add an incoming value to the end of a PHI list.
 */
void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues,
                     LLVMBasicBlockRef *IncomingBlocks, count: int);

/**
 * Obtain the number of incoming basic blocks to a PHI node.
 */
unsigned LLVMCountIncoming(LLVMValueRef PhiNode);

/**
 * Obtain an incoming value to a PHI node as an LLVMValueRef.
 */
LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned Index);

/**
 * Obtain an incoming value to a PHI node as an LLVMBasicBlockRef.
 */
LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned Index);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionExtractValue ExtractValue
 * @defgroup LLVMCCoreValueInstructionInsertValue InsertValue
 *
 * Functions in this group only apply to instructions that map to
 * llvm::ExtractValue and llvm::InsertValue instances.
 *
 * @{
 */

/**
 * Obtain the number of indices.
 * NB: This also works on GEP.
 */
unsigned LLVMGetNumIndices(LLVMValueRef Inst);

/**
 * Obtain the indices as an array.
 */
const unsigned *LLVMGetIndices(LLVMValueRef Inst);

/**
 * @}
 */

/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreInstructionBuilder Instruction Builders
 *
 * An instruction builder represents a point within a basic block and is
 * the exclusive means of building instructions using the C interface.
 *
 * @{
 */

LLVMBuilderRef LLVMCreateBuilderInContext(context: Context);
LLVMBuilderRef LLVMCreateBuilder(void);
void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block,
                         LLVMValueRef Instr);
void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr);
void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block);
LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder);
void LLVMClearInsertionPosition(LLVMBuilderRef Builder);
void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr);
void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr,
                                   const char *Name);
void LLVMDisposeBuilder(LLVMBuilderRef Builder);

/* Metadata */
void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L);
LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder);
void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst);

/* Terminators */
LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef);
LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V);
LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals,
                                   unsigned N);
LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest);
LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If,
                             LLVMBasicBlockRef Then, LLVMBasicBlockRef Else);
LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V,
                             LLVMBasicBlockRef Else, unsigned NumCases);
LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr,
                                 unsigned NumDests);
LLVMValueRef LLVMBuildInvoke(LLVMBuilderRef, function: Value,
                             LLVMValueRef *Args, unsigned NumArgs,
                             LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch,
                             const char *Name);
LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty,
                                 LLVMValueRef PersFn, unsigned NumClauses,
                                 const char *Name);
LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn);
LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef);

/* Add a case to the switch instruction */
void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal,
                 LLVMBasicBlockRef Dest);

/* Add a destination to the indirectbr instruction */
void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest);

/* Get the number of clauses on the landingpad instruction */
unsigned LLVMGetNumClauses(LLVMValueRef LandingPad);

/* Get the value of the clause at idnex Idx on the landingpad instruction */
LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned Idx);

/* Add a catch or filter clause to the landingpad instruction */
void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal);

/* Get the 'cleanup' flag in the landingpad instruction */
LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad);

/* Set the 'cleanup' flag in the landingpad instruction */
void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val);

/* Arithmetic */
LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                                const char *Name);
LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                                const char *Name);
LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op,
                            LLVMValueRef LHS, LLVMValueRef RHS,
                            const char *Name);
LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name);
LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V,
                             const char *Name);
LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V,
                             const char *Name);
LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name);
LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name);

/* Memory */
LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name);
LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty,
                                  value: Value, const char *Name);
LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name);
LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty,
                                  value: Value, const char *Name);
LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal);
LLVMValueRef LLVMBuildLoad(LLVMBuilderRef, LLVMValueRef PointerVal,
                           const char *Name);
LLVMValueRef LLVMBuildStore(LLVMBuilderRef, value: Value, LLVMValueRef Ptr);
LLVMValueRef LLVMBuildGEP(LLVMBuilderRef B, LLVMValueRef Pointer,
                          LLVMValueRef *Indices, unsigned NumIndices,
                          const char *Name);
LLVMValueRef LLVMBuildInBoundsGEP(LLVMBuilderRef B, LLVMValueRef Pointer,
                                  LLVMValueRef *Indices, unsigned NumIndices,
                                  const char *Name);
LLVMValueRef LLVMBuildStructGEP(LLVMBuilderRef B, LLVMValueRef Pointer,
                                unsigned Idx, const char *Name);
LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, str: char ptr,
                                   const char *Name);
LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, str: char ptr,
                                      const char *Name);
LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst);
void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile);
LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst);
void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering);

/* Casts */
LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, value: Value,
                            LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, value: Value,
                           LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, value: Value,
                           LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, value: Value,
                             LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, value: Value,
                             LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, value: Value,
                             LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, value: Value,
                             LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, value: Value,
                              LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, value: Value,
                            LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, value: Value,
                               LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, value: Value,
                               LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, value: Value,
                              LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, value: Value,
                                    LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, value: Value,
                                    LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, value: Value,
                                    LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, value: Value,
                                     LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, value: Value,
                           LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, value: Value,
                                  LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, value: Value, /*Signed cast!*/
                              LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, value: Value,
                             LLVMTypeRef DestTy, const char *Name);

/* Comparisons */
LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op,
                           LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op,
                           LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);

/* Miscellaneous instructions */
LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name);
LLVMValueRef LLVMBuildCall(LLVMBuilderRef, function: Value,
                           LLVMValueRef *Args, unsigned NumArgs,
                           const char *Name);
LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If,
                             LLVMValueRef Then, LLVMValueRef Else,
                             const char *Name);
LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty,
                            const char *Name);
LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal,
                                     LLVMValueRef Index, const char *Name);
LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal,
                                    LLVMValueRef EltVal, LLVMValueRef Index,
                                    const char *Name);
LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1,
                                    LLVMValueRef V2, LLVMValueRef Mask,
                                    const char *Name);
LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal,
                                   unsigned Index, const char *Name);
LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal,
                                  LLVMValueRef EltVal, unsigned Index,
                                  const char *Name);

LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, value: Value,
                             const char *Name);
LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, value: Value,
                                const char *Name);
LLVMValueRef LLVMBuildPtrDiff(LLVMBuilderRef, LLVMValueRef LHS,
                              LLVMValueRef RHS, const char *Name);
LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering,
                            LLVMBool singleThread, const char *Name);
LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op,
                                LLVMValueRef PTR, value: Value,
                                LLVMAtomicOrdering ordering,
                                LLVMBool singleThread);
LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr,
                                    LLVMValueRef Cmp, LLVMValueRef New,
                                    LLVMAtomicOrdering SuccessOrdering,
                                    LLVMAtomicOrdering FailureOrdering,
                                    LLVMBool SingleThread);

LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst);
void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread);

LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst);
void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst,
                                   LLVMAtomicOrdering Ordering);
LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst);
void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst,
                                   LLVMAtomicOrdering Ordering);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreModuleProvider Module Providers
 *
 * @{
 */

/**
 * Changes the type of M so it can be passed to FunctionPassManagers and the
 * JIT.  They take ModuleProviders for historical reasons.
 */
LLVMModuleProviderRef
LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M);

/**
 * Destroys the module M.
 */
void LLVMDisposeModuleProvider(LLVMModuleProviderRef M);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreMemoryBuffers Memory Buffers
 *
 * @{
 */

LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path,
                                                  LLVMMemoryBufferRef *OutMemBuf,
                                                  char **OutMessage);
LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf,
                                         char **OutMessage);
LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData,
                                                          size_t InputDataLength,
                                                          const char *BufferName,
                                                          LLVMBool RequiresNullTerminator);
LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData,
                                                              size_t InputDataLength,
                                                              const char *BufferName);
const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf);
size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf);
void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf);

/**
 * @}
 */

/**
 * @defgroup LLVMCCorePassRegistry Pass Registry
 *
 * @{
 */

/** Return the global pass registry, for use with initialization functions.
    @see llvm::PassRegistry::getPassRegistry */
LLVMPassRegistryRef LLVMGetGlobalPassRegistry(void);

/**
 * @}
 */

/**
 * @defgroup LLVMCCorePassManagers Pass Managers
 *
 * @{
 */

/** Constructs a new whole-module pass pipeline. This type of pipeline is
    suitable for link-time optimization and whole-module transformations.
    @see llvm::PassManager::PassManager */
LLVMPassManagerRef LLVMCreatePassManager(void);

/** Constructs a new function-by-function pass pipeline over the module
    provider. It does not take ownership of the module provider. This type of
    pipeline is suitable for code generation and JIT compilation tasks.
    @see llvm::FunctionPassManager::FunctionPassManager */
LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M);

/** Deprecated: Use LLVMCreateFunctionPassManagerForModule instead. */
LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP);

/** Initializes, executes on the provided module, and finalizes all of the
    passes scheduled in the pass manager. Returns 1 if any of the passes
    modified the module, 0 otherwise.
    @see llvm::PassManager::run(Module&) */
LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M);

/** Initializes all of the function passes scheduled in the function pass
    manager. Returns 1 if any of the passes modified the module, 0 otherwise.
    @see llvm::FunctionPassManager::doInitialization */
LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM);

/** Executes all of the function passes scheduled in the function pass manager
    on the provided function. Returns 1 if any of the passes modified the
    function, false otherwise.
    @see llvm::FunctionPassManager::run(Function&) */
LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F);

/** Finalizes all of the function passes scheduled in in the function pass
    manager. Returns 1 if any of the passes modified the module, 0 otherwise.
    @see llvm::FunctionPassManager::doFinalization */
LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM);

/** Frees the memory of a pass pipeline. For function pipelines, does not free
    the module provider.
    @see llvm::PassManagerBase::~PassManagerBase. */
void LLVMDisposePassManager(LLVMPassManagerRef PM);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreThreading Threading
 *
 * Handle the structures needed to make LLVM safe for multithreading.
 *
 * @{
 */

/** Deprecated: Multi-threading can only be enabled/disabled with the compile
    time define LLVM_ENABLE_THREADS.  This function always returns
    LLVMIsMultithreaded(). */
LLVMBool LLVMStartMultithreaded(void);

/** Deprecated: Multi-threading can only be enabled/disabled with the compile
    time define LLVM_ENABLE_THREADS. */
void LLVMStopMultithreaded(void);

/** Check whether LLVM is executing in thread-safe mode or not.
    @see llvm::llvm_is_multithreaded */
LLVMBool LLVMIsMultithreaded(void);

/**
 * @}
 */

/**
 * @}
 */

/**
 * @}
 */

#ifdef __cplusplus
}
#endif

#endif /* LLVM_C_CORE_H */
