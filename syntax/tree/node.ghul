// import glist;
namespace Syntax is
    use System;
    use Generic;
    use Source;

    namespace Tree is
        class NODE is
            parent: NODE public;
            children: Iterable[NODE] => new NODE[](0); 

            _next_id: int static;
            _id: int;
            location: LOCATION;
            id: int public => _id;

            next_id: int static is
                var result = _next_id;
                _next_id = _next_id + 1;
                return result;
            si

            init(location: LOCATION) is
                _id = next_id;
                self.location = location;
            si

            hash() -> int is
                return id;
            si

            invalidate(from: Iterable[Deletable[NODE]]) is
                for d in from do
                    d.delete(self);
                od
                
                _id = next_id;
            si

            =~(other: NODE) -> bool is
                return _id == other._id;
            si

            >(other: NODE) -> int is
                return _id - other._id;
            si

            clone() -> NODE is
                let result = cast NODE(super.clone());   
                result._id = next_id;         

                return result;
            si
            
            accept(visitor: Visitor) is
                visitor.visit(self);
            si

            walk(visitor: Visitor) is
                accept(visitor);
            si

            rewrite(m: Dict[NODE,NODE]) is
                if isa SINGLE_ENTRY_NODE_MAP(m) then
                    throw new NotImplementedException("Probably not what you want: replace " + Object.dump(self) + " " + m);
                fi
            si

            replace(node: NODE, with: NODE) is
                rewrite(
                    new SINGLE_ENTRY_NODE_MAP(node, with)
                );
            si

            toString() -> String is
                var printer = new Process.Printer.GHUL();
                accept(printer);
                return printer.result;
            si

        si

        class SINGLE_ENTRY_NODE_MAP: Object, Dict[NODE, NODE] is
            // HACK: legacy compiler cannot handle list literals whose generic array
            // type does not also appear as an explicit type expression elsewhere in the program: 
            _dummy0: NODE[] static;
            _dummy1: Pair[NODE,NODE][] static;

            _replace: NODE;
            _with: NODE;

            Length: int => 1;

            Keys: Iterator[NODE] => [_replace].Iterator;
            Pairs: Iterator[Pair[NODE,NODE]] => [new Pair[NODE,NODE](_replace, _with)].Iterator;
            Iterator: Iterator[NODE] => [_with].Iterator;
            
            init(replace: NODE, with: NODE) is
                _replace = replace;
                _with = with;
            si

            [index: NODE]: NODE
                is
                    if index =~ _replace then
                        return _with;
                    else
                        return null;
                    fi
                si,
                = value is
                    throw new NotImplementedException();
                si

            contains(node: NODE) -> bool => _replace =~ node;
            isEmpty() -> bool => false;
            remove(node: NODE) -> NODE is throw new NotImplementedException(); si
            clear() is throw new NotImplementedException(); si
        si
    si
si
