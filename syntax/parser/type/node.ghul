namespace Syntax.Parser.TypeExpression is
    use System;
    use Generic;

    use Source;

    class NODE: BASE[Tree.TypeExpression.NODE] is
        identifier_qualified_parser: Parser[Tree.Identifier.NODE];
        type_list_parser: Parser[Tree.TypeExpression.LIST];
        description: String => "type expression";

        init(
            identifier_qualified_parser: Parser[Tree.Identifier.NODE],
            type_list_parser: Parser[Tree.TypeExpression.LIST]
        )
        is
            super.init();

            self.identifier_qualified_parser = identifier_qualified_parser;
            self.type_list_parser = type_list_parser;

            add_parser(
                (context: CONTEXT) -> Tree.TypeExpression.NODE is
                    var start = context.location;
                    var identifier = identifier_qualified_parser.parse(context);

                    if identifier.is_poisoned then
                        IO.Std.err.println("parse type node, identifier is incomplete, next token is: " + Lexical.TOKEN_NAMES[context.current.token]);

                        if [Lexical.TOKEN.IN].contains(context.current.token) then
                            IO.Std.err.println("parse type node, skip");
                            context.next_token();
                        fi

                        let result =
                            new Tree.TypeExpression.NAMED(identifier.location, identifier);

                        result.poison();

                        return result;
                    fi

                    if
                        !isa Tree.Identifier.QUALIFIED(identifier) &&
                        context.current.token==Lexical.TOKEN.COLON
                    then
                        context.next_token();
                        var type_expression = parse(context);
                        return new Tree.TypeExpression.NAMED_TUPLE_ELEMENT(start::type_expression.location, identifier, type_expression);
                    fi

                    if context.current.token == Lexical.TOKEN.SQUARE_OPEN then
                        context.next_token();

                        let types = type_list_parser.parse(context);

                        var poison = types.is_poisoned || identifier.is_poisoned;

                        let result = new Tree.TypeExpression.GENERIC(start::context.location, identifier, types);

                        if !poison || context.current.token == Lexical.TOKEN.SQUARE_CLOSE then
                            poison = !context.next_token(Lexical.TOKEN.SQUARE_CLOSE, syntax_error_message) || poison;
                        fi

                        result.poison(poison);

                        return result;
                    else
                        return new Tree.TypeExpression.NAMED(identifier.location, identifier);
                    fi
                si,
                Lexical.TOKEN.IDENTIFIER
            );

            add_parser(
                (context: CONTEXT) -> Tree.TypeExpression.NODE is
                    var start = context.location;
                    context.next_token();
                    var types: Tree.TypeExpression.LIST;
                    if context.current.token != Lexical.TOKEN.PAREN_CLOSE then
                        types = type_list_parser.parse(context);
                    else
                        types = new Tree.TypeExpression.LIST(start, new Tree.TypeExpression.NODE[](0));
                    fi
                    var end = context.location;
                    context.next_token(Lexical.TOKEN.PAREN_CLOSE, syntax_error_message);
                    if context.current.token == Lexical.TOKEN.ARROW_THIN then
                        context.next_token();
                        var result = parse(context);
                        end = result.location;
                        return new Tree.TypeExpression.FUNCTION(start::end, types, result);
                    else
                        if
                            !types.Iterator.hasMoreElements()
                        then
                            return new Tree.TypeExpression.UNDEFINED(start::end);
                        else
                            return new Tree.TypeExpression.TUPLE(start::end, types);
                        fi
                    fi
                si,
                Lexical.TOKEN.PAREN_OPEN
            );
        si

        parse(context: CONTEXT) -> Tree.TypeExpression.NODE is
            var result = super.parse(context);

            return parse_structured(context, result);
        si

        parse_structured(
            context: CONTEXT,
            element: Tree.TypeExpression.NODE
        ) -> Tree.TypeExpression.NODE
        is
            var result = element;

            do
                case context.current.token
                when Lexical.TOKEN.ARRAY_DEF:
                    result = new Tree.TypeExpression.ARRAY_(result.location::context.location, result);
                    context.next_token();

                when Lexical.TOKEN.REF:
                    result = new Tree.TypeExpression.REFERENCE(result.location::context.location, result);
                    context.next_token();

                when Lexical.TOKEN.PTR:
                    result = new Tree.TypeExpression.POINTER(result.location::context.location, result);
                    context.next_token();

                when Lexical.TOKEN.ARROW_THIN:
                    context.next_token();

                    var return_type = parse(context);
                    var arguments = new Tree.TypeExpression.LIST(element.location, [element]: Tree.TypeExpression.NODE );
                    result = new Tree.TypeExpression.FUNCTION(result.location::return_type.location, arguments, return_type);

                default
                    return result;

                esac
            od
        si

        other_token(context: CONTEXT) -> Tree.TypeExpression.NODE is
            var should_skip_next_token = false;

            if [Lexical.TOKEN.IN].contains(context.current.token) then
                should_skip_next_token = true;
            fi

            super.other_token(context);

            if should_skip_next_token then
                context.next_token();
            fi

            return new Tree.TypeExpression.UNDEFINED(context.location);
        si
    si
si
