namespace Syntax is
    namespace Parser is
        namespace Type is
            use System;
            use Generic;
            use Source;
            class NODE : BASE[Tree.Type.NODE]  is
                identifier_qualified_parser: Parser[Tree.Identifier.NODE];
                type_list_parser: Parser[Tree.Type.LIST];
                description: String is
                    return "type";
                si

                init(identifier_qualified_parser: Parser[Tree.Identifier.NODE], type_list_parser: Parser[Tree.Type.LIST]) -> void is
                    super.init();
                    self.identifier_qualified_parser = identifier_qualified_parser;
                    self.type_list_parser = type_list_parser;
                    add_parser((context: CONTEXT) -> Tree.Type.NODE is
                        var start = context.location;
                        var identifier = identifier_qualified_parser.parse(context);
                        if 
                            !isa Tree.Identifier.QUALIFIED(identifier) && context.current.token==Lexical.TOKEN.COLON
                         then
                            context.next_token();
                            var type = parse(context);
                            return new Tree.Type.NAMED_TUPLE_ELEMENT(start .. type.location, identifier, type);
                        fi
                        if context.current.token == Lexical.TOKEN.SQUARE_OPEN then
                            context.next_token();
                            var types = type_list_parser.parse(context);
                            var result = new Tree.Type.GENERIC(start .. context.location, identifier, types);
                            context.next_token(Lexical.TOKEN.SQUARE_CLOSE, syntax_error_message);
                            return result;
                        else
                            return new Tree.Type.NAMED(identifier.location, identifier);
                        fi
                    si

                    , Lexical.TOKEN.IDENTIFIER);
                    add_parser((context: CONTEXT) -> Tree.Type.NODE is
                        var start = context.location;
                        context.next_token();
                        var types: Tree.Type.LIST;
                        if context.current.token != Lexical.TOKEN.PAREN_CLOSE then
                            types = type_list_parser.parse(context);
                        else
                            types = new Tree.Type.LIST(start, new Tree.Type.NODE[](0));
                        fi
                        var end = context.location;
                        context.next_token(Lexical.TOKEN.PAREN_CLOSE, syntax_error_message);
                        if context.current.token == Lexical.TOKEN.ARROW_THIN then
                            context.next_token();
                            var result = parse(context);
                            end = result.location;
                            return new Tree.Type.FUNCTION(start .. end, types, result);
                        else
                            if 
                                !types.Iterator.hasMoreElements()
                             then
                                context.error(start .. end, "tuple has no elements");
                                return new Tree.Type.UNDEFINED(start .. end);
                            else
                                return new Tree.Type.TUPLE(start .. end, types);
                            fi
                        fi
                    si

                    , Lexical.TOKEN.PAREN_OPEN);
                si

                parse(context: CONTEXT) -> Tree.Type.NODE is
                    var result = super.parse(context);
                    return parse_structured(context, result);
                si

                parse_structured(context: CONTEXT, element: Tree.Type.NODE) -> Tree.Type.NODE is
                    var result = element;
                    do
                        case context.current.token
                        when Lexical.TOKEN.ARRAY_DEF:
                            result = new Tree.Type.ARRAY(result.location .. context.location, result);
                            context.next_token();
                        when Lexical.TOKEN.REF:
                            result = new Tree.Type.REFERENCE(result.location .. context.location, result);
                            context.next_token();
                        when Lexical.TOKEN.PTR:
                            result = new Tree.Type.POINTER(result.location .. context.location, result);
                            context.next_token();
                        when Lexical.TOKEN.ARROW_THIN:
                            context.next_token();
                            var return_type = parse(context);
                            var arguments = new Tree.Type.LIST(element.location, [element]: Tree.Type.NODE );
                            result = new Tree.Type.FUNCTION(result.location .. return_type.location, arguments, return_type);
                        default
                            return result;
                        esac
                    od
                si

                other_token(context: CONTEXT) -> Tree.Type.NODE is
                    super.other_token(context);
                    return new Tree.Type.UNDEFINED(context.location);
                si

            si

        si
    si
si
