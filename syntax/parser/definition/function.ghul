namespace Syntax is
    namespace Parser is
        namespace Definition is
            use System;
            use Source;
            class FUNCTION : BASE[Tree.Definition.FUNCTION]  is
                identifier_function_name_parser: Parser[Tree.Identifier.NODE];
                type_parser: Parser[Tree.Type.NODE];
                modifier_list_parser: Parser[Tree.Modifier.LIST];
                body_parser: Parser[Tree.Body.NODE];
                variable_list_parser: Parser[Tree.Variable.LIST];

                init(identifier_function_name_parser: Parser[Tree.Identifier.NODE], type_parser: Parser[Tree.Type.NODE], modifier_list_parser: Parser[Tree.Modifier.LIST], body_parser: Parser[Tree.Body.NODE], variable_list_parser: Parser[Tree.Variable.LIST]) -> void is
                    super.init();
                    self.identifier_function_name_parser = identifier_function_name_parser;
                    self.type_parser = type_parser;
                    self.modifier_list_parser = modifier_list_parser;
                    self.body_parser = body_parser;
                    self.variable_list_parser = variable_list_parser;
                si

                parse(context: CONTEXT) -> Tree.Definition.FUNCTION is
                    var start = context.location;
                    var name = identifier_function_name_parser.parse(context);
                    context.next_token(Lexical.TOKEN.PAREN_OPEN);
                    var arguments: Tree.Variable.LIST;

                    if context.current_token != Lexical.TOKEN.PAREN_CLOSE then
                        arguments = variable_list_parser.parse(context);
                    else
                        arguments = new Tree.Variable.LIST(context.location, new Tree.Variable.NODE[](0));
                    fi
                    
                    context.next_token(Lexical.TOKEN.PAREN_CLOSE);
                    var type: Tree.Type.NODE;
                    if context.current.token == Lexical.TOKEN.ARROW_THIN then
                        context.next_token();
                        type = type_parser.parse(context);
                    else
                        type = new Tree.Type.INFER(context.location);
                    fi
                    var modifiers = modifier_list_parser.parse(context);
                    var expect_semicolon = context.current.token != Lexical.TOKEN.IS;
                    var body = body_parser.parse(context);
                    var result = new Tree.Definition.FUNCTION(
                        start .. context.location, 
                        name, 
                        arguments, 
                        type, 
                        modifiers, 
                        body
                    );
                    if expect_semicolon then
                        context.next_token(Lexical.TOKEN.SEMICOLON);
                    fi
                    return result;
                si

            si

        si
    si
si
