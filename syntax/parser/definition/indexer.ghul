namespace Syntax.Parser.Definition is
    use System;
    use Generic;
    
    use Source;

    class INDEXER : BASE[Tree.Definition.INDEXER]  is
        identifier_parser: Parser[Tree.Identifier.NODE];
        type_parser: Parser[Tree.TypeExpression.NODE];
        modifier_list_parser: Parser[Tree.Modifier.LIST];
        variable_parser: Parser[Tree.Variable.NODE];
        body_parser: Parser[Tree.Body.NODE];
        description: String => "indexer";

        init(
            identifier_parser: Parser[Tree.Identifier.NODE],
            type_parser: Parser[Tree.TypeExpression.NODE],
            modifier_list_parser: Parser[Tree.Modifier.LIST],
            variable_parser: Parser[Tree.Variable.NODE],
            body_parser: Parser[Tree.Body.NODE]
        )
        is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.modifier_list_parser = modifier_list_parser;
            self.variable_parser = variable_parser;
            self.body_parser = body_parser;
        si

        parse(context: CONTEXT) -> Tree.Definition.INDEXER is
            var name: Tree.Identifier.NODE;
            var start = context.location;

            if context.current.token == Lexical.TOKEN.IDENTIFIER then
                name = identifier_parser.parse(context);
            fi

            context.next_token(Lexical.TOKEN.SQUARE_OPEN);
            var index_argument = variable_parser.parse(context);
            context.next_token(Lexical.TOKEN.SQUARE_CLOSE);
            var type_expression: Tree.TypeExpression.NODE;

            if context.current.token == Lexical.TOKEN.COLON then
                context.next_token();
                type_expression = type_parser.parse(context);
            else
                type_expression = new Tree.TypeExpression.INFER(context.location);
            fi

            var modifiers = modifier_list_parser.parse(context);
            var read_body: Tree.Body.NODE;
            var assign_body: Tree.Body.NODE;
            var setter_argument_name: Tree.Identifier.NODE;
            var expect_semicolon = true;

            do
                if context.current.token == Lexical.TOKEN.ASSIGN then
                    if setter_argument_name != null then
                        context.error(context.location, "replacing assign");
                    fi
                    context.next_token();
                    setter_argument_name = identifier_parser.parse(context);
                    expect_semicolon = context.current.token == Lexical.TOKEN.ARROW_FAT;
                    assign_body = body_parser.parse(context);
                    if context.current.token == Lexical.TOKEN.COMMA then
                        context.next_token();
                    else
                        break;
                    fi
                elif [Lexical.TOKEN.IS, Lexical.TOKEN.ARROW_FAT].contains(context.current.token) then
                    expect_semicolon = context.current.token == Lexical.TOKEN.ARROW_FAT;
                    if read_body != null then
                        context.error(context.location, "replacing read");
                    fi
                    read_body = body_parser.parse(context);
                    if context.current.token == Lexical.TOKEN.COMMA then
                        context.next_token();
                    else
                        break;
                    fi
                else
                    context.error(context.location, "unexpected input in indexer");
                    break;
                fi
            od

            var result = new Tree.Definition.INDEXER(
                start..context.location, 
                name, 
                index_argument, 
                type_expression, 
                modifiers, 
                read_body, 
                setter_argument_name, 
                assign_body
            );

            if expect_semicolon then
                context.next_token(Lexical.TOKEN.SEMICOLON);
            fi

            return result;
        si
    si
si
