namespace Syntax.Parser.Definition is
    use System;
    use Source;

    class PROPERTY: BASE[Tree.Definition.PROPERTY] is
        identifier_parser: Parser[Tree.Identifier.NODE];
        type_parser: Parser[Tree.TypeExpression.NODE];
        modifier_list_parser: Parser[Tree.Modifier.LIST];
        definition_list_parser: Parser[Tree.Definition.LIST];
        body_parser: Parser[Tree.Body.NODE];

        init(
            identifier_parser: Parser[Tree.Identifier.NODE],
            type_parser: Parser[Tree.TypeExpression.NODE],
            modifier_list_parser: Parser[Tree.Modifier.LIST],
            definition_list_parser: Parser[Tree.Definition.LIST],
            body_parser: Parser[Tree.Body.NODE]
        ) is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.modifier_list_parser = modifier_list_parser;
            self.definition_list_parser = definition_list_parser;
            self.body_parser = body_parser;
        si

        parse(context: CONTEXT) -> Tree.Definition.PROPERTY is
            var fail = false;
            var progress = false;

            var start = context.location;
            var name = identifier_parser.parse(context);
            var type_expression: Tree.TypeExpression.NODE;

            if context.current.token == Lexical.TOKEN.COLON then
                context.next_token();
                progress = true;

                type_expression = type_parser.parse(context);

                if type_expression == null || type_expression.is_poisoned then
                    fail = true;
                fi                
            else
                type_expression = new Tree.TypeExpression.INFER(context.location);
            fi

            var modifiers = modifier_list_parser.parse(context);
            var read_body: Tree.Body.NODE;
            var assign_body: Tree.Body.NODE;
            var setter_argument_name: Tree.Identifier.NODE;
            var expect_semicolon = true;

            do                
                if context.current.token == Lexical.TOKEN.ASSIGN then
                    if setter_argument_name? then
                        context.error(context.location, "replacing assign");
                    fi

                    context.next_token();
                    progress = true;

                    setter_argument_name = identifier_parser.parse(context);
                    expect_semicolon = context.current.token == Lexical.TOKEN.ARROW_FAT;
                    assign_body = body_parser.parse(context);

                    if context.current.token == Lexical.TOKEN.COMMA then
                        context.next_token();
                        progress = true;
                    else
                        if isa Tree.Body.NULL(assign_body) then
                            expect_semicolon = true;
                        fi

                        break;
                    fi
                elif [Lexical.TOKEN.IS, Lexical.TOKEN.ARROW_FAT].contains(context.current.token) then
                    expect_semicolon = context.current.token == Lexical.TOKEN.ARROW_FAT;

                    if read_body? then
                        context.error(context.location, "replacing read");
                    fi

                    read_body = body_parser.parse(context);

                    if context.current.token == Lexical.TOKEN.COMMA then
                        context.next_token();
                        progress = true;
                    else
                        if isa Tree.Body.NULL(read_body) then
                            expect_semicolon = true;
                        else
                            progress = true;
                        fi
                        
                        break;
                    fi
                elif context.current_token == Lexical.TOKEN.SEMICOLON then
                    break;
                elif context.current_token == Lexical.TOKEN.COMMA then
                    if read_body? then
                        context.error(context.location, "replacing read");
                    elif assign_body? then
                        context.error(context.location, "empty read body must precede write body");                        
                    else
                        progress = true;
                        context.next_token();
                        
                        read_body = new Syntax.Tree.Body.NULL(context.current.location);
                    fi
                else
                    if !fail then
                        context.error(context.location, "unexpected input in property");
                    fi

                    fail = true;

                    break;
                fi

                expect_semicolon = true;
            od

            if context.in_trait && read_body == null then
                read_body = new Tree.Body.NULL(context.location);
            fi            

            var result =
                new Tree.Definition.PROPERTY(
                    start::context.location, 
                    type_expression, 
                    name, 
                    modifiers, 
                    read_body, 
                    setter_argument_name, 
                    assign_body
                );

            if expect_semicolon then
                if !fail || context.current.token == Lexical.TOKEN.SEMICOLON then
                    context.next_token(Lexical.TOKEN.SEMICOLON);
                fi
            fi

            if !fail then
                return result;
            else
                IO.Std.err.println("fail property at " + result.location);
                IO.Std.err.println("fail property: " + result);

                if !progress then
                    IO.Std.err.println("no progress so consume next token: " + context.current_token_name);                    
                    context.next_token();    
                fi
                
                return null;
            fi
        si
    si
si
