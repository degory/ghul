namespace Syntax.Parser.Statement is
    use System;
    use Generic;

    use Source;

    class LIST : BASE[Tree.Statement.LIST]  is
        terminators: List[Lexical.TOKEN];
        statement_parser: Parser[Tree.Statement.NODE];
        description: String => "statement list";

        init(terminators: List[Lexical.TOKEN], statement_parser: Parser[Tree.Statement.NODE]) is
            super.init();
            
            self.terminators = terminators;
            self.statement_parser = statement_parser;
        si

        parse(context: CONTEXT) -> Tree.Statement.LIST is
            self.terminators = terminators;

            var start = context.location;
            var end = context.location;
            var statements = new Vector[Tree.Statement.NODE]();

            while !context.is_end_of_file && !at_terminator(context) do
                if context.current.token == Lexical.TOKEN.SEMICOLON then
                    IoC.CONTAINER.instance.logger.warn(context.current.location, "empty statement");
                    context.next_token();
                else                
                    try
                        var statement = statement_parser.parse(context);
                        
                        if statement? then
                            statements.add(statement);
                        fi
                    catch e: Exception
                        while !terminators.contains(context.current.token) do
                            context.next_token();
                        od 
                    yrt
                fi
            od

            return new Tree.Statement.LIST(start::end, statements);
        si

        at_terminator(context: CONTEXT) -> bool => terminators.contains(context.current.token);
    si
si
