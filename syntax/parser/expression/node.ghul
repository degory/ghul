namespace Syntax.Parser.Expression is
    use System;
    use Generic;

    use Logging;
    use Source;

    enum PRECEDENCE is
        NONE, 
        MIN, 
        UNDEFINED, 
        BOOLEAN, 
        RELATIONAL, 
        RANGE, 
        SHIFT, 
        BITWISE, 
        ADDITION, 
        MULTIPLICATION, 
        MEMBER, 
        PRIMARY
    si

    class NODE: BASE[Tree.Expression.NODE] is
        _precedence: Dict[String,PRECEDENCE];
        _real_operation: Dict[String,String];

        expression_tertiary_parser: Parser[Tree.Expression.NODE];

        init(expression_tertiary_parser: Parser[Tree.Expression.NODE]) is
            super.init();
            self.expression_tertiary_parser = expression_tertiary_parser;
            _precedence = new Map[String,PRECEDENCE]();

            _precedence["*"] = PRECEDENCE.MULTIPLICATION;
            _precedence["/"] = PRECEDENCE.MULTIPLICATION;
            _precedence["%"] = PRECEDENCE.MULTIPLICATION;
            _precedence["+"] = PRECEDENCE.ADDITION;
            _precedence["-"] = PRECEDENCE.ADDITION;
            _precedence["&"] = PRECEDENCE.BITWISE;
            _precedence["|"] = PRECEDENCE.BITWISE;
            _precedence["^"] = PRECEDENCE.BITWISE;
            _precedence[".."] = PRECEDENCE.RANGE;
            _precedence["::"] = PRECEDENCE.RANGE;
            _precedence["<<"] = PRECEDENCE.SHIFT;
            _precedence[">>"] = PRECEDENCE.SHIFT;
            _precedence["=="] = PRECEDENCE.RELATIONAL;
            _precedence["!="] = PRECEDENCE.RELATIONAL;
            _precedence["=~"] = PRECEDENCE.RELATIONAL;
            _precedence["!~"] = PRECEDENCE.RELATIONAL;
            _precedence["<"] = PRECEDENCE.RELATIONAL;
            _precedence[">"] = PRECEDENCE.RELATIONAL;
            _precedence[">="] = PRECEDENCE.RELATIONAL;
            _precedence["<="] = PRECEDENCE.RELATIONAL;
            _precedence["&&"] = PRECEDENCE.BOOLEAN;
            _precedence["||"] = PRECEDENCE.BOOLEAN;

            _real_operation = new Map[String,String]();

            _real_operation["!~"] = "=~";
            _real_operation["=~"] = "=~";
            _real_operation["<"] = ">";
            _real_operation["<="] = ">";
            _real_operation[">"] = ">";
            _real_operation[">="] = ">";
        si

        description: String => "expression";

        precedence(context: CONTEXT) -> PRECEDENCE is
            if context.current.token != Lexical.TOKEN.OPERATOR then
                return PRECEDENCE.NONE;
            fi

            var result = _precedence[context.current.string];

            if result == PRECEDENCE.NONE then
                context.error(context.current.location, 
                "operator '" + context.current.string + "' has unknown precedence");
                return PRECEDENCE.UNDEFINED;
            fi

            return result;
        si

        parse(context: CONTEXT) -> Tree.Expression.NODE is
            try
                return parse(context, expression_tertiary_parser.parse(context), PRECEDENCE.MIN);                                       
            catch e: Exception
                IO.Std.err.println("caught exception parsing expression: " + e); 

                return new Tree.Expression.Literal.NONE(context.location);
            yrt
        si

        // precedence climbing expression parser:
        parse(context: CONTEXT, left: Tree.Expression.NODE, min_precedence: PRECEDENCE) -> Tree.Expression.NODE is
            do
                var left_precedence = precedence(context);

                if left_precedence < min_precedence then
                    break;
                fi

                let s = left_precedence.toString();

                let apparent_op = context.current.string;
                let real_op = _real_operation[apparent_op];
                if real_op == null then
                    real_op = apparent_op;
                fi
                
                let op = new Tree.Identifier.NODE(context.location, real_op);

                context.next_token();

                var right: Tree.Expression.NODE = expression_tertiary_parser.parse(context);

                if right == null then
                    IO.Std.err.println("oops: parse right failed");
                    return left;
                fi

                do
                    var right_precedence = precedence(context);

                    if right_precedence <= left_precedence then
                        break;
                    fi

                    right = parse(context, right, right_precedence);
                od

                left = new Tree.Expression.BINARY(left.location::right.location, op, apparent_op, left, right);
            od

            return left;
        si
    si
si
