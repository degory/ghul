namespace Syntax.Parser.Expression is
    use System;

    use Source;

    class PRIMARY: BASE[Tree.Expression.NODE] is
        identifier_parser: Parser[Tree.Identifier.NODE];
        type_parser: Parser[Tree.TypeExpression.NODE];
        expression_parser: Parser[Tree.Expression.NODE];
        expression_list_parser: Parser[Tree.Expression.LIST];
        expression_tuple_parser: Parser[Tree.Expression.TUPLE];

        description: String => "primary expression";

        init(
            identifier_parser: Parser[Tree.Identifier.NODE],
            type_parser: Parser[Tree.TypeExpression.NODE],
            expression_parser: Parser[Tree.Expression.NODE],
            expression_list_parser: Parser[Tree.Expression.LIST],
            expression_tuple_parser: Parser[Tree.Expression.TUPLE]
        )
        is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.expression_parser = expression_parser;
            self.expression_list_parser = expression_list_parser;
            self.expression_tuple_parser = expression_tuple_parser;

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var name = new Tree.Identifier.NODE(context.location, context.current_string);
                    context.next_token();
                    var right = parse(context);

                    return new Tree.Expression.UNARY(name.location..right.location, name, right);
                si,
                Lexical.TOKEN.OPERATOR
            );
            
            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var start = context.location;
                    var identifier = identifier_parser.parse(context);
                    if context.allow_tuple_element && !isa Tree.Identifier.QUALIFIED(identifier) then
                        context.allow_tuple_element = false;
                        var end = identifier.location;
                        var type: Tree.TypeExpression.NODE;
                        var initializer: Tree.Expression.NODE;
                        if context.current.token == Lexical.TOKEN.COLON then
                            context.next_token();
                            type = type_parser.parse(context);
                            end = type.location;
                        fi
                        if context.current.token == Lexical.TOKEN.ASSIGN then
                            context.next_token();
                            initializer = expression_parser.parse(context);
                            end = initializer.location;
                        fi
                        if initializer != null then
                            if type == null then
                                type = new Tree.TypeExpression.INFER(context.location);
                            fi
                        fi
                        if type != null then
                            return new Tree.Expression.VARIABLE(start..end, identifier, type, initializer);
                        fi
                    fi

                    return new Tree.Expression.IDENTIFIER(identifier.location, identifier);
                si, Lexical.TOKEN.IDENTIFIER
            );
            
            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var start = context.location;
                    context.next_token();
                    var elements = expression_list_parser.parse(context);
                    var type: Tree.TypeExpression.NODE;
                    var end = context.location;
                    context.next_token(Lexical.TOKEN.SQUARE_CLOSE);
                    if context.current.token == Lexical.TOKEN.COLON then
                        context.next_token();
                        type = type_parser.parse(context);
                        end = type.location;
                    else
                        type = new Tree.TypeExpression.INFER(start..end);
                    fi

                    return new Tree.Expression.SEQUENCE(start..end, elements, type);
                si,
                Lexical.TOKEN.SQUARE_OPEN
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    return expression_tuple_parser.parse(context);
                si,
                Lexical.TOKEN.PAREN_OPEN
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var start = context.location;
                    context.next_token(Lexical.TOKEN.NEW);
                    var type = type_parser.parse(context);
                    var arguments = expression_tuple_parser.parse(context);
                    return new Tree.Expression.NEW(start..arguments.location, type, arguments);
                si,
                Lexical.TOKEN.NEW
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var start = context.location;
                    context.next_token(Lexical.TOKEN.CAST);
                    var type = type_parser.parse(context);
                    context.next_token(Lexical.TOKEN.PAREN_OPEN);
                    var value = expression_parser.parse(context);
                    var result = new Tree.Expression.CAST(start..context.location, type, value);
                    context.next_token(Lexical.TOKEN.PAREN_CLOSE);
                    return result;
                si,
                Lexical.TOKEN.CAST
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var start = context.location;
                    context.next_token(Lexical.TOKEN.ISA);
                    var type = type_parser.parse(context);
                    context.next_token(Lexical.TOKEN.PAREN_OPEN);
                    var value = expression_parser.parse(context);
                    var result = new Tree.Expression.ISA(start..context.location, type, value);
                    context.next_token(Lexical.TOKEN.PAREN_CLOSE);
                    return result;
                si,
                Lexical.TOKEN.ISA
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var location = context.location;
                    var string = context.current.string;
                    context.next_token();
                    return new Tree.Expression.Literal.INTEGER(location, string);
                si,
                Lexical.TOKEN.INT_LITERAL
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var location = context.location;
                    var string = context.current.string;
                    context.next_token();
                    return new Tree.Expression.Literal.STRING(location, string);
                si,
                Lexical.TOKEN.STRING_LITERAL
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var location = context.location;
                    var string = context.current.string;
                    context.next_token();
                    return new Tree.Expression.Literal.CHARACTER(location, string);
                si,
                Lexical.TOKEN.CHAR_LITERAL
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var location = context.location;
                    context.next_token();
                    return new Tree.Expression.Literal.NONE(location);
                si,
                Lexical.TOKEN.NONE
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var location = context.location;
                    context.next_token();
                    return new Tree.Expression.NULL(location);
                si,
                Lexical.TOKEN.NULL
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var location = context.location;
                    context.next_token();
                    return new Tree.Expression.SELF(location);
                si,
                Lexical.TOKEN.SELF
            );

            add_parser(
                (context: CONTEXT) -> Tree.Expression.NODE is
                    var location = context.location;
                    context.next_token();
                    return new Tree.Expression.SUPER(location);
                si, Lexical.TOKEN.SUPER
            );
        si
    si
si
