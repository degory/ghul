namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;

    class RESOLVE_ANCESTORS: ScopedVisitor is
        _logger: LOGGER;
        _symbol_table: Semantic.SYMBOL_TABLE;

        init(
            logger: LOGGER,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES
        )
        is
            super.init(logger, symbol_table, namespaces);

            _symbol_table = symbol_table;
            
            _logger = logger;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        visit(function: Tree.Definition.FUNCTION) is
            let symbol = _symbol_table.current_function;            

            let types = new Vector[Semantic.Type.BASE]();

            for argument in function.arguments do
                let type = argument.type_expression.type;

                IO.Std.err.println("function argument: " + type);

                types.add(type);
            od

            symbol.arguments = types;
            IO.Std.err.println("set type arguments " + symbol + " (" + types + ")");

            super.visit(function);
        si                

        visit(class_: Tree.Definition.CLASS) is
            IO.Std.err.println("visit class: " + class_.name);

            let class_symbol = cast Semantic.Symbol.CLASS(_symbol_table.current_instance_context);

            IO.Std.err.println("class symbol: " + class_symbol);

            // exit class scope before looking up ancestors:
            super.visit(class_);

            // FIXME: implicit ancestor Ghul.Object
            if class_.ancestors == null then
                return;
            fi

            for a in class_.ancestors do
                IO.Std.err.println("ancestor type expression: " + a);
                var ancestor_type = a.type;

                IO.Std.err.println("ancestor type: " + a.type);

                if isa Semantic.Type.NAMED(ancestor_type) then               
                    var ancestor_symbol = cast Semantic.Type.NAMED(ancestor_type).symbol;
            
                    class_symbol.add_inherited_scope(cast Semantic.Scope(ancestor_symbol));
                else
                    _logger.error(a.location, "cannot inherit from this");
                fi
            od

            IO.Std.err.println("class with ancestors: " + class_symbol);
        si

        visit(trait_: Tree.Definition.INTERFACE) is
            IO.Std.err.println("visit trait: " + trait_.name);

            let trait_symbol = cast Semantic.Symbol.TRAIT(_symbol_table.current_instance_context);

            IO.Std.err.println("trait symbol: " + trait_symbol);

            // exit class scope before looking up ancestors:
            super.visit(trait_);

            if trait_.ancestors == null then
                return;
            fi            

            for a in trait_.ancestors do
                var ancestor_type = a.type;
                IO.Std.err.println("ancestor type expression: " + a);

                if isa Semantic.Type.NAMED(ancestor_type) then
                    var ancestor_symbol = cast Semantic.Type.NAMED(ancestor_type).symbol;
            
                    trait_symbol.add_inherited_scope(cast Semantic.Scope(ancestor_symbol));
                else
                    _logger.error(a.location, "cannot inherit from this");
                fi
            od

            IO.Std.err.println("trait with ancestors: " + trait_symbol);            
        si
    si
si
