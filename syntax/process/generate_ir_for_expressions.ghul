namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Source;

    class GENERATE_IR_FOR_EXPRESSIONS: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _generic_cache: Semantic.GENERIC_CACHE;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            generic_cache: Semantic.GENERIC_CACHE
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _generic_cache = generic_cache;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _system_symbol_lookup = system_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        pre(for_: Tree.Statement.FOR) -> bool is
            super.pre(for_);

            var symbol = find(for_.variable.name);
        si        

        pre(assignment: Tree.Statement.ASSIGNMENT) -> bool is
            super.pre(assignment);
        si

        pre(function: Tree.Expression.FUNCTION) -> bool is
            super.pre(function);
        si

        visit(function: Tree.Expression.FUNCTION) is
            super.visit(function);
        si

        visit(tuple: Tree.Expression.TUPLE) is
        si

        visit(sequence: Tree.Expression.SEQUENCE) is
        si        

        visit(self_: Tree.Expression.SELF) is
        si

        visit(super_: Tree.Expression.SUPER) is
        si

        visit(native_: Tree.Expression.NATIVE) is
        si        

        visit(cast_: Tree.Expression.CAST) is
        si

        visit(new_: Tree.Expression.NEW) is
        si

        visit(unary: Tree.Expression.UNARY) is
        si        

        visit(binary: Tree.Expression.BINARY) is
        si

        visit(index: Tree.Expression.INDEX) is
        si

        visit(member: Tree.Expression.MEMBER) is
        si
        
        visit(variable: Tree.Variable.NODE) is
        si

        visit(integer: Tree.Expression.Literal.INTEGER) is
        si

        visit(string: Tree.Expression.Literal.STRING) is
        si        

        visit(call: Tree.Expression.CALL) is
        si

        visit(identifier: Tree.Expression.IDENTIFIER) is
        si
    si
si
