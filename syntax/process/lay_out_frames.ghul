namespace Syntax.Process is
    use System;
    use Generic;

    use Logging;

    class LAY_OUT_FRAMES: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _generic_cache: Semantic.GENERIC_CACHE;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _frame_factory: IR.FRAME_FACTORY;
        _type_repository: IR.TYPE_REPOSITORY;

        _builder: IR.BUILDER;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            generic_cache: Semantic.GENERIC_CACHE,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            namespaces: Semantic.NAMESPACES,
            frame_factory: IR.FRAME_FACTORY,
            type_repository: IR.TYPE_REPOSITORY
        )
        is
            super.init(logger, symbol_table, namespaces);

            _symbol_table = symbol_table;
            _generic_cache = generic_cache;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _logger = logger;
            _frame_factory = frame_factory;
            _type_repository = type_repository;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        pre(trait_: Tree.Definition.TRAIT) -> bool is
            super.pre(trait_);

            let symbol = _symbol_table.current_instance_context;

            let action = (args: List[Semantic.Type.BASE]) -> void use symbol is
                if args? && args.Length > 0 then
                    IO.Std.err.println("walk generic specialization: " + symbol.qualified_name + "[" + args + "]");
                else
                    IO.Std.err.println("walk plain: " + symbol.qualified_name);
                fi

                symbol.create_frame(_frame_factory);
            si;

            return true;
        si

        pre(class_: Tree.Definition.CLASS) -> bool is
            super.pre(class_);

            let symbol = _symbol_table.current_instance_context;

            let action = (args: List[Semantic.Type.BASE]) -> void use symbol is
                if args? && args.Length > 0 then
                    IO.Std.err.println("walk generic specialization: " + symbol.qualified_name + "[" + args + "]");
                else
                    IO.Std.err.println("walk plain: " + symbol.qualified_name);
                fi

                symbol.create_frame(_frame_factory);
            si;

            return true;
        si

        pre(struct_: Tree.Definition.STRUCT) -> bool is
            super.pre(struct_);

            let symbol = _symbol_table.current_instance_context;

            let action = (args: List[Semantic.Type.BASE]) -> void use symbol is
                if args? && args.Length > 0 then
                    IO.Std.err.println("walk generic specialization: " + symbol.qualified_name + "[" + args + "]");
                else
                    IO.Std.err.println("walk plain: " + symbol.qualified_name);
                fi

                symbol.create_frame(_frame_factory);
            si;

            return true;
        si

        pre(function: Tree.Definition.FUNCTION) -> bool is
            super.pre(function);

            let symbol = _symbol_table.current_function;

            if symbol? then
                if symbol.override? then
                    IO.Std.err.println("function " + symbol.qualified_name + " should pick up slot number from " + symbol.override.qualified_name);
                fi

                /*
                for f in symbol.specializations do
                    let key = new Semantic.GENERIC_KEY(null, symbol, f);
                    let specialization =  _generic_cache[key];

                    IO.Std.err.println("    " + symbol.qualified_name + "[" + f + "] -> " + specialization);
                od
                */

                symbol.allocate(_builder, _type_repository, _ghul_symbol_lookup);

                symbol.create_frame(_frame_factory);
            fi
        si

        // FIXME: think we're doing this twice:
        visit(variable: Tree.Variable.NODE) is
            if variable.name == null then
                return;
            fi

            var symbol = find(variable.name);

            if symbol? then
                let context = symbol.owner;

                symbol.allocate(_builder, _type_repository, _ghul_symbol_lookup);
            fi
        si

        visit(variable: Tree.Expression.VARIABLE) is
            if variable.name == null then
                return;
            fi

            var symbol = find(variable.name);

            if symbol? then
                symbol.allocate(_builder, _type_repository, _ghul_symbol_lookup);
            fi
        si
    si
si
