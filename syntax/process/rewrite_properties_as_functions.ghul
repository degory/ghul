namespace Syntax.Process is
    use System;
    use Generic;

    use Source;
    use Tree;

    class REWRITE_PROPERTIES_AS_FUNCTIONS: Visitor  is
        _stack: Vector[Definition.LIST];

        enclosing_definition: Definition.LIST => _stack.Top;

        init() is
            super.init();

            _stack = new Vector[Definition.LIST]();
        si

        apply(root: NODE) is
            root.walk(self);
        si

        pre(property: Definition.PROPERTY) -> bool is
            IO.Std.err.println("rewrite property: " + property);

            var name =
                new Identifier.NODE(
                    property.name.location,
                    "$" + property.name.name
                );

            // FIXME: ought to be safe with current implemenation of Vector, but
            // shouldn't really change parent's definition list whilst iterating over it

            if property.read_body != null then
                enclosing_definition.add(
                    new Definition.FUNCTION(
                        property.location,
                        name.copy(),
                        new Variable.LIST(LOCATION.dummy, new Variable.NODE[](0)),
                        property.type.copy(),
                        property.modifiers.copy(),
                        property.read_body
                    )
                );
            fi

            if property.assign_body != null then
                enclosing_definition.add(
                    new Definition.FUNCTION(
                        property.location,
                        name.copy(),
                        new Variable.LIST(LOCATION.dummy, [
                            new Variable.NODE(
                                property.assign_argument.location,
                                property.assign_argument.copy(),
                                property.type.copy(),
                                null
                            )
                        ]),
                        new Type.NAMED(
                            LOCATION.dummy,
                            new Identifier.NODE(
                                LOCATION.dummy,
                                "void"
                            )
                        ),
                        property.modifiers.copy(),
                        property.assign_body
                    )
                );
            fi

            if property.read_body == null && property.assign_body == null then
                let variable_name =
                    new Identifier.NODE(
                        property.name.location,
                        "@" + property.name.name
                    );
            
                enclosing_definition.add(
                    new Variable.NODE(
                        property.location,
                        variable_name,
                        property.type.copy(),
                        null
                    )
                );
            fi

            // not safe:
            // enclosing_definition.remove(property);

            IO.Std.err.println("enclosing now: " + enclosing_definition);            
                       
            return true;
        si

        pre(indexer: Definition.INDEXER) -> bool is
            IO.Std.err.println("rewrite indexer: " + indexer);

            var name: Identifier.NODE; 

            if indexer.name != null then
                name =
                    new Identifier.NODE(
                        indexer.name.location,
                        "[]" + indexer.name.name
                    );
            else
                name =
                    new Identifier.NODE(
                        LOCATION.dummy,
                        "[]"
                    );
            fi

            if indexer.read_body != null then
                enclosing_definition.add(
                    new Definition.FUNCTION(
                        indexer.location,
                        name,
                        new Variable.LIST(LOCATION.dummy, [indexer.index_argument.copy()]),
                        indexer.type.copy(),
                        indexer.modifiers.copy(),
                        indexer.read_body
                    )
                );
            fi

            if indexer.assign_body != null then
                enclosing_definition.add(
                    new Definition.FUNCTION(
                        indexer.location,
                        name,
                        new Variable.LIST(LOCATION.dummy, [
                            indexer.index_argument.copy(),
                            new Variable.NODE(
                                indexer.assign_argument.location,
                                indexer.assign_argument.copy(),
                                indexer.type.copy(),
                                null
                            )
                        ]),
                        new Type.NAMED(
                            LOCATION.dummy,
                            new Identifier.NODE(
                                LOCATION.dummy,
                                "void"
                            )
                        ),
                        indexer.modifiers.copy(),
                        indexer.assign_body
                    )
                );
            fi

            // not safe:
            // enclosing_definition.remove(indexer);

            IO.Std.err.println("enclosing now: " + enclosing_definition);            
                       
            return true;
        si

        pre(class_: Definition.CLASS) -> bool is
            _stack.add(class_.body);

            return false;
        si

        visit(class_: Definition.CLASS) is
            _stack.pop();
        si

        pre(interface_: Definition.INTERFACE) -> bool is
            _stack.add(interface_.body);

            return false;
        si

        visit(interface_: Definition.INTERFACE) is
            _stack.pop();
        si

        pre(namespace_: Definition.NAMESPACE) -> bool is
            _stack.add(namespace_.body);

            return false;
        si

        visit(namespace_: Definition.NAMESPACE) is
            _stack.pop();
        si        
    si
si
