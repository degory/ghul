namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Tree;
    use Source;

    class GENERATE_IL: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _generic_cache: Semantic.GENERIC_CACHE;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            generic_cache: Semantic.GENERIC_CACHE,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _generic_cache = generic_cache;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _system_symbol_lookup = system_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;

            _depth = 0;
            _indent = 2;
        si

        println(string: String) is
            print(string);
            println();
        si

        print(string: String) is
            print_indent();
            IO.Std.err.print(string);
        si

        print(c: char) is
            print_indent();
            IO.Std.err.print("" + c);
        si

        println() is
            _indent_needed = true;
            IO.Std.err.println("");
        si

        indent() is
            _depth = _depth + 1;
        si

        outdent() is
            _depth = _depth - 1;
        si

        print_indent() is
            if _indent_needed then
                var i = 0;
                while i < _indent*_depth do
                    IO.Std.err.print(" ");
                    i = i + 1;
                od
                _indent_needed = false;
            fi
        si        

        apply(root: Tree.NODE) is
            root.walk(self);
        si


        pre(class_: Definition.CLASS) -> bool is
            let symbol = symbol_for(class_);
            
            println("class " + symbol);

            enter_scope(class_);

            indent();
        si

        visit(class_: Definition.CLASS) is
            outdent();

            leave_scope(class_);
        si

        pre(trait_: Definition.TRAIT) -> bool is
            let symbol = symbol_for(trait_);
            
            println("trait " + symbol);

            enter_scope(trait_);

            indent();
        si

        visit(trait_: Definition.TRAIT) is
            outdent();

            leave_scope(trait_);
        si

        pre(struct_: Definition.STRUCT) -> bool is
            enter_scope(struct_);
        si

        visit(struct_: Definition.STRUCT) is
            leave_scope(struct_);
        si        

        pre(enum_: Definition.ENUM) -> bool is
            enter_scope(enum_);
        si

        visit(enum_: Definition.ENUM) is
            leave_scope(enum_);
        si

        pre(function: Definition.FUNCTION) -> bool is
            let symbol = symbol_for(function);

            println("function " + symbol);

            enter_scope(function);

            indent();
        si

        visit(function: Definition.FUNCTION) is
            outdent();

            leave_scope(function);            
        si

        visit(assign: Statement.ASSIGNMENT) is
            super.visit(assign);

            print("assign ");

            if assign.left? && assign.left.value? then
                print(assign.left.value.toString());
            fi

            print(" = ");

            if assign.right? && assign.right.value? then
                print(assign.right.value.toString());
            fi

            println();
        si

        visit(expression: Statement.EXPRESSION) is
            super.visit(expression);

            print("expression ");

            if expression.expression? && expression.expression.value? then
                print(expression.expression.value.toString());
            fi
        si

        /*
        visit(v: Statement.VAR) is
            v.variables.accept(self);
            println(";");
        si

        visit(r: Statement.RETURN) is
            print("return");
            if r.expression? then
                print(' ');
                r.expression.accept(self);
            fi
            println(";");
        si

        visit(t: Statement.THROW) is
            print("throw");
            if t.expression? then
                print(' ');
                t.expression.accept(self);
            fi
            println(";");
        si

        visit(i: Statement.IF) is

            var is_first = true;
            var seen_else = false;
            assert(i?);
            assert(i.branches?);
            for b in i.branches do
                assert(!seen_else);
                if b.condition? then
                    if is_first then
                        print("if ");
                    else
                        print("elif ");
                    fi
                    b.condition.accept(self);
                    println(" then");
                else
                    seen_else = true;
                    println("else");
                fi
                indent();
                b.body.accept(self);
                outdent();
                is_first = false;
            od
            println("fi");
        si

        visit(case_: Statement.CASE) is
            print("case ");
            case_.expression.accept(self);
            println();
            for m in case_.matches do
                m.accept(self);
            od
            println("esac");
        si

        visit(match: Statement.CASE_MATCH) is
            if match.expressions? then
                print("when ");
                match.expressions.accept(self);
                println(":");
            else
                println("default");
            fi
            indent();
            match.statements.accept(self);
            outdent();
        si

        visit(try_: Statement.TRY) is
            println("try");
            indent();
            try_.body.accept(self);
            outdent();
            for c in try_.catches do
                c.accept(self);
            od
            if try_.finally_? then
                println("finally");
                indent();
                try_.finally_.accept(self);
                outdent();
            fi
            println("yrt");
        si

        visit(catch_: Statement.CATCH) is
            print("catch ");
            catch_.variable.accept(self);
            println();
            indent();
            catch_.body.accept(self);
            outdent();
        si

        visit(do_: Statement.DO) is
            if do_.condition? then
                print("while ");
                do_.condition.accept(self);
                print(" ");
            fi
            println("do");
            indent();
            do_.body.accept(self);
            outdent();
            println("od");
        si

        visit(labelled: Statement.LABELLED) is
            labelled.label.accept(self);
            print(": ");
            labelled.statement.accept(self);
        si

        visit(break_: Statement.BREAK) is
            print("break");
            if break_.label? then
                print(' ');
                break_.label.accept(self);
            fi
            println(";");
        si

        visit(continue_: Statement.CONTINUE) is
            print("continue");
            if continue_.label? then
                print(' ');
                continue_.label.accept(self);
            fi
            println(";");
        si
        */
    si
si
