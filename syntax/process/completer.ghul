namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Source;

    class COMPLETER: ScopedVisitor is
        _target_line: int;
        _target_column: int;

        _results: List[Semantic.Symbol.BASE];

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES
        )
        is
            super.init(logger, symbol_table, namespaces);
        si

        find_completions(root: Tree.NODE, target_line: int, target_column: int) -> Iterable[Semantic.Symbol.BASE]  is
            _target_line = target_line;
            _target_column = target_column;

            root.walk(self);

            return _results;
        si

        visit(member: Tree.Expression.MEMBER) is
            IO.Std.err.println("complete member: " + member);

            if member.identifier != null then
                if !(member.identifier.location.contains(_target_line, _target_column)) then
                    return;
                fi
            else
                if member.left.location.end_line != _target_line || member.left.location.end_column != _target_column-1 then
                    return;
                fi
            fi

            IO.Std.err.println("member completion hit: " + member);

            if member.left == null || member.left.value == null || member.left.value.type == null then
                IO.Std.err.println("member left too fubared to offer completion");
                return;
            fi
        si

/*
        visit(call: Tree.Expression.CALL) is
            try
                _visit(call);
            catch e: Exception
                call.value = null;

                IO.Std.err.println("something went wrong inferring type for call: " + call + "\n" + e);
            yrt
        si

        _visit(call: Tree.Expression.CALL) is
            if call.function.value == null then
                // _logger.error(call.function.location, "cannot call this");
                return;
            fi

            let arguments = new Vector[Semantic.Graph.Value.BASE]();
            let argument_types = new Vector[Semantic.Type.BASE]();

            for a in call.arguments do
                if a == null then
                    return;
                fi

                if a.value == null then
                    // _logger.error(a.location, "argument has no value");
                    return;
                fi

                if a.value.type == null then
                    // _logger.error(a.location, "argument has no type");
                    return;
                fi

                arguments.add(a.value);
                argument_types.add(a.value.type);
            od                

            if isa Semantic.Graph.Value.Load.SYMBOL(call.function.value) then
                let load = cast Semantic.Graph.Value.Load.SYMBOL(call.function.value);

                if load.symbol? && isa Semantic.Symbol.FUNCTION_GROUP(load.symbol) then
                    let function_group = cast Semantic.Symbol.FUNCTION_GROUP(load.symbol);
                    let function = _overload_resolver.resolve(call.location, function_group, argument_types);

                    if function == null then
                        // _logger.error(call.location, "no overload found");
                        return;
                    fi

                    _symbol_locations.add_symbol_use(call.function.location, function);

                    call.value = function.call(load.from, arguments, _function_caller);
                    
                    show(call.location, "" + call.value);

                    return;
                fi
            fi

            argument_types.add(new Semantic.Type.ANY());
            let expected_type = _innate_symbol_lookup.get_function_type(argument_types);

            if expected_type == null then
                _logger.error(call.location, "no innate function type found");
                return;
            fi

            if call.function.value.type == null then
                IO.Std.err.println("call.function.value.type is null: " + call);
                return;
            fi

            let function_generic_type = call.function.value.type.specialized_from;

            if function_generic_type? then
                let function_type_arguments = function_generic_type.arguments;

                if expected_type =~ function_generic_type then
                    let result_type = function_type_arguments[function_type_arguments.Length-1];

                    call.value =
                        new Semantic.Graph.Value.Call.CLOSURE(
                            call.function.value,
                            result_type,
                            arguments
                        );

                    show(call.location, "" + call.value);

                    return;                        
                elif function_generic_type.name =~ "FUNCTION_" + (function_type_arguments.Length-1) then
                    let expected_argument_types = new Vector[Semantic.Type.BASE]();

                    for i in 0::function_type_arguments.Length-1 do
                        expected_argument_types.add(function_type_arguments[i]);
                    od

                    _logger.error(call.arguments.location, "arguments (" + argument_types + ") not compatible with (" + expected_argument_types + ")" );

                    return;
                fi
            fi

            _logger.error(call.arguments.location, "cannot call through value of type " + call.function.value.type);
        si
*/
        visit(identifier: Tree.Expression.IDENTIFIER) is
            if !identifier.location.contains(_target_line, _target_column) then
                return;
            fi

            IO.Std.err.println("complete identifier: " + identifier);
        si
    si
si
