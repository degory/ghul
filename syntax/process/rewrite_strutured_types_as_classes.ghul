namespace Syntax.Process is
    use System;
    use Generic;

    use Logging;
    use Tree;

    class REWRITE_STRUCTURED_TYPES_AS_CLASSES : Visitor is
        _map: MAP;
        
        init() is
            super.init();
            _map = new MAP();
        si

        apply(root: NODE) is
            root.walk(self);
            var rewriter = new REWRITER(_map);
            rewriter.apply(root);
        si

        replace(node: NODE, name: String, element: TypeExpression.NODE) is
            var n = new TypeExpression.GENERIC(node.location, new Identifier.NODE(node.location, name), new TypeExpression.LIST(node.location, [element]: TypeExpression.NODE ));
            _map[node] = n;
        si

        replace(node: NODE, name: String, elements: Iterable[TypeExpression.NODE]) is
            var n = new TypeExpression.GENERIC(node.location, new Identifier.NODE(node.location, name), new TypeExpression.LIST(node.location, elements));

            _map[node] = n;
        si

        // FIXME: constructed type names all need to be explicitly qualified with Ghul namespace:

        visit(array: TypeExpression.ARRAY) is
            replace(array, "ARRAY", array.element);
        si

        visit(pointer: TypeExpression.POINTER) is
            replace(pointer, "POINTER", pointer.element);
        si

        visit(reference: TypeExpression.REFERENCE) is
            replace(reference, "REFERENCE", reference.element);
        si

        visit(function: TypeExpression.FUNCTION) is
            var elements = new Vector[TypeExpression.NODE]();
    
            for t in function.arguments do
                elements.add(t);
            od

            elements.add(function.result);

            replace(function, "FUNCTION_" + (elements.Length - 1), elements);
        si

        visit(tuple: TypeExpression.TUPLE) is
            var elements = new Vector[TypeExpression.NODE]();

            for t in tuple.elements do
                elements.add(t);
            od

            replace(tuple, "TUPLE_" + elements.Length, elements);
        si
    si
si
