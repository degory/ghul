namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;

    class INFER_TYPES: ScopedVisitor is
        _logger: LOGGER;
        // _map: Map[Tree.NODE,Type.BASE];
        _symbol_table: SYMBOL_TABLE;

        _int_type: Type.NAMED;

        init(
            logger: LOGGER,
            symbol_table: SYMBOL_TABLE,
            namespaces: NAMESPACES
        )
        is
            super.init(logger, symbol_table, namespaces);

            _symbol_table = symbol_table;
            
            _logger = logger;
            // _map = new Map[Tree.NODE,Type.BASE]();

            let global_scope = symbol_table.global_scope;

            IO.Std.err.println("global scope: " + global_scope);

            let ghul_symbol = global_scope.find_direct("Ghul");

            var ghul_namespace = cast Scope(ghul_symbol);

            _int_type =
                 new Type.NAMED(
                    "int",
                    ghul_namespace.find_direct("int")
                );

            IO.Std.err.println("have int type_expression: " + _int_type);
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        pre(property: Tree.Definition.PROPERTY) -> bool is
            IO.Std.err.println("look for property: " + property.name + "...");

            var symbol = find(property.name);

            IO.Std.err.println("type_expression of " + symbol + " is " + property.type_expression);

            return true;
        si

        pre(property: Tree.Definition.INDEXER) -> bool is
            return true;
        si

        visit(named: Tree.TypeExpression.NAMED) is
            let symbol = find(named.name);

            if symbol != null && isa Type.Typed(symbol) then
                let typed_symbol = cast Type.Typed(symbol);
                IO.Std.err.println("named type expression resolves to: " + typed_symbol + " with type " + typed_symbol.type);

                named.type = typed_symbol.type;
            fi
        si

        visit(generic: Tree.TypeExpression.GENERIC) is
            let symbol = find(generic.name);

            if symbol != null && isa Type.BASE(symbol) then
                let typed_symbol = cast Type.Typed(symbol);

                IO.Std.err.println("generic type expression resolves to: " + typed_symbol + " with type " + typed_symbol.type);

                generic.type = typed_symbol.type;
            fi
        si

        visit(type_expression: Tree.TypeExpression.INFER) is
        si

        visit(built_in: Tree.TypeExpression.BUILT_IN) is
        si

        visit(structured: Tree.TypeExpression.STRUCTURED) is
            IO.Std.err.println("visi TypeExpression.STRUCTURED called");
        si

        visit(array: Tree.TypeExpression.ARRAY) is
            IO.Std.err.println("pre TypeExpression.ARRAY called");
        si

        visit(pointer: Tree.TypeExpression.POINTER) is
            IO.Std.err.println("pre TypeExpression.POINTER called");
        si

        visit(reference: Tree.TypeExpression.REFERENCE) is
            IO.Std.err.println("pre TypeExpression.REFERENCE called");
        si

        visit(function: Tree.TypeExpression.FUNCTION) is
            IO.Std.err.println("pre TypeExpression.FUNCTION called");
        si

        visit(tuple: Tree.TypeExpression.TUPLE) is
            IO.Std.err.println("pre TypeExpression.TUPLE called");
        si

        visit(element: Tree.TypeExpression.NAMED_TUPLE_ELEMENT) is
            IO.Std.err.println("pre TypeExpression.NAMED_TUPLE_ELEMENT called");
        si

        visit(member: Tree.Expression.MEMBER) is
            IO.Std.err.println("pre Expression.MEMBER called");
        si
        
        visit(variable: Tree.Variable.NODE) is
            IO.Std.err.println("look for variable: " + variable + "...");

            var symbol = find(variable.name);

            IO.Std.err.println("variable symbol is: " + symbol);

            if symbol != null && isa Type.SettableTyped(symbol) then
                IO.Std.err.println("variable symbol typed");

                var typed_symbol = cast Type.SettableTyped(symbol);

                IO.Std.err.println("existing type is " + typed_symbol.type);

                if typed_symbol.type == null then
                    IO.Std.err.println("Symbol has no type, attempt to assign one");

                    if variable.type_expression != null && !isa Tree.TypeExpression.INFER(variable.type_expression) then
                        IO.Std.err.println("variable " + symbol + " has type expression " + variable.type_expression);

                        IO.Std.err.println("type expression " + variable.type_expression + " has type " + variable.type_expression.type);
                        
                        typed_symbol.type = variable.type_expression.type;
                    elif variable.initializer != null && variable.initializer.value != null then
                        IO.Std.err.println("variable " + symbol + " has type " + variable.initializer.value.type);

                        typed_symbol.type = variable.type_expression.type;
                    fi
                fi

                if symbol != null && isa Type.Typed(symbol) then
                    IO.Std.err.println("variable done: " + symbol);
                fi
            fi        
        si

        visit(integer: Tree.Expression.Literal.INTEGER) is
        /*
            if integer.value == null then
                integer.value = new Value.LITERAL(
                    integer.
                )
            fi
        */
        si

        visit(function: Tree.Expression.CALL) is
            IO.Std.err.println("function call: " + function);
        si

        visit(identifier: Tree.Expression.IDENTIFIER) is
            if identifier.value == null then
                IO.Std.err.println("look for identifier: " + identifier.identifier + "...");

                var symbol = find(identifier.identifier);

                if symbol != null && isa Type.Typed(symbol) then
                    var typed_symbol = cast Type.Typed(symbol);

                    IO.Std.err.println("identifier " + identifier + " is symbol " + symbol + " with type " + typed_symbol.type);                    
                fi
            fi
        si
    si
si
