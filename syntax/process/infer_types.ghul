namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;

    class INFER_TYPES: ScopedVisitor is
        _logger: LOGGER;
        _map: Map[Tree.NODE,Type.BASE];
        _symbol_table: SYMBOL_TABLE;

        _int_type: Type.NAMED;

        init(
            logger: LOGGER,
            symbol_table: SYMBOL_TABLE,
            namespaces: NAMESPACES
        )
        is
            super.init(logger, symbol_table, namespaces);

            _symbol_table = symbol_table;
            
            _logger = logger;
            _map = new Map[Tree.NODE,Type.BASE]();

            let global_scope = symbol_table.global_scope;

            IO.Std.err.println("global scope: " + global_scope);

            let ghul_symbol = global_scope.find_direct("Ghul");

            var ghul_namespace = cast Scope(ghul_symbol);

            _int_type =
                 new Type.NAMED(
                    "int",
                    ghul_namespace.find_direct("int")
                );

            IO.Std.err.println("have int type: " + _int_type);
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        pre(property: Tree.Definition.PROPERTY) -> bool is
            IO.Std.err.println("look for property: " + property.name + "...");

            var symbol = find(property.name);

            IO.Std.err.println("type of " + symbol + " is " + property.type);

            return true;
        si

        pre(property: Tree.Definition.INDEXER) -> bool is
            return true;
        si
        
        visit(variable: Tree.Variable.NODE) is
            IO.Std.err.println("look for variable: " + variable.name + "...");

            var symbol = find(variable.name);

            IO.Std.err.println("type of " + symbol + " is " + variable.type);
        si

        visit(integer: Tree.Expression.Literal.INTEGER) is
            IO.Std.err.println("" + integer + " -> " + _int_type);
            _map[integer] = _int_type;
        si

        visit(function: Tree.Expression.CALL) is
            IO.Std.err.println("function call: " + function);
        si

        visit(identifier: Tree.Expression.IDENTIFIER) is
            IO.Std.err.println("identifier: " + identifier + " => " + _symbol_table.current_scope.find_enclosing(identifier.identifier.name));
        si
    si
si
