namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;

    class INFER_TYPES: ScopedVisitor is
        _logger: LOGGER;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;

        init(
            logger: LOGGER,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES
        )
        is
            super.init(logger, symbol_table, namespaces);

            _symbol_table = symbol_table;
            
            _logger = logger;

            let global_scope = symbol_table.global_scope;

            IO.Std.err.println("global scope: " + global_scope);

            let ghul_symbol = global_scope.find_direct("Ghul");

            var ghul_namespace = cast Semantic.Scope(ghul_symbol);

            _int_type =
                 new Semantic.Type.NAMED(
                    "int",
                    cast Semantic.Symbol.Scoped(ghul_namespace.find_direct("int"))
                );

            IO.Std.err.println("have int type_expression: " + _int_type);

            _symbol_loader = new Semantic.SYMBOL_LOADER(
                _logger,
                _symbol_table,
                _int_type
            );

            _overload_resolver = new Semantic.OVERLOAD_RESOLVER();
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        pre(property: Tree.Definition.PROPERTY) -> bool is
            IO.Std.err.println("look for property: " + property.name + "...");

            var symbol = find(property.name);

            IO.Std.err.println("type_expression of " + symbol + " is " + property.type_expression);

            return true;
        si

        pre(property: Tree.Definition.INDEXER) -> bool is
            return true;
        si

        visit(member: Tree.Expression.MEMBER) is
            IO.Std.err.println("visit Expression.MEMBER left: " + member.left);
            IO.Std.err.println("visit Expression.MEMBER identifier: " + member.identifier);

            IO.Std.err.println("visit Expression.MEMBER left.value: " + member.left.value);

            if member.left.value != null then
                let type = member.left.value.type;

                if type == null then
                    IO.Std.err.println("MEMBER left " + member.left.value + " has no type");
                    return;
                fi

                IO.Std.err.println("visit Expression.MEMBER left value type: " + type);                

                if !isa Semantic.Type.NAMED(type) then
                    _logger.error(member.left.location, "type has no members: " + type);
                    return;
                fi

                let named_type = cast Semantic.Type.NAMED(type);

                let symbol = named_type.scope.find_member(member.identifier.name);

                if symbol == null then
                    _logger.error(member.identifier.location, "member not found");
                    return;
                fi

                IO.Std.err.println("MEMBER: setting value...");

                var value = new Semantic.Graph.Value.Load.SYMBOL(member.left.value, symbol);

                member.value = value;

                IO.Std.err.println("MEMBER value is: " + value);
            fi
        si
        
        visit(variable: Tree.Variable.NODE) is
            IO.Std.err.println("look for variable: " + variable + "...");

            var symbol = find(variable.name);

            IO.Std.err.println("variable symbol is: " + symbol);

            if symbol != null && isa Semantic.Type.SettableTyped(symbol) then
                IO.Std.err.println("variable symbol typed");

                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                IO.Std.err.println("existing type is " + typed_symbol.type);

                if typed_symbol.type == null then
                    IO.Std.err.println("Symbol has no type, attempt to assign one");

                    if variable.type_expression != null && !isa Tree.TypeExpression.INFER(variable.type_expression) then
                        IO.Std.err.println("variable " + symbol + " has type expression " + variable.type_expression);

                        IO.Std.err.println("type expression " + variable.type_expression + " has type " + variable.type_expression.type);
                        
                        typed_symbol.type = variable.type_expression.type;
                    elif variable.initializer != null && variable.initializer.value != null then
                        IO.Std.err.println("variable " + symbol + " has type " + variable.initializer.value.type);

                        typed_symbol.type = variable.initializer.value.type;

                    else
                        IO.Std.err.println("unable to set type for variable: " + variable);
                    fi

                    IO.Std.err.println("variable done: " + typed_symbol);
                    IO.Std.err.println("variable type: " + typed_symbol.type);                 
                fi
            fi        
        si

        visit(integer: Tree.Expression.Literal.INTEGER) is
            if integer.value == null then
                integer.value = new Semantic.Graph.Value.Literal.INTEGER(
                    integer.string,
                    _int_type
                );
            fi
        si

        visit(call: Tree.Expression.CALL) is
            IO.Std.err.println("function call: " + call);

            for a in call.arguments do
                IO.Std.err.println("function argument: " + a + " is " + a.value);
            od

            if call.value == null then
                IO.Std.err.println("function value is: " + call.function.value);

                if call.function.value == null then
                    return;
                fi

                IO.Std.err.println("function value type is: " + call.function.value);

                if isa Semantic.Graph.Value.Load.SYMBOL(call.function.value) then
                    var load = cast Semantic.Graph.Value.Load.SYMBOL(call.function.value);

                    IO.Std.err.println("overloaded: " + load);

                    var function_group = cast Semantic.Symbol.FUNCTION_GROUP(load.symbol);

                    var arguments = new Vector[Semantic.Type.BASE]();

                    for a in call.arguments do
                        if a.value == null then
                            IO.Std.err.println("give up: argument has no value: " + a);
                            return;
                        fi

                        arguments.add(a.value.type);
                    od

                    var function = _overload_resolver.resolve(function_group, arguments);
                fi 
            fi
        si

        visit(identifier: Tree.Expression.IDENTIFIER) is
            if identifier.value == null then
                IO.Std.err.println("look for identifier: " + identifier.identifier + "...");

                var symbol = find(identifier.identifier);

                if symbol != null then
                    identifier.value = new Semantic.Graph.Value.Load.SYMBOL(
                        new Semantic.Graph.Value.Load.LOCAL(),
                        symbol
                    );

                    IO.Std.err.println("set value for identifier: " + identifier.identifier + ": " + identifier.value);                    
                fi                
            fi
        si
    si
si
