namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Source;

    class INFER_TYPES: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _generic_specializer: Semantic.GENERIC_SPECIALIZER;
        _symbol_locations: Semantic.SYMBOL_LOCATIONS;

        _show_code: bool;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            generic_specializer: Semantic.GENERIC_SPECIALIZER,
            symbol_locations: Semantic.SYMBOL_LOCATIONS
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _generic_specializer = generic_specializer;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _system_symbol_lookup = system_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_locations = symbol_locations;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        show(location: LOCATION, message: String) is
            if _show_code then
                _logger.info(location, message);                
            fi
        si

        pre(for_: Tree.Statement.FOR) -> bool is
            super.pre(for_);

            // IO.Std.err.println("infer types for: " + for_);

            var symbol = find(for_.variable.name);

            // IO.Std.err.println("symbol is: " + symbol);

            if symbol != null && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                if typed_symbol.type == null then
                    // IO.Std.err.println("have a typed symbol with no type: " + symbol.qualified_name);

                    if for_.variable.type_expression != null && !isa Tree.TypeExpression.INFER(for_.variable.type_expression) then
                        // IO.Std.err.println("have a non-infer type expression: " + for_.variable.type_expression);

                        if for_.variable.type_expression.type? then
                            typed_symbol.type = for_.variable.type_expression.type.specialize(_generic_specializer);
                        fi
                    elif for_.variable.initializer != null then
                        _logger.error(for_.variable.initializer.location, "cannot initialize variable here");
                    elif for_.expression? then
                        // IO.Std.err.println("walk for expression...");
                        for_.expression.walk(self);

                        if for_.expression.value? && for_.expression.value.type? then
                            _logger.info(for_.variable.location, "iterator is " + for_.expression.value.type);
                        fi
                    else
                        _logger.error(for_.location, "can't figure out what to do with for variable");
                    fi
                else
                    IO.Std.err.println("weird: for variable already has type: " + typed_symbol.type);
                fi
            else
                _logger.error(for_.variable.name.location, "couldn't find typed symbol for variable " + for_.variable.name);
            fi        

            for_.body.walk(self);

            return true;
        si        

        pre(assignment: Tree.Statement.ASSIGNMENT) -> bool is
            assignment.right.walk(self);

            if assignment.right.value != null then
                assignment.left.value = new Semantic.Graph.Value.Need.STORE(assignment.right.value);

                assignment.left.walk(self);
            else
                assignment.left.value = null;
            fi

            return true;
        si

        pre(function: Tree.Expression.FUNCTION) -> bool is
            super.pre(function);

            function.body.walk(self);

            return true;
        si

        visit(function: Tree.Expression.FUNCTION) is
            let closure = cast Semantic.Symbol.CLOSURE(scope_for(function));

            function.value = closure.load(new Semantic.Graph.Value.Load.LOCAL(), _symbol_loader);

            show(function.location, "" + function.value);

            super.visit(function);
        si

        visit(tuple: Tree.Expression.TUPLE) is
            let values = new Vector[Semantic.Graph.Value.BASE]();
            let types = new Vector[Semantic.Type.BASE]();

            for v in tuple.elements do
                if v.value? && v.value.type? then
                    values.add(v.value);
                    types.add(v.value.type);
                else
                    return;
                fi
            od

            let type = _ghul_symbol_lookup.get_tuple_type(types).specialize(_generic_specializer);
                        
            tuple.value = new Semantic.Graph.Value.TUPLE(type, values);

            show(tuple.location, "" + tuple.value);
        si

        visit(self_: Tree.Expression.SELF) is
            self_.value =
                new Semantic.Graph.Value.Load.SELF(
                    _symbol_table.current_instance_context
                );

            _symbol_locations.add_symbol_use(self_.location, _symbol_table.current_instance_context);                

            show(self_.location, "" + self_.value);
        si

        visit(self_: Tree.Expression.SUPER) is
            // FIXME:
            self_.value =
                new Semantic.Graph.Value.Load.SELF(
                    _symbol_table.current_instance_context
                );

            show(self_.location, "" + self_.value);
        si

        visit(cast_: Tree.Expression.CAST) is
            cast_.value = null;

            var type = cast_.type_expression.type;

            if type == null then
                _logger.error(cast_.type_expression.location, "cast has no type");                
                return;
            fi

            type = type.specialize(_generic_specializer);
            
            cast_.value =
                new Semantic.Graph.Value.CAST(
                    type,
                    cast_.right.value
                );

            show(cast_.location, "" + cast_.value);                
        si

        visit(new_: Tree.Expression.NEW) is
            new_.value = null;

            var type = new_.type_expression.type;

            if type == null then
                _logger.error(new_.type_expression.location, "new has no type");
                return;
            fi

            type = type.specialize(_generic_specializer);

            if !isa Semantic.Type.NAMED(type) then
                _logger.error(new_.type_expression.location, "cannot instantiate this: " + type);
                return;
            fi

            let named_type = cast Semantic.Type.NAMED(type);

            let symbol = named_type.scope.find_member("init");

            let function_group = cast Semantic.Symbol.FUNCTION_GROUP(symbol);

            let arguments = new Vector[Semantic.Graph.Value.BASE]();
            let argument_types = new Vector[Semantic.Type.BASE]();

            for a in new_.arguments.elements do
                if a.value == null then
                    // _logger.info(a.location, "argument has no value");
                    return;
                fi

                arguments.add(a.value);
                argument_types.add(a.value.type);
            od

            let function = _overload_resolver.resolve(new_.location, function_group, argument_types);

            if function == null then
                new_.value =
                    new Semantic.Graph.Value.DUMMY(
                        type
                    );
                return;
            fi

            _symbol_locations.add_symbol_use(new_.type_expression.location, function);

            new_.value =
                new Semantic.Graph.Value.NEW(
                    type,
                    function,
                    arguments
                );

            show(new_.location, "" + new_.value);
        si

        visit(unary: Tree.Expression.UNARY) is
            unary.value = null;

            if unary.right.value != null then
                let arguments = [unary.right.value.type];

                let function_group = find(unary.operation);

                if function_group == null || !isa Semantic.Symbol.FUNCTION_GROUP(function_group) then
                    return;
                fi

                let function = _overload_resolver.resolve(unary.location, cast Semantic.Symbol.FUNCTION_GROUP(function_group), arguments);

                if function == null then
                    return;
                fi

                _symbol_locations.add_symbol_use(unary.operation.location, function);

                let value = function.call(null, [unary.right.value], _function_caller);

                unary.value = value;

                show(unary.location, "" + unary.value);                                    
            fi
        si        

        visit(binary: Tree.Expression.BINARY) is
            binary.value = null;

            if binary.left.value != null && binary.right.value != null then
                let arguments = [binary.left.value.type, binary.right.value.type];

                let function_group = find(binary.operation);

                if function_group == null || !isa Semantic.Symbol.FUNCTION_GROUP(function_group) then
                    return;
                fi

                let function = _overload_resolver.resolve(binary.location, cast Semantic.Symbol.FUNCTION_GROUP(function_group), arguments);

                if function == null then
                    return;
                fi

                _symbol_locations.add_symbol_use(binary.operation.location, function);                

                let value = function.call(null, [binary.left.value, binary.right.value], _function_caller);

                binary.value = value;

                show(binary.location, "" + binary.value);                                    
            fi
        si

        visit(index: Tree.Expression.INDEX) is
            try
                _visit(index);
            catch e: Exception
                index.value = null;
            
                IO.Std.err.println("something went wrong with index: " + index + "\n" + e);
            yrt
        si

        _visit(index: Tree.Expression.INDEX) is
            let need_store = index.value? && isa Semantic.Graph.Value.Need.STORE(index.value);

            if index.left.value? && index.index.value? then
                let type = index.left.value.type;

                if type == null then
                    _logger.error(index.left.location, "index left has no type");
                    return;
                fi

                if !isa Semantic.Type.NAMED(type) then
                    _logger.error(index.left.location, "type has no members: " + type);
                    return;
                fi

                let named_type = cast Semantic.Type.NAMED(type);

                var function_name: String;
                var arguments: Iterable[Semantic.Graph.Value.BASE];
                var argument_types: List[Semantic.Type.BASE];

                if need_store then
                    function_name = "__assign";

                    let need_store_value = cast Semantic.Graph.Value.Need.STORE(index.value).value;

                    arguments = [index.index.value, need_store_value];
                    argument_types = [index.index.value.type, need_store_value.type];
                else
                    function_name = "__read";
                    arguments = [index.index.value];
                    argument_types = [index.index.value.type];
                fi

                let symbol = named_type.scope.find_member(function_name);

                if symbol == null then
                    _logger.error(index.location, "no indexer found");
                    return;
                fi

                if !isa Semantic.Symbol.FUNCTION_GROUP(symbol) then
                    _logger.error(index.index.location, "indexer is not a function group: " + symbol);
                fi

                let function = _overload_resolver.resolve(index.location, cast Semantic.Symbol.FUNCTION_GROUP(symbol), argument_types);

                if function == null then
                    _logger.error(index.index.location, "no indexer overload found");
                    return;
                fi

                _symbol_locations.add_symbol_use(
                    new LOCATION(
                        index.left.location.file_name,
                        index.left.location.end_line,
                        index.left.location.end_column+1,
                        index.index.location.start_line,
                        index.index.location.end_column-1
                    ), function);                

                index.value = function.call(index.left.value, arguments, _function_caller);

                show(index.location, "" + index.value);                    
            fi
        si

        visit(member: Tree.Expression.MEMBER) is
            let need_store = member.value? && isa Semantic.Graph.Value.Need.STORE(member.value);

            if member.identifier == null then
                return;
            fi

            if member.left? && member.left.value? then
                let type = member.left.value.type;

                if type == null then
                    _logger.error(member.left.location, "member left has no type");
                    return;
                fi

                if !isa Semantic.Type.NAMED(type) then
                    _logger.error(member.left.location, "type has no members: " + type);
                    return;
                fi

                let named_type = cast Semantic.Type.NAMED(type);

                if named_type.scope == null then
                    _logger.error(member.left.location, "member left type has no type: " + type);
                    return;
                fi

                let symbol = named_type.scope.find_member(member.identifier.name);

                if symbol == null then
                    _logger.error(member.identifier.location, "member " + member.identifier.name + " not found in " + named_type);
                    return;
                fi

                _symbol_locations.add_symbol_use(member.identifier.location, symbol);

                _symbol_loader.find_symbol = 
                    (name: String) -> Semantic.Symbol.BASE use named_type is
                        let result = named_type.scope.find_member(name);

                        if result == null then
                            IO.Std.err.println("property function " + name + " not found in type: " + named_type + ", scope: " + named_type.scope);
                        fi

                        return result;
                    si;

                var value: Semantic.Graph.Value.BASE;

                if need_store then
                    let store_value = cast Semantic.Graph.Value.Need.STORE(member.value).value;

                    value = symbol.store(member.left.value, store_value, _symbol_loader);
                else
                    value = symbol.load(member.left.value, _symbol_loader);
                fi

                member.value = value;

                show(member.location, "" + member.value);
            else
                _logger.error(member.left.location, "member left has no value");
            fi
        si
        
        visit(variable: Tree.Variable.NODE) is
            var symbol = find(variable.name);

            if symbol != null && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                if typed_symbol.type == null then
                    if variable.type_expression != null && !isa Tree.TypeExpression.INFER(variable.type_expression) then
                        if variable.type_expression.type? then
                            typed_symbol.type = variable.type_expression.type.specialize(_generic_specializer);
                        fi
                    elif variable.initializer != null then
                        if variable.initializer.value != null then
                            typed_symbol.type = variable.initializer.value.type;
                        fi
                    else
                        _logger.error(variable.location, "unable to set type for variable " + variable.name);
                    fi
                fi
            else
                _logger.error(variable.name.location, "couldn't find typed symbol for variable " + variable.name);
            fi        
        si

        visit(integer: Tree.Expression.Literal.INTEGER) is
            integer.value = new Semantic.Graph.Value.Literal.INTEGER(
                integer.string,
                _ghul_symbol_lookup.get_type("int")
            );
        si

        visit(string: Tree.Expression.Literal.STRING) is
            string.value = new Semantic.Graph.Value.Literal.STRING(
                string.string,
                _system_symbol_lookup.get_type("String")
            );
        si        

        visit(call: Tree.Expression.CALL) is
            try
                _visit(call);
            catch e: Exception
                call.value = null;

                IO.Std.err.println("something went wrong inferring type for call: " + call + "\n" + e);
            yrt
        si

        _visit(call: Tree.Expression.CALL) is
            if call.function.value == null then
                // _logger.error(call.function.location, "cannot call this");
                return;
            fi

            let arguments = new Vector[Semantic.Graph.Value.BASE]();
            let argument_types = new Vector[Semantic.Type.BASE]();

            for a in call.arguments do
                if a == null then
                    return;
                fi

                if a.value == null then
                    // _logger.error(a.location, "argument has no value");
                    return;
                fi

                if a.value.type == null then
                    // _logger.error(a.location, "argument has no type");
                    return;
                fi

                arguments.add(a.value);
                argument_types.add(a.value.type);
            od                

            if isa Semantic.Graph.Value.Load.SYMBOL(call.function.value) then
                let load = cast Semantic.Graph.Value.Load.SYMBOL(call.function.value);

                if load.symbol? && isa Semantic.Symbol.FUNCTION_GROUP(load.symbol) then
                    let function_group = cast Semantic.Symbol.FUNCTION_GROUP(load.symbol);
                    let function = _overload_resolver.resolve(call.location, function_group, argument_types);

                    if function == null then
                        // _logger.error(call.location, "no overload found");
                        return;
                    fi

                    _symbol_locations.add_symbol_use(call.function.location, function);

                    call.value = function.call(load.from, arguments, _function_caller);
                    
                    show(call.location, "" + call.value);

                    return;
                fi
            fi

            argument_types.add(new Semantic.Type.ANY());
            let expected_type = _ghul_symbol_lookup.get_function_type(argument_types);

            if expected_type == null then
                _logger.error(call.location, "no innate function type found");
                return;
            fi

            if call.function.value.type == null then
                IO.Std.err.println("call.function.value.type is null: " + call);
                return;
            fi

            let function_generic_type = call.function.value.type.specialized_from;

            if function_generic_type? then
                let function_type_arguments = function_generic_type.arguments;

                if expected_type =~ function_generic_type then
                    let result_type = function_type_arguments[function_type_arguments.Length-1];

                    call.value =
                        new Semantic.Graph.Value.Call.CLOSURE(
                            call.function.value,
                            result_type,
                            arguments
                        );

                    show(call.location, "" + call.value);

                    return;                        
                elif function_generic_type.name =~ "FUNCTION_" + (function_type_arguments.Length-1) then
                    let expected_argument_types = new Vector[Semantic.Type.BASE]();

                    for i in 0..function_type_arguments.Length-1 do
                        expected_argument_types.add(function_type_arguments[i]);
                    od

                    _logger.error(call.arguments.location, "arguments (" + argument_types + ") not compatible with (" + expected_argument_types + ")" );

                    return;
                fi
            fi

            _logger.error(call.arguments.location, "cannot call through value of type " + call.function.value.type);
        si

        visit(identifier: Tree.Expression.IDENTIFIER) is
            let need_store = identifier.value != null && isa Semantic.Graph.Value.Need.STORE(identifier.value);
        
            var symbol = find(identifier.identifier);

            if symbol != null then
                _symbol_locations.add_symbol_use(identifier.location, symbol);

                // _symbol_loader.find_symbol = (name: String) -> Semantic.Symbol.BASE => find(name);

                _symbol_loader.find_symbol = 
                    (name: String) -> Semantic.Symbol.BASE is
                        let result = find(name);

                        return result;
                    si;

                if need_store then
                    var store_value = cast Semantic.Graph.Value.Need.STORE(identifier.value).value;
                    identifier.value = symbol.store(null, store_value, _symbol_loader);
                else
                    identifier.value = symbol.load(null, _symbol_loader);
                fi

                show(identifier.location, "" + identifier.value);
            else
                identifier.value = null;
            fi                
        si
    si
si
