namespace Syntax is
    use System;
    use Generic;
    use Logging;
    use Source;
    use Tree;
    class ScopeVisitorBase : Visitor  is
        _logger: LOGGER;
        _symbol_table: SYMBOL_TABLE;
        _namespaces: NAMESPACES;
        current_scope: Scope is
            return _symbol_table.current_scope;
        si

        current_namespace_context: NamespaceContext is
            return _symbol_table.current_namespace_context;
        si

        current_declaration_context: DeclarationContext is
            return _symbol_table.current_declaration_context;
        si

        init(logger: LOGGER, symbol_table: SYMBOL_TABLE, namespaces: NAMESPACES) -> void is
            super.init();
            _logger = logger;
            _symbol_table = symbol_table;
            _namespaces = namespaces;
        si

        scope_for(node: NODE) -> Scope is
            return _symbol_table.scope_for(node);
        si

        find_member(identifier: Identifier.NODE) -> Symbol.BASE is
            var parent = identifier.parent;
            if parent != null then
                var parent_symbol = find_member(parent);
                if parent_symbol != null then
                    return parent_symbol.find_member(identifier.name);
                else
                    return null;
                fi
            else
                var result = current_scope.find_member(identifier.name);
                if result == null then
                    _logger._trace("find-symbol", "indentifier " + identifier + " not found in scope " + current_scope);
                fi
                return result;
            fi
        si

        find_enclosing(identifier: Identifier.NODE) -> Symbol.BASE is
            var parent = identifier.parent;
            if parent != null then
                var parent_symbol = find_enclosing(parent);
                if parent_symbol != null then
                    return parent_symbol.find_enclosing(identifier.name);
                else
                    return null;
                fi
            else
                var result = current_scope.find_enclosing(identifier.name);
                if result == null then
                    _logger._trace("find-symbol", "indentifier " + identifier + " not found in scope " + current_scope);
                fi
                return result;
            fi
        si

        create_and_enter_block_scope(node: NODE) -> void is
            var scope = new BLOCK_SCOPE(current_scope);
            associate_and_enter_scope(node, scope);
        si

        associate_and_enter_scope(node: NODE, symbol: Symbol.BASE) -> void is
            associate_and_enter_scope(node, cast Scope(symbol));
        si

        associate_and_enter_scope(node: NODE, scope: Scope) -> void is
            associate_node_with_scope(node, scope);
            enter_scope(scope);
        si

        associate_node_with_scope(node: NODE, scope: Scope) -> void is
            _symbol_table.associate_node_with_scope(node, scope);
        si

        enter_scope(node: NODE) -> void is
            _symbol_table.enter_scope(node);
        si

        enter_scope(scope: Scope) -> void is
            _symbol_table.enter_scope(scope);
        si

        leave_scope(node: NODE) -> void is
            _symbol_table.leave_scope(node);
        si

        leave_scope(scope: Scope) -> void is
            _symbol_table.leave_scope(scope);
        si

        declare_and_enter_namespace(identifier: Identifier.NODE) -> void is
            _namespaces.declare_and_enter_namespace(identifier.location, identifier.name);
        si

        enter_namespace(identifier: Identifier.NODE) -> void is
            _namespaces.enter_namespace(identifier.location, identifier.name);
        si

        leave_namespace(identifier: Identifier.NODE) -> void is
            _namespaces.leave_namespace(identifier.location, identifier.name);
        si

        enter_uses(namespace_: Definition.NAMESPACE) -> void is
            for u in namespace_.body.uses do
                _logger._trace("use", "enter use for: " + u + ", top scope before: " + _symbol_table.current_scope);
                enter_scope(u);
                _logger._trace("use", "top scope now: " + _symbol_table.current_scope);
            od
        si

        leave_uses(namespace_: Definition.NAMESPACE) -> void is
            for u in namespace_.body.uses.ReverseIterator do
                _logger._trace("use", "exit use for: " + u + ", top scope before: " + _symbol_table.current_scope);
                leave_scope(u);
                _logger._trace("use", "top scope now: " + _symbol_table.current_scope);
            od
        si

    si

si
