namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;

    class RESOLVE_EXPLICIT_VARIABLE_TYPES: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _generic_cache: Semantic.GENERIC_CACHE;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            generic_cache: Semantic.GENERIC_CACHE
        )
        is
            super.init(logger, symbol_table, namespaces);

            _symbol_table = symbol_table;
            _logger = logger;
            _generic_cache = generic_cache;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        visit(function: Tree.Definition.FUNCTION) is
            let symbol = _symbol_table.current_function;

            if symbol == null then
                super.visit(function);
                return;
            fi

            let types = new Vector[Semantic.Type.BASE]();
            let names = new Vector[String]();

            for argument in function.arguments do
                let type = argument.type_expression.type;

                types.add(type);
                names.add(argument.name);
            od

            // FIXME: this should be a structured function type
            // encompassing arguments and return type:
            if !isa Tree.TypeExpression.INFER(function.type_expression) then
                symbol.type = function.type_expression.type;
            else
                symbol.type = IoC.CONTAINER.instance.ghul_symbol_lookup.get_void_type();
            fi

            symbol.arguments = types;
            symbol.argument_names = names;

            super.visit(function);
        si

        visit(property: Tree.Definition.PROPERTY) is            
            if property.name == null || property.name.name == null || property.type_expression == null then
                super.visit(property);
                return;
            fi

            let f = find(property.name);

            if f == null || !isa Semantic.Type.SettableTyped(f) then
                super.visit(property);
                return;
            fi

            let symbol = cast Semantic.Type.SettableTyped(f);

            if symbol? && !isa Tree.TypeExpression.INFER(property.type_expression) then
                symbol.type = property.type_expression.type;
            fi

            super.visit(property);
        si        
        
        // FIXME: think we're doing this twice:
        visit(variable: Tree.Variable.NODE) is
            if variable.name == null then
                return;
            fi

            var symbol = find(variable.name);

            if symbol? && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                if typed_symbol.type == null && variable.type_expression? then
                    if !isa Tree.TypeExpression.INFER(variable.type_expression) then                    
                        if variable.type_expression.type? then
                            typed_symbol.type = variable.type_expression.type;
                        fi
                    fi
                    
                else                
                    _logger.error(variable.location, "something went wrong with variable type");
                fi
            else
                _logger.error(variable.name.location, "cannot locate typed symbol for variable");
            fi       
        si

        visit(variable: Tree.Expression.VARIABLE) is
            if variable.name == null then
                return;
            fi

            var symbol = find(variable.name);
            
            if symbol? && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                if typed_symbol.type == null && variable.type_expression? then
                    if !isa Tree.TypeExpression.INFER(variable.type_expression) then                    
                        typed_symbol.type = variable.type_expression.type;
                    fi
                else
                    _logger.error(variable.location, "something went wrong with variable type");
                fi
            else
                _logger.error(variable.name.location, "cannot locate typed symbol for variable");
            fi        
        si        
    si
si
