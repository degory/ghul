namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;

    class RESOLVE_EXPLICIT_VARIABLE_TYPES: ScopedVisitor is
        _logger: LOGGER;
        _symbol_table: Semantic.SYMBOL_TABLE;

        init(
            logger: LOGGER,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES
        )
        is
            super.init(logger, symbol_table, namespaces);

            _symbol_table = symbol_table;
            
            _logger = logger;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        visit(variable: Tree.Variable.NODE) is
            IO.Std.err.println("attempt to resolve variable type: " + variable + "...");

            var symbol = find(variable.name);

            IO.Std.err.println("variable symbol is: " + symbol);

            if symbol != null && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                if typed_symbol.type == null && variable.type_expression != null && !isa Tree.TypeExpression.INFER(variable.type_expression) then
                    IO.Std.err.println("variable " + symbol + " has type expression " + variable.type_expression);

                    IO.Std.err.println("type expression " + variable.type_expression + " has type " + variable.type_expression.type);
                    
                    typed_symbol.type = variable.type_expression.type;

                    IO.Std.err.println("resolved variable is: " + typed_symbol);
                fi
            fi        
        si

        visit(function: Tree.Definition.FUNCTION) is
            let symbol = _symbol_table.current_function;            

            let types = new Vector[Semantic.Type.BASE]();

            for argument in function.arguments do
                let argument_symbol = find(argument.name);

                IO.Std.err.println("function argument: " + argument_symbol);

                types.add(cast Semantic.Type.Typed(argument_symbol).type);
            od

            symbol.arguments = types;
            IO.Std.err.println("set type arguments " + symbol);

            super.visit(function);
        si        
    si
si
