namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;

    class RESOLVE_TYPE_EXPRESSIONS: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;

        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_use_locations = symbol_use_locations;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        visit(named: Tree.TypeExpression.NAMED) is
            named.type = null;

            let symbol = find(named.name);

            if symbol? && isa Semantic.Type.Typed(symbol) then
                _symbol_use_locations.add_symbol_use(named.name.location, symbol);

                let typed_symbol = cast Semantic.Type.Typed(symbol);

                named.type = typed_symbol.type;
            else
                _logger.error(named.name.location, "not found or not a type: " + named);
            fi
        si

        visit(generic: Tree.TypeExpression.GENERIC) is
            generic.type = null;

            let symbol = find(generic.name);

            if symbol? then
                _symbol_use_locations.add_symbol_use(generic.name.location, symbol);
            
                if !isa Semantic.Symbol.ScopedWithInheritance(symbol) then
                    _logger.error(generic.location, "cannot supply type arguments here");
                    return;
                fi

                let arguments = new Vector[Semantic.Type.BASE]();

                for a in generic.arguments do
                    if a.type? then
                        arguments.add(a.type);
                    else
                        _logger.error(a.location, "no type: " + a);                    
                    fi
                od

                generic.type = new Semantic.Type.GENERIC(
                    generic.location,
                    cast Semantic.Symbol.ScopedWithInheritance(symbol),
                    arguments);
            fi
        si

        visit(structured: Tree.TypeExpression.STRUCTURED) is
            IO.Std.err.println("visit TypeExpression.STRUCTURED called");
        si

        visit(array: Tree.TypeExpression.ARRAY_) is
            IO.Std.err.println("visit TypeExpression.ARRAY_ " + array + " called from\n" + new System.Backtrace());
        si

        visit(pointer: Tree.TypeExpression.POINTER) is
            IO.Std.err.println("visit TypeExpression.POINTER called");
        si

        visit(reference: Tree.TypeExpression.REFERENCE) is
            IO.Std.err.println("visit TypeExpression.REFERENCE called");
        si

        visit(function: Tree.TypeExpression.FUNCTION) is
            IO.Std.err.println("visit TypeExpression.FUNCTION called: " + function);
        si

        visit(tuple: Tree.TypeExpression.TUPLE) is
            IO.Std.err.println("visit TypeExpression.TUPLE called");
        si

        visit(element: Tree.TypeExpression.NAMED_TUPLE_ELEMENT) is
            IO.Std.err.println("visit TypeExpression.NAMED_TUPLE_ELEMENT called");
        si
    si
si
