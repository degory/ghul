namespace Syntax.Process.Printer is
    use System;
    use Logging;

    use Source;
    use Tree;

    class LEGACY: BASE  is
        _logger: LOGGER;

        init(logger: LOGGER) is
            super.init(true);

            _logger = logger;
        si

        error(location: LOCATION, message: String) is
            _logger.error(location, message);
        si

        apply(node: NODE) is
            node.accept(self);
        si

        print(location: LOCATION, type: Type.NODE) is
            if !isa Type.INFER(type) then
                type.accept(self);
            else
                // _logger.warn(location, "legacy compiler cannot infer type here, assuming void");
                print("void");
            fi
        si

        print_name(name: String) is
            var c = name[0];

            if (c>='a'&&c<='z') || (c>='A'&&c<='Z') || c=='_' then
                print(name);
            else
                print("operator");
                print(name);
            fi
        si

        visit(variable: Variable.NODE) is
            if !isa Type.INFER(variable.type) then
                variable.type.accept(self);
                print(' ');
            else
                print("var ");
            fi
            variable.name.accept(self);
            if variable.initializer != null then
                print(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(import_: Definition.IMPORT) is
            for i in import_.imports do
                print("import ");
                i.accept(self);
                println(";");
            od
        si

        visit(namespace_: Definition.NAMESPACE) is
            var seen_any = false;
            for ns in namespace_.name do
                if seen_any then
                    print(' ');
                fi
                print("namespace ");
                print(ns);
                print(" is");
                seen_any = true;
            od
            println();
            indent();
            namespace_.body.accept(self);
            outdent();
            seen_any = false;
            for ns in namespace_.name do
                if seen_any then
                    print(' ');
                fi
                print("si");
                seen_any = true;
            od
            println();
        si

        visit(use_: Definition.USE) is
            for u in use_.uses do
                print("use ");
                u.accept(self);
                println(";");
            od
        si

        visit(class_: Definition.CLASS) is
            print("class ");
            class_.name.accept(self);
            if class_.arguments != null then
                print('<');
                class_.arguments.accept(self);
                print('>');
            fi
            if class_.ancestors != null then
                var count = 0;
                ;
                for ancestor in class_.ancestors do
                    if count == 0 then
                        print(" isa ");
                    elif count == 1 then
                        print(" do ");
                    else
                        print(", ");
                    fi
                    ancestor.accept(self);
                    count = count + 1;
                od
            fi
            println(" is");
            indent();
            class_.body.accept(self);
            outdent();
            println("si");
        si

        visit(interface_: Definition.INTERFACE) is
            print("interface ");
            interface_.name.accept(self);

            if interface_.arguments != null then
                print('<');
                interface_.arguments.accept(self);
                print('>');
            fi

            if interface_.ancestors != null then
                print("do ");
                interface_.ancestors.accept(self);
            fi

            println(" is");
            indent();
            interface_.body.accept(self);
            outdent();
            println("si");
        si

        print_newline_after_body(body: Body.NODE) is
            if !body.is_block then
                println();
            fi
        si

        visit(function: Definition.FUNCTION) is
            if function.modifiers != null then
                function.modifiers.accept(self);
                print(' ');
            fi

            print(function.location, function.type);
            print(' ');
            function.name.accept(self);
            print('(');
            function.arguments.accept(self);
            print(')');

            if function.body != null then
                print(' ');
                function.body.accept(self);
                println();
            else
                println(";");
            fi
        si

        print_getter_modifiers(modifiers: Modifier.LIST, name: Identifier.NODE) is
            if modifiers.is_explicit_access then
                modifiers.access_modifier.accept(self);
                print(' ');
            elif 
                name!=null && name.name.startsWith('_')
                then
                print("private ");
            fi

            if modifiers.storage_class != null then
                modifiers.storage_class.accept(self);
                print(' ');
            fi
        si

        print_setter_modifiers(modifiers: Modifier.LIST) is
            if modifiers.is_explicit_access then
                modifiers.access_modifier.accept(self);
                print(' ');
            else
                print("private ");
            fi

            if modifiers.storage_class != null then
                modifiers.storage_class.accept(self);
                print(' ');
            fi
        si

        print_backing_field_modifiers(modifiers: Modifier.LIST) is
            print("private ");
            if modifiers.storage_class != null then
                modifiers.storage_class.accept(self);
                print(' ');
            fi
        si

        visit(property: Definition.PROPERTY) is
            if property.getter_body!=null || property.setter_body!=null then
                if property.getter_body != null then
                    print_getter_modifiers(property.modifiers, property.name);
                    print("get ");
                    print(property.location, property.type);
                    print(' ');
                    property.name.accept(self);
                    print(' ');
                    property.getter_body.accept(self);
                    println();
                fi

                if property.setter_body != null then
                    print_setter_modifiers(property.modifiers);
                    print("set ");
                    print(property.location, property.type);
                    print(' ');
                    property.name.accept(self);
                    print(' ');
                    print(" = ");
                    property.setter_argument.accept(self);
                    print(' ');
                    property.setter_body.accept(self);
                    println();
                fi
            elif !property.name.name.startsWith('_') && !property.modifiers.is_private then
                print_backing_field_modifiers(property.modifiers);
                print(property.location, property.type);
                print(" _");
                property.name.accept(self);
                println(";");
                print_getter_modifiers(property.modifiers, property.name);
                print("get ");
                print(property.location, property.type);
                print(" ");
                property.name.accept(self);
                print(" is return _");
                property.name.accept(self);
                println("; si");
                print_setter_modifiers(property.modifiers);
                print("set ");
                print(property.location, property.type);
                print(" ");
                property.name.accept(self);
                print(" = __value is _");
                property.name.accept(self);
                println(" = __value; si");
            else
                property.modifiers.accept(self);
                print(property.location, property.type);
                print(" ");
                property.name.accept(self);
                println(";");
            fi
        si

        visit(indexer: Definition.INDEXER) is
            if indexer.getter_body!=null || indexer.setter_body!=null then
                if indexer.getter_body != null then
                    print_getter_modifiers(indexer.modifiers, indexer.name);
                    print("get ");
                    print(indexer.location, indexer.type);
                    if indexer.name != null then
                        print(' ');
                        indexer.name.accept(self);
                    fi
                    print("[");
                    indexer.index_argument.accept(self);
                    print("]");
                    indexer.getter_body.accept(self);
                    println();
                fi

                if indexer.setter_body != null then
                    print_setter_modifiers(indexer.modifiers);
                    print("set ");
                    print(indexer.location, indexer.type);
                    if indexer.name != null then
                        print(' ');
                        indexer.name.accept(self);
                    fi
                    print("[");
                    indexer.index_argument.accept(self);
                    print("] =");
                    indexer.setter_argument.accept(self);
                    print(" ");
                    indexer.setter_body.accept(self);
                    println();
                fi
            else
                error(indexer.location, "indexer must have at at least read or assign body");
            fi
        si

        visit(type: Type.BUILT_IN) is
            print(type.name);
        si

        visit(array: Type.ARRAY) is
            array.element.accept(self);
            print("[]");
        si

        visit(pointer: Type.POINTER) is
            pointer.element.accept(self);
            print(" ptr");
        si

        visit(reference: Type.REFERENCE) is
            reference.element.accept(self);
            print(" ref");
        si

        visit(named: Type.NAMED) is
            named.name.accept(self);
        si

        visit(generic: Type.GENERIC) is
            generic.name.accept(self);
            print('<');
            generic.arguments.accept(self);
            print('>');
        si

        visit(function: Type.FUNCTION) is
            print(function.location, function.result);
            print(" proc(");
            function.arguments.accept(self);
            print(")");
        si

        visit(tuple: Type.TUPLE) is
            print("(");
            tuple.elements.accept(self);
            print(")");
        si

        visit(types: Type.LIST) is
            var seen_any = false;
            for t in types.Iterator do
                if seen_any then
                    print(',');
                fi
                t.accept(self);
                seen_any = true;
            od
        si

        visit(null_: Expression.NULL) is
            print("null");
        si

        visit(self_: Expression.SELF) is
            print("this");
        si

        visit(new_: Expression.NEW) is
            location(new_);
            print("new ");

            if isa Tree.Type.ARRAY(new_.type) then
                cast Tree.Type.ARRAY(new_.type).element.accept(self);
                print('[');
                new_.arguments.elements.accept(self);
                print(']');
            else
                new_.type.accept(self);
                new_.arguments.accept(self);
            fi
        si

        visit(unary: Expression.UNARY) is
            location(unary);
            print(unary.operation.name);
            print(' ');
            unary.right.accept(self);
        si

        visit(binary: Expression.BINARY) is
            location(binary);
            binary.left.accept(self);
            print(' ');
            print(binary.operation.name);
            print(' ');
            binary.right.accept(self);
        si

        visit(variable: Expression.VARIABLE) is
            if !isa Type.INFER(variable.type) then
                variable.type.accept(self);
                print(' ');
            else
                _logger.error(variable.location, "legacy compiler cannot infer type here");
            fi

            variable.identifier.accept(self);

            if variable.initializer != null then
                print(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(function: Syntax.Tree.Expression.FUNCTION) is
            print(function.location, function.type);
            print(" proc");
            function.arguments.accept(self);
            print(" ");
            function.body.accept(self);
        si

        visit(sequence: Expression.SEQUENCE) is
            if !isa Tree.Type.INFER(sequence.type) then
                sequence.type.accept(self);
            fi
            
            print('{');
            sequence.elements.accept(self);
            print('}');
        si

        visit(has_value: Expression.HAS_VALUE) is
            print("((");
            has_value.left.accept(self);
            print(")!=null)");
        si

        visit(l: Statement.LET) is
            l.variables.accept(self);
            println(";");
        si

        visit(match: Statement.CASE_MATCH) is
            if match.expressions != null then
                print("is ");
                match.expressions.accept(self);
                println(":");
            else
                println("default:");
            fi
            
            indent();
            match.statements.accept(self);
            outdent();
        si

        visit(for_: Statement.FOR) is
            print("foreach ");
            for_.variable.accept(self);
            print("; ");
            for_.expression.accept(self);
            println(" do");
            indent();
            for_.body.accept(self);
            outdent();
            println("od");
        si

        visit(expression: Body.EXPRESSION) is
            print(" is return ");
            expression.expression.accept(self);
            print("; si");
        si

        visit(block: Body.BLOCK) is
            println("is");
            indent();
            block.statements.accept(self);
            outdent();
            print("si");
        si
    si
si
