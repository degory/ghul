namespace Syntax is
    namespace Process is
        namespace Printer is
            use System;
            use Logging;
            use Source;
            use Tree;
            class LEGACY : BASE  is
                _logger: LOGGER;
                init(logger: LOGGER) -> void is
                    super.init(true);
                    _logger = logger;
                si

                error(location: LOCATION, message: String) -> void is
                    _logger.error(location, message);
                si

                apply(node: NODE) -> void is
                    node.accept(self);
                si

                print(location: LOCATION, type: Type.NODE) -> void is
                    if !isa Type.INFER(type) then
                        type.accept(self);
                    else
                        _logger.warn(location, "legacy compiler cannot infer type here, assuming void");
                        print("void");
                    fi
                si

                print_name(name: String) -> void is
                    var c = name[0];
                    if (c>='a'&&c<='z') || (c>='A'&&c<='Z') || c=='_' then
                        print(name);
                    else
                        print("operator");
                        print(name);
                    fi
                si

                visit(variable: Variable.NODE) -> void is
                    if !isa Type.INFER(variable.type) then
                        variable.type.accept(self);
                        print(' ');
                    else
                        print("var ");
                    fi
                    variable.name.accept(self);
                    if variable.initializer != null then
                        print(" = ");
                        variable.initializer.accept(self);
                    fi
                si

                visit(import_: Definition.IMPORT) -> void is
                    for i in import_.imports do
                        print("import ");
                        i.accept(self);
                        println(";");
                    od
                si

                visit(namespace_: Definition.NAMESPACE) -> void is
                    var seen_any = false;
                    for ns in namespace_.name do
                        if seen_any then
                            print(' ');
                        fi
                        print("namespace ");
                        print(ns);
                        print(" is");
                        seen_any = true;
                    od
                    println();
                    indent();
                    namespace_.body.accept(self);
                    outdent();
                    seen_any = false;
                    for ns in namespace_.name do
                        if seen_any then
                            print(' ');
                        fi
                        print("si");
                        seen_any = true;
                    od
                    println();
                si

                visit(use_: Definition.USE) -> void is
                    for u in use_.uses do
                        print("use ");
                        u.accept(self);
                        println(";");
                    od
                si

                visit(class_: Definition.CLASS) -> void is
                    print("class ");
                    class_.name.accept(self);
                    if class_.arguments != null then
                        print('<');
                        class_.arguments.accept(self);
                        print('>');
                    fi
                    if class_.ancestors != null then
                        var count = 0;
                        ;
                        for ancestor in class_.ancestors do
                            if count == 0 then
                                print(" isa ");
                            elif count == 1 then
                                print(" do ");
                            else
                                print(", ");
                            fi
                            ancestor.accept(self);
                            count = count + 1;
                        od
                    fi
                    println(" is");
                    indent();
                    class_.body.accept(self);
                    outdent();
                    println("si");
                si

                visit(interface_: Definition.INTERFACE) -> void is
                    print("interface ");
                    interface_.name.accept(self);
                    if interface_.arguments != null then
                        print('<');
                        interface_.arguments.accept(self);
                        print('>');
                    fi
                    if interface_.ancestors != null then
                        print("do ");
                        interface_.ancestors.accept(self);
                    fi
                    println(" is");
                    indent();
                    interface_.body.accept(self);
                    outdent();
                    println("si");
                si

                print_newline_after_body(body: Body.NODE) -> void is
                    if !body.is_block then
                        println();
                    fi
                si

                visit(function: Definition.FUNCTION) -> void is
                    if function.modifiers != null then
                        function.modifiers.accept(self);
                        print(' ');
                    fi
                    print(function.location, function.type);
                    print(' ');
                    function.name.accept(self);
                    print('(');
                    function.arguments.accept(self);
                    print(')');
                    if function.body != null then
                        print(' ');
                        function.body.accept(self);
                        println();
                    else
                        println(";");
                    fi
                si

                print_getter_modifiers(modifiers: Modifier.LIST, name: Identifier.NODE) -> void is
                    if modifiers.is_explicit_access then
                        modifiers.access_modifier.accept(self);
                        print(' ');
                    elif 
                        name!=null && name.name.startsWith('_')
                     then
                        print("private ");
                    fi
                    if modifiers.storage_class != null then
                        modifiers.storage_class.accept(self);
                        print(' ');
                    fi
                si

                print_setter_modifiers(modifiers: Modifier.LIST) -> void is
                    if modifiers.is_explicit_access then
                        modifiers.access_modifier.accept(self);
                        print(' ');
                    else
                        print("private ");
                    fi
                    if modifiers.storage_class != null then
                        modifiers.storage_class.accept(self);
                        print(' ');
                    fi
                si

                print_backing_field_modifiers(modifiers: Modifier.LIST) -> void is
                    print("private ");
                    if modifiers.storage_class != null then
                        modifiers.storage_class.accept(self);
                        print(' ');
                    fi
                si

                visit(property: Definition.PROPERTY) -> void is
                    if property.getter_body!=null || property.setter_body!=null then
                        if property.getter_body != null then
                            print_getter_modifiers(property.modifiers, property.name);
                            print("get ");
                            print(property.location, property.type);
                            print(' ');
                            property.name.accept(self);
                            print(' ');
                            property.getter_body.accept(self);
                            println();
                        fi
                        if property.setter_body != null then
                            print_setter_modifiers(property.modifiers);
                            print("set ");
                            print(property.location, property.type);
                            print(' ');
                            property.name.accept(self);
                            print(' ');
                            print(" = ");
                            property.setter_argument.accept(self);
                            print(' ');
                            property.setter_body.accept(self);
                            println();
                        fi
                    elif 
                            !property.name.name.startsWith('_')
                         && !property.modifiers.is_private
                     then
                        print_backing_field_modifiers(property.modifiers);
                        print(property.location, property.type);
                        print(" _");
                        property.name.accept(self);
                        println(";");
                        print_getter_modifiers(property.modifiers, property.name);
                        print("get ");
                        print(property.location, property.type);
                        print(" ");
                        property.name.accept(self);
                        print(" is return _");
                        property.name.accept(self);
                        println("; si");
                        print_setter_modifiers(property.modifiers);
                        print("set ");
                        print(property.location, property.type);
                        print(" ");
                        property.name.accept(self);
                        print(" = __value is _");
                        property.name.accept(self);
                        println(" = __value; si");
                    else
                        property.modifiers.accept(self);
                        print(property.location, property.type);
                        print(" ");
                        property.name.accept(self);
                        println(";");
                    fi
                si

                visit(indexer: Definition.INDEXER) -> void is
                    if indexer.getter_body!=null || indexer.setter_body!=null then
                        if indexer.getter_body != null then
                            print_getter_modifiers(indexer.modifiers, indexer.name);
                            print("get ");
                            print(indexer.location, indexer.type);
                            if indexer.name != null then
                                print(' ');
                                indexer.name.accept(self);
                            fi
                            print("[");
                            indexer.index_argument.accept(self);
                            print("]");
                            indexer.getter_body.accept(self);
                            println();
                        fi
                        if indexer.setter_body != null then
                            print_setter_modifiers(indexer.modifiers);
                            print("set ");
                            print(indexer.location, indexer.type);
                            if indexer.name != null then
                                print(' ');
                                indexer.name.accept(self);
                            fi
                            print("[");
                            indexer.index_argument.accept(self);
                            print("] =");
                            indexer.setter_argument.accept(self);
                            print(" ");
                            indexer.setter_body.accept(self);
                            println();
                        fi
                    else
                        error(indexer.location, "indexer must have at at least read or assign body");
                    fi
                si

                visit(type: Type.BUILT_IN) -> void is
                    print(type.name);
                si

                visit(array: Type.ARRAY) -> void is
                    array.element.accept(self);
                    print("[]");
                si

                visit(pointer: Type.POINTER) -> void is
                    pointer.element.accept(self);
                    print(" ptr");
                si

                visit(reference: Type.REFERENCE) -> void is
                    reference.element.accept(self);
                    print(" ref");
                si

                visit(named: Type.NAMED) -> void is
                    named.name.accept(self);
                si

                visit(generic: Type.GENERIC) -> void is
                    generic.name.accept(self);
                    print('<');
                    generic.arguments.accept(self);
                    print('>');
                si

                visit(function: Type.FUNCTION) -> void is
                    print(function.location, function.result);
                    print(" proc(");
                    function.arguments.accept(self);
                    print(")");
                si

                visit(tuple: Type.TUPLE) -> void is
                    print("(");
                    tuple.elements.accept(self);
                    print(")");
                si

                visit(types: Type.LIST) -> void is
                    var seen_any = false;
                    for t in types.Iterator do
                        if seen_any then
                            print(',');
                        fi
                        t.accept(self);
                        seen_any = true;
                    od
                si

                visit(null_: Expression.NULL) -> void is
                    print("null");
                si

                visit(self_: Expression.SELF) -> void is
                    print("this");
                si

                visit(new_: Expression.NEW) -> void is
                    location(new_);
                    print("new ");
                    if isa Tree.Type.ARRAY(new_.type) then
                        cast Tree.Type.ARRAY(new_.type).element.accept(self);
                        print('[');
                        new_.arguments.elements.accept(self);
                        print(']');
                    else
                        new_.type.accept(self);
                        new_.arguments.accept(self);
                    fi
                si

                visit(unary: Expression.UNARY) -> void is
                    location(unary);
                    print(unary.operation.name);
                    print(' ');
                    unary.right.accept(self);
                si

                visit(binary: Expression.BINARY) -> void is
                    location(binary);
                    binary.left.accept(self);
                    print(' ');
                    print(binary.operation.name);
                    print(' ');
                    binary.right.accept(self);
                si

                visit(variable: Expression.VARIABLE) -> void is
                    if !isa Type.INFER(variable.type) then
                        variable.type.accept(self);
                        print(' ');
                    else
                        _logger.error(variable.location, "legacy compiler cannot infer type here");
                    fi
                    variable.identifier.accept(self);
                    if variable.initializer != null then
                        print(" = ");
                        variable.initializer.accept(self);
                    fi
                si

                visit(function: Syntax.Tree.Expression.FUNCTION) -> void is
                    print(function.location, function.type);
                    print(" proc");
                    function.arguments.accept(self);
                    print(" ");
                    function.body.accept(self);
                si

                visit(sequence: Expression.SEQUENCE) -> void is
                    if !isa Tree.Type.INFER(sequence.type) then
                        sequence.type.accept(self);
                    fi
                    print('{');
                    sequence.elements.accept(self);
                    print('}');
                si

                visit(has_value: Expression.HAS_VALUE) -> void is
                    print("((");
                    has_value.left.accept(self);
                    print(")!=null)");
                si

                visit(l: Statement.LET) -> void is
                    l.variables.accept(self);
                    println(";");
                si

                visit(match: Statement.CASE_MATCH) -> void is
                    if match.expressions != null then
                        print("is ");
                        match.expressions.accept(self);
                        println(":");
                    else
                        println("default:");
                    fi
                    indent();
                    match.statements.accept(self);
                    outdent();
                si

                visit(for_: Statement.FOR) -> void is
                    print("foreach ");
                    for_.variable.accept(self);
                    print("; ");
                    for_.expression.accept(self);
                    println(" do");
                    indent();
                    for_.body.accept(self);
                    outdent();
                    println("od");
                si

                visit(expression: Body.EXPRESSION) -> void is
                    print(" is return ");
                    expression.expression.accept(self);
                    print("; si");
                si

                visit(block: Body.BLOCK) -> void is
                    println("is");
                    indent();
                    block.statements.accept(self);
                    outdent();
                    print("si");
                si

            si

        si
    si
si
