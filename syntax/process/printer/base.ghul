namespace Syntax is
    namespace Process is
        namespace Printer is
            use System;
            use Tree;
            use Source;
            class BASE : StrictVisitor  is
                _indent: int;
                _depth: int;
                _run_on: bool;
                _indent_needed: bool;
                _want_locations: bool;
                _current_line: int;
                _result: StringBuffer;
                init(want_locations: bool) -> void is
                    super.init();
                    _want_locations = want_locations;
                    _depth = 0;
                    _indent = 2;
                    _result = new StringBuffer();
                    _current_line = 1;
                si

                result: String is
                    return _result;
                si

                println(string: String) -> void is
                    print(string);
                    println();
                si

                print(string: String) -> void is
                    print_indent();
                    _result.append(string);
                si

                print(c: char) -> void is
                    print_indent();
                    _result.append(c);
                si

                println() -> void is
                    _current_line = _current_line + 1;
                    _indent_needed = true;
                    _result.append('\n');
                si

                indent() -> void is
                    _depth = _depth + 1;
                si

                outdent() -> void is
                    _depth = _depth - 1;
                si

                print_indent() -> void is
                    if _indent_needed then
                        var i = 0;
                        while i < _indent*_depth do
                            _result.append(' ');
                            i = i + 1;
                        od
                        _indent_needed = false;
                    fi
                si

                location(node: NODE) -> void is
                    location(node.location);
                si

                location(location: LOCATION) -> void is
                    var new_line = location.start_line;
                    if new_line != _current_line then
                        _current_line = new_line;
                        if _want_locations then
                            print("#" + _current_line + " ");
                        fi
                    fi
                si

                print(node: NODE) -> void is
                    node.accept(self);
                si

                print_name(name: String) -> void is
                    print(name);
                si

                visit(identifier: Identifier.NODE) -> void is
                    location(identifier);
                    print_name(identifier.name);
                si

                visit(identifier: Identifier.QUALIFIED) -> void is
                    location(identifier);
                    identifier.parent.accept(self);
                    print('.');
                    print_name(identifier.name);
                si

                visit(modifier: Modifier.NODE) -> void is
                    location(modifier);
                    print(modifier.name);
                si

                visit(modifiers: Modifier.LIST) -> void is
                    location(modifiers);
                    if modifiers.access_modifier != null then
                        modifiers.access_modifier.accept(self);
                        print(' ');
                    fi
                    if modifiers.storage_class != null then
                        modifiers.storage_class.accept(self);
                        print(' ');
                    fi
                si

                visit(variables: Variable.LIST) -> void is
                    location(variables);
                    var first = true;
                    for v in variables do
                        if !first then
                            print(", ");
                        fi
                        v.accept(self);
                        first = false;
                    od
                si

                visit(definitions: Definition.LIST) -> void is
                    location(definitions);
                    for d in definitions do
                        d.accept(self);
                    od
                si

                visit(enum_: Definition.ENUM) -> void is
                    location(enum_);
                    print("enum ");
                    enum_.name.accept(self);
                    println(" is");
                    indent();
                    var seen_any = false;
                    for member in enum_.members do
                        if seen_any then
                            println(",");
                        fi
                        member.accept(self);
                        seen_any = true;
                    od
                    println();
                    outdent();
                    println("si");
                si

                visit(member: Definition.ENUM_MEMBER) -> void is
                    location(member);
                    member.name.accept(self);
                    if member.initializer != null then
                        print(" = ");
                        member.initializer.accept(self);
                    fi
                si

                visit(functions: Definition.FUNCTION_GROUP) -> void is
                    println("function group ");
                    indent();
                    for f in functions.functions do
                        f.accept(self);
                    od
                    outdent();
                si

                visit(type: Type.INFER) -> void is
                    print("infer");
                si

                visit(type: Type.BUILT_IN) -> void is
                    print(type.name);
                si

                visit(array: Type.ARRAY) -> void is
                    array.element.accept(self);
                    print("[]");
                si

                visit(pointer: Type.POINTER) -> void is
                    pointer.element.accept(self);
                    print(" ptr");
                si

                visit(reference: Type.REFERENCE) -> void is
                    reference.element.accept(self);
                    print(" ref");
                si

                visit(functions: Type.FUNCTION_GROUP) -> void is
                    print("function group ");
                    for f in functions.functions do
                        f.accept(self);
                        print(' ');
                    od
                si

                visit(named: Type.NAMED) -> void is
                    location(named);
                    named.name.accept(self);
                si

                visit(tuple: Type.TUPLE) -> void is
                    location(tuple);
                    print("(");
                    tuple.elements.accept(self);
                    print(")");
                si

                visit(element: Type.NAMED_TUPLE_ELEMENT) -> void is
                    location(element);
                    element.name.accept(self);
                    print(": ");
                    element.type.accept(self);
                si

                visit(types: Type.LIST) -> void is
                    location(types);
                    var seen_any = false;
                    for t in types.Iterator do
                        if seen_any then
                            print(',');
                        fi
                        t.accept(self);
                        seen_any = true;
                    od
                si

                visit(none: Expression.Literal.NONE) -> void is
                    location(none);
                    print("none");
                si

                visit(identifier: Expression.IDENTIFIER) -> void is
                    location(identifier);
                    identifier.identifier.accept(self);
                si

                visit(super_: Expression.SUPER) -> void is
                    location(super_);
                    print("super");
                si

                visit(new_: Expression.NEW) -> void is
                    location(new_);
                    print("new ");
                    new_.type.accept(self);
                    new_.arguments.accept(self);
                si

                visit(cast_: Expression.CAST) -> void is
                    location(cast_);
                    print("cast ");
                    cast_.type.accept(self);
                    print('(');
                    cast_.right.accept(self);
                    print(')');
                si

                visit(isa_: Expression.ISA) -> void is
                    location(isa_);
                    print("isa ");
                    isa_.type.accept(self);
                    print('(');
                    isa_.right.accept(self);
                    print(')');
                si

                visit(tuple: Expression.TUPLE) -> void is
                    location(tuple);
                    print('(');
                    tuple.elements.accept(self);
                    print(')');
                si

                visit(call: Expression.CALL) -> void is
                    location(call);
                    call.function.accept(self);
                    print('(');
                    call.arguments.accept(self);
                    print(')');
                si

                visit(member: Expression.MEMBER) -> void is
                    location(member);
                    member.left.accept(self);
                    print('.');
                    member.identifier.accept(self);
                si

                visit(index: Expression.INDEX) -> void is
                    location(index);
                    index.left.accept(self);
                    print('[');
                    index.index.accept(self);
                    print(']');
                si

                visit(unary: Expression.UNARY) -> void is
                    location(unary);
                    unary.operation.accept(self);
                    print(' ');
                    unary.right.accept(self);
                si

                visit(binary: Expression.BINARY) -> void is
                    location(binary);
                    binary.left.accept(self);
                    print(' ');
                    binary.operation.accept(self);
                    print(' ');
                    binary.right.accept(self);
                si

                visit(expressions: Expression.LIST) -> void is
                    location(expressions);
                    var seen_any = false;
                    for e in expressions do
                        if seen_any then
                            print(',');
                        fi
                        e.accept(self);
                        seen_any = true;
                    od
                si

                visit(literal: Expression.Literal.NODE) -> void is
                    location(literal);
                    print(literal.value);
                si

                print_escape_char(c: char) -> void is
                    var ci = cast int(c);
                    if ci == 9 then
                        print("\t");
                    elif ci == 10 then
                        print("\n");
                    elif ci == 13 then
                        print("\015");
                    elif ci < 32 then
                        print("\\");
                        var b = new StringBuffer(5);
                        b.append(ci, 8);
                        print(b);
                    elif ci == 34 then
                        print("\\");
                        print(cast char(34));
                    elif ci == 39 then
                        print("'");
                    elif ci == 92 then
                        print("\\\\");
                    else
                        print(c);
                    fi
                si

                visit(string: Expression.Literal.STRING) -> void is
                    location(string);
                    print(cast char(34));
                    for c in string.value do
                        print_escape_char(c);
                    od
                    print(cast char(34));
                si

                visit(character: Expression.Literal.CHARACTER) -> void is
                    location(character);
                    print("'");
                    print_escape_char(character.value[0]);
                    print("'");
                si

                visit(list: Statement.LIST) -> void is
                    location(list);
                    for s in list.Iterator do
                        s.accept(self);
                    od
                si

                visit(assign: Statement.ASSIGNMENT) -> void is
                    location(assign);
                    assign.left.accept(self);
                    print(" = ");
                    assign.right.accept(self);
                    println(";");
                si

                visit(expression: Statement.EXPRESSION) -> void is
                    location(expression);
                    expression.expression.accept(self);
                    println(";");
                si

                visit(v: Statement.VAR) -> void is
                    location(v);
                    v.variables.accept(self);
                    println(";");
                si

                visit(r: Statement.RETURN) -> void is
                    location(r);
                    print("return");
                    if r.expression != null then
                        print(' ');
                        r.expression.accept(self);
                    fi
                    println(";");
                si

                visit(t: Statement.THROW) -> void is
                    location(t);
                    print("throw");
                    if t.expression != null then
                        print(' ');
                        t.expression.accept(self);
                    fi
                    println(";");
                si

                visit(i: Statement.IF) -> void is
                    location(i);
                    var is_first = true;
                    var seen_else = false;
                    assert(i != null);
                    assert(i.branches != null);
                    for b in i.branches do
                        location(b);
                        assert(!seen_else);
                        if b.condition != null then
                            if is_first then
                                print("if ");
                            else
                                print("elif ");
                            fi
                            b.condition.accept(self);
                            println(" then");
                        else
                            seen_else = true;
                            println("else");
                        fi
                        indent();
                        b.body.accept(self);
                        outdent();
                        is_first = false;
                    od
                    println("fi");
                si

                visit(case_: Statement.CASE) -> void is
                    location(case_);
                    print("case ");
                    case_.expression.accept(self);
                    println();
                    for m in case_.matches do
                        m.accept(self);
                    od
                    println("esac");
                si

                visit(match: Statement.CASE_MATCH) -> void is
                    location(match);
                    if match.expressions != null then
                        print("when ");
                        match.expressions.accept(self);
                        println(":");
                    else
                        println("default");
                    fi
                    indent();
                    match.statements.accept(self);
                    outdent();
                si

                visit(try_: Statement.TRY) -> void is
                    location(try_);
                    println("try");
                    indent();
                    try_.body.accept(self);
                    outdent();
                    for c in try_.catches do
                        c.accept(self);
                    od
                    if try_.finally_ != null then
                        println("finally");
                        indent();
                        try_.finally_.accept(self);
                        outdent();
                    fi
                    println("yrt");
                si

                visit(catch_: Statement.CATCH) -> void is
                    location(catch_);
                    print("catch ");
                    catch_.variable.accept(self);
                    println();
                    indent();
                    catch_.body.accept(self);
                    outdent();
                si

                visit(do_: Statement.DO) -> void is
                    location(do_);
                    if do_.condition != null then
                        print("while ");
                        do_.condition.accept(self);
                        print(" ");
                    fi
                    println("do");
                    indent();
                    do_.body.accept(self);
                    outdent();
                    println("od");
                si

                visit(labelled: Statement.LABELLED) -> void is
                    location(labelled);
                    labelled.label.accept(self);
                    print(": ");
                    labelled.statement.accept(self);
                si

                visit(break_: Statement.BREAK) -> void is
                    location(break_);
                    print("break");
                    if break_.label != null then
                        print(' ');
                        break_.label.accept(self);
                    fi
                    println(";");
                si

                visit(continue_: Statement.CONTINUE) -> void is
                    location(continue_);
                    print("continue");
                    if continue_.label != null then
                        print(' ');
                        continue_.label.accept(self);
                    fi
                    println(";");
                si

            si

        si
    si
si
