namespace Syntax.Trees.Patterns is
    use Source;

    class Pattern: Trees.Node is
        init(location: LOCATION) is
            super.init(location);
        si
    si

    /*
    list of tree nodes in this file that need to be added to Visitor:
    - LIST
    - DISCARD
    - TUPLE
    - TYPE
    - IF
    - LITERAL
    - VARIANT
    - IDENTIFIER
    - CLAUSE
    */

    class LIST: Trees.Node is
        patterns: Collections.List[Pattern];

        init(location: LOCATION, patterns: Collections.Iterable[Pattern]) is
            super.init(location);

            assert patterns? else "list pattern is null";
            assert patterns | .all(e => e?) else "list pattern an element is null";

            self.patterns = patterns | .collect();
        si
        
        walk(visitor: Syntax.Visitor) is
            if !visitor.pre(self) then
                for pattern in patterns do
                    pattern.walk(visitor);
                od
            fi

            accept(visitor);
        si

        accept(visitor: Syntax.Visitor) is
            visitor.visit(self);
        si
    si

    class DISCARD: Pattern is
        init(location: LOCATION) is
            super.init(location);
        si

        walk(visitor: Syntax.Visitor) is
            visitor.pre(self);

            accept(visitor);
        si

        accept(visitor: Syntax.Visitor) is
            visitor.visit(self);
        si
    si

    class TUPLE: Pattern is
        elements: Collections.List[Pattern];

        init(location: LOCATION, elements: Collections.Iterable[Pattern]) is
            super.init(location);

            assert elements? else "tuple pattern elements is null";
            assert elements | .all(e => e?) else "tuple pattern an element is null";

            self.elements = elements | .collect();
        si

        walk(visitor: Syntax.Visitor) is
            if !visitor.pre(self) then
                for element in elements do
                    element.walk(visitor);
                od
            fi

            accept(visitor);
        si

        accept(visitor: Syntax.Visitor) is
            visitor.visit(self);
        si
    si

    class TYPE: Pattern is
        type_expression: Trees.TypeExpressions.TypeExpression;
        identifier: Trees.Identifiers.Identifier;

        init(
            location: LOCATION, 
            type_expression: Trees.TypeExpressions.TypeExpression,
            identifier: Trees.Identifiers.Identifier
        ) is
            super.init(location);

            assert type_expression? else "type expression is null";
            assert identifier? else "identifier is null";

            self.type_expression = type_expression;
            self.identifier = identifier;
        si

        walk(visitor: Syntax.Visitor) is
            if !visitor.pre(self) then
                identifier.walk(visitor);
                type_expression.walk(visitor);
            fi

            accept(visitor);
        si

        accept(visitor: Syntax.Visitor) is
            visitor.visit(self);
        si
    si

    class IF: Pattern is
        pattern: Pattern;
        condition: Trees.Expressions.Expression;
        expression: Trees.Expressions.Expression;

        init(
            location: LOCATION, 
            pattern: Pattern,
            condition: Trees.Expressions.Expression,
            expression: Trees.Expressions.Expression
        ) is
            super.init(location);

            assert pattern? else "pattern is null";
            assert condition? else "condition is null";
            assert expression? else "expression is null";

            self.pattern = pattern;
            self.condition = condition;
            self.expression = expression;
        si

        walk(visitor: Syntax.Visitor) is
            if !visitor.pre(self) then
                pattern.walk(visitor);
                condition.walk(visitor);
                expression.walk(visitor);
            fi

            accept(visitor);
        si
    si

    class LITERAL: Pattern is
        literal: Trees.Expressions.Literals.Literal;

        init(location: LOCATION, literal: Trees.Expressions.Literals.Literal) is
            super.init(location);

            assert literal? else "literal is null";

            self.literal = literal;
        si

        walk(visitor: Syntax.Visitor) is
            if !visitor.pre(self) then
                literal.walk(visitor);
            fi

            accept(visitor);
        si
        
        accept(visitor: Syntax.Visitor) is
            visitor.visit(self);
        si
    si

    class VARIANT: Pattern is
        variant: Trees.TypeExpressions.TypeExpression;
        fields: Collections.List[Pattern];

        init(
            location: LOCATION, 
            variant: Trees.TypeExpressions.TypeExpression,
            fields: Collections.Iterable[Pattern]
        ) is
            super.init(location);

            assert variant? else "variant is null";
            assert fields? else "fields is null";
            assert fields | .all(e => e?) else "fields an element is null";

            self.variant = variant;
            self.fields = fields | .collect();
        si

        walk(visitor: Syntax.Visitor) is
            if !visitor.pre(self) then
                variant.walk(visitor);

                for `field in fields do
                    `field.walk(visitor);
                od
            fi

            accept(visitor);
        si
    si

    class IDENTIFIER: Pattern is
        identifier: Trees.Identifiers.Identifier;

        init(location: LOCATION, identifier: Trees.Identifiers.Identifier) is
            super.init(location);

            assert identifier? else "identifier is null";

            self.identifier = identifier;
        si

        walk(visitor: Syntax.Visitor) is
            if !visitor.pre(self) then
                identifier.walk(visitor);
            fi

            accept(visitor);
        si

        accept(visitor: Syntax.Visitor) is
            visitor.visit(self);
        si
    si

    class CLAUSE: Trees.Node is
        pattern: Pattern;
        statement: Trees.Statements.Statement;

        init(location: LOCATION, pattern: Pattern, statement: Trees.Statements.Statement) is
            super.init(location);

            assert pattern? else "pattern is null";
            assert statement? else "statement is null";

            self.pattern = pattern;
            self.statement = statement;
        si

        walk(visitor: Syntax.Visitor) is
            if !visitor.pre(self) then
                pattern.walk(visitor);
                statement.walk(visitor);
            fi

            accept(visitor);
        si

        accept(visitor: Syntax.Visitor) is
            visitor.visit(self);
        si
    si
si
