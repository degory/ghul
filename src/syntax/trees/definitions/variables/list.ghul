namespace Syntax.Trees.Variables is
    
    use Source;

    class VARIABLE_ITERATOR: Collections.Iterator[VARIABLE] is
        root: LIST;

        stack: Collections.STACK[Collections.Iterator[Node]];

        current: VARIABLE;

        init(root: LIST) is
            self.root = root;
            self.stack = new Collections.STACK[Collections.Iterator[Node]]();
            self.stack.push(root.variables.iterator);
        si

        move_next() -> bool is
            let top = stack.peek();

            do 
                if top.move_next() then
                    let current = top.current;

                    if isa LIST(current) then
                        let list = cast LIST(current);

                        stack.push(list.variables.iterator);

                        continue;
                    else
                        self.current = cast VARIABLE(current); 
                        return true;
                    fi
                fi

                if stack.count > 0 then
                    stack.pop();
                else
                    return false;
                fi
            od
        si

        reset() is
            stack.clear();
            stack.push(root.variables.iterator);
        si

        dispose() is
            stack.clear();
        si
    si

    class LIST: Trees.Node, Collections.Iterable[VARIABLE] is
        variables: Collections.MutableList[Node];

        iterator: Collections.Iterator[VARIABLE] => new VARIABLE_ITERATOR(self);

        init(location: LOCATION, variables: Collections.Iterable[Node]) is
            super.init(location);

            assert variables? else "variables list is null";
            assert variables | .all(v => v?) else "variables list contains null elements";

            self.variables = new Collections.LIST[Node](variables);
        si

        mark_want_dispose() is
            for v in variables do
                v.mark_want_dispose();
            od
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                for v in variables do
                    v.walk(visitor);
                od
            fi
            
            accept(visitor);
        si
    si
si
