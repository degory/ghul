// FIXME: correct this namespace:
namespace Syntax.Trees.Variables is
    
    use Source;

    class VARIABLE: Trees.Definitions.Definition is
        left: VariableLeft;
        name: Identifiers.Identifier => left.name;

        names: Collections.Iterator[Identifiers.Identifier] => left.names;

        type_expression: TypeExpressions.TypeExpression;
        initializer: Expressions.Expression;
        is_static: bool;
        is_explicit_type: bool;
        is_variable: bool => true;
        want_dispose: bool;
        
        init(
            location: LOCATION,
            left: VariableLeft,
            type_expression: TypeExpressions.TypeExpression,
            is_static: bool,
            is_explicit_type: bool,
            initializer: Expressions.Expression
        ) is
            super.init(location);

            assert left? else "left part of variable cannot be null";

            self.left = left;
            self.type_expression = type_expression;
            self.is_static = is_static;
            self.is_explicit_type = is_explicit_type;
            self.initializer = initializer;
        si

        init(
            location: LOCATION,
            name: Identifiers.Identifier,
            type_expression: TypeExpressions.TypeExpression,
            is_static: bool,
            is_explicit_type: bool,
            initializer: Expressions.Expression
        ) is
            assert name? else "name of variable cannot be null";

            init(
                location,
                new SINGLE_NAME_LEFT(location, name),
                type_expression,
                is_static,
                is_explicit_type,
                initializer
            );
        si

        set_type_expression(type_expression: TypeExpressions.TypeExpression) is
            self.type_expression = type_expression;
        si

        mark_want_dispose() is
            want_dispose = true;
        si

        copy() -> VARIABLE is
            assert initializer == null else "cannot copy a variable node with non null initializer";

            return new VARIABLE(
                location,
                left.copy(),
                type_expression.copy(),
                is_static,
                is_explicit_type,
                null
            );
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                left.walk(visitor);
                type_expression.walk(visitor);
                if initializer? then
                    initializer.walk(visitor);
                fi
            fi
            accept(visitor);
        si
    si

    class VariableLeft: Trees.Node is
        is_simple_name: bool => false;
        name: Identifiers.Identifier => null;
        names: Collections.Iterator[Identifiers.Identifier] => null;
        elements: Collections.List[VariableLeft] => null;

        init(location: LOCATION) is
            super.init(location);
        si

        copy() -> VariableLeft;
    si

    class SINGLE_NAME_LEFT: VariableLeft is
        name: Identifiers.Identifier;
        is_simple_name: bool => true;

        elements: Collections.List[VariableLeft] => System.Array.empty`[VariableLeft]();
        names: Collections.Iterator[Identifiers.Identifier] => [name].iterator;

        init(
            location: LOCATION, 
            name: Identifiers.Identifier
        ) is
            super.init(location);
            self.name = name;
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                name.walk(visitor);
            fi

            accept(visitor);
        si

        copy() -> VariableLeft is
            return new SINGLE_NAME_LEFT(location, name);
        si
    si

    class DESTRUCTURE_LEFT: VariableLeft is
        elements: Collections.List[VariableLeft];

        names: Collections.Iterator[Identifiers.Identifier] => new DESTRUCTURE_LEFT_NAMES_ITERATOR(elements);

        init(location: LOCATION, elements: Collections.List[VariableLeft]) is
            super.init(location);
            self.elements = elements;
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                for e in elements do
                    e.walk(visitor);
                od
            fi
            accept(visitor);
        si

        copy() -> VariableLeft is
            let new_elements = new Collections.LIST[VariableLeft](elements.count);

            for e in elements do
                new_elements.add(e.copy());
            od

            return new DESTRUCTURE_LEFT(location, new_elements);
        si
    si

    class DESTRUCTURE_LEFT_NAMES_ITERATOR: Collections.Iterator[Identifiers.Identifier] is
        _stack: Collections.STACK[Collections.Iterator[VariableLeft]];

        current: Identifiers.Identifier;

        init(elements: Collections.List[VariableLeft]) is
            _stack = new Collections.STACK[Collections.Iterator[VariableLeft]]();

            _stack.push(elements.iterator);
        si

        move_next() -> bool is
            while _stack.count > 0 do
                let top = _stack.peek();

                if top.move_next() then
                    let c = top.current;

                    if c.is_simple_name then
                        current = c.name;

                        return true;
                    else
                        _stack.push(c.elements.iterator);
                    fi

                    return true;
                else
                    _stack.pop();
                fi
            od

            return false;
        si

        reset() is
            current = null;
            _stack.clear();
        si

        dispose() is
            current = null;
            _stack.clear();
        si
    si
si
