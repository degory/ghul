// FIXME: correct this namespace:
namespace Syntax.Trees.Variables is
    
    use Source;

    class Variable: Trees.Definitions.Definition is
        want_dispose: bool;
        is_destructure: bool => false;
        is_variable: bool => false;
        name: Identifiers.Identifier => null;
        element: DESTRUCTURE_ELEMENT => null;
        variable: VARIABLE => null;
        type_expression: TypeExpressions.TypeExpression => null;

        mark_want_dispose() is
            want_dispose = true;
        si

        init(location: LOCATION) is
            super.init(location);
        si
    si

    class Destructure: Variable is
        is_destructure_element: bool => false;        
        is_destructure: bool => true;

        elements: Collections.List[Destructure] => new Collections.LIST[Destructure]();

        init(location: LOCATION) is
            super.init(location);
        si
    si

    class DESTRUCTURE_ELEMENT: Destructure is
        name: Identifiers.Identifier;
        is_destructure_element: bool => true;

        element: DESTRUCTURE_ELEMENT => self;

        elements: Collections.List[Destructure] => [self]: Destructure;

        init(location: LOCATION, name: Identifiers.Identifier) is
            super.init(location);
            self.name = name;
        si
    si

    class DESTRUCTURE_ELEMENTS: Destructure is
        element: DESTRUCTURE_ELEMENT => null;
        elements: Collections.List[Destructure];

        init(location: LOCATION, elements: Collections.List[Destructure]) is
            super.init(location);
            self.elements = elements;
        si
    si

    class VARIABLE: Variable is
        name: Identifiers.Identifier;
        type_expression: TypeExpressions.TypeExpression;
        initializer: Expressions.Expression;
        is_static: bool;
        is_explicit_type: bool;
        is_variable: bool => true;

        variable: VARIABLE => self;
        
        init(
            location: LOCATION,
            name: Identifiers.Identifier,
            type_expression: TypeExpressions.TypeExpression,
            is_static: bool,
            is_explicit_type: bool,
            initializer: Expressions.Expression
        ) is
            super.init(location);

            self.name = name;
            self.type_expression = type_expression;
            self.is_static = is_static;
            self.is_explicit_type = is_explicit_type;
            self.initializer = initializer;
        si

        set_type_expression(type_expression: TypeExpressions.TypeExpression) is
            self.type_expression = type_expression;
        si

        copy() -> VARIABLE is
            assert initializer == null else "cannot copy a variable node with non null initializer";

            return new VARIABLE(
                location,
                name.copy(),
                type_expression.copy(),
                is_static,
                is_explicit_type,
                null
            );
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                name.walk(visitor);
                type_expression.walk(visitor);
                if initializer? then
                    initializer.walk(visitor);
                fi
            fi
            accept(visitor);
        si
    si
si
