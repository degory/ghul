// FIXME: correct this namespace:
namespace Syntax.Trees.Variables is
    
    use Source;

    class Variable: Trees.Definitions.Definition is
        want_dispose: bool;
        is_destructure: bool => false;
        is_variable: bool => false;
        is_element: bool => false;
        is_explicit_type: bool => false;

        // variables and destructure elements both have names:
        name: Identifiers.Identifier => null;

        // if the variable is a true variable, then it has a type expression and may have an initializer:
        variable: VARIABLE => null;
        type_expression: TypeExpressions.TypeExpression => null;
        set_type_expression(type_expression: TypeExpressions.TypeExpression) is si
        initializer: Expressions.Expression => null;

        // if the variable is actually a destructure element, then element returns it:
        element: DESTRUCTURE_ELEMENT => null;

        // if the variable is actually a destruture element list, then elements returns its elements:
        elements: Collections.List[Destructure] => System.Array.empty`[Destructure]();

        // if the variable is actually a destructure, then elements returns all its elements, including nested destructures
        // as a flat iterator:
        all_elements: Collections.Iterator[DESTRUCTURE_ELEMENT] => System.Array.empty`[DESTRUCTURE_ELEMENT]().iterator;

        all: Collections.Iterator[Variable] => System.Array.empty`[Variable]().iterator;

        mark_want_dispose() is
            want_dispose = true;
        si

        init(location: LOCATION) is
            super.init(location);
        si
    si

    class Destructure: Variable is
        is_element: bool => false;        
        is_destructure: bool => true;

        elements: Collections.List[Destructure] => System.Array.empty`[Destructure]();
        all_elements: Collections.Iterator[DESTRUCTURE_ELEMENT] => System.Array.empty`[DESTRUCTURE_ELEMENT]().iterator;

        init(location: LOCATION) is
            super.init(location);
        si

        copy() -> Destructure;
    si

    class DESTRUCTURE_ELEMENT: Destructure is
        name: Identifiers.Identifier;
        is_element: bool => true;
        type_expression: TypeExpressions.TypeExpression;

        element: DESTRUCTURE_ELEMENT => self;
        elements: Collections.List[Destructure] => [self]: Destructure;
        all_elements: Collections.Iterator[DESTRUCTURE_ELEMENT] => [self].iterator;

        all: Collections.Iterator[Variable] => new SINGLE_VARIABLE_ITERATOR(self);

        init(
            location: LOCATION, 
            name: Identifiers.Identifier,
            type_expression: TypeExpressions.TypeExpression
        ) is
            super.init(location);
            self.name = name;
            self.type_expression = type_expression;
        si

        set_type_expression(type_expression: TypeExpressions.TypeExpression) is
            self.type_expression = type_expression;
        si

        copy() -> Destructure is
            return new DESTRUCTURE_ELEMENT(
                location,
                name.copy(),
                if type_expression? then type_expression.copy() else null fi
            );
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                name.walk(visitor);
            fi

            accept(visitor);
        si
    si

    class DESTRUCTURE_ELEMENT_LIST: Destructure is
        element: DESTRUCTURE_ELEMENT => null;
        elements: Collections.List[Destructure];

        all_elements: Collections.Iterator[DESTRUCTURE_ELEMENT] => new DESTRUCTURE_ELEMENT_LIST_ITERATOR(self);
        all: Collections.Iterator[Variable] => new DESTRUCTURE_ELEMENT_LIST_MAPPER[Variable](self, (e: DESTRUCTURE_ELEMENT) => e);
 
        init(location: LOCATION, elements: Collections.List[Destructure]) is
            super.init(location);
            self.elements = elements;
        si

        copy() -> Destructure is
            assert initializer == null else "cannot copy a variable node with non null initializer";

            return 
                new DESTRUCTURE_ELEMENT_LIST(
                    location,
                    new Collections.LIST[Destructure](
                        elements | 
                            .map(e => e.copy()))
                );
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                for e in elements do
                    e.walk(visitor);
                od
            fi
            accept(visitor);
        si
    si

    class VARIABLE: Variable is
        name: Identifiers.Identifier;
        type_expression: TypeExpressions.TypeExpression;
        initializer: Expressions.Expression;
        is_static: bool;
        is_explicit_type: bool;
        is_variable: bool => true;

        variable: VARIABLE => self;

        all: Collections.Iterator[Variable] => new SINGLE_VARIABLE_ITERATOR(self);
        
        init(
            location: LOCATION,
            name: Identifiers.Identifier,
            type_expression: TypeExpressions.TypeExpression,
            is_static: bool,
            is_explicit_type: bool,
            initializer: Expressions.Expression
        ) is
            super.init(location);

            self.name = name;
            self.type_expression = type_expression;
            self.is_static = is_static;
            self.is_explicit_type = is_explicit_type;
            self.initializer = initializer;
        si

        set_type_expression(type_expression: TypeExpressions.TypeExpression) is
            self.type_expression = type_expression;
        si

        copy() -> VARIABLE is
            assert initializer == null else "cannot copy a variable node with non null initializer";

            return new VARIABLE(
                location,
                name.copy(),
                type_expression.copy(),
                is_static,
                is_explicit_type,
                null
            );
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                name.walk(visitor);
                type_expression.walk(visitor);
                if initializer? then
                    initializer.walk(visitor);
                fi
            fi
            accept(visitor);
        si
    si

    class SINGLE_VARIABLE_ITERATOR: Collections.Iterator[Variable] is
        _variable: Variable;
        current: Variable;

        init(variable: Variable) is
            assert variable? else "variable cannot be null";
            _variable = variable;
        si
        
        move_next() -> bool is
            if current == null then
                current = _variable;
                return true;
            else
                return false;
            fi
        si

        reset() is
            current = null;
        si
        
        dispose() is
            current = null;
            _variable = null;
        si
    si

    class DESTRUCTURE_ELEMENT_LIST_ITERATOR: Collections.Iterator[DESTRUCTURE_ELEMENT] is
        _destructure: Destructure;
        _state: Collections.STACK[Collections.Iterator[Destructure]];

        current: DESTRUCTURE_ELEMENT;

        init(destructure: Destructure) is
            assert destructure? else "destructure cannot be null";

            _state = new Collections.STACK[Collections.Iterator[Destructure]]();
            _destructure = destructure;
            _state.push(destructure.elements.iterator);
        si

        move_next() -> bool is
            while _state.count > 0 do
                let top = _state.peek();
                if top.move_next() then
                    if top.current.is_destructure then
                        _state.push(current.elements.iterator);
                    else 
                        current = top.current.element;
                        return true;
                    fi
                else
                    _state.pop();
                fi
            od

            return false;
        si

        reset() is
            _state.clear();
            _state.push(_destructure.elements.iterator);
        si

        dispose() is
            _destructure = null;
            _state = null;
        si
    si

    class DESTRUCTURE_ELEMENT_LIST_MAPPER[T]: Collections.Iterator[T] is
        _destructure: Destructure;
        _state: Collections.STACK[Collections.Iterator[Destructure]];
        _f: DESTRUCTURE_ELEMENT -> T;

        _current_element: DESTRUCTURE_ELEMENT;
        current: T;

        init(destructure: Destructure, f: DESTRUCTURE_ELEMENT -> T) is
            assert destructure? else "destructure cannot be null";

            _state = new Collections.STACK[Collections.Iterator[Destructure]]();
            _destructure = destructure;
            _f = f;
            _state.push(destructure.elements.iterator);
        si

        move_next() -> bool is
            while _state.count > 0 do
                let top = _state.peek();
                if top.move_next() then
                    if top.current.is_destructure then
                        _state.push(_current_element.elements.iterator);
                    else 
                        _current_element = top.current.element;
                        current = _f(_current_element);
                        return true;
                    fi
                else
                    _state.pop();
                fi
            od

            return false;
        si

        reset() is
            _state.clear();
            _state.push(_destructure.elements.iterator);
        si

        dispose() is
            _destructure = null;
            _state = null;
        si
    si
si
