namespace Syntax.Trees.Expressions is
    use Source;

    use IR.Values.Value;

    use Debugging;

    class Expression: Node, TypeConstrained is
        value: Value public;
        right_location: LOCATION => location;

        is_identifier: bool => false;
        is_unqualified_identifier: bool => false;
        is_member: bool => false;
        is_tuple_literal: bool => false;
        is_pinned: bool => false;

        could_be_formal_argument: bool => false;
        could_be_nested_function_definition: bool => false;
        could_be_type_expression: bool => false;
        must_be_consumed: bool => false;

        description: string => "expression";

        constraint: Semantic.Types.Type => null;
        concrete_constraint: Semantic.Types.Type =>
            let c = constraint in
            if c? /\ c.any_count == 0 then
                c
            else
                null;
            fi;


        init(location: LOCATION) is
            super.init(location);
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        try_copy_as_variables() -> Variables.LIST => null;
        try_copy_as_variable() -> VARIABLE => null;
        try_copy_as_tuple_element() -> TUPLE_ELEMENT => null;
        try_copy_as_type_expression() -> TypeExpressions.TypeExpression => null;
        try_copy_as_identifer() -> Identifiers.Identifier => null;

        rewrite_as_assignment_left() -> AssignmentLeftExpression => SIMPLE_LEFT_EXPRESSION(location, self);        
        rewrite_as_expression() -> Expression => self;

        try_get_string_literal() -> string => null; 

        pin() -> void is
        si

        unpin() -> void is
        si

        set_constraint(constraint: Semantic.Types.Type, constraint_error_message: string) is si

        upgrade_constraint(new_constraint: Semantic.Types.Type, new_error_message: string) is
            if !new_constraint? then
                return;
            fi

            let existing_constraint = self.constraint;

            if
                !existing_constraint? \/ 
                (new_constraint.any_count < existing_constraint.any_count) \/
                (new_constraint.any_count == existing_constraint.any_count /\ existing_constraint.is_assignable_from(new_constraint))
            then
                debug("{get_type()} upgrade constraint {existing_constraint} >> {new_constraint}");

                set_constraint(new_constraint, new_error_message);
            else
                debug("{get_type()} ignore constraint {existing_constraint} >> {new_constraint}");                
            fi
        si

        clear_constraint() is si
    si
si
