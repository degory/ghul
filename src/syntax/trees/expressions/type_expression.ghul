namespace Syntax.Trees.Expressions is
    use Source;

    class TYPE_EXPRESSION: Expression is
        // when we encounter a `[` token in an expression, it may 
        // be ambiguous whether it's introducing the actual type arguments
        // of generic specialization type expression, or if it's an index
        // expression. We speculatively parse both kinds of arguments.
        // if the type expression parse fails, we're certain it's an index
        // and we just create an INDEX node.

        // if both parses succeed, we construct a TYPE_EXPRESSION
        // node to represent the ambiguity

        // if the type expression parse succeeds and the index parse fails,
        // we're certain it's a type expression and create a TYPE_EXPRESSION
        // with no index (effectively resolving the ambiguity immediately)
    
        // there are three possibilities:
        // 1. index is null, we're certain it's a type expression
        // 2. type_expression is null, we're certain it's an index expression
        // 3. both are non-null, we're not certain

        // any ambiguity will be resolved in the resolve-explicit-types
        // phase - if the left hand side is a type, it's a type expression
        // otherwise we'll treat it as an index expression and report
        // an error in compile-expression if it's not a valid index expression
     
        expression: Expressions.Expression;
        type_expression: Trees.TypeExpressions.TypeExpression;

        // could_be_type_expression: bool => type_expression?;

        init(location: LOCATION, expression: Expressions.Expression, type_expression: TypeExpressions.TypeExpression) is
            super.init(location);
           
            // expression can be null, but there's no point in having a null type expression

            assert type_expression? else "type_expression must be non-null";

            self.expression = expression;
            self.type_expression = type_expression;
        si

        clear_expression() is
            expression = null;
        si

        clear_type_expression() is
            type_expression = null;
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                assert expression? \/ type_expression? else "expression and type_expression cannot both be null";

                if expression? then
                    expression.walk(visitor);
                fi

                if type_expression? then
                    type_expression.walk(visitor);
                fi
            fi
            
            accept(visitor);
        si
    si
si