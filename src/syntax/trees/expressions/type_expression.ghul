namespace Syntax.Trees.Expressions is
    use Source;

    union AmbiguousExpressionResult is
        INDEX;
        FUNCTION(symbol: Semantic.Symbols.Symbol);
        TYPE(type: Semantic.Types.Type);
    si

    class AMBIGUOUS_EXPRESSION: Expression is
/*
        the parser has encountered an ambiguous expression
        consisting of an identifier followed by another
        identifier enclosed in square brackets
        
        as we have no declared symbols at parse time,
        the parser cannot decide whether the first identifier
        is a type, a function name, or something that can
        be indexed.

        this TYPE_EXPRESSION could turn out be one of three things:
        1. application of type arguments to an identifier representing
        a generic type
        2. application of type arguments to an identifier representing
        a generic function
        3. an indexer operation where the indexed value is an identifier
        and the index expresion is an identifier

        we have:
        1. an index expression
        2. an identifier
        3. a list of type arguments

        In the resolve type expressions pass, when symbols are available,
        we need to search for the identifier.

        If the identifier is not found, it's an error

        If the identifier is found and it is a type, we have application of
        type arguments to a generic type.
        If the identifier is found and it is a function, we have application of
        type arguments to a generic function.
        Otherwise, we assume it's an indexer operation.
 */
        result: AmbiguousExpressionResult public;

        // index expression
        expression: Expressions.Expression;
        
        // application of actual type arguments to either
        // a generic type or a generic function: 
        identifier: Trees.Identifiers.Identifier;
        type_arguments: Trees.TypeExpressions.LIST;

        // could_be_type_expression: bool => type_expression?;

        init(
            location: LOCATION, 
            expression: Expressions.Expression, 
            identifier: Trees.Identifiers.Identifier,
            type_arguments: Trees.TypeExpressions.LIST
        ) is
            super.init(location);
           
            assert expression? else "expression cannot be null";
            assert identifier? else "identifier cannot be null";
            assert type_arguments? else "type_arguments cannot be null";

            self.expression = expression;
            self.identifier = identifier;
            self.type_arguments = type_arguments;
        si

        clear_expression() is
            expression = null;
        si

        clear_type_expression() is
            identifier = null;
            type_arguments = null;
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                if result? then
                    if result.is_index then
                        expression.walk(visitor);
                    else
                        identifier.walk(visitor);
                        type_arguments.walk(visitor);
                    fi
                fi
            fi
            
            accept(visitor);
        si
    si

    union GenericApplicationResult is
        FUNCTION(symbol: Semantic.Symbols.Symbol);
        TYPE(type: Semantic.Types.Type);
    si

    class GENERIC_APPLICATION: Expression is
        /*
        Application of type arguments to a generic type or a generic function.

        This is similar to AMBIGUOUS_EXPRESSION, but the parser 
        determined that the expression cannot be an indexer operation.
        */

        result: GenericApplicationResult public;
        
        // identifier representing a generic type or a generic function:
        identifier: Trees.Identifiers.Identifier;

        // actual type arguments to apply to the generic type or function:
        type_arguments: Trees.TypeExpressions.LIST;

        // could_be_type_expression: bool => type_expression?;

        init(
            location: LOCATION, 
            identifier: Trees.Identifiers.Identifier,
            type_arguments: Trees.TypeExpressions.LIST
        ) is
            super.init(location);

            assert identifier? else "identifier cannot be null";
            assert type_arguments? else "type_arguments cannot be null";

            self.identifier = identifier;
            self.type_arguments = type_arguments;
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                if result? then
                    identifier.walk(visitor);
                    type_arguments.walk(visitor);
                fi
            fi
            
            accept(visitor);
        si
    si
si