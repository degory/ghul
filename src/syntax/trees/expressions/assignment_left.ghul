// FIXME: correct this namespace:
namespace Syntax.Trees.Expressions is
    
    use Source;

    class AssignmentLeft: Expression is
        is_simple_expression: bool => false;
        expression: Expression => null;
        expressions: Collections.Iterator[Expression] => null;
        elements: Collections.List[AssignmentLeft] => null;

        init(location: LOCATION) is
            super.init(location);
        si

        get_names_into(into: Collections.MutableList[Expression]);

        copy() -> AssignmentLeft;
    si

    class SINGLE_EXPRESSION_LEFT: AssignmentLeft is
        expression: Expression;
        is_simple_expression: bool => true;

        elements: Collections.List[AssignmentLeft] => System.Array.empty`[AssignmentLeft]();
        expressions: Collections.Iterator[Expression] => [expression].iterator;

        init(
            location: LOCATION, 
            name: Expression
        ) is
            super.init(location);
            self.expression = name;
        si

        get_names_into(into: Collections.MutableList[Expression]) is
            into.add(expression);
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                expression.walk(visitor);
            fi

            accept(visitor);
        si

        copy() -> AssignmentLeft is
            return new SINGLE_EXPRESSION_LEFT(location, expression);
        si
    si

    class DESTRUCTURE_LEFT: AssignmentLeft is
        elements: Collections.List[AssignmentLeft];

        expressions: Collections.Iterator[Expression] => new DESTRUCTURE_LEFT_NAMES_ITERATOR(elements);

        init(location: LOCATION, elements: Collections.List[AssignmentLeft]) is
            super.init(location);
            self.elements = elements;
        si

        get_names_into(into: Collections.MutableList[Expression]) is
            for e in elements do
                e.get_names_into(into);
            od
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                for e in elements do
                    e.walk(visitor);
                od
            fi
            accept(visitor);
        si

        copy() -> AssignmentLeft is
            let new_elements = new Collections.LIST[AssignmentLeft](elements.count);

            for e in elements do
                new_elements.add(e.copy());
            od

            return new DESTRUCTURE_LEFT(location, new_elements);
        si
    si

    class DESTRUCTURE_LEFT_NAMES_ITERATOR: Collections.Iterator[Expression] is
        _stack: Collections.STACK[Collections.Iterator[AssignmentLeft]];

        current: Expression;

        init(elements: Collections.List[AssignmentLeft]) is
            _stack = new Collections.STACK[Collections.Iterator[AssignmentLeft]]();

            _stack.push(elements.iterator);
        si

        move_next() -> bool is
            while _stack.count > 0 do
                let top = _stack.peek();

                if top.move_next() then
                    let c = top.current;

                    if c.is_simple_expression then
                        current = c.expression;

                        return true;
                    else
                        _stack.push(c.elements.iterator);
                        return move_next();
                    fi
                else
                    _stack.pop();
                fi
            od

            return false;
        si

        reset() is
            current = null;
            _stack.clear();
        si

        dispose() is
            current = null;
            _stack.clear();
        si
    si
si
