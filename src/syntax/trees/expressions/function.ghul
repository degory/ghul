namespace Syntax.Trees.Expressions is
    use Source;

    use Debugging;

    class FUNCTION: Expression  is
        arguments: LIST;
        type_expression: TypeExpressions.TypeExpression;    
        is_recursive: bool;
        body: Bodies.Body;

        constraint: Semantic.Types.Type;
        constraint_error_message: string;

        compile_count: int public;

        init(
            location: LOCATION,
            arguments: LIST,
            type_expression: TypeExpressions.TypeExpression,
            body: Bodies.Body,
            is_recursive: bool
        )
        is
            super.init(location);

            self.arguments = arguments;
            self.type_expression = type_expression;
            self.is_recursive = is_recursive;

            self.body = body;
        si

        set_constraint(constraint: Semantic.Types.Type, constraint_error_message: string) is
            assert constraint? else "constraint is null";
            assert constraint_error_message? \/ self.constraint_error_message? else "constraint error message is null";

            debug("{get_type()} set constraint {self.constraint} >> {constraint}");
            
            self.constraint = constraint;
            self.constraint_error_message = constraint_error_message;
        si

        clear_constraint() is
            self.constraint = null;
            self.constraint_error_message = null;

            debug("{get_type()} clear constraint from {System.Diagnostics.StackTrace().to_string().replace_line_endings(" ")}");
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                type_expression.walk(visitor);
                arguments.walk(visitor);
                body.walk(visitor);
            fi

            accept(visitor);
        si
    si
si
