namespace Syntax.Trees.Statements is
    use Source;
    use IR.Values.Value;

    use Logging;
    
    class Statement: Node, TypeConstrained is
        value: Value public;
        expects_semicolon: bool => false;
        provides_value: bool => false;
        is_tuple_literal: bool => false;
        is_pinned: bool => false;
        constraint: Semantic.Types.Type => null;
        concrete_constraint: Semantic.Types.Type =>
            let c = constraint in
            if c? /\ c.any_count == 0 then
                c
            else
                null;
            fi;

        want_value: bool public;

        init(location: LOCATION) is
            super.init(location);
        si

        pin() -> void is si

        unpin() -> void is si

        set_constraint(constraint: Semantic.Types.Type, constraint_error_message: string) is
        si

        upgrade_constraint(new_constraint: Semantic.Types.Type, new_error_message: string) is
            if !new_constraint? then
                return;
            fi

            let existing_constraint = self.constraint;

            if !existing_constraint? \/ new_constraint.any_count <= existing_constraint.any_count then
                debug_always("{get_type()} upgrade constraint {existing_constraint} to {new_constraint}");
                set_constraint(new_constraint, new_error_message);
            fi
        si

        clear_constraint() is
        si
    si
si
