namespace Syntax.Trees.Statements is
    use Source;
    use IR.Values.Value;

    use Logging;
    
    class Statement: Trees.Node  is
        value: Value public;
        expects_semicolon: bool => false;
        provides_value: bool => false;
        is_tuple_literal: bool => false;
        is_pinned: bool => false;
        constraint: Semantic.Types.Type => null;

        want_value: bool public;

        init(location: LOCATION) is
            super.init(location);
        si

        pin() -> void is si

        unpin() -> void is si

        set_constraint(constraint: Semantic.Types.Type, error_message: string) is
        si

        upgrade_constraint(new_constraint: Semantic.Types.Type, error_message: string) is
            if !new_constraint? then
                return;
            fi

            let existing_constraint = self.constraint;

            if !existing_constraint? \/ new_constraint.any_count <= existing_constraint.any_count then
                set_constraint(new_constraint, error_message);
            fi
        si

        clear_constraint() is
        si
    si
si
