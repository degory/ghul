namespace Syntax.Parsers.Statements is
    use System.Exception;

    use IO.Std;
    
    use Source;

    class LIST : Base[Trees.Statements.LIST]  is
        terminators: Collections.List[Lexical.TOKEN];
        statement_parser: Parser[Trees.Statements.Statement];
        description: string => "statement list";

        init(terminators: Collections.LIST[Lexical.TOKEN], statement_parser: Parser[Trees.Statements.Statement]) is
            super.init();
            
            self.terminators = terminators;
            self.statement_parser = statement_parser;
        si

        parse(context: CONTEXT) -> Trees.Statements.LIST is
            self.terminators = terminators;

            let start = context.location;
            let end = context.location;
            let statements = new Collections.LIST[Trees.Statements.Statement]();

            let want_semicolon = false;

            while !context.is_end_of_file /\ !at_terminator(context) do
                if context.current.token == Lexical.TOKEN.SEMICOLON then
                    let location = context.location;
                    
                    context.next_token();

                    // TODO: warn about unnecessary semicolon if we are at the end of a statement list
                    if !want_semicolon /\ !at_terminator(context) then
                        IoC.CONTAINER.instance.logger.warn(location, "empty statement");
                    fi

                    want_semicolon = false;
                else                
                    try
                        let statement = statement_parser.parse(context);
                        
                        if statement? then
                            statements.add(statement);
                            want_semicolon = statement.expects_semicolon;
                        fi

                        end = statement.location;
                    catch e: Exception
                        end = context.current.location;

                        while !terminators | .has(t => t == context.current_token) do
                            end = context.current.location;
                            
                            context.next_token();
                        od 
                    yrt
                fi
            od

            return new Trees.Statements.LIST(start::end, statements);
        si

        at_terminator(context: CONTEXT) -> bool => terminators | .has(t => t == context.current_token);
    si
si
