


/*

class Pattern: Trees.Node is
    init(location: LOCATION) is
        super.init(location);
    si
si

class DISCARD: Pattern is
    init(location: LOCATION) is
        super.init(location);
    si
si

class TUPLE: Pattern is
    elements: Collections.List[Pattern];

    init(location: LOCATION, elements: Collections.Iterable[Pattern]) is
        super.init(location);

        assert elements? else "tuple pattern elements is null";
        assert elements | .all(e => e?) else "tuple pattern an element is null";

        self.elements = elements | .collect();
    si
si

class TYPE: Pattern is
    type_expression: Trees.TypeExpressions.TypeExpression;
    identifier: Trees.Identifiers.Identifier;

    init(
        location: LOCATION, 
        type_expression: Trees.TypeExpressions.TypeExpression,
        identifier: Trees.Identifiers.Identifier
    ) is
        super.init(location);

        assert type_expression? else "type expression is null";
        assert identifier? else "identifier is null";

        self.type_expression = type_expression;
        self.identifier = identifier;
    si
si

class IF: Pattern is
    pattern: Pattern;
    condition: Trees.Expressions.Expression;
    expression: Trees.Expressions.Expression;

    init(
        location: LOCATION, 
        pattern: Pattern,
        condition: Trees.Expressions.Expression,
        expression: Trees.Expressions.Expression
    ) is
        super.init(location);

        assert pattern? else "pattern is null";
        assert condition? else "condition is null";
        assert expression? else "expression is null";

        self.pattern = pattern;
        self.condition = condition;
        self.expression = expression;
    si
si

class LITERAL: Pattern is
    literal: Trees.Expressions.Literals.Literal;

    init(location: LOCATION, literal: Trees.Expressions.Literals.Literal) is
        super.init(location);

        assert literal? else "literal is null";

        self.literal = literal;
    si
si

class VARIANT: Pattern is
    variant: Trees.Identifiers.Identifier;
    fields: Collections.List[Pattern];

    init(
        location: LOCATION, 
        variant: Trees.Identifiers.Identifier,
        fields: Collections.Iterable[Pattern]
    ) is
        super.init(location);

        assert variant? else "variant is null";
        assert fields? else "fields is null";
        assert fields | .all(e => e?) else "fields an element is null";

        self.variant = variant;
        self.fields = fields | .collect();
    si
si

class CLAUSE: Trees.Node is
    pattern: Pattern;
    statement: Trees.Statements.Statement;

    init(location: LOCATION, pattern: Pattern, statement: Trees.Statements.Statement) is
        super.init(location);

        assert pattern? else "pattern is null";
        assert statement? else "statement is null";

        self.pattern = pattern;
        self.statement = statement;
    si
si

*/

namespace Syntax.Parsers.Patterns is
    use IO.Std;

    use Source;

    use Logging;
    
    class PATTERN: Base[Trees.Patterns.Pattern] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_parser: Parser[Trees.TypeExpressions.TypeExpression];
        expression_parser: Parser[Trees.Expressions.Expression];
        expression_primary_parser: Parser[Trees.Expressions.Expression];
        expression_tuple_parser: Parser[Trees.Expressions.TUPLE];
        statement_parser: Parser[Trees.Statements.Statement];
        variable_list_parser: Parser[Trees.Variables.LIST];

        description: string => "primary expression";

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_parser: Parser[Trees.TypeExpressions.TypeExpression],
            expression_parser: Parser[Trees.Expressions.Expression],
            expression_primary_parser: Parser[Trees.Expressions.Expression],
            expression_tuple_parser: Parser[Trees.Expressions.TUPLE],
            statement_parser: Parser[Trees.Statements.Statement],
            variable_list_parser: Parser[Trees.Variables.LIST]
        )
        is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.expression_parser = expression_parser;
            self.expression_primary_parser = expression_primary_parser;
            self.expression_tuple_parser = expression_tuple_parser;
            self.statement_parser = statement_parser;
            self.variable_list_parser = variable_list_parser;

            add_parsers();
        si

/*
case_expression ::= "case" expression "when" pattern_clause+ ("else" statement)? "esac"

pattern_clause ::= pattern ":" statement
                 | pattern "if" expression ":" statement

pattern ::= literal_pattern
          | identifier_pattern
          | variant_pattern
          | tuple_pattern
          | type_pattern
          | wildcard_pattern
          | nested_pattern

literal_pattern ::= int_literal
                  | string_literal
                  | qualified_identifier

identifier_pattern ::= identifier ("=" identifier)?

variant_pattern ::= qualified_identifier variant_pattern_fields?
variant_pattern_fields ::= "(" pattern ("," pattern)* ")"

tuple_pattern ::= "(" pattern ("," pattern)* ")"

type_pattern ::= type_expression "(" identifier ")"

wildcard_pattern ::= "_"

nested_pattern ::= "(" pattern ")"

identifier ::= ...
qualified_identifier := ...
int_literal ::= ...
string_literal ::= ...
expression ::= ...
type_expression ::= ...
*/

        add_parsers() is
            add_parser(
                (context: CONTEXT) -> Trees.Patterns.Pattern is
                    let start = context.location;

                    context.next_token();

                    return Trees.Patterns.DISCARD(start);
                si,
                Lexical.TOKEN.DISCARD
            );

            add_parser(
                (context: CONTEXT) -> Trees.Patterns.Pattern is
                    let start = context.location;
                    let type = type_parser.parse(context);

                    if context.current_token == Lexical.TOKEN.PAREN_OPEN then
                        context.next_token();

                        let patterns = parse_list(context);

                        let end = context.location;

                        context.next_token(Lexical.TOKEN.PAREN_CLOSE);

                        return Trees.Patterns.VARIANT(start::end, type, patterns);
                    fi

                    let identifier = type.try_copy_as_identifier();

                    if identifier? then
                        return Trees.Patterns.IDENTIFIER(start::identifier.location, identifier);
                    else
                        context.next_token(Lexical.TOKEN.PAREN_OPEN);
                        
                        return new Trees.Patterns.TYPE(type.location, type, Trees.Identifiers.Identifier(context.location, "$dummy"));
                    fi
                si,
                Lexical.TOKEN.IDENTIFIER
            );

            add_parser(
                (context: CONTEXT) -> Trees.Patterns.Pattern is
                    let literal = cast Trees.Expressions.Literals.Literal(expression_primary_parser.parse(context));

                    let result = Trees.Patterns.LITERAL(literal.location, literal);
                si,
                [Lexical.TOKEN.INT_LITERAL, Lexical.TOKEN.STRING_LITERAL, Lexical.TOKEN.ENTER_STRING, Lexical.TOKEN.CHAR_LITERAL]
            );

            add_parser(
                (context: CONTEXT) -> Trees.Patterns.Pattern is
                    let start = context.location;
                    context.next_token(Lexical.TOKEN.PAREN_OPEN);

                    let patterns = parse_list(context);

                    let end = context.location;

                    context.next_token(Lexical.TOKEN.PAREN_CLOSE);

                    return Trees.Patterns.TUPLE(start::end, patterns);                    
                si,
                Lexical.TOKEN.PAREN_OPEN
            );
        si

        parse_list(context: CONTEXT) -> Collections.List[Trees.Patterns.Pattern] is
            let result = Collections.LIST[Trees.Patterns.Pattern]();

            do
                let pattern = parse(context);

                if pattern? then
                    result.add(pattern);
                else
                    result.add(Trees.Patterns.DISCARD(context.location));
                fi

                if context.current_token != Lexical.TOKEN.COMMA then
                    return result;
                fi
            od
        si

        other_token(context: CONTEXT) -> Trees.Patterns.Pattern is
            super.other_token(context);

            let result = Trees.Patterns.DISCARD(context.location);

            result.poison();

            return result;
        si        
    si
si
