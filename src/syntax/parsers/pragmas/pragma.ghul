namespace Syntax.Parsers.Pragmas is
    
    use Source;

    use Logging;

    class PRAGMA: Base[Trees.Pragmas.PRAGMA] is
        qualified_identifier_parser: Parser[Trees.Identifiers.Identifier];
        expression_list_parser: Parser[Trees.Expressions.LIST];

        init(
            qualified_identifier_parser: Parser[Trees.Identifiers.Identifier],
            expression_list_parser: Parser[Trees.Expressions.LIST]
        ) is
            super.init();

            self.qualified_identifier_parser = qualified_identifier_parser;
            self.expression_list_parser = expression_list_parser;
        si

        parse(context: CONTEXT) -> Trees.Pragmas.PRAGMA is
            try
                // debug_always(">>pragma");

                // debug_enter();

                let fail = false;
                let expect_semicolon = false;
                
                let start = context.location;
    
                if !context.next_token(Lexical.TOKEN.AT) then
                    debug("pragma: no @");
                    return null;
                fi
    
                debug("pragma: parse qualified_identifier");

                let name = qualified_identifier_parser.parse(context);
    
                if !name? then
                    debug("pragma: no name");
                    return null;
                fi

                debug("pragma: name: {name}");
    
                if context.next_token(Lexical.TOKEN.PAREN_OPEN) then
                    debug("pragma: maybe parse expression_list");

                    let arguments: Trees.Expressions.LIST;
                    
                    if context.current.token != Lexical.TOKEN.PAREN_CLOSE then
                        debug("pragma: parse expression_list");

                        arguments = expression_list_parser.parse(context);

                        debug("pragma: expression_list: {arguments}");
                    fi

                    debug("pragma: expect closing paren");
    
                    context.next_token(Lexical.TOKEN.PAREN_CLOSE);

                    debug("pragma: about to return");
                    
                    return new Trees.Pragmas.PRAGMA(start::context.location, name, arguments);
                fi

                debug("pragma: no expression_list: return pragma without arguments");

                // FIXME: should this be an error?
                return new Trees.Pragmas.PRAGMA(start::context.location, name, new Trees.Expressions.LIST(context.location, new Collections.LIST[Trees.Expressions.Expression]()));
            finally
                // debug_exit();

                // debug_always("<<pragma");
            yrt
        si
    si
si
