namespace Syntax.Parsers.Definitions is
    use IO.Std;

    use Source;

    class PROPERTY: Base[Trees.Definitions.PROPERTY] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_parser: Parser[Trees.TypeExpressions.TypeExpression];
        modifier_list_parser: Parser[Trees.Modifiers.LIST];
        body_parser: Parser[Trees.Bodies.Body];

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_parser: Parser[Trees.TypeExpressions.TypeExpression],
            modifier_list_parser: Parser[Trees.Modifiers.LIST],
            body_parser: Parser[Trees.Bodies.Body]
        ) is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.modifier_list_parser = modifier_list_parser;
            self.body_parser = body_parser;
        si

        parse(context: CONTEXT) -> Trees.Definitions.PROPERTY is
            let fail = false;
            let progress = false;

            try
                if context.in_classy then
                    context.in_member = true;
                    context.member_indent = context.location.start_column
                else
                    context.in_global_function = true;
                    context.global_indent = context.location.start_column;
                fi
    
                Logging.debug("start parsing property...");

                let start = context.location;
                let name = identifier_parser.parse(context);
                let type_expression: Trees.TypeExpressions.TypeExpression;
    
                Logging.debug("parsed property name: {name}, now parsing type...");
    
                if context.current.token == Lexical.TOKEN.COLON then
                    context.next_token();
                    progress = true;
    
                    Logging.debug("read colon, now parsing type...");
    
                    type_expression = type_parser.parse(context);
    
                    if type_expression == null \/ type_expression.is_poisoned then
                        Logging.debug("failed to parse type expression, setting fail flag...");
                        fail = true;
                    fi
                else
                    Logging.debug("no colon, setting type to infer...");
    
                    type_expression = new Trees.TypeExpressions.INFER(context.location);
                fi
    
                Logging.debug("parsed type expression: {type_expression}");
    
                let modifiers = modifier_list_parser.parse(context);
                let read_body: Trees.Bodies.Body;
                let assign_body: Trees.Bodies.Body;
                let setter_argument_name: Trees.Identifiers.Identifier;
                let expect_semicolon = true;
    
                Logging.debug("parsed modifiers: {modifiers}");
    
                do
                    Logging.debug("top of loop...");
    
                    if context.current.token == Lexical.TOKEN.ASSIGN then
                        Logging.debug("found assign, parsing assign body...");
    
                        if setter_argument_name? then
                            Logging.debug("replacing assign body: error");
                            context.error(context.location, "replacing assign");
                        fi
    
                        context.next_token();
                        progress = true;
    
                        Logging.debug("parsing assign argument name...");
    
                        setter_argument_name = identifier_parser.parse(context);
                        expect_semicolon = context.current.token == Lexical.TOKEN.ARROW_FAT \/ context.current.token == Lexical.TOKEN.INNATE;
                        assign_body = body_parser.parse(context);
    
                        Logging.debug("parsed assign body: {setter_argument_name} {assign_body}");
    
                        if context.current.token == Lexical.TOKEN.COMMA then
                            Logging.debug("found comma after assign body, consuming and continuing...");
    
                            context.next_token();
                            progress = true;
                        else
                            Logging.debug("no comma after assign body, breaking...");
    
                            if isa Trees.Bodies.NULL(assign_body) then
                                Logging.debug("assign body is null, setting expect semicolon...");
                                expect_semicolon = true;
                            fi
    
                            break;
                        fi
                    elif 
                        context.current.token == Lexical.TOKEN.IS \/ 
                        context.current.token == Lexical.TOKEN.ARROW_FAT \/ 
                        context.current.token == Lexical.TOKEN.INNATE
                    then
                        expect_semicolon = context.current.token == Lexical.TOKEN.ARROW_FAT \/ context.current.token == Lexical.TOKEN.INNATE;
    
                        Logging.debug("found read body, parsing...");
    
                        if read_body? then
                            Logging.debug("replacing read body: error");
    
                            context.error(context.location, "replacing read");
                        fi
    
                        read_body = body_parser.parse(context);
    
                        Logging.debug("parsed read body: {read_body}");
    
                        if context.current.token == Lexical.TOKEN.COMMA then
                            Logging.debug("found comma after read body, consuming and continuing...");
    
                            context.next_token();
                            progress = true;
                        else
                            Logging.debug("no comma after read body, breaking...");
    
                            if isa Trees.Bodies.NULL(read_body) then
                                Logging.debug("read body is null, setting expect semicolon...");
                                expect_semicolon = true;
                            else
                                progress = true;
                            fi
                            
                            break;
                        fi
                    elif context.current_token == Lexical.TOKEN.SEMICOLON then
                        Logging.debug("found semicolon, breaking...");
                        
                        break;
                    elif context.current_token == Lexical.TOKEN.COMMA then
                        Logging.debug("found comma, implies empty read body...");
    
                        if read_body? then
                            Logging.debug("replacing read body: error");
                            context.error(context.location, "replacing read");
                        elif assign_body? then
                            Logging.debug("empty read body must precede write body: error");
                            context.error(context.location, "empty read body must precede write body");                        
                        else
                            Logging.debug("empty read body, setting expect semicolon...");
                            progress = true;
                            context.next_token();
                            
                            read_body = new Syntax.Trees.Bodies.NULL(context.current.location);
                        fi
                    else
                        Logging.debug("unexpected token: {context.current_token_name}");
    
                        if !fail then
                            Logging.debug("haven't reported error yet");
                            context.error(context.location, "syntax error in property: unexpected token {context.current_token_name}");
                        fi
    
                        fail = true;
    
                        break;
                    fi
    
                    Logging.debug("end of loop: setting expect semicolon");
                    expect_semicolon = true;
                od
    
                Logging.debug("end of loop: creating property...");
    
                if context.in_trait /\ read_body == null then
                    read_body = new Trees.Bodies.NULL(context.location);
                fi
    
                let result =
                    new Trees.Definitions.PROPERTY(
                        start::context.location, 
                        type_expression, 
                        name, 
                        modifiers, 
                        read_body, 
                        setter_argument_name, 
                        assign_body
                    );
    
                if expect_semicolon then
                    Logging.debug("expecting semicolon, may consume {context.current_token_name} {fail}...");
                    if !fail \/ context.current.token == Lexical.TOKEN.SEMICOLON then
                        Logging.debug("consuming semicolon...");
                        context.next_token(Lexical.TOKEN.SEMICOLON);
                    fi
                fi
    
                if fail /\ !progress then
                    Logging.debug("parsing property: no progress made so giving up...");
    
                    Std.error.write_line("parsing property: no progress made so consuming next token: {context.current_token_name}");                    
                    context.next_token();    
    
                    return null;
                fi
    
                Logging.debug("may poison result: {fail}...");
    
                result.poison(fail);
    
                Logging.debug("returning property: {result}...");
    
                return result;    
            finally                
                context.in_member = false;
            yrt
        si
    si
si
