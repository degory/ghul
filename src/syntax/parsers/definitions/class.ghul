namespace Syntax.Parsers.Definitions is
    use Source;
    use Logging;

    class CLASS: Base[Trees.Definitions.CLASS] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_parser: Parser[Trees.TypeExpressions.TypeExpression];
        type_list_parser: Parser[Trees.TypeExpressions.LIST];
        modifier_list_parser: Parser[Trees.Modifiers.LIST];
        definition_list_parser: Parser[Trees.Definitions.LIST];

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_parser: Parser[Trees.TypeExpressions.TypeExpression],
            type_list_parser: Parser[Trees.TypeExpressions.LIST],
            modifier_list_parser: Parser[Trees.Modifiers.LIST],
            definition_list_parser: Parser[Trees.Definitions.LIST]
        )
        is
            super.init();
            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.type_list_parser = type_list_parser;
            self.modifier_list_parser = modifier_list_parser;
            self.definition_list_parser = definition_list_parser;
        si

        parse(context: CONTEXT) -> Trees.Definitions.CLASS is
            let start = context.location;
            context.in_classy = true;
            context.global_indent = start.start_column;

            try
                debug_enter();
                debug("parse class definition...");

                context.next_token(Lexical.TOKEN.CLASS);
                let identifier = identifier_parser.parse(context);
    
                let is_poisoned = false;
    
                if identifier == null then
                    return null;
                fi            
    
                let arguments: Trees.TypeExpressions.LIST;
                let ancestors: Trees.TypeExpressions.LIST;

                debug("parse class definition: parse arguments and ancestors...");
    
                if context.current.token == Lexical.TOKEN.SQUARE_OPEN then
                    context.next_token();
    
                    arguments = type_list_parser.parse(context);
                    arguments.check_no_reference_types(context.logger);                
    
                    is_poisoned = arguments.is_poisoned;
                    
                    if
                        !is_poisoned \/
                        context.current.token == Lexical.TOKEN.SQUARE_CLOSE
                    then
                        is_poisoned = !context.next_token(Lexical.TOKEN.SQUARE_CLOSE) \/ is_poisoned;
                    fi
                fi

                debug("parse class definition: parse ancestors...");
    
                if context.current.token == Lexical.TOKEN.COLON then
                    context.next_token();
                    ancestors = type_list_parser.parse(context);
                    ancestors.check_no_reference_types(context.logger);                
    
                    is_poisoned = is_poisoned \/ ancestors.is_poisoned;
                fi

                debug("parse class definition: parse modifiers and body...");
    
                let modifiers = modifier_list_parser.parse(context);
    
                let read_a_body = false;
    
                let body: Trees.Definitions.LIST;
                let expect_body = false;

                debug("parse class definition: parse body: {is_poisoned}, {context.current.to_short_string()}...");                

                if !is_poisoned then
                    debug("parse class definition: parse body: not poisoned: looking for is: {context.current.to_short_string()}...");

                    if context.next_token(Lexical.TOKEN.IS) then
                        debug("parse class definition: parse body: found is, expect body");
                        expect_body = true;
                    elif lookahead_for_body(context) then
                        debug("parse class definition: parse body: error recovery lookahead found is, expect body");
                        is_poisoned = true;
                        expect_body = true;
                    fi
                else
                    debug("parse class definition: parse body: poisoned, error recovery, look for body...");
                    expect_body = lookahead_for_body(context);
                    debug("parse class definition: parse body: poisoned, error recovery, found body {expect_body}...")
                fi
                
                if expect_body then
                    debug("parse class definition: parse body: expecting to parse body...");
                    body = definition_list_parser.parse(context);

                    debug("parse class definition: parse body: parsed body");
    
                    read_a_body = true;
                else
                    debug("parse class definition: parse body: not expecting to parse body...");

                    body = new Trees.Definitions.LIST(LOCATION.internal, new Collections.LIST[Trees.Definitions.Definition](0));
                fi

                debug("parse class definition: create class definition...");
    
                let result = new Trees.Definitions.CLASS(
                    start::context.location, 
                    identifier, 
                    arguments, 
                    ancestors, 
                    modifiers, 
                    body
                );
   
                debug("parse class definition: poison result: {is_poisoned}...");

                result.poison(is_poisoned);
    
                if read_a_body then
                    if !is_poisoned then
                        debug("parse class definition: read a body and not poisoned, expect `si`...");
                        context.next_token(Lexical.TOKEN.SI);
                    elif context.current_token == Lexical.TOKEN.SI /\ context.current.location.start_column >= start.start_column then
                        debug("parse class definition: read a body, poisoned, and have `si`: consume it...");

                        context.next_token();
                    fi
                else
                    debug("parse class definition: did not read a body, don't expect a `si`");
                fi
                
                return result;
            finally
                context.in_classy = false;
                debug_exit();
            yrt
        si

        lookahead_for_body(context: CONTEXT) -> bool is
            let want_backtrack = true;

            let line = context.current.location.start_line;

            try
                context.speculate();

                // search on the current line for an 'is'
                while context.current.location.start_line == line /\ context.current.location.start_column >= context.global_indent do
                    if context.current.token == Lexical.TOKEN.IS then
                        want_backtrack = false;
                        context.next_token();
                        context.commit();

                        // is on the same line as the start of the class definition means it's likely the block is associated with the
                        // class, and we should parse it as such, even if the first part of the class definition is invalid
                        return true;
                    fi

                    context.next_token();
                od

                if context.current_token == Lexical.TOKEN.IS /\ context.current.location.start_column >= context.global_indent then
                    want_backtrack = false;
                    context.next_token();
                    context.commit();

                    // again, if the `is` is on the line immediately following the class definition, and it's properly indented, 
                    // it's likely the block is associated with the class, and we should parse it as such, even if the first part of
                    // the class definition is invalid
                    return true;
                fi

                return false;
            finally
                if want_backtrack then
                    context.backtrack();
                fi
            yrt
        si
    si
si
