namespace Syntax.Parsers.Definitions is
    use Source;
    use Logging;

    class UNION: Base[Trees.Definitions.UNION] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_parser: Parser[Trees.TypeExpressions.TypeExpression];
        type_list_parser: Parser[Trees.TypeExpressions.LIST];
        modifier_list_parser: Parser[Trees.Modifiers.LIST];
        variant_list_parser: Parser[Trees.Definitions.LIST];

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_parser: Parser[Trees.TypeExpressions.TypeExpression],
            type_list_parser: Parser[Trees.TypeExpressions.LIST],
            modifier_list_parser: Parser[Trees.Modifiers.LIST],
            variant_list_parser: Parser[Trees.Definitions.LIST]
        )
        is
            super.init();
            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.type_list_parser = type_list_parser;
            self.modifier_list_parser = modifier_list_parser;
            self.variant_list_parser = variant_list_parser;
        si

        parse(context: CONTEXT) -> Trees.Definitions.UNION is            
            let start = context.location;

            // let use debug_dispose = debug_enter();
            debug("start parsing union definition at {start}");

            context.in_classy = true;
            context.global_indent = start.start_column;

            debug("U 001");

            /*
            union_definition ::= "union" identifier type_parameters? modifiers? "is" variant_definition+ "si"

            type_parameters ::= "[" type_parameter ("," type_parameter)* "]"
            type_parameter ::= identifier

            variant_definition ::= identifier variant_fields? ";"
            variant_fields ::= "(" variant_field ("," variant_field)* ")"
            variant_field ::= identifier ":" type_expression

            type_arguments ::= "[" type_expression ("," type_expression)* "]"```

            identifier ::= ...
            type_expression ::= ...
            */

            try
                debug("U 002");
                context.next_token(Lexical.TOKEN.UNION);

                debug("expect identifier");
                let identifier = identifier_parser.parse(context);
    
                let should_poison = false;
    
                if identifier == null then
                    debug("no identifier, bailing");
                    return null;
                fi

                debug("have identifier {identifier}");
    
                let arguments: Trees.TypeExpressions.LIST;
    
                if context.current.token == Lexical.TOKEN.SQUARE_OPEN then
                    debug("reading type parameters");

                    context.next_token();

                    debug("U 003");
    
                    arguments = type_list_parser.parse(context);

                    debug("U 004");

                    if arguments? then
                        arguments.check_no_reference_types(context.logger);
                    
                        should_poison = arguments.is_poisoned;

                        debug("have type arguments {arguments}");
                    else
                        debug("oops: square bracket but no type arguments");
                    fi

                    if
                        !should_poison \/
                        context.current.token == Lexical.TOKEN.SQUARE_CLOSE
                    then
                        should_poison = !context.next_token(Lexical.TOKEN.SQUARE_CLOSE) \/ should_poison;
                    fi

                    debug("U 005");
                fi

                debug("reading modifiers");
    
                let modifiers = modifier_list_parser.parse(context);
    
                let read_a_body = false;
    
                let body: Trees.Definitions.LIST;
                let expect_body = false;

                if !should_poison then
                    debug("U 006");                    
                    if context.next_token(Lexical.TOKEN.IS) then
                        debug("U 007");
                        expect_body = true;
                    elif lookahead_for_body(context) then
                        debug("U 008");
                        should_poison = true;
                        expect_body = true;
                    fi

                    debug("U 009");
                else
                    debug("U 010");
                    expect_body = lookahead_for_body(context);
                    debug("U 011 {expect_body}");
                fi

                debug("expect body: {expect_body}");
                
                if expect_body then
                    body = variant_list_parser.parse(context);

                    debug("have body {body}");        

                    read_a_body = true;
                else
                    debug("no body");
                    body = new Trees.Definitions.LIST(LOCATION.internal, new Collections.LIST[Trees.Definitions.Definition](0));

                    debug("U 012");
                fi

                debug("U 013");

                if arguments? then
                    for member in body do
                        debug("U 014");
                        debug("member {member}");

                        if isa Trees.Definitions.VARIANT(member) then
                            debug("is a variant member");
                            let variant = cast Trees.Definitions.VARIANT(member);

                            variant.set_arguments(arguments.deep_copy());

                            debug("variant member {variant}");
                        fi

                        debug("U 015");
                    od
                fi

                debug("U 016");
    
                let result = new Trees.Definitions.UNION(
                    start::context.location, 
                    identifier, 
                    arguments, 
                    modifiers, 
                    body
                );

                debug("U 017");

                result.poison(should_poison);
    
                debug("U 018");

                if read_a_body then
                    debug("U 019");
                    if !should_poison then
                        debug("well formed union - expecting si");
                        context.next_token(Lexical.TOKEN.SI);
                    elif context.current_token == Lexical.TOKEN.SI /\ context.current.location.start_column >= start.start_column then
                        debug("poisoned union but well positioned - expecting si");
                        context.next_token();
                    else
                        debug("poisoned union and no well positioned si - assuming end of block");
                    fi

                    debug("U 020");
                fi

                debug("U 021");
                
                return result;
            finally
                debug("U 022");
                context.in_classy = false;
            yrt
        si

        lookahead_for_body(context: CONTEXT) -> bool is
            let want_backtrack = true;

            let line = context.current.location.start_line;

            let use logger_snapshot = context.logger_speculate_then_backtrack();

            // search on the current line for an 'is'
            while context.current.location.start_line == line /\ context.current.location.start_column >= context.global_indent do
                if context.current.token == Lexical.TOKEN.IS then
                    logger_snapshot.commit();

                    context.next_token();

                    // is on the same line as the start of the class definition means it's likely the block is associated with the
                    // class, and we should parse it as such, even if the first part of the class definition is invalid
                    return true;
                fi

                context.next_token();
            od

            if context.current_token == Lexical.TOKEN.IS /\ context.current.location.start_column >= context.global_indent then
                logger_snapshot.commit();
                context.next_token();

                // again, if the `is` is on the line immediately following the class definition, and it's properly indented, 
                // it's likely the block is associated with the class, and we should parse it as such, even if the first part of
                // the class definition is invalid
                return true;
            fi

            return false;
        si
    si
si
