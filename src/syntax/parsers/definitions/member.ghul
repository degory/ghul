namespace Syntax.Parsers.Definitions is
    use IO.Std;

    use Source;
    use Logging;
    
    class MEMBER: Base[Trees.Definitions.Definition]  is
        function_parser: Parser[Trees.Definitions.FUNCTION];
        property_parser: Parser[Trees.Definitions.PROPERTY];
        indexer_parser: Parser[Trees.Definitions.INDEXER];
        pragma_parser: Parser[Trees.Definitions.PRAGMA];
        description: string => "member";

        expected_tokens: Collections.Iterable[Lexical.TOKEN] => property_tokens;

        property_tokens: Collections.List[Lexical.TOKEN];

        init(
            function_parser: Parser[Trees.Definitions.FUNCTION],
            property_parser: Parser[Trees.Definitions.PROPERTY],
            indexer_parser: Parser[Trees.Definitions.INDEXER],
            pragma_parser: Parser[Trees.Definitions.PRAGMA]
        )
        is
            super.init();
            self.function_parser = function_parser;
            self.property_parser = property_parser;
            self.indexer_parser = indexer_parser;
            self.pragma_parser = pragma_parser;
            property_tokens = new Collections.LIST[Lexical.TOKEN]([Lexical.TOKEN.COLON, Lexical.TOKEN.ASSIGN, Lexical.TOKEN.ARROW_FAT, Lexical.TOKEN.SEMICOLON]);
        si

        parse(context: CONTEXT) -> Trees.Definitions.Definition is
            let need_commit = false;

            try
                // debug(">> parsing member");
                // debug_enter();

                if context.current.token == Lexical.TOKEN.SQUARE_OPEN then
                    debug("parsing member: parsing indexer...");
                    return indexer_parser.parse(context);
                elif context.current.token == Lexical.TOKEN.AT then
                    debug("parsing member: parsing pragma...");
                    return pragma_parser.parse(context);
                fi
    
                need_commit = true;
                context.speculate();

                debug("parsing member: skip over identifier to see what is after {context.current.to_short_string()}");

                context.next_token();

                debug("parsing member: next token is {context.current.to_short_string()}");

                if property_tokens | .any(t => t == context.current.token) then
                    debug("parsing member: next token is a property token {context.current.to_short_string()}");

                    context.backtrack();
                    need_commit = false;

                    return property_parser.parse(context);
                elif 
                    context.current.token == Lexical.TOKEN.SQUARE_OPEN \/
                    context.current.token == Lexical.TOKEN.PAREN_OPEN
                then
                    debug("parsing member: next token is a function token {context.current.to_short_string()}");

                    need_commit = false;
                    context.backtrack();

                    return function_parser.parse(context);
                fi

                debug("parsing member: next token is not a member token {context.current.to_short_string()} error but do not backtrack");

                need_commit = false;
                context.commit();

                other_token(context);    
            finally
                if need_commit then
                    debug("parsing member: returning in speculation: commit");

                    context.commit();
                fi

                // debug_exit();

                // debug("<< parsing member");
            yrt
        si
    si
si
