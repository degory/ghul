namespace Syntax.Parsers.Definitions is
    
    use Source;
    use Logging;

    class FUNCTION: Base[Trees.Definitions.FUNCTION] is
        identifier_function_name_parser: Parser[Trees.Identifiers.Identifier];
        type_parser: Parser[Trees.TypeExpressions.TypeExpression];
        type_list_parser: Parser[Trees.TypeExpressions.LIST];
        modifier_list_parser: Parser[Trees.Modifiers.LIST];
        body_parser: Parser[Trees.Bodies.Body];
        variable_list_parser: Parser[Trees.Variables.LIST];

        init(
            identifier_function_name_parser: Parser[Trees.Identifiers.Identifier],
            type_parser: Parser[Trees.TypeExpressions.TypeExpression],
            type_list_parser: Parser[Trees.TypeExpressions.LIST],
            modifier_list_parser: Parser[Trees.Modifiers.LIST],
            body_parser: Parser[Trees.Bodies.Body],
            variable_list_parser: Parser[Trees.Variables.LIST])
        is
            super.init();

            self.identifier_function_name_parser = identifier_function_name_parser;
            self.type_parser = type_parser;
            self.type_list_parser = type_list_parser;
            self.modifier_list_parser = modifier_list_parser;
            self.body_parser = body_parser;
            self.variable_list_parser = variable_list_parser;
        si

        parse(context: CONTEXT) -> Trees.Definitions.FUNCTION is
            // debug_always(">> parse function");
            // debug_enter();

            // if we get here, we expect lookahead to have already seen
            // and recognized an identifier and either a '(' or a '['

            if context.in_classy then
                context.in_member = true;
                context.member_indent = context.location.start_column
            else
                context.in_global_function = true;
                context.global_indent = context.location.start_column;
            fi

            let need_backtrack = false;

            try
                let is_poisoned = false;
                let start = context.location;

                debug("parse function name");
                let name = identifier_function_name_parser.parse(context);
                debug("have function name {name}");

                let generic_arguments: Syntax.Trees.TypeExpressions.LIST;
    
                if context.current.token == Lexical.TOKEN.SQUARE_OPEN then
                    debug("parse generic arguments");
                    context.next_token();
    
                    generic_arguments = type_list_parser.parse(context);
                    generic_arguments.check_no_reference_types(context.logger);
    
                    is_poisoned = !generic_arguments? \/ generic_arguments.is_poisoned;

                    debug("have generic arguments, poisoned is {is_poisoned}");
                    
                    if !is_poisoned \/ context.current.token == Lexical.TOKEN.SQUARE_CLOSE then
                        debug("expecting close square bracket");
                        is_poisoned = !context.next_token(Lexical.TOKEN.SQUARE_CLOSE) \/ is_poisoned;
                        debug("after maybe square bracket, poisoned is {is_poisoned}");
                    fi

                    debug("after generic arguments poisoned is {is_poisoned}");
                fi

                debug("expect opening parenthesis {context.current.to_short_string()} poisoned is {is_poisoned}");

                context.next_token(Lexical.TOKEN.PAREN_OPEN);

                context.speculate();
                context.logger.speculate();
    
                let arguments: Trees.Variables.LIST;
    
                let any_bad_arguments = false;
    
                if context.current_token != Lexical.TOKEN.PAREN_CLOSE then
                    debug("parse formal arguments");

                    if context.current.token != Lexical.TOKEN.IDENTIFIER then
                        debug("no argument name found");

                        is_poisoned = true;
                    fi
    
                    arguments = variable_list_parser.parse(context);

                    any_bad_arguments = arguments.is_poisoned;

                    debug("have arguments poisoned is {is_poisoned}");

                    let last_valid_argument_line = 0;
    
                    for a in arguments do
                        if !a? \/ a.is_poisoned then
                            debug("argument is null or poisoned");
                            is_poisoned = true;
                            any_bad_arguments = true;
                        elif isa Trees.TypeExpressions.INFER(a.type_expression) then
                            debug("argument {a.name} has no type");

                            context.error(a.location, "explicit argument type required");
                            is_poisoned = true;
                            any_bad_arguments = true;
                        else
                            last_valid_argument_line = a.name.location.start_line;

                            debug("argument {a.name} has type");
                        fi
                    od

                    if context.current_token == Lexical.TOKEN.PAREN_OPEN then
                        // we might have run off the end of an incomplete function
                        // signature into the start of a following function
                        // signature

                        debug("unexpected parenthesis at {context.location.start_line} arguments at {if arguments? then arguments.location.end_line else 0 fi}");

                        let could_be_next_function = false;

                        if !arguments? \/ arguments.variables.count == 0 then
                            debug("no arguments or bad arguments, followed by '(' - assume next function signature");
                            could_be_next_function = true;
                        elif /* arguments.variables.count == 1 /\ */ any_bad_arguments then
                            debug("bad arguments followed by '(' - assume next function signature");
                            could_be_next_function = true;
                        elif any_bad_arguments /\ context.location.start_line > arguments.location.end_line then
                            debug("bad arguments followed by '(' on next line - assume next function signature");
                            could_be_next_function = true;
                        elif last_valid_argument_line < context.location.start_line then
                            debug("unexpected '(' on line after the last valid argument - assume next function signature");
                            could_be_next_function = true;
                        fi

                        if could_be_next_function then
                            debug("possible incomplete function signature");
                            context.logger.roll_back();

                            for a in arguments do
                                if a? then
                                    a.poison(true);
                                fi
                            od

                            let roll_forwards_to_line = context.location.start_line;

                            context.backtrack();

                            debug("skip tokens from {context.location.start_line} to {roll_forwards_to_line} starting with {context.current.to_short_string()}");

                            while context.location.start_line < roll_forwards_to_line do
                                debug("skip token {context.current.to_short_string()} at {context.location.start_line}");
                                context.next_token();
                                debug("now at {context.location.start_line}");
                            od

                            debug("skipped to {context.location.start_line} current now {context.current.to_short_string()}");
                            debug("after body poisoned is {is_poisoned}");

                            // FIXME we need to preserve every arg the user has typed or started typing, because other wise
                            // completion won't work, but we need to sanitise the list to make sure all the args are sufficiently
                            // complete to prevent anything that might consume them from throwing.

                            // Also, if the last argument has absorbed the following function name, we 

                            /*
                            let arguments_list = 
                                if arguments? then 
                                    arguments.variables | 
                                        .filter(
                                            a => 
                                                a? /\ !a.is_poisoned /\ 
                                                // a.type_expression? /\ !a.type_expression.is_poisoned /\ !a.type_expression.is_inferred /\
                                                a.location.start_line < roll_forwards_to_line)
                                        .collect_list()
                                else 
                                    new Collections.LIST[Trees.Variables.Variable](0)
                                fi;
                            */
            
                            let result =
                                new Trees.Definitions.FUNCTION(
                                    start::name.location, 
                                    name, 
                                    generic_arguments,
                                    if arguments? then
                                        arguments
                                    else
                                        new Trees.Variables.LIST(context.location, new Collections.LIST[Trees.Variables.Variable](0))
                                    fi,
                                    new Trees.TypeExpressions.INFER(context.location), 
                                    new Trees.Modifiers.LIST(context.location, null, null), 
                                    new Trees.Bodies.NULL(context.location)
                                );

                            let end = 
                                if arguments? /\ arguments.variables.count > 0 then 
                                arguments.variables[arguments.variables.count-1].location
                                else
                                    name.location
                                fi;

                            context.logger.error(start::end, "syntax error: incomplete function signature");

                            return result;
                        fi

                        debug("unexpected parenthesis but probably not a possible incomplete function signature");
                    fi

                    debug("after arguments poisoned is {is_poisoned}");
                fi

                context.commit();
                context.logger.commit();
    
                if arguments == null \/ any_bad_arguments then
                    debug("{if !arguments? then "no arguments" else "" fi} {if any_bad_arguments then "bad arguments" else "" fi}");

                    // null arguments is not an error - the arguments list parser legitimately
                    // returns null for an empty list:
                    arguments = new Trees.Variables.LIST(context.location, new Collections.LIST[Trees.Variables.Variable](0));
                fi
                
                if !is_poisoned \/ context.current.token == Lexical.TOKEN.PAREN_CLOSE then
                    debug("expecting close parenthesis");
                    is_poisoned = !context.next_token(Lexical.TOKEN.PAREN_CLOSE) \/ is_poisoned;
                    debug("after maybe close parenthesis, poisoned is {is_poisoned}");
                fi
    
                let type_expression: Trees.TypeExpressions.TypeExpression;

                if context.current.token == Lexical.TOKEN.ARROW_THIN then
                    let arrow_location = context.location;
                    debug("parse return type");
                    context.next_token();

                    context.speculate();

                    type_expression = type_parser.parse(context);
                    type_expression.check_is_not_reference(context.logger, "function cannot return a reference");

                    is_poisoned = is_poisoned \/ !type_expression? \/ type_expression.is_poisoned;

                    debug("after return type poisoned is {is_poisoned}");

                    if context.current_token == Lexical.TOKEN.PAREN_OPEN then
                        // we might have run off the end of an incomplete function
                        // signature into the start of a following function
                        // signature

                        debug("unexpected parenthesis at {context.location.start_line}");
    

                        // assume next function signature

                        context.backtrack();

                        let arguments_list = 
                        if arguments? then 
                            arguments.variables | 
                                .filter(a => a? /\ !a.is_poisoned)
                                .collect_list()
                        else 
                            new Collections.LIST[Trees.Variables.Variable](0)
                        fi;
    
                        let result =
                            new Trees.Definitions.FUNCTION(
                                start::name.location, 
                                name, 
                                generic_arguments,
                                new Trees.Variables.LIST(context.location, arguments_list), 
                                new Trees.TypeExpressions.INFER(context.location), 
                                new Trees.Modifiers.LIST(context.location, null, null), 
                                new Trees.Bodies.NULL(context.location)
                            );

                        context.logger.error(start::arrow_location, "syntax error: incomplete function signature");

                        return result;
                    fi

                    context.commit();
                else
                    type_expression = new Trees.TypeExpressions.INFER(context.location);
                fi

                debug("parse modifiers {context.current.to_short_string()} poisoned is {is_poisoned}");
                let modifiers = modifier_list_parser.parse(context);
                let expect_semicolon = context.current.token != Lexical.TOKEN.IS;

                let body: Trees.Bodies.Body;

                try 
                    debug("parse body {context.current.to_short_string()} poisoned is {is_poisoned}");

                    body = body_parser.parse(context)
                catch ue: UNWIND_TO_MEMBER_EXCEPTION
                    debug("caught unwind to member");
                    body = new Trees.Bodies.NULL(context.location);
                yrt

                debug("after body poisoned is {is_poisoned}");

                let result =
                    new Trees.Definitions.FUNCTION(
                        start::body.location, 
                        name, 
                        generic_arguments,
                        arguments, 
                        type_expression, 
                        modifiers, 
                        body
                    );
    
                if expect_semicolon then
                    debug("expecting semicolon {context.current.to_short_string()} poisoned is {is_poisoned}");
                    if !is_poisoned \/ context.current.token == Lexical.TOKEN.SEMICOLON then
                        debug("expecting semicolon...");
                        is_poisoned = !context.next_token(Lexical.TOKEN.SEMICOLON) \/ is_poisoned;
                        debug("after maybe semicolon poisoned is {is_poisoned}");
                    fi
                fi

                debug("about to return poisoned is {is_poisoned}");

                result.poison(is_poisoned);
    
                return result;
    
            finally
                if context.in_classy then
                    context.in_member = false;
                else
                    context.in_global_function = false;
                fi

                // debug_exit();
                // debug_always("<< parse function");
            yrt
        si
    si
si
