namespace Syntax.Parsers.Variables is
    use Source;
    use Logging;

    class LIST: Base[Trees.Variables.LIST] is
        allow_empty: bool;
        variable_parser: Parser[Trees.Variables.Variable];

        init(variable_parser: Parser[Trees.Variables.Variable]) is
            super.init();

            self.variable_parser = variable_parser;
        si

        parse(context: CONTEXT) -> Trees.Variables.LIST is
            let use debug_dispose = debug_enter();
            let start = context.location;
            let end = context.location;
            let variables = new Collections.LIST[Trees.Variables.Variable]();
            
            if 
                context.current.token == Lexical.TOKEN.IDENTIFIER \/ !allow_empty
            then
                do
                    let variable = variable_parser.parse(context);

                    if variable? then
                        if context.current.token == Lexical.TOKEN.PAREN_OPEN then
                            if variable.is_explicit_type then
                                // we've probably just absorbed the name of a following
                                // function declaration

                                // exclude the type from the variable's location
                                // to stop the error message running on into
                                // the following function declaration
                                end = variable.name.location;

                                // clear the type expression so we don't report a spurious error
                                // about it being undefined
                                variable.set_type_expression(new Trees.TypeExpressions.INFER(variable.name.location));

                                variables.add(variable);
                            else
                                context.expect_token(Lexical.TOKEN.COLON);                                
                            fi

                            break;
                        fi

                        end = variable.location;

                        variables.add(variable);

                        if context.current.token == Lexical.TOKEN.IDENTIFIER /\ context.location.start_line == variable.location.start_line then
                            context.expect_token(Lexical.TOKEN.COMMA);
                        elif context.is_end_of_file \/ context.current.token != Lexical.TOKEN.COMMA then
                            break;
                        else
                            end = context.location;
                            context.next_token();
                        fi
                        
                    else
                        break;
                    fi                    
                od
            fi
            
            return new Trees.Variables.LIST(start::end, variables);
        si
    si
si
