namespace Syntax.Parsers.Variables is
    use Source;
    use Logging;

    class DESTRUCTURE_ELEMENT_LIST: Base[Trees.Variables.DESTRUCTURE_ELEMENT_LIST] is
        destructure_element_parser: Parser[Trees.Variables.DESTRUCTURE_ELEMENT];

        init(
            destructure_element_parser: Parser[Trees.Variables.DESTRUCTURE_ELEMENT]
        ) is
            super.init();

            self.destructure_element_parser = destructure_element_parser;
        si

        parse(context: CONTEXT) -> Trees.Variables.DESTRUCTURE_ELEMENT_LIST is
            let use debug_dipose = debug_enter();
            debug(">> parse destructure element list...");

            let start = context.location;
            let end = context.location;
            let elements = new Collections.LIST[Trees.Variables.Destructure]();

            let should_poison = false;

            if !context.next_token(Lexical.TOKEN.PAREN_OPEN) then
                debug("<< parse destructure element list: no open parenthesis");

                return null;
            fi

            end = context.location;
            
            do
                debug("-- parse destructure element: top of loop...");

                let element: Trees.Variables.Destructure;

                if context.current_token == Lexical.TOKEN.PAREN_OPEN then
                    // we've reached the start of a nested list of destructure elements

                    debug("-- parse destructure element: nested list: recurse...");

                    element = parse(context);

                    debug("-- parse destructure element: nested list: recurse: done: {element}");
                else
                    debug("-- parse destructure element: regular element...");

                    element = destructure_element_parser.parse(context);

                    debug("-- parse destructure element: regular element: done: {element}");
                fi

                elements.add(element);

                debug("-- parsed element: {element}");

                if context.current_token == Lexical.TOKEN.PAREN_CLOSE then
                    debug("<< parse destructure element list: end of list: break");

                    // we've reached the end of a list of destructure elements

                    end = element.location;
                    context.next_token();

                    break;
                elif context.current_token == Lexical.TOKEN.COMMA then
                    debug("-- parse destructure element list: comma: continue");

                    // more elements to come

                    context.next_token();
                elif
                    (context.current.token == Lexical.TOKEN.IDENTIFIER \/ context.current.token == Lexical.TOKEN.PAREN_OPEN) /\ 
                    context.location.start_line >= element.location.end_line /\
                    context.location.start_column > element.location.end_column
                then
                    debug("-- parse destructure element list: missing comma: continue");

                    // after parsing an element, we've arrived at something that could be another
                    // element with no intervening comma, and the indentation suggests it's part of
                    // the same list: we'll assume it is, report an error, but continue parsing:

                    context.expect_token(Lexical.TOKEN.COMMA);
                    should_poison = true;
                else
                    debug("-- parse destructure element list: something else: break");
                    // something else, so we'll assume we've reached the end of the list but the
                    // user forgot to close the parentheses:

                    should_poison = true;
                    end = context.location;
                    context.expect_token(Lexical.TOKEN.PAREN_CLOSE);

                    break;
                fi


                debug("-- parse destructure element list: loop again...");
            od

            debug("-- parse destructure element list: done");
            
            let result = new Trees.Variables.DESTRUCTURE_ELEMENT_LIST(start::end, elements);

            if should_poison then
                result.poison();
            fi

            debug("<< parse destructure element list: done: {result}");

            return result;
        si
    si

    class DESTRUCTURE_ELEMENT: Base[Trees.Variables.DESTRUCTURE_ELEMENT] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_expression_parser: Parser[Trees.TypeExpressions.TypeExpression];

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_expression_parser: Parser[Trees.TypeExpressions.TypeExpression]            
        ) is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_expression_parser = type_expression_parser;
        si

        parse(context: CONTEXT) -> Trees.Variables.DESTRUCTURE_ELEMENT is
            let use debug_dispose = debug_enter();
            debug(">> parse single destructure element...");

            let start = context.location;
            let elements = new Collections.LIST[Trees.Variables.Destructure]();

            let should_poison = false;
            
            let identifier = identifier_parser.parse(context);

            if !identifier? then
                debug("<< parse single destructure element: no identifier");
                return null;
            fi

            debug("parsed identifier: {identifier}");

            let type_expression: Trees.TypeExpressions.TypeExpression;

            let end = identifier.location;

            if context.current.token == Lexical.TOKEN.COLON then
                debug("-- parse single destructure element: type expression...");

                context.next_token();
                type_expression = type_expression_parser.parse(context);

                if !type_expression? \/ type_expression.is_poisoned then
                    debug("<< parse single destructure element: type expression: failed");
                    should_poison = true;
                fi

                debug("parsed type expression: {type_expression}");

                end = type_expression.location;
            fi

            debug("-- parse single destructure element: done");

            let result = new Trees.Variables.DESTRUCTURE_ELEMENT(start::end, identifier, type_expression);

            debug("-- created result");

            try
                debug("-- result is {result}");
            catch ex: System.Exception
                debug("-- but can't print it: {ex}");
            yrt

            if should_poison then
                result.poison();
            fi

            debug("<< parse single destructure element: done: {result}");

            return result;
        si
    si
si
