namespace Syntax.Parsers.Variables is
    use Source;
    use Logging;

    class DESTRUCTURE_ELEMENT_LIST: Base[Trees.Variables.DESTRUCTURE_ELEMENT_LIST] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_expression_parser: Parser[Trees.TypeExpressions.TypeExpression];

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_expression_parser: Parser[Trees.TypeExpressions.TypeExpression]            
        ) is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_expression_parser = type_expression_parser;
        si

        parse(context: CONTEXT) -> Trees.Variables.DESTRUCTURE_ELEMENT_LIST is
            let start = context.location;
            let end = context.location;
            let elements = new Collections.LIST[Trees.Variables.Destructure]();
            
            if context.current.token == Lexical.TOKEN.IDENTIFIER then
                debug("start parsing list...");

                do
                    debug("top of loop: parse single identifier...");
                    let identifier = identifier_parser.parse(context);
                    let type_expression: Trees.TypeExpressions.TypeExpression;

                    if identifier? then
                        debug("parsed identifier: {identifier}");

                        end = identifier.location;

                        if context.current.token == Lexical.TOKEN.COLON then
                            context.next_token();
                            type_expression = type_expression_parser.parse(context);
                        fi

                        elements.add(new Trees.Variables.DESTRUCTURE_ELEMENT(identifier.location, identifier, type_expression));

                        if 
                            context.current.token == Lexical.TOKEN.IDENTIFIER /\ 
                            context.location.start_line >= identifier.location.start_line /\
                            context.location.start_column > identifier.location.end_column
                        then
                            context.expect_token(Lexical.TOKEN.COMMA);
                        elif context.is_end_of_file \/ context.current.token != Lexical.TOKEN.COMMA then
                            break;
                        else
                            end = context.location;
                            context.next_token();
                        fi                        
                    else
                        break;
                    fi                    
                od
            fi
            
            return new Trees.Variables.DESTRUCTURE_ELEMENT_LIST(start::end, elements);
        si
    si
si
