namespace Syntax.Parsers.Variables is
    use Logging;

    class VARIABLE: Base[Trees.Variables.Variable] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_parser: Parser[Trees.TypeExpressions.TypeExpression];
        expression_parser: Parser[Trees.Expressions.Expression];
        destruct_element_list_parser: Parser[Trees.Variables.DESTRUCTURE_ELEMENT_LIST];

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_parser: Parser[Trees.TypeExpressions.TypeExpression],
            expression_parser: Parser[Trees.Expressions.Expression],
            destruct_element_list_parser: Parser[Trees.Variables.DESTRUCTURE_ELEMENT_LIST]
        )
        is
            super.init();
           
            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.expression_parser = expression_parser;
            self.destruct_element_list_parser = destruct_element_list_parser;
        si

        parse(context: CONTEXT) -> Trees.Variables.Variable is
            let use debug_dispose = debug_enter();
            debug(">> parsing variable...");

            let start = context.location;

            if context.current_token == Lexical.TOKEN.PAREN_OPEN then
                debug(">> parsing destructuring variable list...");
                let destructure_element_list = destruct_element_list_parser.parse(context);

                debug("<< parsed destructuring variable list: {destructure_element_list}");
                
                return destructure_element_list;
                
            elif context.expect_token(Lexical.TOKEN.IDENTIFIER, syntax_error_message) then
                let identifier = identifier_parser.parse(context);

                if identifier == null then
                    return  null;
                fi
                
                let end = identifier.location;
                let type_expression: Trees.TypeExpressions.TypeExpression = new Trees.TypeExpressions.INFER(start::context.location);
                let initializer: Trees.Expressions.Expression;
                let is_explicit_type = false;
                
                if context.current.token == Lexical.TOKEN.COLON then
                    is_explicit_type = true;
                    context.next_token();
                    type_expression = type_parser.parse(context);
                    
                    end = type_expression.location;
                fi
                
                if context.current.token == Lexical.TOKEN.ASSIGN then
                    context.next_token();
                    initializer = expression_parser.parse(context);
                    end = initializer.location;
                fi
                
                let result = 
                    new Trees.Variables.VARIABLE(
                        start::end, 
                        identifier, 
                        type_expression, 
                        false, 
                        is_explicit_type,
                        initializer
                    );

                result.poison(type_expression.is_poisoned);

                return result;
            fi
        si
    si
si
