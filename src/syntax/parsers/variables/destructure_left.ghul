namespace Syntax.Parsers.Variables is
    use Source;
    use Logging;

    class DESTRUCTURE_LEFT: Base[Trees.Variables.DESTRUCTURE_LEFT] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier]
        ) is
            super.init();

            self.identifier_parser = identifier_parser;
        si

        parse(context: CONTEXT) -> Trees.Variables.DESTRUCTURE_LEFT is
            let use debug_dipose = debug_enter();
            debug(">> parse destructure element list...");

            let start = context.location;
            let end = context.location;
            let elements = new Collections.LIST[Trees.Variables.VariableLeft]();

            let should_poison = false;

            if !context.next_token(Lexical.TOKEN.PAREN_OPEN) then
                debug("<< parse destructure element list: no open parenthesis");

                return null;
            fi

            end = context.location;
            
            do
                debug("-- parse destructure element: top of loop...");

                let element: Trees.Variables.VariableLeft;

                if context.current_token == Lexical.TOKEN.PAREN_OPEN then
                    // we've reached the start of a nested list of destructure elements

                    debug("-- parse destructure element: nested list: recurse...");

                    element = parse(context);

                    debug("-- parse destructure element: nested list: recurse: done: {element}");
                else
                    debug("-- parse destructure element: regular element...");

                    let identifier = identifier_parser.parse(context);

                    element = new Trees.Variables.SINGLE_NAME_LEFT(identifier.location, identifier);

                    debug("-- parse destructure element: regular element: done: {element}");
                fi

                elements.add(element);

                debug("-- parsed element: {element}");

                if context.current_token == Lexical.TOKEN.PAREN_CLOSE then
                    debug("<< parse destructure element list: end of list: break");

                    // we've reached the end of a list of destructure elements

                    end = element.location;
                    context.next_token();

                    break;
                elif context.current_token == Lexical.TOKEN.COMMA then
                    debug("-- parse destructure element list: comma: continue");

                    // more elements to come

                    context.next_token();
                elif
                    (context.current.token == Lexical.TOKEN.IDENTIFIER \/ context.current.token == Lexical.TOKEN.PAREN_OPEN) /\ 
                    context.location.start_line >= element.location.end_line /\
                    context.location.start_column > element.location.end_column
                then
                    debug("-- parse destructure element list: missing comma: continue");

                    // after parsing an element, we've arrived at something that could be another
                    // element with no intervening comma, and the indentation suggests it's part of
                    // the same list: we'll assume it is, report an error, but continue parsing:

                    context.expect_token(Lexical.TOKEN.COMMA);
                    should_poison = true;
                else
                    debug("-- parse destructure element list: something else: break");
                    // something else, so we'll assume we've reached the end of the list but the
                    // user forgot to close the parentheses:

                    should_poison = true;
                    end = context.location;
                    context.expect_token(Lexical.TOKEN.PAREN_CLOSE);

                    break;
                fi


                debug("-- parse destructure element list: loop again...");
            od

            debug("-- parse destructure element list: done");
            
            let result = new Trees.Variables.DESTRUCTURE_LEFT(start::end, elements);

            if should_poison then
                result.poison();
            fi

            debug("<< parse destructure element list: done: {result}");

            return result;
        si
    si
si
