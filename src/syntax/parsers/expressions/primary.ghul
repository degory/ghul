namespace Syntax.Parsers.Expressions is
    use IO.Std;

    use Logging;
    use Source;

    class PRIMARY: Base[Trees.Expressions.Expression] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_parser: Parser[Trees.TypeExpressions.TypeExpression];
        expression_parser: Parser[Trees.Expressions.Expression];
        expression_list_parser: Parser[Trees.Expressions.LIST];
        expression_tuple_parser: Parser[Trees.Expressions.TUPLE];
        statement_parser: Parser[Trees.Statements.Statement];

        description: string => "primary expression";

        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_parser: Parser[Trees.TypeExpressions.TypeExpression],
            expression_parser: Parser[Trees.Expressions.Expression],
            expression_list_parser: Parser[Trees.Expressions.LIST],
            expression_tuple_parser: Parser[Trees.Expressions.TUPLE],
            statement_parser: Parser[Trees.Statements.Statement]
        )
        is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.expression_parser = expression_parser;
            self.expression_list_parser = expression_list_parser;
            self.expression_tuple_parser = expression_tuple_parser;
            self.statement_parser = statement_parser;

            add_parsers();
        si

        add_parsers() is
            add_parser(
                (context: CONTEXT) -> Trees.Expressions.Expression is
                    let start = context.location;
                    let identifier = identifier_parser.parse(context);
                    if context.allow_tuple_element /\ !identifier.is_qualified then
                        context.allow_tuple_element = false;
                        let end = identifier.location;
                        let type_expression: Trees.TypeExpressions.TypeExpression;
                        let initializer: Trees.Expressions.Expression;

                        if context.current.token == Lexical.TOKEN.COLON then
                            context.next_token();
                            type_expression = type_parser.parse(context);
                            end = type_expression.location;
                        fi

                        if context.current.token == Lexical.TOKEN.ASSIGN then
                            context.next_token();
                            initializer = expression_parser.parse(context);
                            end = initializer.location;
                        fi

                        if initializer? then
                            if type_expression == null then
                                type_expression = new Trees.TypeExpressions.INFER(context.location);
                            fi
                        fi

                        if type_expression? then
                            return new Trees.Expressions.VARIABLE(start::end, identifier, type_expression, initializer);
                        fi
                    fi

                    return new Trees.Expressions.IDENTIFIER(identifier.location, identifier);
                si, Lexical.TOKEN.IDENTIFIER
            );
            
            add_parser(
                (context: CONTEXT) is
                    let start = context.location;
                    context.next_token();
                    let elements = expression_list_parser.parse(context);
                    let type_expression: Trees.TypeExpressions.TypeExpression;
                    let end = context.location;
                    context.next_token(Lexical.TOKEN.SQUARE_CLOSE);
                    if context.current.token == Lexical.TOKEN.COLON then
                        context.next_token();
                        type_expression = type_parser.parse(context);
                        end = type_expression.location;
                    else
                        type_expression = new Trees.TypeExpressions.INFER(start::end);
                    fi

                    return new Trees.Expressions.SEQUENCE(start::end, elements, type_expression);
                si,
                Lexical.TOKEN.SQUARE_OPEN
            );

            add_parser(
                (context: CONTEXT) is
                    return expression_tuple_parser.parse(context);
                si,
                Lexical.TOKEN.PAREN_OPEN
            );

            add_parser(
                (context: CONTEXT) is
                    let start = context.location;

                    context.next_token(Lexical.TOKEN.NEW);

                    let type_expression = type_parser.parse(context);

                    let arguments: Trees.Expressions.LIST;

                    if context.next_token(Lexical.TOKEN.PAREN_OPEN) then
                        if context.current.token != Lexical.TOKEN.PAREN_CLOSE then
                            arguments = expression_list_parser.parse(context);
                        fi
                        context.next_token(Lexical.TOKEN.PAREN_CLOSE, syntax_error_message);
                    fi

                    if arguments == null then
                        arguments = new Trees.Expressions.LIST(context.location, new Collections.LIST[Trees.Expressions.Expression]());
                    fi

                    return new Trees.Expressions.NEW(start::arguments.location, type_expression, arguments);
                si,
                Lexical.TOKEN.NEW
            );

            add_parser(
                (context: CONTEXT) is
                    let start = context.location;

                    context.next_token(Lexical.TOKEN.CAST);

                    let type_expression = type_parser.parse(context);

                    context.next_token(Lexical.TOKEN.PAREN_OPEN);

                    let value = expression_parser.parse(context);
                    let result = new Trees.Expressions.CAST(start::context.location, type_expression, value);

                    context.next_token(Lexical.TOKEN.PAREN_CLOSE);
                    return result;
                si,
                Lexical.TOKEN.CAST
            );

            add_parser(
                (context: CONTEXT) is
                    let start = context.location;
                    context.next_token(Lexical.TOKEN.ISA);
                    let type_expression = type_parser.parse(context);
                    context.next_token(Lexical.TOKEN.PAREN_OPEN);
                    let value = expression_parser.parse(context);
                    let result = new Trees.Expressions.ISA(start::context.location, type_expression, value);
                    context.next_token(Lexical.TOKEN.PAREN_CLOSE);
                    return result;
                si,
                Lexical.TOKEN.ISA
            );

            add_parser(
                (context: CONTEXT) is
                    let start = context.location;
                    context.next_token(Lexical.TOKEN.TYPEOF);
                    let type_expression = type_parser.parse(context);
                    let result = new Trees.Expressions.TYPEOF(start::context.location, type_expression);
                    return result;
                si,
                Lexical.TOKEN.TYPEOF
            );

            add_parser(
                (context: CONTEXT) is
                    let location = context.location;
                    let value_string = context.current.value_string;
                    context.next_token();
                    return new Trees.Expressions.Literals.INTEGER(location, value_string);
                si,
                Lexical.TOKEN.INT_LITERAL
            );

            add_parser(
                (context: CONTEXT) is
                    let location = context.location;
                    let value_string = context.current.value_string;
                    context.next_token();
                    return new Trees.Expressions.Literals.FLOAT(location, value_string);
                si,
                Lexical.TOKEN.FLOAT_LITERAL
            );

            add_parser(
                (context: CONTEXT) is
                    let location = context.location;
                    let value_string = context.current.value_string;
                    context.next_token();
                    return new Trees.Expressions.Literals.STRING(location, value_string);
                si,
                Lexical.TOKEN.STRING_LITERAL
            );

            add_parser(
                (context: CONTEXT) is
                    let location = context.location;
                    let value_string = context.current.value_string;
                    context.next_token();
                    return new Trees.Expressions.Literals.CHARACTER(location, value_string);
                si,
                Lexical.TOKEN.CHAR_LITERAL
            );

            add_parser(
                (context: CONTEXT) => parse_string_interpolation(context),
                Lexical.TOKEN.ENTER_STRING
            );

            add_parser(
                (context: CONTEXT) is
                    let location = context.location;
                    let value_string = context.current.value_string;
                    context.next_token();
                    return new Trees.Expressions.Literals.BOOLEAN(location, value_string);
                si,
                [Lexical.TOKEN.TRUE, Lexical.TOKEN.FALSE]
            );

            add_parser(
                (context: CONTEXT) is
                    let location = context.location;
                    context.next_token();
                    return new Trees.Expressions.NULL(location);
                si,
                Lexical.TOKEN.NULL
            );

            add_parser(
                (context: CONTEXT) is
                    let location = context.location;
                    context.next_token();
                    return new Trees.Expressions.SELF(location);
                si,
                Lexical.TOKEN.SELF
            );

            add_parser(
                (context: CONTEXT) is
                    let location = context.location;
                    context.next_token();
                    return new Trees.Expressions.SUPER(location);
                si, Lexical.TOKEN.SUPER
            );

            add_parser(
                (context: CONTEXT) -> Trees.Expressions.Expression is
                    let statement = statement_parser.parse(context);

                    return new Trees.Expressions.STATEMENT(statement.location, statement);
                si, Lexical.TOKEN.IF
            );
        si

        // TODO add a string interpolation syntax tree that has a list of string fragments
        // and expressions. Then we can generate more efficient concatenation calls based
        // on the different string concat overloads available in the runtime
        parse_string_interpolation(context: CONTEXT) -> Trees.Expressions.Expression is
            debug_enter();
            // a string interpolation consists of:
            // ENTER_STRING token
            // an expression
            // a series of zero or more:
            //   CONTINUE_STRING token
            //   an expression
            // finally, an EXIT_STRING token

            // we need to create a running result value to accumulate the result of the interpolation
            // starting with a string literal for the first fragment of the string, then adding in
            // each expression and following string fragment as we go, until we reach the end of the
            // interpolation

            debug("start parsing string interpolation...");

            let start = context.location;
            let fragment = context.current.value_string;

            debug("have first fragment: " + fragment);

            // consume the first string fragment
            context.next_token();

            // the tokenizer is guaranteed to return at a minium ENTER_STRING (expressions...) EXIT_STRING

            let expression = expression_parser.parse(context);

            if !expression? \/ expression.is_poisoned then
                debug("first expression is null or poisoned: " + expression);

                return new Trees.Expressions.Literals.STRING(start, fragment);
            fi

            debug("construct first binary...");

            let result: Trees.Expressions.Expression = new Trees.Expressions.BINARY(
                start::context.location, 
                new Trees.Identifiers.Identifier(context.location, "+"),
                "+",
                new Trees.Expressions.Literals.STRING(start, fragment),
                expression
            );

            debug("first binary constructed: " + result);

            while context.current.token == Lexical.TOKEN.CONTINUE_STRING do
                fragment = context.current.value_string;

                debug("have next fragment: " + fragment);

                context.next_token();

                // left = new Trees.Expressions.BINARY(left.location::right.location, op, apparent_op, left, right);

                debug("construct next binary A...");

                result = new Trees.Expressions.BINARY(
                    start::context.location, 
                    new Trees.Identifiers.Identifier(context.location, "+"),
                    "+",
                    result,
                    new Trees.Expressions.Literals.STRING(context.location, fragment)
                );

                debug("next binary A constructed: " + result);

                debug("parse next expression, parser is: " + expression_parser);
                debug("parse next expression, context is: " + context);
                debug("parse next expression, self is: " + self);

                // debug("stack trace is: " + new System.Diagnostics.StackTrace());

                try
                    expression = expression_parser.parse(context);
                catch e: System.Exception
                    debug("caught exception: " + e);
                    expression = null;
                yrt

                debug("after expression parse, before printing expression");

                debug("next expression: " + expression);

                if !expression? \/ expression.is_poisoned then
                    debug("next expression is null or poisoned: " + expression);

                    debug_exit();
                    return result;
                fi

                debug("construct next binary B...");

                result = new Trees.Expressions.BINARY(
                    start::context.location, 
                    new Trees.Identifiers.Identifier(context.location, "+"),
                    "+",
                    result,
                    expression
                );

                debug("next binary B constructed: " + result);
            od

            debug("expecting EXIT_STRING token...");

            if context.current_token == Lexical.TOKEN.EXIT_STRING then
                debug("found EXIT_STRING token, construct final binary...");

                fragment = context.current.value_string;

                result = new Trees.Expressions.BINARY(
                    start::context.location, 
                    new Trees.Identifiers.Identifier(context.location, "+"),
                    "+",
                    result,
                    new Trees.Expressions.Literals.STRING(context.location, fragment)
                );

                debug("final binary constructed: " + result);

                context.next_token();
            else
                context.error(context.location, "Expected string interpolation to end with EXIT_STRING token");
            fi

            debug("returning result: " + result);

            debug_exit();

            return result;
        si

        other_token(context: CONTEXT) -> Trees.Expressions.Expression is
            super.other_token(context);

            let result = new Trees.Expressions.Literals.NONE(context.location);

            result.poison();

            return result;
        si        
    si
si
