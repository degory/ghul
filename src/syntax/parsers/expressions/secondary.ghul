namespace Syntax.Parsers.Expressions is
    use IO.Std;

    use Source;

    class SECONDARY: Base[Trees.Expressions.Expression] is
        identifier_parser: Parser[Trees.Identifiers.Identifier];
        type_parser: Parser[Trees.TypeExpressions.TypeExpression];
        type_list_parser: Parser[Trees.TypeExpressions.LIST];
        expression_parser: Parser[Trees.Expressions.Expression];
        expression_primary_parser: Parser[Trees.Expressions.Expression];
        expression_list_parser: Parser[Trees.Expressions.LIST];
        body_parser: Parser[Trees.Bodies.Body];
        description: string => "secondary expression";
        
        init(
            identifier_parser: Parser[Trees.Identifiers.Identifier],
            type_parser: Parser[Trees.TypeExpressions.TypeExpression],
            type_list_parser: Parser[Trees.TypeExpressions.LIST],
            expression_parser: Parser[Trees.Expressions.Expression],
            expression_primary_parser: Parser[Trees.Expressions.Expression],
            expression_list_parser: Parser[Trees.Expressions.LIST],
            body_parser: Parser[Trees.Bodies.Body]
        )
        is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.type_list_parser = type_list_parser;
            self.expression_parser = expression_parser;
            self.expression_primary_parser = expression_primary_parser;
            self.expression_list_parser = expression_list_parser;
            self.body_parser = body_parser;
        si

        parse(context: CONTEXT) -> Trees.Expressions.Expression is
            let start = context.location;
            let result: Trees.Expressions.Expression = expression_primary_parser.parse(context);

            do
                case context.current.token
                when Lexical.TOKEN.PAREN_OPEN:
                    context.next_token();
                    let arguments: Trees.Expressions.LIST;
                    if context.current.token != Lexical.TOKEN.PAREN_CLOSE then
                        arguments = expression_list_parser.parse(context);
                    else
                        arguments = new Trees.Expressions.LIST(context.location, new Collections.LIST[Trees.Expressions.Expression]());
                    fi
                    result = new Trees.Expressions.CALL(start::context.location, result, arguments);
                    context.next_token(Lexical.TOKEN.PAREN_CLOSE, syntax_error_message);

                when Lexical.TOKEN.SQUARE_OPEN:
                    context.next_token();
                    let index = expression_parser.parse(context);
                    result = new Trees.Expressions.INDEX(start::context.location, result, index);
                    context.next_token(Lexical.TOKEN.SQUARE_CLOSE, syntax_error_message);

                when Lexical.TOKEN.DOT:
                    let completion_target_start = context.location;

                    context.next_token();

                    if
                        context.current.token == Lexical.TOKEN.IDENTIFIER
                        // \/ context.current.token == Lexical.TOKEN.OPERATOR
                    then
                        let member = identifier_parser.parse(context);
                        result = new Trees.Expressions.MEMBER(start::member.location, result, member, completion_target_start::member.location);
                    else
                        context.expect_token(Lexical.TOKEN.IDENTIFIER);                        
                        result = new Trees.Expressions.MEMBER(start..context.location, result, null, completion_target_start::context.location);
                    fi

                when Lexical.TOKEN.ARROW_THIN, Lexical.TOKEN.ARROW_FAT, Lexical.TOKEN.IS:
                    if result.could_be_formal_argument then
                        let type_expression: Trees.TypeExpressions.TypeExpression;
                        let arguments: Trees.Expressions.LIST;

                        if context.current.token == Lexical.TOKEN.ARROW_THIN then
                            context.next_token();
                            type_expression = type_parser.parse(context);
                            type_expression.check_is_not_reference(context.logger, "function cannot return a reference");
                        else
                            type_expression = new Trees.TypeExpressions.INFER(start::result.location);
                        fi

                        if context.expect_token([Lexical.TOKEN.ARROW_FAT, Lexical.TOKEN.IS]) then
                            if isa Trees.Expressions.TUPLE(result) then
                                arguments = cast Trees.Expressions.TUPLE(result).elements;
                                arguments.rewrite_as_variables();
                            else
                                let elements = new Collections.LIST[Trees.Expressions.Expression]();
                                elements.add(result);
                                arguments = new Trees.Expressions.LIST(start::result.location, elements);
                            fi
                            let body = body_parser.parse(context);
                            result = new Trees.Expressions.FUNCTION(start::body.location, arguments, type_expression, body);
                        else
                            return new Trees.Expressions.Literals.NONE(start::context.location);
                        fi
                    else
                        context.error(result.location, "expected a function formal argument");
                        return new Trees.Expressions.Literals.NONE(start::context.location);
                    fi

                when Lexical.TOKEN.QUESTION:
                    result = new Trees.Expressions.HAS_VALUE(start::context.location, result);
                    context.next_token();

                when Lexical.TOKEN.REF:
                    result = new Trees.Expressions.REFERENCE(start::context.location, result);
                    context.next_token();

                when Lexical.TOKEN.OPERATOR:
                    if context.current_string =~ "|" then
                        let location = context.location;

                        let pipes = new Trees.Identifiers.Identifier(location, "Pipes");
                        let pipe = new Trees.Identifiers.QUALIFIED(location, pipes, "Factory", location, location);
                        let from = new Trees.Identifiers.QUALIFIED(location, pipe, "from", location, location);

                        let function = new Trees.Expressions.IDENTIFIER(location, from);

                        let arguments = new Trees.Expressions.LIST(
                            result.location,
                            [result]
                        );

                        result = 
                            new Trees.Expressions.CALL(
                                start::location,
                                function,
                                arguments
                            );
                            
                        context.next_token();                            
                    else
                        return result;
                    fi

                when Lexical.TOKEN.SQUARE_OPEN_TICK:
                    context.next_token();
                    
                    let types = type_list_parser.parse(context);

                    result =
                        new Trees.Expressions.EXPLICIT_SPECIALIZATION(
                            start::context.location,
                            result,
                            types
                        );

                    context.next_token(Lexical.TOKEN.SQUARE_CLOSE);
                    
                default
                    return result;
                esac
            od
        si
    si
si
