namespace Syntax.Tree.Identifier is
    use System;
    use Generic;

    use Source;

    class NODE: Tree.NODE, Collections.Iterable[String] is
        name: String;

        qualifier: NODE => null;
        
        qualifier_names: Collections.LIST[String] => new Collections.LIST[String](0);

        names: Collections.LIST[String] => new Collections.LIST[String]([name]); // : String;

        @IL.name.read("GetEnumerator")
        iterator: Collections.Iterator[String] => names.iterator;

        init(location: LOCATION, name: String) is
            super.init(location);

            if name == null then
                poison();
                name = "__poisoned";
            fi

            self.name = name;
        si

        copy() -> NODE =>
            new NODE(location, name);

        accept(visitor: Visitor) is
            visitor.visit(self);
        si
    si

    class NONE: NODE is
        names: Collections.LIST[String] => new Collections.LIST[String](0);

        init(location: LOCATION) is
            super.init(location, null);
        si        
    si

    class QUALIFIED: NODE is
        _qualifier: NODE;

        completion_target: LOCATION;        

        qualifier: NODE is
            return _qualifier;
        si

        qualifier_names: Collections.LIST[String] is
            var result = new Collections.LIST[String]();
            var p = qualifier;

            while p? do
                result.add(p.name);
                p = p.qualifier;
            od

            return result;
        si

        names: Collections.LIST[String] is
            var result = new Collections.LIST[String]();

            result.add(name);

            var p = qualifier;

            while p? do
                result.add(p.name);
                p = p.qualifier;
            od

            return result;
        si

        @IL.name.read("GetEnumerator")
        iterator: Collections.Iterator[String] is
            var result = new Collections.LIST[String]();

            result.add(name);

            var p = qualifier;

            while p? do
                result.add(p.name);
                p = p.qualifier;
            od
            
            return result.iterator;
        si        

        init(location: LOCATION, qualifier: NODE, name: String, completion_target: LOCATION) is
            super.init(location, name);

            self._qualifier = qualifier;
            self.completion_target = completion_target;

            poison(qualifier.is_poisoned);
        si

        copy() -> NODE is
            var np: NODE;

            if qualifier? then
                np = qualifier.copy();
            fi

            return new QUALIFIED(
                location,
                np,
                name,
                completion_target
            );
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                if qualifier? then
                    qualifier.walk(visitor);
                fi
            fi

            accept(visitor);
        si
    si
si
