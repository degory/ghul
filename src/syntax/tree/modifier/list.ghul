namespace Syntax.Tree.Modifier is
    use Generic;
    use Source;

    class LIST: Tree.NODE is
        access_modifier: ACCESS_MODIFIER;
        storage_class: STORAGE_CLASS;

        is_empty: bool => !(access_modifier?) && !(storage_class?);

        is_static: bool => storage_class? && isa STATIC(storage_class);

        is_public: bool => access_modifier? && isa PUBLIC(access_modifier);

        is_private: bool => access_modifier? && isa PRIVATE(access_modifier);

        is_explicit_access: bool => access_modifier?;

        children: Collections.Iterable[Tree.NODE] is
            var result = new Collections.LIST[Tree.NODE](2);

            if access_modifier? then
                result.add(access_modifier);
            fi

            if storage_class? then
                result.add(storage_class);            
            fi

            return result;
        si

        init(location: LOCATION, access_modifier: ACCESS_MODIFIER, storage_class: STORAGE_CLASS) is
            super.init(location);

            self.access_modifier = access_modifier;
            self.storage_class = storage_class;
        si

        copy() -> LIST is
            var nam: ACCESS_MODIFIER;
            var nsc: STORAGE_CLASS;

            if access_modifier? then
                nam = access_modifier.copy();
            fi

            if storage_class? then
                nsc = storage_class.copy();
            fi

            return new LIST(
                location,
                nam,
                nsc
            );
        si

        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            if !visitor.pre(self) then
                if access_modifier? then
                    access_modifier.walk(visitor);
                fi
                
                if storage_class? then
                    storage_class.walk(visitor);
                fi
            fi

            accept(visitor);
        si
    si
si
