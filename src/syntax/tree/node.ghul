// import glist;
namespace Syntax.Tree is
    use System;
    
    use Generic;
    use Source;

    class NODE is
        // parent: NODE public;
        location: LOCATION;

        _next_id: int static;
        _id: int;
        id: int public => _id;

        is_poisoned: bool;

        next_id: int static is
            var result = _next_id;
            _next_id = _next_id + 1;
            return result;
        si

        debug_next_id: int static => _next_id;

        init(location: LOCATION) is
            _id = next_id;
            self.location = location;
        si

        hash() -> int is
            return id;
        si

        invalidate(from: Collections.Iterable[Deletable[NODE]]) is
            for d in from do
                d.delete(self);
            od
            
            _id = next_id;
        si

        =~(other: NODE) -> bool is
            return _id == other._id;
        si

        >(other: NODE) -> int is
            return _id - other._id;
        si

        clone() -> NODE is
            let result = cast NODE(super.clone());   
            result._id = next_id;         

            return result;
        si
        
        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            accept(visitor);
        si

        poison(should_poison: bool) is
            if should_poison then
                is_poisoned = true;
            fi
        si

        poison() is
            is_poisoned = true;
        si        

        toString() -> String is
            var printer = new Process.Printer.GHUL();
            accept(printer);
            return printer.result;
        si

    si
si
