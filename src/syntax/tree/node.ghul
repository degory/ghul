// import glist;
namespace Syntax.Tree is
    use System;
    
    use Generic;
    use Source;

    class NODE is
        // parent: NODE public;
        children: Iterable[NODE] => new NODE[](0); 
        location: LOCATION;

        _next_id: int static;
        _id: int;
        id: int public => _id;

        is_poisoned: bool;

        next_id: int static is
            var result = _next_id;
            _next_id = _next_id + 1;
            return result;
        si

        debug_next_id: int static => _next_id;

        init(location: LOCATION) is
            _id = next_id;
            self.location = location;
        si

        hash() -> int is
            return id;
        si

        assert_not_null(o: Object, name: String) is
            assert(o?, ClassName + " " + name + " is null");
        si

        invalidate(from: Iterable[Deletable[NODE]]) is
            for d in from do
                d.delete(self);
            od
            
            _id = next_id;
        si

        =~(other: NODE) -> bool is
            return _id == other._id;
        si

        >(other: NODE) -> int is
            return _id - other._id;
        si

        clone() -> NODE is
            let result = cast NODE(super.clone());   
            result._id = next_id;         

            return result;
        si
        
        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            accept(visitor);
        si

        rewrite(m: Dict[NODE,NODE]) is
            if isa SINGLE_ENTRY_NODE_MAP(m) then
                throw new NotImplementedException("Probably not what you want: replace " + Object.dump(self) + " " + m);
            fi
        si

        replace(node: NODE, with: NODE) is
            rewrite(
                new SINGLE_ENTRY_NODE_MAP(node, with)
            );
        si

        poison(should_poison: bool) is
            if should_poison then
                is_poisoned = true;
            fi
        si

        poison() is
            is_poisoned = true;
        si        

        toString() -> String is
            var printer = new Process.Printer.GHUL();
            accept(printer);
            return printer.result;
        si

    si

    class SINGLE_ENTRY_NODE_MAP: Object, Dict[NODE, NODE] is
        // HACK: legacy compiler cannot handle list literals whose generic array
        // type does not also appear as an explicit type expression elsewhere in the program: 
        _dummy0: NODE[] static;
        _dummy1: Pair[NODE,NODE][] static;

        _replace: NODE;
        _with: NODE;

        Length: int => 1;

        Keys: Generic.Iterator[NODE] => [_replace].Iterator;
        Pairs: Generic.Iterator[Pair[NODE,NODE]] => [new Pair[NODE,NODE](_replace, _with)].Iterator;
        Iterator: Generic.Iterator[NODE] => [_with].Iterator;
        
        init(replace: NODE, with: NODE) is
            _replace = replace;
            _with = with;
        si

        [index: NODE]: NODE
            is
                if index =~ _replace then
                    return _with;
                else
                    return null;
                fi
            si,
            = value is
                throw new NotImplementedException();
            si

        contains(node: NODE) -> bool => _replace =~ node;
        isEmpty() -> bool => false;
        remove(node: NODE) -> NODE is throw new NotImplementedException(); si
        clear() is throw new NotImplementedException(); si
    si
si
