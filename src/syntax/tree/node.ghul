// import glist;
namespace Syntax.Tree is
    use System;
    
    use Generic;
    use Source;

    class NODE is
        // parent: NODE public;
        location: LOCATION;

        _next_id: int static;
        _id: int;
        id: int public => _id;

        is_poisoned: bool;

        next_id: int static is
            var result = _next_id;
            _next_id = _next_id + 1;
            return result;
        si

        debug_next_id: int static => _next_id;

        init(location: LOCATION) is
            _id = next_id;
            self.location = location;
        si

        @IF.legacy()
        hash() -> int => id;

        @IF.dotnet()
        @IL.name("GetHashCode")
        get_hash_code() -> int => id;
        
        @IL.name("Equals")
        =~(other: NODE) -> bool => other? && _id == other._id;

        >(other: NODE) -> int => _id - other._id;

        clone() -> NODE is
            @IF.legacy()
            let result = cast NODE(super.clone());   

            @IF.dotnet()
            let result = cast NODE(memberwise_clone());   

            result._id = next_id;         

            return result;
        si
        
        accept(visitor: Visitor) is
            visitor.visit(self);
        si

        walk(visitor: Visitor) is
            accept(visitor);
        si

        poison(should_poison: bool) is
            if should_poison then
                is_poisoned = true;
            fi
        si

        poison() is
            is_poisoned = true;
        si        

        @IF.legacy()
        toString() -> String is
            var printer = new Process.Printer.GHUL();
            accept(printer);
            return printer.result;
        si

        @IF.dotnet()
        @IL.name("ToString")
        to_string() -> String is
            var printer = new Process.Printer.GHUL();
            accept(printer);
            return printer.result;
        si

    si
si
