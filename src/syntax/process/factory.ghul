namespace Syntax.Process is
    class FACTORY is
        _container: IoC.CONTAINER;

        init(container: IoC.CONTAINER) is
            assert container?;

            _container = container;
        si

        create_state(owner: string) -> Semantic.SYMBOL_TABLE_STATE =>
            new Semantic.SYMBOL_TABLE_STATE(_container.logger, _container.symbol_table, owner);

        create_dependencies(owner: string) -> (Semantic.SYMBOL_TABLE_STATE, Semantic.SYMBOL_LOADER, Semantic.FUNCTION_CALLER) is
            let symbol_table_state = create_state(owner);
            
            let function_caller = new Semantic.FUNCTION_CALLER(_container.symbol_table, symbol_table_state, _container.value_boxer);

            let symbol_loader = 
                new Semantic.SYMBOL_LOADER(
                    _container.logger, 
                    _container.symbol_table, 
                    symbol_table_state, 
                    function_caller, 
                    _container.value_boxer,
                    _container.innate_symbol_lookup
                );

            return (symbol_table_state, symbol_loader, function_caller);
        si
        
        create_conditional_compilation() -> CONDITIONAL_COMPILATION =>
            new CONDITIONAL_COMPILATION();

        create_expand_namespaces() -> EXPAND_NAMESPACES => 
            new EXPAND_NAMESPACES();

        create_add_accessors_for_properties() -> ADD_ACCESSORS_FOR_PROPERTIES => 
            new ADD_ACCESSORS_FOR_PROPERTIES();

        create_declare_symbols() -> DECLARE_SYMBOLS =>
            new DECLARE_SYMBOLS(
                _container.logger, 
                _container.stable_symbols,
                _container.symbol_table,
                create_state("declare-symbols"),
                _container.namespaces, 
                _container.symbol_definition_locations,
                _container.local_id_generator);

        create_resolve_uses() -> RESOLVE_USES => 
            new RESOLVE_USES(
                _container.logger, 
                _container.symbol_table, 
                create_state("resolve-uses"), 
                _container.namespaces);

        create_resolve_ancestors() -> RESOLVE_ANCESTORS =>
            new RESOLVE_ANCESTORS(
                _container.logger, 
                _container.stable_symbols, 
                _container.symbol_table, 
                create_state("resolve-ancestors"), 
                _container.namespaces, 
                _container.innate_symbol_lookup);
    
        create_resolve_type_expressions() -> RESOLVE_TYPE_EXPRESSIONS =>
            new RESOLVE_TYPE_EXPRESSIONS(
                _container.logger,
                _container.stable_symbols,
                _container.symbol_table,
                create_state("resolve-type-expressions"),
                _container.namespaces,
                _container.symbol_use_locations,
                _container.innate_symbol_lookup
            );
    
        create_resolve_explicit_types() -> RESOLVE_EXPLICIT_TYPES =>
            new RESOLVE_EXPLICIT_TYPES(
                _container.logger,
                _container.stable_symbols,
                _container.symbol_table,
                create_state("resolve-explicit-types"),
                _container.namespaces,
                _container.innate_symbol_lookup
            );
    
        create_compile_expressions() -> COMPILE_EXPRESSIONS is
            let dependencies = create_dependencies("compile-expressions");

            return
                new COMPILE_EXPRESSIONS(
                    _container.logger,
                    _container.stable_symbols,
                    _container.symbol_table,
                    dependencies._0,
                    _container.namespaces,
                    dependencies._1,
                    _container.innate_symbol_lookup,
                    dependencies._2,
                    _container.overload_resolver,
                    _container.symbol_use_locations,
                    _container.value_converter
                );
        si
    
        create_resolve_overrides() -> RESOLVE_OVERRIDES =>
            new RESOLVE_OVERRIDES(
                _container.logger,
                _container.stable_symbols,                    
                _container.symbol_table,
                create_state("resolve-overrides"),
                _container.namespaces
            );
    
        create_generate_il() -> GENERATE_IL is
            let dependencies = create_dependencies("compile-expressions");

            return
                new GENERATE_IL(
                    _container.logger,
                    _container.symbol_table,
                    dependencies._0,
                    _container.namespaces,
                    dependencies._1,
                    _container.innate_symbol_lookup,
                    dependencies._2,
                    _container.overload_resolver,
                    _container.symbol_use_locations,
                    _container.ir_context,
                    _container.brancher,
                    _container.boilerplate_generator,
                    _container.value_boxer
                );
        si
    
        create_completer() -> COMPLETER =>
            new COMPLETER(
                _container.logger,
                _container.symbol_table,
                create_state("completer"),
                _container.namespaces,
                _container.dotnet_symbol_table
            );
    
        create_signature_help() -> SIGNATURE_HELP =>
            new SIGNATURE_HELP(
                _container.logger,
                _container.symbol_table,
                create_state("signature-help"),
                _container.namespaces,
                _container.overload_resolver
            );        
    si    
si