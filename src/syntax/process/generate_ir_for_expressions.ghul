namespace Syntax.Process is
    use System;
    use Generic;

    use Logging;
    use Source;

    class GENERATE_IR_FOR_EXPRESSIONS: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _generic_cache: Semantic.GENERIC_CACHE;
        _context_factory: IR.CONTEXT_FACTORY;

        _context: IR.CONTEXT;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            generic_cache: Semantic.GENERIC_CACHE,
            context_factory: IR.CONTEXT_FACTORY
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _generic_cache = generic_cache;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _system_symbol_lookup = system_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _context_factory = context_factory;
        si

        type_name(value: Semantic.Graph.Value.BASE) -> String is
            if value? && value.type? then
                return value.type.toString();
            else
                return "no IR type";
            fi
        si

        to_string(value: IR.Value) -> String is
            return value.toString();
        si

        apply(root: Tree.NODE) is
            IO.Std.err.println(">>> IR.GENERATE_IR_FOR_EXPRESSIONS");
            root.walk(self);
            IO.Std.err.println("<<< IR.GENERATE_IR_FOR_EXPRESSIONS");
        si

        pre(for_: Tree.Statement.FOR) -> bool is
            super.pre(for_);

            var symbol = find(for_.variable.name);
        si

        pre(assignment: Tree.Statement.ASSIGNMENT) -> bool is
            super.pre(assignment);
        si

        pre(function: Tree.Expression.FUNCTION) -> bool is            
            super.pre(function);

            let symbol = _symbol_table.current_function;

            if !symbol? then
                return false;
            fi
            
            _context = _context_factory.create_context(symbol);
        si

        visit(function: Tree.Expression.FUNCTION) is
            super.visit(function);
        si

        visit(expression: Tree.Statement.EXPRESSION) is
            IO.Std.err.println("expression: " + expression.expression.value);

            if expression.expression.value? then
                    expression.expression.value.gen(_context);
            fi
        si

        visit(tuple: Tree.Expression.TUPLE) is
        si

        visit(sequence: Tree.Expression.SEQUENCE) is
        si

        visit(self_: Tree.Expression.SELF) is
        si

        visit(super_: Tree.Expression.SUPER) is
        si

        visit(native_: Tree.Expression.NATIVE) is
        si

        visit(cast_: Tree.Expression.CAST) is
        si

        visit(new_: Tree.Expression.NEW) is
        si

        visit(unary: Tree.Expression.UNARY) is
            // IO.Std.err.println("unary: " + unary.value);
        si

        visit(binary: Tree.Expression.BINARY) is
            // IO.Std.err.println("binary: " + binary.value + " / " + type_name(binary.value));
        si

        visit(index: Tree.Expression.INDEX) is
            // IO.Std.err.println("index: " + index.value + " / " + type_name(index.value));
        si

        visit(member: Tree.Expression.MEMBER) is
            // IO.Std.err.println("member: " + member.value + " / " + type_name(member.value));
        si

        visit(variable: Tree.Variable.NODE) is
        si

        visit(integer: Tree.Expression.Literal.INTEGER) is
        si

        visit(string: Tree.Expression.Literal.STRING) is
        si

        visit(call: Tree.Expression.CALL) is
            // IO.Std.err.println("call: " + call.value + " / " + type_name(call.value));
        si

        visit(identifier: Tree.Expression.IDENTIFIER) is
            // IO.Std.err.println("identifier: " + identifier.value + " / " + type_name(identifier.value) );
        si
    si
si
