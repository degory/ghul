namespace Syntax.Process is
    use LAZY = System.Lazy`1;

    use IO.Std;

    use Pair = Collections.KeyValuePair`2;

    use Logging;
    use Source;

    use Trees;

    class FORMAT_WEIGHT_CALCULATOR: ValueVisitor[int,int] is
        _have_hit: bool;

        _range: LOCATION;

        _weight_stack: Collections.STACK[int];

        _weights: Collections.MutableMap[Node,int];

        _weight: int;

        init(range: LOCATION) is
            super.init();

            _range = range;
            _weights = new Collections.MAP[Node,int]();
            _weight_stack = new Collections.STACK[int]();
        si

        // Want to find the smallest node that completely contains the range to format
        checkNode(node: Node) -> MATCH_TYPE is
        si
        
        visit(identifier: Identifiers.Identifier, state: int) -> int is
            return identifier.name.length;
        si

        visit(identifier: Identifiers.QUALIFIED, state: int) -> int is
            return identifier.name.length;
        si

        visit(modifier: Modifiers.Modifier) is
            checkNode(modifier);
        si

        visit(modifiers: Modifiers.LIST) is
            checkNode(modifiers);
        si

        visit(definition: Definitions.Definition) is
            checkNode(definition);
        si

        visit(definitions: Definitions.LIST) is
            checkNode(definitions);
        si

        visit(`namespace: Definitions.NAMESPACE) is
            checkNode(`namespace);
        si

        visit(`use: Definitions.USE) is
            checkNode(`use);
        si

        visit(`class: Definitions.CLASS) is
            checkNode(`class);
        si

        visit(`trait: Definitions.TRAIT) is
            checkNode(`trait);
        si

        visit(`struct: Definitions.STRUCT) is
            checkNode(`struct);
        si        

        visit(`enum: Definitions.ENUM) is
            checkNode(`enum);
        si

        visit(enum_member: Definitions.ENUM_MEMBER) is
            checkNode(enum_member);
        si

        visit(function: Definitions.FUNCTION) is
            checkNode(function);
        si

        visit(property: Definitions.PROPERTY) is
            checkNode(property);
        si

        visit(indexer: Definitions.INDEXER) is
            checkNode(indexer);
        si

        visit(variable: Variables.Variable) is
            checkNode(variable);
        si

        visit(variables: Variables.LIST) is
            checkNode(variables);
        si

        visit(type_expression: TypeExpressions.TypeExpression) is
            checkNode(type_expression);
        si

        visit(type_expression: TypeExpressions.INFER) is
            checkNode(type_expression);
        si

        visit(structured: TypeExpressions.Structured) is
            checkNode(structured);
        si

        visit(array: TypeExpressions.ARRAY_) is
            checkNode(array);
        si

        visit(pointer: TypeExpressions.POINTER) is
            checkNode(pointer);
        si

        visit(reference: TypeExpressions.REFERENCE) is
            checkNode(reference);
        si

        visit(named: TypeExpressions.NAMED) is
            checkNode(named);
        si

        visit(types: TypeExpressions.LIST) is
            checkNode(types);
        si

        visit(generic: TypeExpressions.GENERIC) is
            checkNode(generic);
        si

        visit(function: TypeExpressions.FUNCTION) is
            checkNode(function);
        si

        visit(tuple: TypeExpressions.TUPLE) is
            checkNode(tuple);
        si

        visit(element: TypeExpressions.NAMED_TUPLE_ELEMENT) is
            checkNode(element);
        si

        visit(element: TypeExpressions.UNDEFINED) is
            checkNode(element);
        si

        visit(expression: Expressions.Expression) is
            checkNode(expression);
        si

        visit(identifier: Expressions.IDENTIFIER) is
            checkNode(identifier);
        si

        visit(literal: Expressions.Literals.Literal) is
            checkNode(literal);
        si

        visit(`string: Expressions.Literals.STRING) is
            checkNode(`string);
        si

        visit(integer: Expressions.Literals.INTEGER) is
            checkNode(integer);
        si        

        visit(float: Expressions.Literals.FLOAT) is
            checkNode(float);
        si        

        visit(character: Expressions.Literals.CHARACTER) is
            checkNode(character);
        si

        visit(boolean: Expressions.Literals.BOOLEAN) is
            checkNode(boolean);
        si

        visit(variable: Expressions.VARIABLE) is
            checkNode(variable);
        si

        visit(variable: Expressions.TUPLE_ELEMENT) is
            checkNode(variable);
        si

        visit(none: Expressions.Literals.NONE) is
            checkNode(none);
        si

        visit(`null: Expressions.NULL) is
            checkNode(`null);
        si

        visit(`self: Expressions.SELF) is
            checkNode(`self);
        si

        visit(`super: Expressions.SUPER) is
            checkNode(`super);
        si

        visit(`new: Expressions.NEW) is
            checkNode(`new);
        si

        visit(`cast: Expressions.CAST) is
            checkNode(`cast);
        si

        visit(`isa: Expressions.ISA) is
            checkNode(`isa);
        si

        visit(`isa: Expressions.TYPEOF) is
            checkNode(`isa);
        si

        visit(function: Syntax.Trees.Expressions.FUNCTION) is
            checkNode(function);
        si

        visit(tuple: Expressions.TUPLE) is
            checkNode(tuple);
        si

        visit(sequence: Expressions.SEQUENCE) is
            checkNode(sequence);
        si

        visit(list: Expressions.LIST) is
            checkNode(list);
        si

        visit(call: Expressions.CALL) is
            checkNode(call);
        si

        visit(member: Expressions.MEMBER) is
            checkNode(member);
        si

        visit(index: Expressions.INDEX) is
            checkNode(index);
        si

        visit(has_value: Expressions.HAS_VALUE) is
            checkNode(has_value);
        si

        visit(reference: Expressions.REFERENCE) is
            checkNode(reference);
        si

        visit(unary: Expressions.UNARY) is
            checkNode(unary);
        si

        visit(binary: Expressions.BINARY) is
            checkNode(binary);
        si

        visit(statement: Statements.Statement) is
            checkNode(statement);
        si

        visit(statements: Statements.LIST) is
            checkNode(statements);
        si

        visit(l: Statements.LET) is
            checkNode(l);
        si

        visit(v: Statements.VAR) is
            checkNode(v);
        si

        visit(assign: Statements.ASSIGNMENT) is
            checkNode(assign);
        si

        visit(expression: Statements.EXPRESSION) is
            checkNode(expression);
        si

        visit(`return: Statements.RETURN) is
            checkNode(`return);
        si

        visit(`throw: Statements.THROW) is
            checkNode(`throw);
        si

        visit(`assert: Statements.ASSERT) is
            checkNode(`assert);
        si

        visit(`if: Statements.IF) is
            checkNode(`if);
        si

        visit(`case: Statements.CASE) is
            checkNode(`case);
        si

        visit(case_match: Statements.CASE_MATCH) is
            checkNode(case_match);
        si

        visit(`try: Statements.TRY) is
            checkNode(`try);
        si

        visit(`catch: Statements.CATCH) is
            checkNode(`catch);
        si

        visit(`do: Statements.DO) is
            checkNode(`do);
        si

        visit(`for: Statements.FOR) is
            checkNode(`for);
        si

        visit(labelled: Statements.LABELLED) is
            checkNode(labelled);
        si

        visit(`break: Statements.BREAK) is
            checkNode(`break);
        si

        visit(`continue: Statements.CONTINUE) is
            checkNode(`continue);
        si

        visit(body: Bodies.Body) is
            checkNode(body);
        si

        visit(expression: Bodies.EXPRESSION) is
            checkNode(expression);
        si

        visit(block: Bodies.BLOCK) is
            checkNode(block);
        si
    si
si
