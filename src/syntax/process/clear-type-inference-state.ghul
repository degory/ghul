namespace Syntax.Process is
    use System.Exception;

    use IO.Std;
        
    use Logging;
    use Source;

    use IR.Values;
    use IR.VALUE_CONVERTER;
    use IR.VALUE_BOXER;

    use Semantic.Types.Type;

    use Syntax.Trees.Definitions.PRAGMA;

    // TODO some of these clear_constraints probably end up being
    // duplicates

    class CLEAR_TYPE_INFERENCE_STATE: Visitor is
        init() is
            super.init();
        si

        apply(root: Trees.Node) is
            root.walk(self);
        si

        visit(let_in: Trees.Expressions.LET_IN) is
            let_in.expression.clear_constraint();
            let_in.expression.unpin();
        si
        
        visit(assignment: Trees.Statements.ASSIGNMENT) is
            assignment.left.clear_constraint();
            assignment.left.unpin();
            assignment.right.clear_constraint();
            assignment.right.unpin();
        si

        visit(expression: Trees.Statements.EXPRESSION) is
            expression.expression.clear_constraint();
            expression.expression.unpin();
        si

        visit(r: Trees.Statements.RETURN) is
            if r.expression? then
                r.expression.clear_constraint();
                r.expression.unpin();
            fi
        si

        visit(branch: Trees.Statements.IF_BRANCH) is
            branch.body.clear_constraint();
            branch.body.unpin();
        si

        visit(expression: Trees.Bodies.EXPRESSION) is
            expression.expression.clear_constraint();
            expression.expression.unpin();
        si

        visit(identifier: Trees.Expressions.IDENTIFIER) is
            identifier.clear_constraint();
            identifier.unpin();
        si
        
        visit(function: Trees.Expressions.FUNCTION) is
            function.clear_constraint();
            function.unpin();

            for a in function.arguments do
                a.clear_constraint();
                a.unpin();
            od
        si

        visit(tuple: Trees.Expressions.TUPLE) is
            tuple.clear_constraint();
            tuple.unpin();

            for element in tuple.elements do
                element.clear_constraint();
                element.unpin();
            od
        si

        visit(sequence: Trees.Expressions.SEQUENCE) is
            sequence.clear_constraint();
            sequence.unpin();

            for e in sequence.elements do
                e.clear_constraint();
                e.unpin();
            od                        
        si

        visit(call: Trees.Expressions.CALL) is
            call.clear_constraint();
            call.unpin();

            for a in call.arguments do
                a.clear_constraint();
                a.unpin();
            od
        si

        visit(statement: Trees.Expressions.STATEMENT) is
            statement.statement.clear_constraint();
            statement.statement.unpin();
        si

        visit(list: Trees.Statements.LIST) is
            list.clear_constraint();
            list.unpin();
        si

        visit(`if: Trees.Statements.IF) is
            `if.clear_constraint();
            `if.unpin();
        si
    si
si