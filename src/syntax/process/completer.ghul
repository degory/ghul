namespace Syntax.Process is
    use LAZY = System.Lazy`1;

    use IO.Std;

    use Pair = Collections.KeyValuePair`2;
        
    use Logging;
    use Source;

    class COMPLETER: ScopedVisitor is
        _target_line: int;
        _target_column: int;

        _dotnet_symbol_table: LAZY[Semantic.DotNet.SYMBOL_TABLE];

        _results: Collections.MAP[string,Semantic.Symbols.Symbol];

        _have_hit: bool;
                
        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            dotnet_symbol_table: LAZY[Semantic.DotNet.SYMBOL_TABLE]
        )
        is
            super.init(logger, null, symbol_table, namespaces);

            _dotnet_symbol_table = dotnet_symbol_table; 
        si

        find_completions(root: Trees.Node, target_line: int, target_column: int) -> Collections.Iterable[Pair[string,Semantic.Symbols.Symbol]] is
            _have_hit = false;

            _target_line = target_line;
            _target_column = target_column;

            _results = new Collections.MAP[string,Semantic.Symbols.Symbol]();

            root.walk(self);

            return _results;
        si

        leave_scope(node: Trees.Node) is 
            if !_have_hit /\ node.location.contains(_target_line, _target_column) then
                find_matches("", _results);

                _namespaces.find_root_matches(_results);
                _dotnet_symbol_table.value.find_root_matches(_results);

                _have_hit = true;
            fi

            super.leave_scope(node);
        si

        visit_literal(location: LOCATION) is            
            if
                location.contains(_target_line, _target_column) \/ 
                location.contains(_target_line, _target_column - 1)
            then
                _have_hit = true;
            fi
        si

        visit(literal: Trees.Expressions.Literals.INTEGER) is
            visit_literal(literal.location);
        si

        visit(literal: Trees.Expressions.Literals.FLOAT) is
            visit_literal(literal.location);
        si

        visit(literal: Trees.Expressions.Literals.STRING) is
            visit_literal(literal.location);
        si
        
        visit(literal: Trees.Expressions.Literals.CHARACTER) is
            visit_literal(literal.location);
        si

        visit(literal: Trees.Expressions.Literals.BOOLEAN) is
            visit_literal(literal.location);
        si

        visit(qualified: Trees.Identifiers.QUALIFIED) is
            if !qualified.completion_target.contains(_target_line, _target_column-1) then
                return;
            fi

            let symbol = find(qualified.qualifier);           

            let namespace_name = qualified.qualifier.to_string();

            if symbol == null then
                Std.error.write_line("no left symbol for: " + namespace_name); 

                _dotnet_symbol_table.value.find_member_matches(namespace_name, _results);

                _have_hit = true;
                return;
            fi
            
            Std.error.write_line("have left symbol: " + symbol + " of type: " + symbol.get_type());

            if !isa Semantic.Symbols.Scoped(symbol) then
                Std.error.write_line("but it has no scope: " + symbol.get_type()); 
                return;
            fi

            cast Semantic.Symbols.Scoped(symbol).find_member_matches("", _results);

            _namespaces.find_namespace_matches(namespace_name, _results);

            _have_hit = true;
        si

        visit(member: Trees.Expressions.MEMBER) is
            if !member.completion_target.contains(_target_line, _target_column-1) then
                return;
            fi

            if member.left == null \/ member.left.value == null \/ member.left.value.type == null then
                return;
            fi

            var type: Semantic.Types.NAMED;

            if isa Semantic.Types.NAMED(member.left.value.type) then
                type = cast Semantic.Types.NAMED(member.left.value.type);
            elif isa Semantic.Types.GENERIC(member.left.value.type) then
                Std.error.write_line("oops: expected type to be specialized by now: " + member.left.value.type);
                return;
            else
                Std.error.write_line("oops: not sure how to complete member of type: " + member.left.value.type);
                return;
            fi

            type.symbol.find_member_matches("", _results);

            _have_hit = true;
        si
    si
si
