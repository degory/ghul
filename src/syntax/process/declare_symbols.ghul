namespace Syntax.Process is
    use System;
    
    use Logging;
    use Source;
    use Tree;

    class DECLARE_SYMBOLS: ScopeVisitorBase is
        _logger: Logger;

        _anon_index: int;
        _stub_depth: int;

        _symbol_definition_listener: Semantic.SymbolDefinitionListener;

        _local_id_generator: IR.LOCAL_ID_GENERATOR;

        init(
            logger: Logger,
            symbol_table:Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_use_listener: Semantic.SymbolDefinitionListener,
            local_id_generator: IR.LOCAL_ID_GENERATOR
        ) is
            super.init(symbol_table, namespaces);

            _logger = logger;
            _symbol_definition_listener = symbol_use_listener;
            _local_id_generator = local_id_generator;
        si

        apply(node: NODE) is
            node.walk(self);
        si

        next_anon_name() -> String is
            let result = "__anon_" + _anon_index;
            _anon_index = _anon_index + 1;
            return result;
        si

        pre(pragma_: Definition.PRAGMA) -> bool is
            if !pragma_.pragma_? then
                System.Console.error.write_line("pragma is null");
                return false;
            fi

            let p = pragma_.pragma_;

            let name = Shim.STR.format(p.name);

            if name =~ "IL.stub" then
                _stub_depth = _stub_depth + 1;
            fi
        si

        visit(pragma_: Definition.PRAGMA) is
            if !pragma_.pragma_? then
                System.Console.error.write_line("pragma is null");
                return;
            fi

            let p = pragma_.pragma_;

            let name = Shim.STR.format(p.name);

            let is_built_in = name =~ "IL.built_in_type";

            if 
                is_built_in ||
                name =~ "IL.name" ||
                name =~ "IL.name.read" ||
                name =~ "IL.name.assign"
            then
                if !p.arguments? || p.arguments.expressions.count != 1 then
                    _logger.error(p.arguments.location, "expected one argument");
                    return;
                fi

                let argument = p.arguments.expressions[0];

                if !argument? || !isa Expression.Literal.STRING(argument) then
                    _logger.error(p.arguments.location, "expected a string literal argument");
                    return;
                fi

                let il_name = cast Expression.Literal.STRING(argument).string;

                let definition = pragma_.definition;

                while isa Definition.PRAGMA(definition) do
                    definition = cast Definition.PRAGMA(definition).definition;
                od
                
                let symbol = symbol_for(pragma_.definition);

                if symbol? then
                    if isa Semantic.Symbol.Property(symbol) then
                        let property = cast Semantic.Symbol.Property(symbol);

                        // FIXME: these should be inherited:
                        if name =~ "IL.name.read" then
                            property.read_function_il_name_override = il_name;
                        elif name =~ "IL.name.assign" then
                            property.assign_function_il_name_override = il_name;
                        else
                            _logger.error(pragma_.location, "IL.name.read and/or IL.name.assign expected here");
                        fi

                        return;
                    fi

                    if is_built_in then
                        symbol.il_is_built_in_type = true;    
                    fi

                    symbol.il_name_override = il_name;
                fi
            elif name =~ "IL.stub" then
                _stub_depth = _stub_depth - 1;
            fi            
        si

        pre(namespace_: Definition.NAMESPACE) -> bool is
            declare_and_enter_namespace(namespace_.name, _symbol_definition_listener);
        si

        visit(namespace_: Definition.NAMESPACE) is
            leave_namespace(namespace_.name);
        si

        get_generic_arguments(arguments: Tree.TypeExpression.LIST) -> Collections.LIST[String] is
            let result = new Collections.LIST[String]();

            if arguments? then
                // FIXME: this is a bodge - generic class definition arguments are not type expressions, they're
                // their own thing and should support type variance and type constraints - need new syntax tree
                // node classes to represent them:
                for a in arguments do                    
                    if isa Tree.TypeExpression.NAMED(a) then
                        let named = cast Tree.TypeExpression.NAMED(a);

                        result.add(named.name.name);
                    elif isa Tree.TypeExpression.NAMED_TUPLE_ELEMENT(a) then
                        let named = cast Tree.TypeExpression.NAMED_TUPLE_ELEMENT(a);

                        result.add(named.name.name);
                    elif !a.is_poisoned then
                        _logger.error(a.location, "cannot handle type argument: " + a);
                    fi
                od
            fi

            return result;
        si

        declare_generic_arguments(arguments: Tree.TypeExpression.LIST) is
            if arguments? then
                // FIXME: this is a bodge - generic class definition arguments are not type expressions, they're
                // their own thing and should support type variance and type constraints - need new syntax tree
                // node classes to represent them:
                let index = 0;

                for a in arguments do
                    if isa Tree.TypeExpression.NAMED(a) then
                        let named = cast Tree.TypeExpression.NAMED(a);

                        current_declaration_context.declare_type(named.name.location, named.name.name, index, _symbol_definition_listener);
                    elif isa Tree.TypeExpression.NAMED_TUPLE_ELEMENT(a) then
                        let named = cast Tree.TypeExpression.NAMED_TUPLE_ELEMENT(a);

                        current_declaration_context.declare_type(named.name.location, named.name.name, index, _symbol_definition_listener);
                    fi

                    index = index + 1;
                od
            fi
        si
        
        pre(class_: Definition.CLASS) -> bool is
            let arguments = get_generic_arguments(class_.arguments);

            associate_and_enter_scope(
                class_,
                current_declaration_context.declare_class(
                    class_.name.location,
                    class_.name.name,
                    arguments,
                    _stub_depth > 0,
                    current_scope,
                    _symbol_definition_listener
                )
            );

            declare_generic_arguments(class_.arguments);
        si

        visit(class_: Definition.CLASS) is
            leave_scope(class_);
        si

        pre(trait_: Definition.TRAIT) -> bool is
            let arguments = get_generic_arguments(trait_.arguments);

            associate_and_enter_scope(
                trait_, 
                current_declaration_context.declare_trait(
                    trait_.name.location, 
                    trait_.name.name, 
                    arguments, 
                    _stub_depth > 0,
                    current_scope, 
                    _symbol_definition_listener
                )
            );

            declare_generic_arguments(trait_.arguments);
        si

        visit(trait_: Definition.TRAIT) is
            leave_scope(trait_);
        si

        pre(struct_: Definition.STRUCT) -> bool is
            let arguments = get_generic_arguments(struct_.arguments);

            associate_and_enter_scope(
                struct_, 
                current_declaration_context.declare_struct(
                    struct_.name.location, 
                    struct_.name.name, 
                    arguments,
                    _stub_depth > 0,
                    current_scope, 
                    _symbol_definition_listener
                )
            );

            declare_generic_arguments(struct_.arguments);
        si

        visit(struct_: Definition.STRUCT) is
            leave_scope(struct_);
        si        

        pre(enum_: Definition.ENUM) -> bool is
            associate_and_enter_scope(
                enum_, 
                current_declaration_context.declare_enum(
                    enum_.name.location, 
                    enum_.name.name, 
                    _symbol_definition_listener
                )
            );
        si

        visit(enum_: Definition.ENUM) is
            leave_scope(enum_);
        si

        pre(enum_member: Definition.ENUM_MEMBER) -> bool is
            let value: String;

            if enum_member.initializer? then
                let i = enum_member.initializer;

                if isa Tree.Expression.Literal.NODE(i) then
                    value = cast Tree.Expression.Literal.NODE(i).string;
                else
                    _logger.error(i.location, "enum member initializer must be an integer literal");
                fi
            fi
            
            current_declaration_context.declare_enum_member(
                enum_member.name.location, 
                enum_member.name.name,
                value,
                _symbol_definition_listener
            );
        si

        pre(function: Definition.FUNCTION) -> bool is
            let is_innate = function.body? && isa Tree.Body.INNATE(function.body);
            let is_static = function.modifiers.is_static;

            let is_private = function.modifiers.is_private;

            let property: Semantic.Symbol.Property;

            _local_id_generator.enter_function();

            if function.for_property? then
                let symbol = symbol_for(function.for_property);

                assert symbol? else "function is accessor for property but no property found: " + function.location;
                assert isa Semantic.Symbol.Property(symbol) else "function is accessor for property but associated symbol is not a property: " + function.location;

                property = cast Semantic.Symbol.Property(symbol);
            fi
            
            if is_innate then
                let innate_ = cast Tree.Body.INNATE(function.body);

                associate_and_enter_scope(
                    function, 
                    current_declaration_context.declare_innate(
                        function.name.location, 
                        function.name.name, 
                        Shim.STR.format(innate_.name),
                        current_scope,_symbol_definition_listener
                    )
                );
            else
                associate_and_enter_scope(
                    function, 
                    current_declaration_context.declare_function(
                        function.name.location, 
                        function.name.name,
                        is_static,
                        is_private,
                        current_scope, 
                        _symbol_definition_listener));
            fi
            
            let symbol = symbol_for(function);

            if symbol? && isa Semantic.Symbol.Function(symbol) then
                let function_symbol = cast Semantic.Symbol.Function(symbol);

                if property? then
                    if function.arguments.variables.count == 0 then
                        property.read_function = function_symbol;

                        if property.read_function_il_name_override? then
                            function_symbol.il_name_override = property.read_function_il_name_override;
                        fi                        
                    else
                        property.assign_function = function_symbol;

                        if property.assign_function_il_name_override? then
                            function_symbol.il_name_override = property.assign_function_il_name_override;
                        fi
                    fi
                fi
                
                function_symbol.start_declaring_arguments();
                function.arguments.walk(self);
                function_symbol.end_declaring_arguments();                    
            fi
            
            if function.body? then
                function.body.walk(self);
            fi

            return true ;
        si

        visit(function: Definition.FUNCTION) is
            _local_id_generator.leave_function();

            leave_scope(function);
        si

        pre(property: Definition.PROPERTY) -> bool is
            let is_static = property.modifiers.is_static;

            if 
                Shim.STR.starts_with(property.name.name, '_') && 
                !property.read_body? && 
                !property.assign_body?
            then
                current_declaration_context.declare_variable(property.name.location, property.name.name, is_static, _symbol_definition_listener);
            else
                let is_assignable = !property.read_body? || property.assign_argument?;
                let is_private: bool;

                if Shim.STR.starts_with(property.name.name, '_') then
                    is_private = !property.modifiers.is_public;
                else
                    is_private = property.modifiers.is_private;
                fi

                let symbol = current_declaration_context.declare_property(property.name.location, property.name.name, is_static, is_private, is_assignable, _symbol_definition_listener);

                if property.read_body == null && property.assign_body == null then
                    // declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is

                    current_declaration_context.declare_variable(
                        property.name.location, 
                        "__backing_" + property.name.name,
                        is_static, 
                        _symbol_definition_listener);
                fi

                associate_node_with_scope(property, symbol);
            fi

            return true;
        si

        pre(indexer: Definition.INDEXER) -> bool is
            // ???

            return true;
        si

        visit(variable: Variable.NODE) is
            current_declaration_context.declare_variable(variable.name.location, variable.name.name, variable.is_static, _symbol_definition_listener);
        si

        visit(variable: Expression.VARIABLE) is
        si

        pre(if_branch: Statement.IF_BRANCH) -> bool is
            create_and_enter_block_scope(if_branch);
        si

        visit(if_branch: Statement.IF_BRANCH) is
            leave_scope(if_branch);
        si

        pre(case_: Statement.CASE) -> bool is
            create_and_enter_block_scope(case_);
        si

        visit(case_: Statement.CASE) is
            leave_scope(case_);
        si

        pre(case_match: Statement.CASE_MATCH) -> bool is
            create_and_enter_block_scope(case_match);
        si

        visit(case_match: Statement.CASE_MATCH) is
            leave_scope(case_match);
        si

        pre(try_: Statement.TRY) -> bool is
            create_and_enter_block_scope(try_);
        si

        visit(try_: Statement.TRY) is
            leave_scope(try_);
        si

        pre(catch_: Statement.CATCH) -> bool is
            create_and_enter_block_scope(catch_);
        si

        visit(catch_: Statement.CATCH) is
            leave_scope(catch_);
        si

        pre(do_: Statement.DO) -> bool is
            create_and_enter_block_scope(do_);
        si

        visit(do_: Statement.DO) is
            leave_scope(do_);
        si

        pre(for_: Statement.FOR) -> bool is
            create_and_enter_block_scope(for_);
        si

        visit(for_: Statement.FOR) is
            leave_scope(for_);
        si

        pre(labelled: Statement.LABELLED) -> bool is
            current_declaration_context.declare_label(labelled.label.location, labelled.label.name, _symbol_definition_listener);
        si

        visit(labelled: Statement.LABELLED) is
        si

        pre(body: Body.NODE) -> bool is
            create_and_enter_block_scope(body);
        si

        visit(body: Body.NODE) is
            leave_scope(body);
        si

        pre(tuple: Expression.TUPLE) -> bool is
        si

        pre(variable: Expression.VARIABLE) -> bool is
            current_declaration_context.declare_variable(variable.name.location, variable.name.name, false, _symbol_definition_listener);
        si

        pre(function: Expression.FUNCTION) -> bool is
            let closure = current_function.declare_closure(
                function.location, 
                next_anon_name(),
                // FIXME: only correct for closures in methods - closures within a global function will not have a class/trait/struct owner:
                current_instance_context, 
                current_scope,
                _symbol_definition_listener
            );

            associate_and_enter_scope(
                function,
                closure
            );

            return true;
        si

        visit(function: Expression.FUNCTION) is
            let symbol = symbol_for(function);

            if symbol? && isa Semantic.Symbol.Function(symbol) then
                let function_symbol = cast Semantic.Symbol.Function(symbol);

                function_symbol.start_declaring_arguments();
                function.arguments.walk(self);
                function_symbol.end_declaring_arguments();                    
            fi
        
            if function.body? then
                function.body.walk(self);
            fi

            leave_scope(function);
        si        

        pre(expression: Body.EXPRESSION) -> bool is
            create_and_enter_block_scope(expression);
        si

        visit(expression: Body.EXPRESSION) is
            leave_scope(expression);
        si

        pre(block: Body.BLOCK) -> bool is
            create_and_enter_block_scope(block);
        si

        visit(block: Body.BLOCK) is
            leave_scope(block);
        si
    si
si