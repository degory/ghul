namespace Syntax.Process is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System;
    
    use Logging;
    use Source;
    use Trees;

    class DECLARE_SYMBOLS: ScopeVisitorBase is
        _logger: Logger;

        _anon_index: int;
        _stub_depth: int;
        _keep_depth: int;

        _symbol_definition_listener: Semantic.SymbolDefinitionListener;

        _local_id_generator: IR.LOCAL_ID_GENERATOR;

        _stable_symbols: Semantic.STABLE_SYMBOLS;

        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,
            symbol_table:Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_use_listener: Semantic.SymbolDefinitionListener,
            local_id_generator: IR.LOCAL_ID_GENERATOR
        ) is
            super.init(symbol_table, namespaces);

            _logger = logger;
            _stable_symbols = stable_symbols;
            _symbol_definition_listener = symbol_use_listener;
            _local_id_generator = local_id_generator;
        si

        apply(node: Node) is
            assert _keep_depth == 0;
            assert _stub_depth == 0;

            node.walk(self);

            assert _keep_depth == 0;
            assert _stub_depth == 0;
        si

        next_anon_name() -> string is
            let result = "__anon_" + _anon_index;
            _anon_index = _anon_index + 1;
            return result;
        si

        // FIXME: #500 Pragma handling code is duplicated across multiple visitors
        pre(pragma_: Definitions.PRAGMA) -> bool is
            if !pragma_.pragma_? then
                Std.error.write_line("pragma is null");
                return false;
            fi

            let p = pragma_.pragma_;

            let name = p.name.to_string();

            if name =~ "IL.stub" then
                _stub_depth = _stub_depth + 1;
            elif name =~ "KEEP" then
                _keep_depth = _keep_depth + 1;
            fi
        si

        visit(pragma_: Definitions.PRAGMA) is
            if !pragma_.pragma_? then
                Std.error.write_line("pragma is null");
                return;
            fi

            let p = pragma_.pragma_;

            let name = p.name.to_string();

            let is_built_in = name =~ "IL.built_in_type";

            if 
                is_built_in ||
                name =~ "IL.name" ||
                name =~ "IL.name.read" ||
                name =~ "IL.name.assign"
            then
                if !p.arguments? || p.arguments.expressions.count != 1 then
                    _logger.error(p.arguments.location, "expected one argument");
                    return;
                fi

                let argument = p.arguments.expressions[0];

                if !argument? || !isa Expressions.Literals.STRING(argument) then
                    _logger.error(p.arguments.location, "expected a string literal argument");
                    return;
                fi

                let il_name = cast Expressions.Literals.STRING(argument).value_string;

                let definition = pragma_.definition;

                while isa Definitions.PRAGMA(definition) do
                    definition = cast Definitions.PRAGMA(definition).definition;
                od
                
                let symbol = symbol_for(definition);

                // FIXME: IL name pragmas not consistently applied to properties and fields 552
                if symbol? then
                    if isa Semantic.Symbols.Property(symbol) then
                        let property = cast Semantic.Symbols.Property(symbol);

                        if name =~ "IL.name.read" then
                            property.read_function_il_name_override = il_name;
                        elif name =~ "IL.name.assign" then
                            property.assign_function_il_name_override = il_name;
                        elif name =~ "IL.name" then
                            property.il_name_override = il_name;

                            if !property.read_function_il_name_override? then
                                property.read_function_il_name_override = "get_" + il_name;
                            fi

                            if !property.assign_function_il_name_override? then
                                property.assign_function_il_name_override = "set_" + il_name;
                            fi                            
                        fi

                        return;
                    fi

                    if is_built_in then
                        symbol.il_is_built_in_type = true;    
                    fi

                    symbol.il_name_override = il_name;
                // elif isa Definitions.PROPERTY(definition) then
                //     let property = cast Definitions.PROPERTY(definition);
                fi
            elif name =~ "IL.stub" then
                _stub_depth = _stub_depth - 1;
            elif name =~ "KEEP" then
                _keep_depth = _keep_depth - 1;
            fi
        si

        pre(namespace_: Definitions.NAMESPACE) -> bool is
            declare_and_enter_namespace(namespace_.name, _symbol_definition_listener);
        si

        visit(namespace_: Definitions.NAMESPACE) is
            leave_namespace(namespace_.name);
        si

        get_generic_arguments(arguments: Trees.TypeExpressions.LIST) -> Collections.LIST[string] is
            let result = new Collections.LIST[string]();

            if arguments? then
                // FIXME: this is a bodge - generic class definition arguments are not type expressions, they're
                // their own thing and should support type variance and type constraints - need new syntax tree
                // node classes to represent them:
                for a in arguments do                    
                    if isa Trees.TypeExpressions.NAMED(a) then
                        let named = cast Trees.TypeExpressions.NAMED(a);

                        result.add(named.name.name);
                    elif isa Trees.TypeExpressions.NAMED_TUPLE_ELEMENT(a) then
                        let named = cast Trees.TypeExpressions.NAMED_TUPLE_ELEMENT(a);

                        result.add(named.name.name);
                    elif !a.is_poisoned then
                        _logger.error(a.location, "cannot handle type argument: " + a);
                    fi
                od
            fi

            return result;
        si

        declare_generic_arguments(arguments: Trees.TypeExpressions.LIST) is
            if arguments? then
                // FIXME: this is a bodge - generic class definition arguments are not type expressions, they're
                // their own thing and should support type variance and type constraints - need new syntax tree
                // node classes to represent them:
                let index = 0;

                for a in arguments do
                    if isa Trees.TypeExpressions.NAMED(a) then
                        let named = cast Trees.TypeExpressions.NAMED(a);

                        current_declaration_context.declare_type(named.name.location, named.name.name, index, _symbol_definition_listener);
                    elif isa Trees.TypeExpressions.NAMED_TUPLE_ELEMENT(a) then
                        let named = cast Trees.TypeExpressions.NAMED_TUPLE_ELEMENT(a);

                        current_declaration_context.declare_type(named.name.location, named.name.name, index, _symbol_definition_listener);
                    fi

                    index = index + 1;
                od
            fi
        si

        _pre(classy: Definitions.Classy) -> bool is
            let symbol: Semantic.Scope;
            let stable_symbol: Semantic.STABLE_SYMBOL;

            if _keep_depth > 0 && _stable_symbols.try_get_symbol(classy, stable_symbol ref) then
                symbol = stable_symbol.symbol;
                @IF.not.release() Std.error.write_line("reuse stable symbol " + symbol);

                current_declaration_context.declare_stable(cast Semantic.Symbols.Symbol(symbol));

                associate_and_enter_scope(
                    classy,
                    symbol
                );
    
                return true;                
            fi
            
            let arguments = get_generic_arguments(classy.arguments);

            // FIXME: we could avoid this by passing in an anonymous function
            // or by merging + parameterizing declare_class/declare_struct/declare_trait
            if isa Trees.Definitions.CLASS(classy) then
                symbol = current_declaration_context.declare_class(
                    classy.name.location,
                    classy.name.name,
                    arguments,
                    _stub_depth > 0,
                    current_scope,
                    _symbol_definition_listener
                );
            elif isa Trees.Definitions.TRAIT(classy) then
                symbol = current_declaration_context.declare_trait(
                    classy.name.location,
                    classy.name.name,
                    arguments,
                    _stub_depth > 0,
                    current_scope,
                    _symbol_definition_listener
                );
            elif isa Trees.Definitions.STRUCT(classy) then
                symbol = current_declaration_context.declare_struct(
                    classy.name.location,
                    classy.name.name,
                    arguments,
                    _stub_depth > 0,
                    current_scope,
                    _symbol_definition_listener
                );    
            else
                throw new Exception("FIXME: OCP...");
            fi

            associate_and_enter_scope(
                classy,
                symbol
            );

            if _keep_depth > 0 then
                _stable_symbols.add(classy, symbol);

                @IF.debug() Std.error.write_line("re-define stable symbol " + symbol);
            fi
            
            declare_generic_arguments(classy.arguments);
        si


        pre(class_: Definitions.CLASS) -> bool => _pre(class_);

        visit(class_: Definitions.CLASS) is
            leave_scope(class_);
        si

        pre(trait_: Definitions.TRAIT) -> bool => _pre(trait_);

        visit(trait_: Definitions.TRAIT) is
            leave_scope(trait_);
        si

        pre(struct_: Definitions.STRUCT) -> bool => _pre(struct_);

        visit(struct_: Definitions.STRUCT) is
            leave_scope(struct_);
        si        

        pre(enum_: Definitions.ENUM) -> bool is
            associate_and_enter_scope(
                enum_, 
                current_declaration_context.declare_enum(
                    enum_.name.location, 
                    enum_.name.name, 
                    _symbol_definition_listener
                )
            );
        si

        visit(enum_: Definitions.ENUM) is
            leave_scope(enum_);
        si

        pre(enum_member: Definitions.ENUM_MEMBER) -> bool is
            let value: string;

            if enum_member.initializer? then
                let i = enum_member.initializer;

                if isa Trees.Expressions.Literals.Literal(i) then
                    value = cast Trees.Expressions.Literals.Literal(i).value_string;
                else
                    _logger.error(i.location, "enum member initializer must be an integer literal");
                fi
            fi
            
            current_declaration_context.declare_enum_member(
                enum_member.name.location, 
                enum_member.name.name,
                value,
                _symbol_definition_listener
            );
        si

        pre(function: Definitions.FUNCTION) -> bool is
            let is_innate = function.body? && isa Trees.Bodies.INNATE(function.body);
            let is_static = function.modifiers.is_static;

            let is_private = function.modifiers.is_private;

            let property: Semantic.Symbols.Property;

            _local_id_generator.enter_function();

            if function.for_property? then
                let symbol = symbol_for(function.for_property);

                assert symbol? else "function is accessor for property but no property found: " + function.location;
                assert isa Semantic.Symbols.Property(symbol) else "function is accessor for property but associated symbol is not a property: " + function.location;

                property = cast Semantic.Symbols.Property(symbol);
            fi
            
            if is_innate then
                let innate_ = cast Trees.Bodies.INNATE(function.body);

                associate_and_enter_scope(
                    function, 
                    current_declaration_context.declare_innate(
                        function.name.location, 
                        function.name.name, 
                        innate_.name.to_string(),
                        current_scope,_symbol_definition_listener
                    )
                );
            else
                associate_and_enter_scope(
                    function, 
                    current_declaration_context.declare_function(
                        function.name.location, 
                        function.name.name,
                        is_static,
                        is_private,
                        current_scope, 
                        _symbol_definition_listener));
            fi
            
            let symbol = symbol_for(function);

            if symbol? && isa Semantic.Symbols.Function(symbol) then
                let function_symbol = cast Semantic.Symbols.Function(symbol);

                if property? then
                    if function.arguments.variables.count == 0 then
                        property.read_function = function_symbol;

                        if property.read_function_il_name_override? then
                            function_symbol.il_name_override = property.read_function_il_name_override;
                        fi                        
                    else
                        property.assign_function = function_symbol;

                        if property.assign_function_il_name_override? then
                            function_symbol.il_name_override = property.assign_function_il_name_override;
                        fi
                    fi
                fi
                
                function_symbol.start_declaring_arguments();
                function.arguments.walk(self);
                function_symbol.end_declaring_arguments();                    
            fi
            
            if function.body? then
                function.body.walk(self);
            fi

            return true ;
        si

        visit(function: Definitions.FUNCTION) is
            _local_id_generator.leave_function();

            leave_scope(function);
        si

        pre(property: Definitions.PROPERTY) -> bool is
            let is_static = property.modifiers.is_static;

            if 
                property.name.name.starts_with('_') && 
                !property.read_body? && 
                !property.assign_body?
            then
                let symbol = current_declaration_context.declare_variable(property.name.location, property.name.name, is_static, _symbol_definition_listener);

                associate_node_with_scope(property, symbol);

            else
                let is_assignable = !property.read_body? || property.assign_argument?;
                let is_private: bool;

                if property.name.name.starts_with('_') then
                    is_private = !property.modifiers.is_public;
                else
                    is_private = property.modifiers.is_private;
                fi

                let symbol = current_declaration_context.declare_property(property.name.location, property.name.name, is_static, is_private, is_assignable, _symbol_definition_listener);

                if property.read_body == null && property.assign_body == null then
                    current_declaration_context.declare_variable(
                        property.name.location, 
                        "$" + property.name.name,
                        is_static, 
                        _symbol_definition_listener);
                fi

                associate_node_with_scope(property, symbol);
            fi

            return true;
        si

        pre(indexer: Definitions.INDEXER) -> bool is
            // ???

            return true;
        si

        visit(variable: Variables.Variable) is
            current_declaration_context.declare_variable(variable.name.location, variable.name.name, variable.is_static, _symbol_definition_listener);
        si

        visit(variable: Expressions.VARIABLE) is
        si

        pre(if_branch: Statements.IF_BRANCH) -> bool is
            create_and_enter_block_scope(if_branch);
        si

        visit(if_branch: Statements.IF_BRANCH) is
            leave_scope(if_branch);
        si

        pre(case_: Statements.CASE) -> bool is
            create_and_enter_block_scope(case_);
        si

        visit(case_: Statements.CASE) is
            leave_scope(case_);
        si

        pre(case_match: Statements.CASE_MATCH) -> bool is
            create_and_enter_block_scope(case_match);
        si

        visit(case_match: Statements.CASE_MATCH) is
            leave_scope(case_match);
        si

        pre(try_: Statements.TRY) -> bool is
            create_and_enter_block_scope(try_);
        si

        visit(try_: Statements.TRY) is
            leave_scope(try_);
        si

        pre(catch_: Statements.CATCH) -> bool is
            create_and_enter_block_scope(catch_);
        si

        visit(catch_: Statements.CATCH) is
            leave_scope(catch_);
        si

        pre(do_: Statements.DO) -> bool is
            create_and_enter_block_scope(do_);
        si

        visit(do_: Statements.DO) is
            leave_scope(do_);
        si

        pre(for_: Statements.FOR) -> bool is
            create_and_enter_block_scope(for_);
        si

        visit(for_: Statements.FOR) is
            leave_scope(for_);
        si

        pre(labelled: Statements.LABELLED) -> bool is
            current_declaration_context.declare_label(labelled.label.location, labelled.label.name, _symbol_definition_listener);
        si

        visit(labelled: Statements.LABELLED) is
        si

        pre(body: Bodies.Body) -> bool is
            create_and_enter_block_scope(body);
        si

        visit(body: Bodies.Body) is
            leave_scope(body);
        si

        pre(tuple: Expressions.TUPLE) -> bool is
        si

        pre(variable: Expressions.VARIABLE) -> bool is
            current_declaration_context.declare_variable(variable.name.location, variable.name.name, false, _symbol_definition_listener);
        si

        pre(function: Expressions.FUNCTION) -> bool is
            let closure = current_function.declare_closure(
                function.location, 
                next_anon_name(),
                // FIXME: only correct for closures in methods - closures within a global function will not have a class/trait/struct owner:
                current_instance_context, 
                current_scope,
                _symbol_definition_listener
            );

            associate_and_enter_scope(
                function,
                closure
            );

            return true;
        si

        visit(function: Expressions.FUNCTION) is
            let symbol = symbol_for(function);

            if symbol? && isa Semantic.Symbols.Function(symbol) then
                let function_symbol = cast Semantic.Symbols.Function(symbol);

                function_symbol.start_declaring_arguments();
                function.arguments.walk(self);
                function_symbol.end_declaring_arguments();                    
            fi
        
            if function.body? then
                function.body.walk(self);
            fi

            leave_scope(function);
        si        

        pre(expression: Bodies.EXPRESSION) -> bool is
            create_and_enter_block_scope(expression);
        si

        visit(expression: Bodies.EXPRESSION) is
            leave_scope(expression);
        si

        pre(block: Bodies.BLOCK) -> bool is
            create_and_enter_block_scope(block);
        si

        visit(block: Bodies.BLOCK) is
            leave_scope(block);
        si
    si
si