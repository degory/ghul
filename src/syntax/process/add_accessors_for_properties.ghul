namespace Syntax.Process is
    use IO.Std;
    
    use Source;
    use Trees;

    class ADD_ACCESSORS_FOR_PROPERTIES: Visitor is
        _stub_depth: int;
        _stack: Collections.STACK[Definitions.LIST];

        enclosing_definition: Definitions.LIST => _stack.peek();

        init() is
            super.init();

            _stack = new Collections.STACK[Definitions.LIST]();
        si

        apply(root: Node) is
            root.walk(self);
        si

        // FIXME: #500 Pragma handling code is duplicated across multiple visitors
        pre(pragma: Definitions.PRAGMA) -> bool is
            if !pragma.pragma? then
                Std.error.write_line("pragma is null");
                return false;
            fi

            let p = pragma.pragma;

            let name = p.name.to_string();

            if name =~ "IL.stub" then
                _stub_depth = _stub_depth + 1;
            fi
        si

        visit(pragma: Definitions.PRAGMA) is
            if !pragma.pragma? then
                Std.error.write_line("pragma is null");
                return;
            fi

            let p = pragma.pragma;

            let name = p.name.to_string();

            if name =~ "IL.stub" then
                _stub_depth = _stub_depth - 1;
            fi            
        si

        pre(property: Definitions.PROPERTY) -> bool is
            if
                !property.is_poisoned /\ (
                    !property.name.name.starts_with('_') \/
                    property.read_body? \/
                    property.assign_body?
                )
            then
                let is_assignable = !property.read_body? \/ property.assign_argument?;

                add_accessor_functions_for_property(property, is_assignable);
            fi

            return true;
        si

        add_accessor_functions_for_property(property: Definitions.PROPERTY, is_assignable: bool) is
            let read_name =
                new Identifiers.Identifier(
                    property.name.location,
                    "$get_{property.name.name}"
                );

            property.is_auto_property =
                _stub_depth == 0 /\
                !property.read_body? /\
                !property.assign_body? /\
                !property.name.name.starts_with('_') /\
                !property.modifiers.is_private;

            let backing_variable_name = "${property.name.name}";

            let assign_argument_name = "$$value";

            if property.assign_argument != null then
                assign_argument_name = property.assign_argument.name;
            fi

            if property.is_auto_property then
                enclosing_definition.add(
                    new Variables.Variable(
                        property.name.location,
                        new Identifiers.Identifier(
                            LOCATION.internal,
                            backing_variable_name
                        ),
                        property.type_expression.copy(),
                        property.modifiers.is_static,
                        null
                    )
                );

                property.read_body =
                    new Trees.Bodies.BLOCK(property.location,
                        new Trees.Statements.LIST(property.location,
                            new Collections.LIST[Statements.Statement]([
                                new Trees.Statements.RETURN(property.location,
                                    new Trees.Expressions.IDENTIFIER(property.location,
                                        new Trees.Identifiers.Identifier(property.location, backing_variable_name)
                                    )
                                )
                            ]: Statements.Statement)
                        )
                    );

                property.assign_body =
                    new Trees.Bodies.BLOCK(property.location,
                        new Trees.Statements.LIST(property.location,
                            new Collections.LIST[Statements.Statement]([
                                new Trees.Statements.ASSIGNMENT(property.location,
                                    new Trees.Expressions.IDENTIFIER(property.location,
                                        new Trees.Identifiers.Identifier(property.location, backing_variable_name)
                                    ),
                                    new Trees.Expressions.IDENTIFIER(property.location,
                                        new Trees.Identifiers.Identifier(property.location, assign_argument_name)
                                    )                                        
                                )
                            ]: Statements.Statement)
                        )
                    );
            fi

            let read_function = new Definitions.FUNCTION(
                property.location,
                read_name,
                null,
                new Variables.LIST(property.name.location, new Collections.LIST[Variables.Variable](0)),
                property.type_expression.copy(),
                property.modifiers.copy(),
                property.read_body
            );

            read_function.for_property = property;

            enclosing_definition.add(
                read_function
            );

            property.read_function = read_function;

            if is_assignable \/ property.is_auto_property then
                let assign_name =
                    new Identifiers.Identifier(
                        property.name.location,
                        "$set_{property.name.name}"
                    );                

                if !property.assign_argument? then
                    property.assign_argument = new Identifiers.Identifier(property.location, "$$value");
                fi

                let assign_function = new Definitions.FUNCTION(
                    property.name.location,
                    assign_name,
                    null,
                    new Variables.LIST(LOCATION.internal, new Collections.LIST[Syntax.Trees.Variables.Variable]([
                        new Variables.Variable(
                            property.assign_argument.location,
                            property.assign_argument,
                            property.type_expression.copy(),
                            false,
                            null
                        )
                    ])),
                    new TypeExpressions.NAMED(
                        LOCATION.internal,
                        new Identifiers.Identifier(
                            LOCATION.internal,
                            "void"
                        )
                    ),
                    property.modifiers.copy(),
                    property.assign_body
                );

                assign_function.for_property = property;

                enclosing_definition.add(
                    assign_function
                );

                property.assign_function = assign_function;
            fi
        si

        visit(property: Definitions.PROPERTY) is
        si

        pre(indexer: Definitions.INDEXER) -> bool is
            let name: string;
            let location: LOCATION;

            if indexer.name? then
                name = indexer.name.name;
                location = indexer.name.location;
            else
                name = "Item";
                location = indexer.location;
            fi

            if indexer.read_body? then
                enclosing_definition.add(
                    new Definitions.FUNCTION(
                        indexer.location,
                        new Identifiers.Identifier(
                            location,
                            "get_{name}"
                        ),
                        null,
                        new Variables.LIST(
                            LOCATION.internal, new Collections.LIST[Syntax.Trees.Variables.Variable]([indexer.index_argument.copy()])),                        
                        indexer.type_expression.copy(),
                        indexer.modifiers.copy(),
                        indexer.read_body
                    )
                );
            fi

            if indexer.assign_body? then
                enclosing_definition.add(
                    new Definitions.FUNCTION(
                        indexer.location,
                        new Identifiers.Identifier(
                            location,
                            "set_{name}"
                        ),
                        null,
                        new Variables.LIST(LOCATION.internal, new Collections.LIST[Syntax.Trees.Variables.Variable]([
                            indexer.index_argument.copy(),
                            new Variables.Variable(
                                indexer.assign_argument.location,
                                indexer.assign_argument.copy(),                                
                                indexer.type_expression.copy(),
                                false,
                                null
                            )
                        ])),
                        new TypeExpressions.NAMED(
                            LOCATION.internal,
                            new Identifiers.Identifier(
                                LOCATION.internal,
                                "void"
                            )
                        ),
                        indexer.modifiers.copy(),
                        indexer.assign_body
                    )
                );
            fi
                       
            return true;
        si

        pre(`class: Definitions.CLASS) -> bool is
            _stack.push(`class.body);

            return false;
        si

        visit(`class: Definitions.CLASS) is
            _stack.pop();
        si

        pre(`trait: Definitions.TRAIT) -> bool is
            _stack.push(`trait.body);

            return false;
        si

        visit(`trait: Definitions.TRAIT) is
            _stack.pop();
        si

        pre(`struct: Definitions.STRUCT) -> bool is
            _stack.push(`struct.body);

            return false;
        si

        visit(`struct: Definitions.STRUCT) is
            _stack.pop();
        si        

        pre(`namespace: Definitions.NAMESPACE) -> bool is
            _stack.push(`namespace.body);

            return false;
        si

        visit(`namespace: Definitions.NAMESPACE) is
            _stack.pop();
        si        
    si
si
