namespace Syntax.Process is
    use Source;
    use Trees;

    class EXPAND_NAMESPACES: Visitor is
        _depth: int;

        init() is
            super.init();
        si

        apply(node: Node) is
            assert isa Definitions.LIST(node) else "expected the root syntax tree node of file to be a definition list";

            let list = cast Definitions.LIST(node);

            let seen_any_namespaces = false;
            let seen_any_other_definitions = false;

            for definition in list do
                if isa Definitions.NAMESPACE(definition) then
                    seen_any_namespaces = true;
                elif !isa Definitions.PRAGMA(definition) then
                    seen_any_other_definitions = true;
                fi
            od
            
            if seen_any_namespaces /\ seen_any_other_definitions then
                let logger = IoC.CONTAINER.instance.logger;

                for definition in list do
                    if 
                        !isa Definitions.NAMESPACE(definition) /\ 
                        !isa Definitions.Classy(definition) /\
                        !isa Definitions.PRAGMA(definition)
                    then
                        logger.error(definition.location, "cannot mix global definitions and namespaces in the same file");                        
                    fi
                od
            elif seen_any_other_definitions then
                let path = list | .first().value.location.file_name;

                let root_namespace_name = get_namespace_name(path);

                let new_definitions = new Collections.LIST[Definitions.Definition](
                    list
                );

                let root_namespace = 
                    new Definitions.NAMESPACE(
                        list.location,
                        new Trees.Identifiers.Identifier(Source.LOCATION.internal, root_namespace_name),
                        new Definitions.LIST(list.location, new_definitions)
                    );

                list.clear();

                list.add(root_namespace);
            fi

            node.walk(self);
        si

        convert_file_name_to_identifier(name: string) -> string is
            name = 
                name
                    .replace('-', '_')
                    .replace('.', '_') |
                    .filter(c: char => char.is_letter_or_digit(c) \/ c == '_')
                    .to_string("");
            
            if !char.is_letter(name.get_chars(0)) then
                name = "`" + name;
            fi

            return name;
        si
        
        get_namespace_name(path: string) -> string is
            if path.starts_with("file://") then
                path = path.substring(7);
            fi

            let result = 
                convert_file_name_to_identifier(
                    IO.Path.get_file_name_without_extension(path)
                );

            let folder = IO.Path.get_directory_name(path);

            return get_namespace_name_for_folder(folder) + result;
        si

        get_namespace_name_for_folder(path: string) -> string is
            if !path? \/ path =~ "" then
                path = IO.Directory.get_current_directory();
            fi

            let info = new IO.DirectoryInfo(path);

            return get_namespace_name_for_folder(info);            
        si        

        get_namespace_name_for_folder(info: IO.DirectoryInfo) -> string is
            let result = convert_file_name_to_identifier(info.name) + "__";

            if IO.File.exists(info.to_string() + "/ghul.json") \/ IO.Directory.get_files(info.to_string(), "*.ghulproj").count > 0 then
                return result;                
            fi

            if info.parent? then
                result = get_namespace_name_for_folder(info.parent) + result;                
            fi

            return result;
        si

        pre(`namespace: Definitions.NAMESPACE) -> bool is
            _depth = _depth + 1;
        si

        visit(`namespace: Definitions.NAMESPACE) is
            let names = `namespace.name.qualifier_names;

            if _depth == 1 then
                `namespace.body.push(
                    new Definitions.USE(
                        Source.LOCATION.internal,
                        null,
                        new Identifiers.Identifier(
                            LOCATION.internal,
                            "Ghul"
                        )
                    )
                );
            fi

            if names.count > 0 then
                `namespace.name = new Identifiers.Identifier(`namespace.name.location, `namespace.name.name);
                let body = `namespace.body;
                let current = `namespace;
                
                for n in names do
                    current.body = 
                        new Definitions.LIST(
                            current.location, 
                            new Collections.LIST[Definitions.Definition](
                                [new Definitions.NAMESPACE(current.location, current.name, current.body)]: Definitions.Definition
                            )
                        );
                    current.name = new Identifiers.Identifier(`namespace.name.location, n);
                od
            fi

            _depth = _depth - 1;
        si
    si
si
