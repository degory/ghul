namespace Syntax.Process is
    use System.Exception;

    use IO.Std;
        
    use Logging;
    use Source;

    use IR.Values;
    use IR.VALUE_CONVERTER;

    use Semantic.Types.Type;

    use Syntax.Trees.Definitions.PRAGMA;

    class COMPILE_EXPRESSIONS: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Types.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;
        _value_converter: VALUE_CONVERTER;

        _partial_argument_types: Collections.MAP[Trees.Node, Type];

        _will_generate_code: bool;

        _search_type: Semantic.Types.NAMED;

        _stub_depth: int;
        _keep_depth: int;

        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            value_converter: VALUE_CONVERTER
        )
        is
            super.init(logger, stable_symbols, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _innate_symbol_lookup = innate_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;
            _value_converter = value_converter;
        si

        apply(root: Trees.Node) is
            assert _keep_depth == 0;
            assert _stub_depth == 0;

            _will_generate_code = IoC.CONTAINER.instance.build_flags.want_assembler;
            _partial_argument_types = new Collections.MAP[Trees.Node, Type]();

            root.walk(self);

            assert _keep_depth == 0;
            assert _stub_depth == 0;
        si

        should_skip(node: Trees.Node) -> bool => _stub_depth > 0 \/ is_stable(node);

        get_zero_argument_function(type: Type, name: string) -> Semantic.Symbols.Function is
            let symbol = type.find_member(name);

            if symbol? /\ isa Semantic.Symbols.FUNCTION_GROUP(symbol) then
                let function_group = cast Semantic.Symbols.FUNCTION_GROUP(symbol);

                for f in function_group.functions do
                    if f.arguments.count == 0 then
                        return f;
                    fi
                od
            fi
        si

        set_iterator_for(`for: Trees.Statements.FOR, type: Type, recursing: bool) -> bool is
            if !type? then
                return false;
            fi

            let move_next = get_zero_argument_function(type, "move_next");

            let next_element = get_zero_argument_function(type, "nextElement");
            
            if move_next? then
                let read_current = get_zero_argument_function(type, "$get_current");

                if !read_current? then
                    read_current = get_zero_argument_function(type, "$get_Current");                    
                fi
                
                if !read_current? then
                    _logger.error(`for.expression.location, "incomplete iterator type (has move_next method but no current property)");
                    return false;
                fi

                `for.move_next = move_next;
                `for.read_current = read_current;

                return true;
            elif next_element? then
                // FIXME
                `for.read_current = next_element;

                return true;
            elif !recursing then
                let read_iterator = get_zero_argument_function(type, "$get_iterator");

                if read_iterator? then
                    `for.read_iterator = read_iterator;

                    return set_iterator_for(`for, read_iterator.return_type, true);
                fi
            fi
            
            _logger.error(`for.expression.location, "not iterable");

            return false;
        si

        // FIXME: #500 Pragma handling code is duplicated across multiple visitors
        pre(pragma: Trees.Definitions.PRAGMA) -> bool is
            if !pragma.pragma? then
                return false;
            fi

            let p = pragma.pragma;

            let name = p.name.to_string();

            if name =~ "IL.stub" then
                _stub_depth = _stub_depth + 1;
            elif name =~ "KEEP" then
                _keep_depth = _keep_depth + 1;
            fi
        si

        visit(pragma: Trees.Definitions.PRAGMA) is
            if !pragma.pragma? then
                return;
            fi

            let p = pragma.pragma;

            let name = p.name.to_string();

            if name =~ "IL.stub" then
                _stub_depth = _stub_depth - 1;
            elif name =~ "KEEP" then
                _keep_depth = _keep_depth - 1;
            fi
        si

        pre(`namespace: Trees.Definitions.NAMESPACE) -> bool is
            super.pre(`namespace);
            return _stub_depth > 0;
        si

        pre(`class: Trees.Definitions.CLASS) -> bool is
            super.pre(`class);
            return should_skip(`class);
        si

        pre(`trait: Trees.Definitions.TRAIT) -> bool is
            super.pre(`trait);
            return should_skip(`trait);            
        si        

        pre(`struct: Trees.Definitions.STRUCT) -> bool is
            super.pre(`struct);
            return should_skip(`struct);            
        si

        pre(`for: Trees.Statements.FOR) -> bool is
            super.pre(`for);

            try
                _pre(`for);
            catch ex: Exception
                _logger.exception(`for.location, ex, "exception compiling for");
            yrt
            
            return true;
        si
        
        _pre(`for: Trees.Statements.FOR) -> bool is
            if !`for.expression? \/ !`for.variable? then
                _logger.error(`for.location, "incomplete for statement");
            fi

            let symbol = find(`for.variable.name);

            symbol.define();

            `for.expression.walk(self);

            if symbol? /\ isa Semantic.Types.SettableTyped(symbol) then
                let typed_symbol = cast Semantic.Types.SettableTyped(symbol);

                let type: Type;

                if set_iterator_for(`for, `for.expression.value.type, false) then
                    if `for.variable.type_expression? /\ !isa Trees.TypeExpressions.INFER(`for.variable.type_expression) then
                        if !`for.variable.type_expression.type.is_assignable_from(`for.read_current.return_type) then
                            _logger.error(`for.variable.location, "type mismatch");
                        fi
                        
                    elif `for.variable.initializer? then
                        _logger.error(`for.variable.initializer.location, "cannot initialize variable here");
                    elif !`for.expression? then
                        _logger.error(`for.location, "expression expected");
                    else
                        typed_symbol.set_type(`for.read_current.return_type);
                    fi
                fi
            else
                _logger.poison(`for.variable.name.location, "couldn't find typed symbol for variable " + `for.variable.name);
            fi

            `for.body.walk(self);            
        si
        
        pre(assignment: Trees.Statements.ASSIGNMENT) -> bool is
            assignment.right.walk(self);

            if assignment.right.value? then
                assignment.left.value = new Need.STORE(assignment.right.value);

                assignment.left.walk(self);
            else
                assignment.left.value = null;
                return true;
            fi

            if !assignment.left.value? \/ !assignment.left.value.type? \/ !assignment.right.value.type? then
                return true;
            fi

            if !assignment.left.value.type.is_assignable_from(assignment.right.value.type) then
                _logger.error(assignment.location, "" + assignment.right.value.type + " is not assignable to " + assignment.left.value.type);
            fi

            return true;
        si

        visit(r: Trees.Statements.RETURN) is
            super.visit(r);

            let function = current_function;

            if !function? \/ !function.return_type? then
                // FIXME: null function happens for properties, null return type happens for anonymous functions
                return;
            fi

            if r.expression? then
                if
                    r.expression.value? /\
                    r.expression.value.type?
                then
                    if function.return_type.is_any then
                        function.set_return_type(r.expression.value.type);                
                    elif function.return_type =~ _innate_symbol_lookup.get_void_type() /\ !function.return_type.is_type_variable then
                        _logger
                            .error(
                                r.expression.location,
                                "cannot return value from function of void type"
                                );                        
                    elif !function.return_type.is_assignable_from(r.expression.value.type) then
                        _logger
                            .error(
                                r.expression.location,
                                "cannot return value of type " + r.expression.value.type + " from function of type " + function.return_type
                            );
                    fi

                    return;
                fi
            else
                if function.return_type !~ _innate_symbol_lookup.get_void_type() then
                    _logger
                        .warn(
                            r.location,
                            "return without value from non void function returns default value of type " + function.return_type
                        );
                fi
            fi
        si

        visit(`throw: Trees.Statements.THROW) is
            super.visit(`throw);

            if !`throw.expression.value? \/ !`throw.expression.value.type? then
                return;
            fi

            let exception_type = _innate_symbol_lookup.get_exception_type();

            if !exception_type.is_assignable_from(`throw.expression.value.type) then
                _logger.warn(`throw.expression.location, "thrown value is not derived from System.Exception");
            fi
        si

        visit(`assert: Trees.Statements.ASSERT) is
            super.visit(`assert);

            if !`assert.expression.value? \/ !`assert.expression.value.type? then
                return;
            fi

            if
                !_innate_symbol_lookup
                    .get_bool_type()
                    .is_assignable_from(`assert.expression.value.type)
            then
                _logger.error(`assert.expression.location, "assertion expression must be bool");
            fi

            if `assert.message? /\ `assert.message.value? /\ `assert.message.value.type? then
                if !_innate_symbol_lookup
                    .get_exception_type()
                    .is_assignable_from(`assert.expression.value.type)
                then
                    `assert.needs_exception_wrapper = true;
                elif 
                    !_innate_symbol_lookup
                        .get_string_type()
                        .is_assignable_from(`assert.expression.value.type)
                then
                    _logger.error(`assert.message.location, "assertion else must be string or System.Exception");
                fi
            fi
        si

        visit(`try: Trees.Statements.TRY) is
            super.visit(`try);

            if
                (!`try.catches? \/ `try.catches.count == 0) /\
                !`try.`finally?    
            then
                _logger.error(`try.location, "try statement must have at least one catch clause and/or a finally clause");
            fi
        si
        
        visit(`catch: Trees.Statements.CATCH) is
            super.visit(`catch);

            if !`catch.variable? \/ !`catch.variable.type_expression? then
                return;
            fi
            
            let type = `catch.variable.type_expression.type;

            if !type? then
                return;
            fi

            let exception_type = _innate_symbol_lookup.get_exception_type();

            if !exception_type.is_assignable_from(type) then
                _logger.error(`catch.variable.type_expression.location, "cannot catch " + type + " because it does not derive from System.Exception");
            fi
        si

        pre(expression: Trees.Bodies.EXPRESSION) -> bool is
            super.pre(expression);
        si

        visit(expression: Trees.Bodies.EXPRESSION) is
            let function = current_function;

            if
                !function? \/
                !function.return_type? \/
                !expression.expression? \/
                !expression.expression.value? \/
                !expression.expression.value.type?
            then
                super.visit(expression);

                return;
            fi

            if function.return_type.is_any then
                function.set_return_type(expression.expression.value.type);
            elif function.return_type =~ _innate_symbol_lookup.get_void_type() /\ !function.return_type.is_type_variable then
                _logger
                    .error(
                        expression.location,
                        "cannot return value from function of void type"
                    );                        
            elif !function.return_type.is_assignable_from(expression.expression.value.type) then
                _logger
                    .error(
                        expression.location,
                        "cannot return value of type " + expression.expression.value.type + " from function of type " + function.return_type
                    );
            fi

            super.visit(expression);
        si
        
        pre(function: Trees.Expressions.FUNCTION) -> bool is
            super.pre(function);

            return true;
        si

        visit(function: Trees.Expressions.FUNCTION) is
            let closure = cast Semantic.Symbols.Closure(scope_for(function));

            let owning_class = _symbol_table.current_instance_context;

            let implied_type: Type;
            let implied_argument_types: Collections.List[Type];

            if _partial_argument_types.try_get_value(function, implied_type ref) then
                implied_argument_types = implied_type.arguments;
            fi

            owning_class.add_closure(closure);

            let argument_names = new Collections.LIST[string]();
            let argument_types = new Collections.LIST[Type]();

            let any_errors: bool;

            let arguments = function.arguments.expressions;

            for index in 0..arguments.count do
                let a = arguments[index];
                
                if isa Trees.Expressions.VARIABLE(a) then
                    let argument = cast Trees.Expressions.VARIABLE(a);

                    argument_names.add(argument.name.name);
                    let partial_argument_type: Type;

                    if !isa Trees.TypeExpressions.INFER(argument.type_expression) then
                        argument_types.add(argument.type_expression.type);
                    elif implied_argument_types? then
                        let implied_argument_type = implied_argument_types[index];

                        if implied_argument_type? /\ !implied_argument_type.is_type_variable then
                            argument_types.add(implied_argument_type);

                            let symbol = cast Semantic.Symbols.Variable(closure.find_direct(argument.name.name));

                            symbol.set_type(implied_argument_type);
                        else
                            _logger.error(a.location, "could not infer type here");
                            argument_types.add(new Semantic.Types.ANY());    
                        fi

                    else
                        _logger.error(a.location, "cannot infer type here");
                        argument_types.add(new Semantic.Types.ANY());
                    fi
                else
                    _logger.error(a.location, "unexpected kind of argument (" + a.get_type() + ")");
                    any_errors = true;
                fi

                index = index + 1;
            od
            
            if !any_errors then
                closure.arguments = new Collections.LIST[Type](argument_types);

                let return_type: Type;

                if function.type_expression.type? then  
                    return_type = function.type_expression.type;
                else
                    return_type = new Semantic.Types.ANY();
                fi

                argument_types.add(return_type);

                closure.argument_names = argument_names;

                let t = cast Semantic.Symbols.Function(closure);
                t.type = _innate_symbol_lookup.get_function_type(argument_types);

                closure.return_type = return_type;
            fi

            function.body.walk(self);

            if _will_generate_code /\ !any_errors /\ closure.could_be_delegate then
                closure.convert_to_delegate();

                function.body.walk(self);
            fi

            let value = closure.load(function.location, _symbol_loader);

            if _will_generate_code /\ function.value? then
                // FIXME: have to update in place, otherwise the parent IR value tree node that
                // references this will continue to point at the stale value:
                function.value.copy_from(value);
            else
                function.value = value;
            fi

            super.visit(function);
        si

        visit(tuple: Trees.Expressions.TUPLE) is
            let names = new Collections.LIST[string]();
            let values = new Collections.LIST[Value]();
            let types = new Collections.LIST[Type]();

            if tuple.elements.expressions.count == 1 then
                tuple.value = tuple.elements.expressions[0].value;
                return;
            fi            

            let seen_any_named = false;

            for iv in tuple.elements | .index() do
                let index = iv.index;
                let v = iv.value;

                if isa Trees.Expressions.TUPLE_ELEMENT(v) then
                    let element = cast Trees.Expressions.TUPLE_ELEMENT(v);

                    if element.initializer? /\ element.initializer.value? then
                        seen_any_named = true;
                        names.add(element.name.name);
                        values.add(element.initializer.value);
                        types.add(element.initializer.value.type);
                    else
                        return;
                    fi  
                elif v.value? /\ v.value.type? then
                    names.add("_" + index);
                    values.add(v.value);
                    types.add(v.value.type);
                else
                    return;
                fi
            od

            if !seen_any_named then
                names = null;
            fi            

            let type = _innate_symbol_lookup.get_tuple_type(types, names);
                        
            tuple.value = new TUPLE(type, values);
        si

        visit(sequence: Trees.Expressions.SEQUENCE) is
            let type: Type;
            let have_explicit_type: bool;

            let elements = new Collections.LIST[Trees.Expressions.Expression](sequence.elements);

            if sequence.type_expression? /\ !isa Trees.TypeExpressions.INFER(sequence.type_expression) then
                if sequence.type_expression.type? then
                    type = sequence.type_expression.type;

                    have_explicit_type = true;
                else
                    _logger.error(sequence.type_expression.location, "bad explicit type expression");
                    return;
                fi
            elif elements.count == 0 then
                _logger.error(sequence.location, "cannot infer type of list literal with no elements");

                return; 
            else
                // FIXME: this is assuming the type of the sequence is the type of its first element
                // should be the most specific type that is assignable from all element types

                let seen_any = false;

                for v in elements do
                    if v.value? /\ v.value.type? then
                        seen_any = true;

                        if !type? then
                            type = v.value.type;
                        elif v.value.type.is_assignable_from(type) then
                            type = v.value.type;
                        elif !type.is_assignable_from(v.value.type) then
                            type = _innate_symbol_lookup.get_object_type();
                            @IF.not.release() _logger.info(sequence.location, "inferring object element type");
                            break;
                        fi
                    fi
                od

                if type == null then
                    if seen_any then
                        _logger.error(sequence.location, "cannot infer type of list literal with only null elements");
                    fi
                    
                    return;
                fi
            fi

            let values = new Collections.LIST[Value](sequence.elements.expressions.count);
            
            for v in sequence.elements do
                if v.value? /\ v.value.type? then
                    let u = v.value.type;
                    if have_explicit_type /\ !type.is_assignable_from(v.value.type) then
                        _logger.error(v.location, "element not compatible with explicit type");
                    fi

                    values.add(v.value);
                else
                    values.add(new DUMMY(new Semantic.Types.ANY(), v.location));
                fi
            od
                        
            sequence.value = 
                new SEQUENCE(_innate_symbol_lookup.get_array_type(type), type, values);
        si        

        visit(`self: Trees.Expressions.SELF) is
            let s = current_instance_context;

            let type: Type;

            if s? then
                let f = current_function;
                
                if !f? \/ !f.is_instance then
                    _logger.error(`self.location, "cannot access self from non-instance context");
                fi

                if s.argument_names.count > 0 then
                    let arguments = new Collections.LIST[Type]();

                    for n in s.argument_names do
                        let argument = s.find_member(n);

                        if argument? /\ isa Semantic.Symbols.TYPE(argument) then
                            arguments.add(cast Semantic.Symbols.TYPE(argument).type);
                        fi
                    od
                    
                    if arguments.count == s.argument_names.count then
                        type = new Semantic.Types.GENERIC(
                            `self.location,
                            cast Semantic.Symbols.Classy(s),
                            arguments);
                    fi
                fi

                `self.value =
                    new Load.SELF(
                        s, type
                    );

                _symbol_use_locations.add_symbol_use(`self.location, s);
            else
                _logger.error(`self.location, "cannot access self from non-instance context");
            fi
        si

        visit(`super: Trees.Expressions.SUPER) is
            // FIXME:
            let s = _symbol_table.current_instance_context;

            if s? then
                if s.is_trait then
                    _logger.error(`super.location, "trait " + s.description + " does not have a super class");
                    
                    return;
                fi
                
                `super.value =
                    new Load.SUPER(
                        s, cast Semantic.Symbols.Classy(s).ancestors[0]
                    );

                _symbol_use_locations.add_symbol_use(`super.location, s);
            fi
        si

        visit(`cast: Trees.Expressions.CAST) is
            `cast.value = null;

            let type = `cast.type_expression.type;

            if !type? then
                _logger.error(`cast.type_expression.location, "cast has no type");                
                return;
            fi

            if !`cast.right.value? then
                _logger.poison(`cast.right.location, "cast has no value");

                `cast.value =
                    new DUMMY(
                        type,
                        `cast.right.location
                    );

                return;
            fi

            // type = type.specialize(_generic_cache);

            if type.is_value_type /\ `cast.right.value.type.is_value_type then
                let instruction = _value_converter.get_instruction(type);

                if !instruction? then
                    let left_type_symbol = type.symbol;
                    let right_type_symbol = `cast.right.value.type.symbol;

                    if 
                        !isa Semantic.Symbols.ENUM_(left_type_symbol) /\
                        !isa Semantic.Symbols.ENUM_(right_type_symbol)
                    then
                        _logger.warn(`cast.location, "cannot convert " + `cast.right.value.type + " to " + `cast.type_expression.type);
                    fi

                    `cast.value =
                        new CONVERT(
                            type,
                            `cast.right.value,
                            "conv.i4"
                        );                    
               else
                    `cast.value =
                        new CONVERT(
                            type,
                            `cast.right.value,
                            instruction
                        );                    
                fi
                
                return;
            fi
            
            if type.is_value_type then
                `cast.value =
                    new TYPE_WRAPPER(
                        type,
                        new UNBOX(
                            `cast.right.value
                        )
                    );

                return;
            fi
            
            `cast.value =
                new CAST(
                    type,
                    `cast.right.value
                );
        si

        visit(`isa: Trees.Expressions.ISA) is
            `isa.value = null;

            let isa_type = `isa.type_expression.type;

            if isa_type == null then
                _logger.error(`isa.type_expression.location, "isa has no type");
                return;
            fi

            let bool_type = _innate_symbol_lookup.get_bool_type();

            `isa.value =
                new ISA(
                    bool_type,
                    isa_type,                     
                    `isa.right.value
                );
        si

        visit(`typeof: Trees.Expressions.TYPEOF) is
            `typeof.value = null;

            let typeof_type = `typeof.type_expression.type;

            if !typeof_type? then
                _logger.error(`typeof.type_expression.location, "typeof has no type");
                return;
            fi

            let type_type = _innate_symbol_lookup.get_type_type();

            `typeof.value =
                new TYPEOF(
                    type_type,
                    typeof_type
                );
        si

        visit(`new: Trees.Expressions.NEW) is
            `new.value = null;

            let type = `new.type_expression.type;

            if type == null then     
                _logger.poison(`new.type_expression.location, "new has no type");
                return;
            fi

            // type = type.specialize(_generic_cache);

            if !isa Semantic.Types.NAMED(type) then
                _logger.error(`new.type_expression.location, "cannot instantiate this: " + type);
                return;
            fi

            let named_type = cast Semantic.Types.NAMED(type);
            let type_symbol = named_type.symbol;

            let symbol = named_type.scope.find_direct("init");

            let function_group = cast Semantic.Symbols.FUNCTION_GROUP(symbol);

            let arguments = new Collections.LIST[Value]();
            let argument_types = new Collections.LIST[Type]();

            for a in `new.arguments do
                if a? /\ a.value? /\ a.value.type? then
                    arguments.add(a.value);
                    argument_types.add(a.value.type);                    
                else
                    let t = new Semantic.Types.ANY();

                    if a? then
                        arguments.add(new DUMMY(type, a.location));
                    else
                        arguments.add(new DUMMY(type, `new.arguments.location));
                    fi
                    
                    argument_types.add(t);
                fi
            od

            if !function_group? then
                `new.value =
                    new DUMMY(
                        type,
                        `new.location
                    );

                _logger.error(`new.location, "no constructor found init(" + argument_types| + ")");                

                return;
            fi

            let overload_result = _overload_resolver.resolve(`new.location, function_group, argument_types, false);

            if overload_result == null then
                `new.value =
                    new DUMMY(
                        type,
                        `new.location
                    );
    
                return;
            fi

            let function = overload_result.function;

            let is_directly_owned = false;

            if isa Semantic.Symbols.GENERIC(type_symbol) /\ isa Semantic.Symbols.Symbol(function.owner) then
                is_directly_owned = cast Semantic.Symbols.GENERIC(type_symbol) =~ cast Semantic.Symbols.Symbol(function.owner);
            else
                is_directly_owned = type_symbol == function.owner;
            fi
            
            if !is_directly_owned then
                _logger.error(`new.location, "cannot call superclass constructor " + function);
            fi
            
            _symbol_use_locations.add_symbol_use(`new.type_expression.location, function);

            `new.value =
                new NEW(
                    type,
                    function,
                    arguments
                );
        si

        visit(unary: Trees.Expressions.UNARY) is
            unary.value = null;

            if unary.right.value? then
                let arguments = new Collections.LIST[Type]([unary.right.value.type]);

                let function_group = find(unary.operation);

                if function_group == null \/ !isa Semantic.Symbols.FUNCTION_GROUP(function_group) then
                    return;
                fi

                let overload_result =
                    _overload_resolver.resolve(
                        unary.location,
                        cast Semantic.Symbols.FUNCTION_GROUP(function_group),
                        arguments,
                        false);

                if overload_result == null then
                    return;
                fi

                let function = overload_result.function;

                _symbol_use_locations.add_symbol_use(unary.operation.location, function);

                let value = function.call(unary.location, null, new Collections.LIST[Value]([unary.right.value]), null, _function_caller);

                unary.value = value;
            fi
        si        

        visit(binary: Trees.Expressions.BINARY) is
            try
                _visit(binary);
            catch ex: Exception
                _logger.exception(binary.location, ex, "exception compiling binary operator");
            yrt            
        si

        _visit(binary: Trees.Expressions.BINARY) is
            binary.value = null;

            if !binary.left? \/ !binary.left.value? \/ !binary.right? \/ !binary.right.value? then
                return;                
            fi
            
            let binary_function_group: Semantic.Symbols.FUNCTION_GROUP;
            let binary_overload_result: Semantic.OVERLOAD_RESOLVE_RESULT;
            let binary_errors: (text: string, error_count: int, is_poisoned: bool);

            let binary_name = binary.operation.name.to_string();

            let binary_function_symbol = find(binary.operation.name);

            if binary_function_symbol? /\ isa Semantic.Symbols.FUNCTION_GROUP(binary_function_symbol) then
                binary_function_group = cast Semantic.Symbols.FUNCTION_GROUP(binary_function_symbol);

                _logger.speculate();

                binary_overload_result =
                    _overload_resolver
                        .resolve(
                            binary.location,
                            binary_function_group,
                            new Collections.LIST[Type]([binary.left.value.type, binary.right.value.type]),
                            false
                        );

                binary_errors = _logger.roll_back();
            fi

            let member_overload_result: Semantic.OVERLOAD_RESOLVE_RESULT;
            let member_function_group: Semantic.Symbols.FUNCTION_GROUP;
            let member_errors: (text: string, error_count: int, is_poisoned: bool);

            if binary.left.value.type? then
                let member_function_symbol = 
                    binary.left.value.type.find_member(binary.operation.name);

                if member_function_symbol? /\ isa Semantic.Symbols.FUNCTION_GROUP(member_function_symbol) then
                    member_function_group = cast Semantic.Symbols.FUNCTION_GROUP(member_function_symbol);
    
                    _logger.speculate();

                    member_overload_result = 
                        _overload_resolver
                            .resolve(
                                binary.location,
                                cast Semantic.Symbols.FUNCTION_GROUP(member_function_group),
                                new Collections.LIST[Type]([binary.right.value.type]),
                                false
                            );

                    member_errors = _logger.roll_back();
                fi
            fi

            let function: Semantic.Symbols.Function;

            if member_overload_result? /\ binary_overload_result? then
                if member_overload_result.score <= binary_overload_result.score then
                    function = member_overload_result.function;
                else
                    function = binary_overload_result.function;
                fi              
            elif member_overload_result? then
                function = member_overload_result.function;
            elif binary_overload_result? then
                function = binary_overload_result.function;
            fi
        
            if function? then
                _symbol_use_locations.add_symbol_use(binary.operation.location, function);
                let force_type: Type;
                let want_not = false;
                
                if binary.operation.name =~ "<>" then                        
                    if function.return_type !~ _innate_symbol_lookup.get_int_type() then
                        // FIXME: do this check on the definition:
                        _logger.error(binary.location, "<> order operator must return int");
                    fi

                    // FIXME: for non-innate implementations of <> operator, need to translate the result to bool
                    // based on actual operation

                    force_type = _innate_symbol_lookup.get_bool_type();
                elif binary.operation.name =~ "==" then
                    if 
                        binary.left.value.type.compare(binary.right.value.type) > Semantic.Types.MATCH.ASSIGNABLE /\
                        binary.right.value.type.compare(binary.left.value.type) > Semantic.Types.MATCH.ASSIGNABLE 
                    then
                        if binary.actual_operation =~ "==" then
                            _logger.warn(binary.location, "== applied to values of non-assignable types will always return false");
                        else
                            _logger.warn(binary.location, "!= applied to values of non-assignable types will always return true");
                        fi
                    fi
                elif !function.is_innate /\ binary.actual_operation =~ "!~" then
                    want_not = true;
                fi

                let value: Value;
                
                if function.is_instance then
                    value = function.call(binary.location, binary.left.value, new Collections.LIST[Value]([binary.right.value]), force_type,_function_caller);
                else
                    value = function.call(binary.location, null, new Collections.LIST[Value]([binary.left.value, binary.right.value]), force_type,_function_caller);

                    if isa Call.INNATE(value) then
                        cast Call.INNATE(value).actual_operation = binary.actual_operation;
                    fi
                fi
                
                if want_not then
                    value = new NOT(value);
                fi
                
                binary.value = value;
            else
                if binary_errors.error_count > 0 then
                    _logger.write(binary_errors.text, binary_errors.error_count, binary_errors.is_poisoned);
                fi

                if member_errors.error_count > 0 then
                    _logger.write(member_errors.text, member_errors.error_count, binary_errors.is_poisoned);
                fi

                if binary_errors.error_count == 0 /\ member_errors.error_count == 0 then
                    _logger.error(binary.operation.location, "operator '" + binary.operation + "' not found");
                fi
            fi
        si

        visit(index: Trees.Expressions.INDEX) is
            try
                _visit(index);
            catch e: Exception
                index.value = null;

                _logger.exception(index.location, e, "exception compiling indexer");
            yrt
        si

        _visit(index: Trees.Expressions.INDEX) is
            let need_store = index.value? /\ isa Need.STORE(index.value);

            if index.left.value? /\ index.index.value? then
                let type = index.left.value.type;

                if type == null then
                    _logger.poison(index.left.location, "index left has no type");
                    return;
                fi

                if !isa Semantic.Types.NAMED(type) then
                    _logger.error(index.left.location, "cannot index " + type);
                    return;
                fi

                let named_type = cast Semantic.Types.NAMED(type);

                let function_name: string;
                let arguments: Collections.LIST[Value];
                let argument_types: Collections.LIST[Type];

                if need_store then
                    function_name = "set_Item";

                    let need_store_value = cast Need.STORE(index.value).value;

                    arguments = new Collections.LIST[Value]([index.index.value, need_store_value]);
                    argument_types = new Collections.LIST[Type]([index.index.value.type, need_store_value.type]);
                else
                    function_name = "get_Item";
                    arguments = new Collections.LIST[Value]([index.index.value]);
                    argument_types = new Collections.LIST[Type]([index.index.value.type]);
                fi

                let symbol = named_type.scope.find_member(function_name);

                if symbol == null then
                    if need_store then
                        if named_type.scope.find_member("get_Item")? then
                            _logger.error(index.location, "indexer is read-only in " + type);
                        else
                            _logger.error(index.location, "no indexer found in " + type);
                        fi
                    else
                        _logger.error(index.location, "no indexer found in " + type);
                    fi
                    
                    if isa Semantic.Symbols.GENERIC(named_type.scope) then
                        let g = cast Semantic.Symbols.GENERIC(named_type.scope);
                    fi
                    
                    return;
                fi

                if !isa Semantic.Symbols.FUNCTION_GROUP(symbol) then
                    _logger.poison(index.index.location, "indexer is not a function group: " + symbol);
                fi

                _logger.speculate();

                let overload_result =
                    _overload_resolver.resolve(
                        index.location,
                        cast Semantic.Symbols.FUNCTION_GROUP(symbol),
                        argument_types,
                        false);

                _logger.roll_back();

                if overload_result == null then
                    if need_store then
                        _logger.error(index.location, "indexer [" + argument_types[0] + "] = " + argument_types[1] + " not found in " + type);
                    else
                        _logger.error(index.location, "indexer [" + argument_types[0] + "] not found in " + type);
                    fi

                    return;
                fi

                let function = overload_result.function;

                _symbol_use_locations.add_symbol_use(
                    new LOCATION(
                        index.left.location.file_name,
                        index.left.location.end_line,
                        index.left.location.end_column+1,
                        index.index.location.start_line,
                        index.index.location.end_column-1
                    ), function);                

                if need_store then
                    index.value = 
                    new TYPE_WRAPPER(
                        function.arguments[1],
                        function.call(index.location, index.left.value, arguments, null, _function_caller));
                else
                    index.value = function.call(index.location, index.left.value, arguments, null, _function_caller);
                fi                
            fi
        si

        visit(member: Trees.Expressions.MEMBER) is
            let need_store = member.value? /\ isa Need.STORE(member.value);
            
            if member.identifier == null then
                return;
            fi

            if member.left? /\ member.left.value? then                
                let type = member.left.value.type;

                if type == null then
                    _logger.poison(member.left.location, "member left has no type");
                    return;
                fi

                if !isa Semantic.Types.NAMED(type) then
                    if !isa Semantic.Types.ANY(type) then
                        _logger.poison(member.left.location, "type has no members: " + type);
                    fi
                    
                    return;
                fi

                let named_type = cast Semantic.Types.NAMED(type);

                if named_type.scope == null then
                    _logger.poison(member.left.location, "member left type has no type: " + type);
                    return;
                fi

                let symbol = named_type.scope.find_member(member.identifier.name);

                let x = named_type.symbol;

                if symbol == null then
                    _logger.error(member.identifier.location, "member " + member.identifier.name + " not found in " + named_type);

                    return;
                fi

                _symbol_use_locations.add_symbol_use(member.location, symbol);

                // FIXME: can now be captured so does not need to be instance variable:
                _search_type = named_type;

                _symbol_loader.find_symbol = 
                    (name: string) -> Semantic.Symbols.Symbol is
                        let result = _search_type.scope.find_member(name);

                        return result;
                    si;

                let value: Value;

                if need_store then
                    let store_value = cast Need.STORE(member.value).value;

                    value = symbol.store(member.location, member.left.value, store_value, _symbol_loader, false);
                else
                    value = symbol.load(member.location, member.left.value, _symbol_loader);
                fi

                member.value = value;
            fi
        si
        
        visit(variable: Trees.Variables.Variable) is
            let symbol = find(variable.name);

            if symbol? /\ isa Semantic.Types.SettableTyped(symbol) then
                let typed_symbol = cast Semantic.Types.SettableTyped(symbol);

                symbol.define();

                if typed_symbol.type == null then
                    if variable.type_expression? /\ !isa Trees.TypeExpressions.INFER(variable.type_expression) then
                        _logger.poison(variable.location, "explicitly typed variable should already have a type");
                    elif variable.initializer? then
                        if variable.initializer.value? then
                            typed_symbol.set_type(variable.initializer.value.type);
                        fi
                    else
                        _logger.error(variable.location, "variable must have explict type or initializer");
                    fi
                else
                    if 
                        !isa Trees.TypeExpressions.INFER(variable.type_expression) /\
                        variable.initializer? /\ 
                        variable.initializer.value? /\
                        variable.initializer.value.type? /\
                        !variable.type_expression.type.is_assignable_from(variable.initializer.value.type)
                    then
                        _logger.error(
                            variable.location, 
                            "" + variable.initializer.value.type + " is not assignable to " + variable.type_expression.type);
                    fi
                fi
            else
                _logger.error(variable.name.location, "couldn't find typed symbol for variable " + variable.name);
            fi        
        si

        visit(integer: Trees.Expressions.Literals.INTEGER) is
            let type: Type;
            let suffix = "i4";

            let value_string = integer.value_string;
            let conv: string;

            let last_char = value_string.get_chars(value_string.length-1);

            if "bBcCsSiIlLwWuU".contains(last_char) then
                let is_unsigned = false;

                let cutoff = value_string.length;

                if last_char == 'u' \/ last_char == 'U' then
                    is_unsigned = true;

                    cutoff = cutoff - 1;
                elif value_string.length > 2 then
                    let sign_char = value_string.get_chars(value_string.length - 2);

                    if sign_char == 'u' \/ sign_char == 'U' then
                        is_unsigned = true;

                        cutoff = cutoff - 1;
                    elif sign_char == 's' \/ sign_char == 'S' then
                        cutoff = cutoff - 1;
                    fi
                 fi

                case last_char
                when 'b', 'B': 
                    if is_unsigned then
                        type = _innate_symbol_lookup.get_ubyte_type();
                    else
                        type = _innate_symbol_lookup.get_byte_type();
                    fi
                    
                    cutoff = cutoff - 1;

                when 'c', 'C':
                    if is_unsigned then
                        _logger.error(integer.location, "numeric character literal cannot be unsigned");
                    else
                        type = _innate_symbol_lookup.get_char_type();
                    fi

                    cutoff = cutoff - 1;

                when 's', 'S':
                    if is_unsigned then
                        type = _innate_symbol_lookup.get_ushort_type();
                    else
                        type = _innate_symbol_lookup.get_short_type();
                    fi

                    cutoff = cutoff - 1;

                when 'i', 'I':
                    if is_unsigned then
                        type = _innate_symbol_lookup.get_uint_type();
                    else
                        type = _innate_symbol_lookup.get_int_type();
                    fi

                    cutoff = cutoff - 1;

                when 'l', 'L':
                    suffix = "i8";

                    if is_unsigned then
                        type = _innate_symbol_lookup.get_ulong_type();
                    else
                        type = _innate_symbol_lookup.get_long_type();
                    fi

                    cutoff = cutoff - 1;

                when 'w', 'W':
                    suffix = "i8";

                    if is_unsigned then
                        type = _innate_symbol_lookup.get_uword_type();
                        conv = "conv.u";
                    else
                        type = _innate_symbol_lookup.get_word_type();
                        conv = "conv.i";
                    fi

                    cutoff = cutoff - 1;

                default
                    if is_unsigned then
                        type = _innate_symbol_lookup.get_uint_type();
                    else
                        type = _innate_symbol_lookup.get_int_type();
                    fi
                esac

                value_string = value_string.substring(0, cutoff);
            else
                type = _innate_symbol_lookup.get_int_type();                
            fi 
            
            integer.value = new Literal.NUMBER(
                value_string,
                type,
                suffix,
                conv
            );
        si

        visit(float: Trees.Expressions.Literals.FLOAT) is
            let type: Type;
            let suffix: string;

            let value_string = float.value_string;

            if
                value_string.ends_with('D') \/
                value_string.ends_with('d')
            then
                type = _innate_symbol_lookup.get_double_type();
                suffix = "r8";
            else
                type = _innate_symbol_lookup.get_single_type();
                suffix = "r4";
            fi
            
            float.value = new Literal.NUMBER(
                value_string.substring(0, value_string.length -1),
                type,
                suffix
            );
        si

        visit(`string: Trees.Expressions.Literals.STRING) is
            `string.value = new Literal.STRING(
                `string.value_string,
                _innate_symbol_lookup.get_string_type()
            );
        si        

        visit(character: Trees.Expressions.Literals.CHARACTER) is
            let value_string = character.value_string;
            let c: int = 0;

            if value_string.length < 1 \/ value_string.length > 1 then
                _logger.error(character.location, "invalid character literal");
            else
                c = cast int(value_string.get_chars(0));
            fi
            
            character.value = new Literal.NUMBER(
                "" + c,
                _innate_symbol_lookup.get_char_type(),
                "i4"
            );
        si

        visit(boolean: Trees.Expressions.Literals.BOOLEAN) is
            let value_string = boolean.value_string;

            let value: string;

            if value_string =~ "true" then
                value = "1";
            elif value_string =~ "false" then
                value = "0";
            else
                throw new System.Exception("invalid value for boolean literal: " + value_string);
            fi
                        
            boolean.value = new Literal.NUMBER(
                value,
                _innate_symbol_lookup.get_bool_type(),
                "i4"
            );
        si

        pre(call: Trees.Expressions.CALL) -> bool is
            super.pre(call);

            // FIXME: walk directly in visit, so we can keep speculate + commit paired if exception thrown, and prevent the logger stack getting out of sync:
            _logger.speculate();

            return false;
        si

        visit(call: Trees.Expressions.CALL) is
            try
                _visit(call);
            catch e: Exception
                call.value = null;

                _logger.exception(call.location, e, "exception compiling call");
            finally
                _logger.commit();
            yrt
        si

        _visit(call: Trees.Expressions.CALL) is
            

            if call.function.value == null then
                // _logger.error(call.function.location, "cannot call this");
                return;
            fi

            let is_partial = false;

            let arguments = new Collections.LIST[Value]();
            let argument_types = new Collections.LIST[Type]();

            let buffer: IO.TextWriter;

            let outer_state: (writer: IO.TextWriter, error_count: int);

            for a in call.arguments do
                if a? /\ a.value? /\ a.value.type? then
                    arguments.add(a.value);
                    argument_types.add(a.value.type);                    
                else
                    let type = new Semantic.Types.ANY();

                    if a? then
                        arguments.add(new DUMMY(type, a.location));
                    else
                        arguments.add(new DUMMY(type, call.arguments.location));
                    fi
                                        
                    argument_types.add(type);
                fi
            od

            if isa Load.SYMBOL(call.function.value) then
                let load = cast Load.SYMBOL(call.function.value);

                if load.symbol? /\ isa Semantic.Symbols.FUNCTION_GROUP(load.symbol) then
                    let function_group = cast Semantic.Symbols.FUNCTION_GROUP(load.symbol);
                    let overload_result = _overload_resolver.resolve(call.arguments.location, function_group, argument_types, true);

                    if overload_result == null then
                        return;
                    fi

                    if overload_result.score == Semantic.Types.MATCH.PARTIAL then
                        _logger.roll_back();
                        
                        _logger.speculate();

                        is_partial = true;

                        for iv in call.arguments | .index() do
                            let a = iv.value;

                            if a? /\ a.value? /\ isa Trees.Expressions.FUNCTION(a) then
                                let f = overload_result.function.arguments[iv.index];

                                _partial_argument_types[a] = f;

                                a.walk(self);

                                argument_types[iv.index] = a.value.type;
                            fi
                        od

                        overload_result = _overload_resolver.resolve(call.arguments.location, function_group, argument_types, false);

                        if !overload_result? then
                            return;
                        fi    
                    fi

                    if !overload_result? then
                        return;
                    fi    

                    let function = overload_result.function;

                    _symbol_use_locations.add_symbol_use(call.function.location, function);

                    call.value = function.call(call.function.location, load.from, arguments, null, _function_caller);

                    return;
                fi
            fi

            let function_type = call.function.value.type;

            if !function_type? \/ !isa Semantic.Types.NAMED(function_type) then
                _logger.error(call.function.location, "cannot call value of non-function type " + call.function.value.type);
                return;
            fi

            let function_generic_type = cast Semantic.Types.NAMED(function_type);

            let function_type_arguments = function_generic_type.arguments;

            // FIXME: need to check for actual types here, and or presence of invoke method:
            let is_action = function_generic_type.name.starts_with("ACTION_");

            let is_function = function_generic_type.name.starts_with("FUNCTION_");

            if is_action then
                if function_type_arguments.count != arguments.count then
                    _logger.error(
                        call.arguments.location, 
                        "expected " + function_type_arguments.count + " arguments but " + arguments.count + " supplied");
                    return;
                fi
            elif is_function then
                if function_type_arguments.count != arguments.count + 1 then
                    _logger.error(
                        call.arguments.location, 
                        "expected " + (function_type_arguments.count - 1) + " arguments but " + arguments.count + " supplied");
                    return;
                fi
            else
               _logger.error(call.function.location, "cannot call value of non-function type " + call.function.value.type);
                return;                    
            fi

            let ok = true;

            for i in 0..arguments.count do
                if function_generic_type.arguments[i]
                    .compare(argument_types[i])
                        > Semantic.Types.MATCH.CONVERTABLE
                then
                    ok = false;
                    _logger.error(call.arguments.expressions[i].location, "expected argument of type " + function_type_arguments[i] + " but " + argument_types[i] + " supplied");
                fi
            od

            if !ok then
                return;
            fi

            let result_type: Type;

            if is_function then
                result_type = function_generic_type.arguments[function_type_arguments.count - 1];
            else
                result_type = _innate_symbol_lookup.get_void_type();
            fi

            call.value =
                new Call.CLOSURE(
                    call.function.value,
                    result_type,
                    is_function,
                    function_generic_type,
                    arguments
                );
        si

        visit(identifier: Trees.Expressions.IDENTIFIER) is
            try
                _visit(identifier);

            catch ex: Exception
                _logger.exception(identifier.location, ex, "something went wrong with identifier");
            yrt            
        si

        _visit(identifier: Trees.Expressions.IDENTIFIER) is
            let need_store = identifier.value? /\ isa Need.STORE(identifier.value);
        
            let symbol = find(identifier.identifier);

            if symbol? then
                _symbol_use_locations.add_symbol_use(identifier.location, symbol);

                // _symbol_loader.find_symbol = (name: string) -> Semantic.Symbols.Symbol => find(name);

                _symbol_loader.find_symbol = 
                    (name: string) -> Semantic.Symbols.Symbol is
                        let result = find(name);

                        return result;
                    si;

                if need_store then
                    let store_value = cast Need.STORE(identifier.value).value;
                    identifier.value = symbol.store(identifier.location, null, store_value, _symbol_loader, false);
                else
                    identifier.value = symbol.load(identifier.location, null, _symbol_loader);
                fi
            else
                identifier.value = null;
            fi                
        si

        visit(has_value: Trees.Expressions.HAS_VALUE) is
            if !has_value.left? then
                _logger.poison(has_value.location, "has value expression has no left expression");
                return;
            elif !has_value.left.value? then
                _logger.poison(has_value.left.location, "has value expression has no value");
                return;                
            fi
            
            has_value.value = new HAS_VALUE(has_value.left.value, _innate_symbol_lookup.get_bool_type());
        si

        visit(reference: Trees.Expressions.REFERENCE) is
            if !reference.left? then
                _logger.poison(reference.location, "reference expression has no left expression");
                return;
            elif !reference.left.value? \/ !reference.left.value.type? then
                _logger.poison(reference.left.location, "reference expression has no value");
                return;                
            elif !reference.left.value.has_address then
                _logger.warn(reference.left.location, "reference to an expression");                
            fi
            
            reference.value = new ADDRESS(reference.left.value, _innate_symbol_lookup.get_reference_type(reference.left.value.type));
        si
        
        visit(`null: Trees.Expressions.NULL) is
            `null.value = new NULL(new Semantic.Types.NULL());
        si

        // Do not descend into properties (otherwise accessor functions will be walked twice)
        pre(property: Trees.Definitions.PROPERTY) -> bool => true;

        visit(property: Trees.Definitions.PROPERTY) is
        si
    si
si
