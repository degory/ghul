namespace Syntax.Process is
    use System.Exception;

    use IO.Std;
        
    use Logging;
    use Debugging;
    use Source;

    use IR.Values;
    use IR.VALUE_CONVERTER;
    use IR.VALUE_BOXER;

    use Semantic.LEAST_UPPER_BOUND_MAP;
    use Semantic.Types.Type;

    use Syntax.Trees.Definitions.PRAGMA;

    class COMPILE_EXPRESSIONS: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Types.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;
        _value_converter: VALUE_CONVERTER;
        _value_boxer: VALUE_BOXER;

        _will_generate_code: bool;

        _stub_depth: int;
        _keep_depth: int;

        current_statement_list: Trees.Statements.LIST;

        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            context: IR.CONTEXT,
            value_converter: VALUE_CONVERTER,
            value_boxer: VALUE_BOXER
        )
        is
            super.init(logger, stable_symbols, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _innate_symbol_lookup = innate_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;
            _value_converter = value_converter;
            _value_boxer = value_boxer;
        si

        apply(root: Trees.Node) is
            assert _keep_depth == 0;
            assert _stub_depth == 0;

            _will_generate_code = IoC.CONTAINER.instance.build_flags.want_assembler;

            IR.LABEL.reset_id();
            IR.LABEL.set_pass("E");
            
            root.walk(self);

            assert _keep_depth == 0;
            assert _stub_depth == 0;
        si

        should_skip(node: Trees.Node) -> bool => _stub_depth > 0 \/ is_stable(node);

        get_zero_argument_function(type: Type, name: string) -> Semantic.Symbols.Function is
            let symbol = type.find_member(name);

            if symbol? /\ isa Semantic.Symbols.FUNCTION_GROUP(symbol) then
                let function_group = cast Semantic.Symbols.FUNCTION_GROUP(symbol);

                for f in function_group.functions do
                    if f.arguments.count == 0 then
                        return f;
                    fi
                od
            fi
        si

        set_iterator_for(`for: Trees.Statements.FOR, type: Type, recursing: bool) -> bool is
            if !type? then
                return false;
            fi

            `for.expression.value.check_is_consumable(_logger, `for.expression.location);

            if type.is_error then
                return false;
            fi

            let move_next = get_zero_argument_function(type, "move_next");
            
            if move_next? then
                let read_current = get_zero_argument_function(type, "$get_current");

                if !read_current? then
                    read_current = get_zero_argument_function(type, "$get_Current");                    
                fi
                
                if !read_current? then
                    _logger.error(`for.expression.location, "incomplete iterator type (has move_next method but no current property)");
                    return false;
                fi

                `for.move_next = move_next;
                `for.read_current = read_current;

                return true;
            elif !recursing then
                let read_iterator = get_zero_argument_function(type, "$get_iterator");

                if read_iterator? then
                    `for.read_iterator = read_iterator;

                    return set_iterator_for(`for, read_iterator.return_type, true);
                fi
            fi
            
            _logger.error(`for.expression.location, "not iterable");

            return false;
        si

        // FIXME: #500 Pragma handling code is duplicated across multiple visitors
        pre(pragma: Trees.Definitions.PRAGMA) -> bool is
            if !pragma.pragma? then
                return false;
            fi

            let p = pragma.pragma;

            let name = p.name.to_string();

            if name =~ "IL.stub" then
                _stub_depth = _stub_depth + 1;
            elif name =~ "KEEP" then
                _keep_depth = _keep_depth + 1;
            fi
        si

        visit(pragma: Trees.Definitions.PRAGMA) is
            if !pragma.pragma? then
                return;
            fi

            let p = pragma.pragma;

            let name = p.name.to_string();

            if name =~ "IL.stub" then
                _stub_depth = _stub_depth - 1;
            elif name =~ "KEEP" then
                _keep_depth = _keep_depth - 1;
            fi
        si

        pre(`namespace: Trees.Definitions.NAMESPACE) -> bool is
            super.pre(`namespace);
            return _stub_depth > 0;
        si

        pre(`class: Trees.Definitions.CLASS) -> bool is
            super.pre(`class);
            return should_skip(`class);
        si

        pre(`trait: Trees.Definitions.TRAIT) -> bool is
            super.pre(`trait);
            return should_skip(`trait);            
        si        

        pre(`struct: Trees.Definitions.STRUCT) -> bool is
            super.pre(`struct);
            return should_skip(`struct);            
        si

        pre(function: Trees.Definitions.FUNCTION) -> bool is
            return true;
        si

        visit(function: Trees.Definitions.FUNCTION) is
            let use debug_dispose = debug_enter();
            debug("enter function {function.name}");

            let mark = _logger.mark();

            super.pre(function);

            try
                _logger.speculate();

                _visit(function);

                debug("logger commit");
                _logger.commit();
            catch ex: Exception
                _logger.release(mark);

                debug("function {function.name} exception {ex}");
    
                _logger.exception(function.location, ex, "exception compiling function");
            finally
                debug("exit function {function.name}");

                super.visit(function);
            yrt
        si
    
        _visit(function: Trees.Definitions.FUNCTION) is
            let use debug_dispose = debug_enter();

            let symbol = symbol_for(function);

            debug("visit function {symbol}");

            function.name.walk(self);
            function.type_expression.walk(self);
            function.arguments.walk(self);

            let retries = 20;

            for i in 1::retries do
                let use debug_dispose = debug_enter();
                debug("inference attempt #{i} for {symbol}");
                
                debug("consumed any {_logger.has_consumed_any} consumed error {_logger.has_consumed_error}");

                function.body.walk(self);

                debug("consumed any {_logger.has_consumed_any} consumed error {_logger.has_consumed_error}");

                if _logger.is_clean then
                    debug("no errors");
                    IO.Std.error.write_line("clean:\n{IoC.CONTAINER.instance.inference_info_printer.print(function)}");
                    break;
                fi
                
                if i < retries then
                    _logger.roll_back();
                    _logger.speculate();
                else
                    debug("failed after {retries} attempts");
                fi

                IO.Std.error.write_line("dirty\n{IoC.CONTAINER.instance.inference_info_printer.print(function)}");
            od
        si

        pre(`let: Trees.Statements.LET) -> bool is
            super.pre(`let);
            return false;
        si

        visit(`let: Trees.Statements.LET) is
            super.visit(`let);

            if `let.want_dispose then
                let idisposable = _innate_symbol_lookup.get_idisposable_type();

                for v in `let.variables do
                    for name in v.names do
                        let symbol = find(v.name);

                        if symbol? /\ isa Semantic.Symbols.Variable(symbol) then
                            let variable = cast Semantic.Symbols.Variable(symbol); 
                            variable.is_disposed = true;

                            let type = variable.type;

                            if !idisposable.is_assignable_from(type) then
                                _logger.error(v.name.location, "not disposable");
                            fi

                            current_statement_list.add_variable_to_dispose(variable);
                        fi
                    od
                od
            fi
        si
        
        pre(`for: Trees.Statements.FOR) -> bool is
            super.pre(`for);

            try
                _pre(`for);
            catch ex: Exception
                _logger.exception(`for.location, ex, "exception compiling for");
            yrt
            
            return true;
        si
        
        _pre(`for: Trees.Statements.FOR) -> bool is
            let symbol: Semantic.Symbols.Symbol;

            let type: Type = Semantic.Types.ERROR();
    
            if `for.expression? /\ !`for.expression.is_poisoned then
                `for.expression.walk(self);

                if 
                    `for.expression.value? /\ set_iterator_for(`for, `for.expression.value.type, false)
                then
                    if `for.variable.type_expression? /\ !isa Trees.TypeExpressions.INFER(`for.variable.type_expression) then
                        if `for.variable.type_expression.type.is_assignable_from(`for.read_current.return_type) then
                            type = `for.variable.type_expression.type;
                        else
                            _logger.error(`for.variable.location, "type mismatch");
                        fi
                    else
                        type = `for.read_current.return_type;
                    fi
                fi
            fi

            if `for.variable? /\ !`for.variable.is_poisoned then
                set_symbol_type(`for.variable.left, type);
            fi

            if `for.body? then
                `for.body.walk(self);
            fi
        si

        pre(left: Trees.Expressions.SIMPLE_LEFT_EXPRESSION) -> bool is
            super.pre(left);

            if !left.value? then
                return false;
            fi

            if !left.value.is_consumable then
                _logger.error(left.location, "cannot use this here");
                return false;
            fi

            left.expression.value = Need.STORE(left.value);
            return false;
        si

        visit(left: Trees.Expressions.SIMPLE_LEFT_EXPRESSION) is
            super.visit(left);

            if !left.value? \/ !left.value.type? \/ !left.expression.value? \/ !left.expression.value.type? then
                return;
            fi

            if !left.expression.value.is_consumable then
                _logger.error(left.location, "cannot assign to this");
                return;
            fi

            if !left.expression.value.type.is_assignable_from(left.value.type) then
                _logger.error(left.assign_location, "{left.value.type} is not assignable to {left.expression.value.type}");
                return;
            fi

            left.value = left.expression.value;
        si
        
        get_conventionally_named_destructure_member_types(type: Type) -> Collections.List[Type] is
            // ask the type to give us its destructure members in order, if
            // it has any, and return their types, otherwise return an empty list

            let result = Collections.LIST[Type]();

            for member in iter_while(i => type.find_destructure_member(i), m => m?) do
                result.add(member.type);
            od
            
            return result;
        si

        pre(left: Trees.Expressions.DESTRUCTURING_LEFT_EXPRESSION) -> bool is
            super.pre(left);

            let from = left.value;

            if !from? then
                return true;
            fi
            
            let from_type = from.type;

            if !from_type? then
                return true;
            fi

            let from_types: Collections.List[Type];

            if from_type.is_error then
                return true;
            fi

            if from_type.is_value_tuple then
                from_types = from_type.arguments;
            else
                from_types = get_conventionally_named_destructure_member_types(from_type);
            fi

            if from_types.count == 0 then
                _logger.error(left.location, "cannot destructure {from_type}");
                return true;
            fi

            let elements = left.elements;

            let count = elements.count;

            if elements.count != from_types.count then
                _logger.error(left.location, "expected {elements.count} destructuring elements but found {from_types.count}");

                if elements.count > from_types.count then
                    count = from_types.count;
                fi
            fi

            let block = IR.Values.BLOCK();

            let get_from = from.get_temp_copier(block, "destructure");

            for i in 0..count do
                let element = elements[i];

                let member = from_type.find_member("`{i}");

                element.value = member.load(LOCATION.internal, get_from(), _symbol_loader);

                element.walk(self);

                if element.value? then
                    block.add(element.value);
                fi
            od

            block.close();
            left.value = block;

            return true;
        si

        pre(let_in: Trees.Expressions.LET_IN) -> bool is
            super.pre(let_in);

            return false;
        si

        visit(let_in: Trees.Expressions.LET_IN) is
            super.visit(let_in);

            if 
                !let_in.expression.value? \/
                !let_in.expression.value.check_is_consumable_allow_void(_logger, let_in.expression.location)
            then
                let_in.value = IR.Values.DUMMY(Semantic.Types.ERROR(), let_in.location);
                return;
            fi

            let_in.value = let_in.expression.value;
        si
        
        pre(assignment: Trees.Statements.ASSIGNMENT) -> bool is
            let use debug_dispose = debug_enter();
            debug("assign {assignment.to_string().replace_line_endings(" ")}");

            if assignment.right.constraint? then 
                debug("assign right constraint is {assignment.right.constraint}");
            fi  

            assignment.right.walk(self);

            if !assignment.right.value? then
                return true;
            fi
            
            if !assignment.right.value.is_consumable then
                _logger.error(assignment.right.location, "cannot use this here");
                assignment.left.value = IR.Values.DUMMY(Semantic.Types.ERROR(), assignment.right.location);
            else
                assignment.left.value = assignment.right.value;

                debug("assign right value is {assignment.right.value}");
                debug("assign right type is {assignment.right.value.type}");
            fi

            debug_always("assign upgrade right constraint from {assignment.right.constraint} to {assignment.right.value.type}");

            assignment.right.upgrade_constraint(assignment.right.value.type, "{{0}} burble {{1}}");

            assignment.left.upgrade_constraint(assignment.right.value.type, "{{0}} burble {{1}}");
            
            assignment.left.assign_location = assignment.location;

            assignment.left.walk(self);

            assignment.value = assignment.left.value;

            return true;
        si

        pre(expression: Trees.Statements.EXPRESSION) -> bool is
            super.pre(expression);

            return false;
        si

        visit(expression: Trees.Statements.EXPRESSION) is
            super.visit(expression);

            Value.check_is_consumable_allow_void(_logger, expression.expression.location, expression.expression.value);

            if !expression.want_value then
                if expression.expression.must_be_consumed then
                    _logger.error(expression.expression.location, "{expression.expression.description} result is not used");
                fi

                return;
            fi

            expression.value = expression.expression.value;
        si

        pre(r: Trees.Statements.RETURN) -> bool is
            super.pre(r);

            if !r.expression? then
                return false;
            fi

            let function = current_function;

            if
                !function.return_type? \/ 
                function.return_type.is_any \/ 
                function.return_type =~ _innate_symbol_lookup.get_void_type()
            then
                return false;
            fi

            r.expression.upgrade_constraint(function.return_type, "cannot return value of type {{0}} where {{1}} expected");

            return false;
        si

        visit(r: Trees.Statements.RETURN) is
            super.visit(r);

            let function = current_function;

            if !function? \/ !function.return_type? then
                // FIXME: null function happens for properties, null return type happens for anonymous functions
                return;
            fi

            if r.expression? then
                if
                    r.expression.value? /\
                    r.expression.value.type? /\
                    r.expression.value.check_is_consumable(_logger, r.expression.location)
                then
                    if function.return_type.is_any then
                        function.set_return_type(r.expression.value.type);                
                    elif function.return_type =~ _innate_symbol_lookup.get_void_type() /\ !function.return_type.is_type_variable then
                        _logger
                            .error(
                                r.expression.location,
                                "cannot return value from function of void type"
                            );                        
                    elif !function.return_type.is_assignable_from(r.expression.value.type) then
                        _logger
                            .error(
                                r.expression.location,
                                "cannot return value of type {r.expression.value.type} where {function.return_type} expected"
                            );
                    fi

                    return;
                fi
            else
                if function.return_type !~ _innate_symbol_lookup.get_void_type() then
                    _logger
                        .warn(
                            r.location,
                            "return without value from non void function returns default value of type {function.return_type}"
                        );
                fi
            fi
        si

        visit(`throw: Trees.Statements.THROW) is
            super.visit(`throw);

            if 
                !Value.check_is_consumable(_logger, `throw.expression.location, `throw.expression.value)
            then
                return;
            fi

            let exception_type = _innate_symbol_lookup.get_exception_type();

            if !exception_type.is_assignable_from(`throw.expression.value.type) then
                _logger.warn(`throw.expression.location, "thrown value is not derived from System.Exception");
            fi

            // FIXME: need to signal to any enclosing expression if statement that this is a throw so
            // if all branches are throws, an error can be reported
        si

        visit(`assert: Trees.Statements.ASSERT) is
            super.visit(`assert);

            if 
                !`assert.expression.value? \/ 
                !`assert.expression.value.type? \/
                !`assert.expression.value.check_is_consumable(_logger, `assert.expression.location)
            then
                return;
            fi

            if
                !_innate_symbol_lookup
                    .get_bool_type()
                    .is_assignable_from(`assert.expression.value.type)
            then
                _logger.error(`assert.expression.location, "assertion expression must be bool");
            fi

            if `assert.message? /\ `assert.message.value? /\ `assert.message.value.type? then
                `assert.message.value.check_is_consumable(_logger, `assert.message.location);

                if !_innate_symbol_lookup
                    .get_exception_type()
                    .is_assignable_from(`assert.expression.value.type)
                then
                    `assert.needs_exception_wrapper = true;
                elif 
                    !_innate_symbol_lookup
                        .get_string_type()
                        .is_assignable_from(`assert.expression.value.type)
                then
                    _logger.error(`assert.message.location, "assertion else must be string or System.Exception");
                fi
            fi
        si

        visit(`try: Trees.Statements.TRY) is
            super.visit(`try);

            if
                (!`try.catches? \/ `try.catches.count == 0) /\
                !`try.`finally?
            then
                _logger.warn(`try.location, "try statement should have at least one catch clause and/or a finally clause");
            fi
        si
        
        visit(`catch: Trees.Statements.CATCH) is
            super.visit(`catch);

            if !`catch.variable? \/ !`catch.variable.type_expression? then
                return;
            fi
            
            let type = `catch.variable.type_expression.type;

            if !type? then
                return;
            fi

            let exception_type = _innate_symbol_lookup.get_exception_type();

            if !exception_type.is_assignable_from(type) then
                _logger.error(`catch.variable.type_expression.location, "cannot catch {type} because it does not derive from System.Exception");
            fi
        si

        visit(`do: Trees.Statements.DO) is
            if
                `do? /\
                `do.condition? /\
                Value.check_is_consumable(_logger, `do.condition.location, `do.condition.value)
            then
                if `do.condition.value.type !~_innate_symbol_lookup.get_bool_type() then
                    _logger.error(`do.condition.location, "while condition must be bool");
                fi
            fi

            super.visit(`do);
        si

        visit(`if: Trees.Statements.IF_BRANCH) is
            if
                `if? /\
                `if.condition? /\
                Value.check_is_consumable(_logger, `if.condition.location, `if.condition.value)
            then
                if `if.condition.value.type !~_innate_symbol_lookup.get_bool_type() then
                    _logger.error(`if.condition.location, "if condition must be bool");
                fi
            fi

            super.visit(`if);
        si

        pre(expression: Trees.Bodies.EXPRESSION) -> bool is
            super.pre(expression);

            if !expression.expression? then
                return false;
            fi

            let function = current_function;

            if 
                !function.return_type? \/ 
                function.return_type.is_any
            then
                return false;
            fi

            expression.expression.set_constraint(function.return_type, "cannot return value of type {{0}} where {{1}} expected");

            return false;

        si

        visit(expression: Trees.Bodies.EXPRESSION) is
            let function = current_function;

            if
                !function? \/
                !function.return_type? \/
                !expression.expression? \/
                !expression.expression.value? \/
                !expression.expression.value.type?
            then
                super.visit(expression);

                expression.expression.value = IR.Values.DUMMY(Semantic.Types.ERROR(), expression.expression.location);

                if function? /\ (!function.return_type? \/ function.return_type.is_wild) then
                    function.set_return_type(Semantic.Types.ERROR());
                fi

                return;
            fi

            let void_type = _innate_symbol_lookup.get_void_type();
            
            if function.return_type.is_inferred then
                if Value.check_is_consumable_allow_void(_logger, expression.expression.location, expression.expression.value) then
                    function.set_return_type(expression.expression.value.type);
                elif expression.expression.value? /\ expression.expression.value.type? /\ expression.expression.value.type.is_error then
                    function.set_return_type(Semantic.Types.ERROR());
                fi
            elif function.return_type =~ void_type /\ !function.return_type.is_type_variable then
                if expression.expression.value.type !~ void_type then
                    _logger
                        .error(
                            expression.location,
                            "cannot return value from function of void type"
                        );                        
                fi
            elif !function.return_type.is_assignable_from(expression.expression.value.type) then
                _logger
                    .error(
                        expression.location,
                        "cannot return value of type {expression.expression.value.type} where {function.return_type} expected"
                    );
            else
                Value.check_is_consumable_allow_void(_logger, expression.expression.location, expression.expression.value);
            fi

            super.visit(expression);
        si
        
        pre(function: Trees.Expressions.FUNCTION) -> bool is
            return true;
        si

        visit(function: Trees.Expressions.FUNCTION) is
            let mark = _logger.mark();

            try
                // _logger.speculate();

                super.pre(function);

                _visit(function);

                // _logger.commit();
            catch e: Exception
                debug_always("oops caught exception in lambda {e}");

                function.value = DUMMY(Semantic.Types.ERROR(), function.location);
                _logger.release(mark);
 
                _logger.exception(function.location, e, "exception compiling function literal");

            finally
                super.visit(function);
            yrt
        si

        _visit(function: Trees.Expressions.FUNCTION) is
            let use debug_dispose = debug_enter();

            debug("compile function literal {function.to_string().replace_line_endings(" ")}");

            if !function.value? then
                function.value = IR.Values.WRAPPER();
            fi

            let closure = cast Semantic.Symbols.Closure(scope_for(function));

            closure.map_type_arguments();

            let implied_type: Type;
            let constraint_argument_types: Collections.List[Type];
            let constraint_return_type: Type;

            // have we been passed expected arguments types? If so we'll use them
            // to argument types of any anonymous function literal arguments
            if function.constraint? then
                constraint_argument_types = function.constraint.arguments;

                debug("have function constraint {function.constraint} args and return type {constraint_argument_types|}");

                if function.constraint.is_function /\ constraint_argument_types.count > 0 then
                    debug("expect return type from {constraint_argument_types|} count {constraint_argument_types.count}");

                    let rt = constraint_argument_types[constraint_argument_types.count-1];

                    if rt.any_count == 0 then
                        debug("concrete return type {rt}");
                        constraint_return_type = rt;
                    else
                        debug("ignore wild return type {rt}");
                    fi
                fi
            else
                debug("no constraint or unusable constraint");
            fi

            _symbol_table.current_closure_context.add_closure(closure);

            let argument_names = Collections.LIST[string]();
            let argument_types = Collections.LIST[Type]();

            let any_errors: bool;

            let arguments = function.arguments.expressions;

            debug("compile function {function.compile_count} {function.to_string().replace_line_endings(" ")}");
            function.compile_count = function.compile_count + 1;

            // we are walking the arguments here while speculating
            for index in 0..arguments.count do
                let a = arguments[index];
                debug("function argument #{index} {a}");
                
                // TODO: destructure
                if isa Trees.Expressions.VARIABLE(a) then
                    let argument = cast Trees.Expressions.VARIABLE(a);

                    argument_names.add(argument.name.name);
                    let partial_argument_type: Type;
                    let symbol = cast Semantic.Symbols.Variable(closure.find_direct(argument.name.name));

                    if !isa Trees.TypeExpressions.INFER(argument.type_expression) then
                        debug("explicit type {argument.type_expression.type}");
                        argument_types.add(argument.type_expression.type);
                    elif constraint_argument_types? then
                        let constraint_argument_type = constraint_argument_types[index];

                        debug("constrained argument type {constraint_argument_type} {constraint_argument_type.get_type()} inferred: {constraint_argument_type.is_inferred}");

                        if constraint_argument_type? /\ !constraint_argument_type.is_type_variable /\ !constraint_argument_type.is_inferred then
                            debug("apply constraint {constraint_argument_type}");
                            argument_types.add(constraint_argument_type);

                            symbol.set_type(constraint_argument_type);
                        else
                            let best_guess = symbol.try_get_inferred_type(symbol.location, _logger);

                            debug("lambda arg #{index} {a} LUB result {best_guess}");
    
                            if !best_guess? then
                                best_guess = Semantic.Types.INFERRED_VARIABLE_TYPE(symbol.location);
                            fi
                            
                            symbol.set_type(best_guess);
                            argument_types.add(best_guess);
                        fi
                    else
                        let best_guess = symbol.try_get_inferred_type(symbol.location, _logger);

                        debug("lambda arg #{index} {a} LUB result {best_guess}");

                        if !best_guess? then
                            best_guess = Semantic.Types.INFERRED_VARIABLE_TYPE(symbol.location);
                        fi
                        
                        symbol.set_type(best_guess);
                        argument_types.add(best_guess);
                    fi
                else
                    _logger.error(a.location, "unexpected kind of argument ({a.get_type()})");
                    any_errors = true;
                fi

                index = index + 1;
            od

            // if !any_errors then
                closure.arguments = Collections.LIST[Type](argument_types);

                let return_type: Type;

                if function.type_expression.type? then
                    return_type = function.type_expression.type;
                    debug("explicit return type {return_type}");
                elif constraint_return_type? then
                    return_type = constraint_return_type;
                    debug("constrained return type {return_type}");
                else
                    return_type = Semantic.Types.INFERRED_RETURN_TYPE(function.location);
                    debug("infer return type {return_type}");
                fi

                closure.argument_names = argument_names;

                // TODO only set if it's an improvement?
                closure.set_return_type(return_type);

                debug("set return type {return_type}");
            // fi

            // _logger.commit();
            // _logger.speculate();

            debug("walk function A {function.compile_count} {function.to_string().replace_line_endings(" ")}");
            function.body.walk(self);

            if closure.is_recursive /\ closure.is_recurse_capture_type_any then
                debug("recurse is any type");
                _logger.error(function.body.location, "no type inferred for recursive capture");
            fi

            /*            

            let reported_inference_failure = false;

            if closure.is_recursive then
                _logger.roll_back();
                _logger.speculate();

                debug("walk function B {function.compile_count} {function.to_string().replace_line_endings(" ")}");
                function.body.walk(self);
            fi

            */
            
            if closure.return_type.is_inferred /\ ! closure.arguments | .any(a => a.is_error) then
                debug("set void return type");
                closure.set_return_type(_innate_symbol_lookup.get_void_type());
            fi
            
            debug("finishing up function {function.compile_count} {function.to_string().replace_line_endings(" ")}");

            closure.unmap_type_arguments();

            let value = closure.load(function.location, _symbol_loader).freeze();

            debug("lambda result type {value.type} closure return type {closure.return_type} closure type {closure.type}");

            if closure.is_recursive then
                debug("recurse capture is {closure.find_or_add_recurse()}");
            fi

            cast IR.Values.WRAPPER(function.value).value = value;

            debug("value is {function.value} (inner should be {value})");

            if _will_generate_code /\ !any_errors then
                debug("generating IL ensure return type is applied");

                // FIXME should roll back here, speculate again

                // _logger.roll_back();
                // _logger.speculate();

                // let mark = _logger.mark();
                // _logger.speculate();

                // try
                    if closure.could_be_delegate then
                        closure.convert_to_delegate();
                        _logger.error(function.location, "converted to delegate needs re-infer")
                    fi

                    // debug("walk function C {function.compile_count} {function.to_string().replace_line_endings(" ")}");
                    // function.body.walk(self);
   
                    /*
                    if !_logger.is_clean then
                        let errors = _logger.roll_back();

                        debug("final walk failed");

                        errors.write_all_diagnostics(IO.Std.error, new Logging.HUMAN_READABLE_DIAGNOSTIC_FORMATTER());

                        if closure.could_be_delegate then
                            _logger.error(function.location, "failed to convert anonymous function to delegate");
                        else
                            _logger.error(function.location, "unexpected error generating code for anonymous function");
                        fi
                    else
                        debug("final walk succeeded");
                    fi
                    */
                // finally
                //     _logger.release(mark);
                // yrt

                debug("needs another iteration");
            fi

            debug("done function {function.compile_count} {function.to_string().replace_line_endings(" ")}");
        si

        visit(recurse: Trees.Expressions.RECURSE) is
            let function = current_function;

            if !function? \/ !function.is_closure then
                recurse.value = IR.Values.DUMMY(Semantic.Types.ERROR(), recurse.location);

                _logger.error(recurse.location, "rec can only be used in a function literal body");
                return;
            fi

            let closure = cast Semantic.Symbols.Closure(function);

            recurse.value = closure.load_recurse(recurse.location, _symbol_loader);

            if !function.is_recursive then
                _logger.error(recurse.location, "rec can only be used in a recursive function");
                return;
            fi
        si

        pre(tuple: Trees.Expressions.TUPLE) -> bool is
            // if we've been given a tuple typed constraint then
            // apply the corresponding element types from it to the
            // tuple elements: 
            if tuple.constraint? /\ tuple.constraint.is_value_tuple then
                for (element, type) in tuple.elements | .zip(tuple.constraint.arguments) do
                    element.upgrade_constraint(type, tuple.constraint_error_message);
                od
            else
                // TODO we may not want to do this - there's a chance that
                // removing a constraint will cause us to go backwards
                for element in tuple.elements do
                    element.clear_constraint();
                od
            fi

            return false;
        si

        visit(tuple: Trees.Expressions.TUPLE) is
            let names = Collections.LIST[string]();
            let values = Collections.LIST[Value]();
            let types = Collections.LIST[Type]();

            let element_constraints: Collections.List[Type] = null;
            let constraint_error_message: string = null;


            if tuple.constraint? /\ tuple.constraint.is_value_tuple then
                element_constraints = tuple.constraint.arguments;
                constraint_error_message = tuple.constraint_error_message;
            fi;

            if tuple.elements.expressions.count == 1 then
                tuple.value = tuple.elements.expressions[0].value;
                return;
            elif tuple.elements.expressions.count == 0 then
                tuple.value = IR.Values.DUMMY(Semantic.Types.ERROR(), tuple.location);

                _logger.error(tuple.location, "empty tuple");
                return;
            fi

            let seen_any_named = false;

            for (index, v) in tuple.elements | .index() do
                let element_type_constraint =
                    if element_constraints? /\ index < element_constraints.count then
                        element_constraints[index];
                    else
                        null;
                    fi;

                if isa Trees.Expressions.TUPLE_ELEMENT(v) then
                    let element = cast Trees.Expressions.TUPLE_ELEMENT(v);

                    seen_any_named = true;
                    names.add(element.name.name);

                    if element.initializer? then
                        if Value.check_is_consumable(_logger, element.initializer.location, element.initializer.value) then
                            if element.type_expression? /\ element.type_expression.type? then
                                let type =
                                    if element_type_constraint? then
                                        element_type_constraint
                                    else
                                        element.type_expression.type
                                    fi;

                                if element.type_expression.check_is_not_reference(_logger, "tuple element cannot be a reference") then
                                    if !type.is_assignable_from(element.initializer.value.type) then
                                        _logger.error(element.location, "{element.initializer.value.type} is not assignable to {type}");
                                    elif element_type_constraint? /\ !element_type_constraint.is_assignable_from(element.type_expression.type) then
                                        debug("error {element.type_expression.location} {string.format(constraint_error_message, [element.type_expression.type, element_type_constraint])}");
                                        _logger.error(
                                            element.type_expression.location,
                                            string.format(constraint_error_message, [element.type_expression.type, element_type_constraint]));
                                    fi
                                fi

                                types.add(type);
                                values.add(_value_boxer.box_if_needed(element.initializer.value, type));

                            elif element_type_constraint? then
                                let type = element_type_constraint;

                                if !type.is_assignable_from(element.initializer.value.type) then
                                    debug("error {element.type_expression.location} {string.format(constraint_error_message, [element.type_expression.type, element_type_constraint])}");
                                    _logger.error(
                                        element.type_expression.location,
                                        string.format(constraint_error_message, [element.type_expression.type, element_type_constraint]));
                                fi

                                types.add(type);
                                values.add(_value_boxer.box_if_needed(element.initializer.value, type));
                            else
                                types.add(element.initializer.value.type);
                                values.add(element.initializer.value);
                            fi

                            continue;
                        fi
                    else
                        _logger.error(element.location, "tuple element must have a value");
                    fi  

                    values.add(IR.Values.DUMMY(Semantic.Types.ERROR(), element.location));
                    types.add(Semantic.Types.ERROR());

                elif Value.check_is_consumable(_logger, v.location, v.value) then
                    names.add("`{index}");

                    if element_type_constraint? then
                        let type = element_type_constraint;

                        if !type.is_assignable_from(v.value.type) then
                            debug("error {v.location} {string.format(constraint_error_message, [v.value.type, type])}");
                            _logger.error(
                                v.location,
                                string.format(constraint_error_message, [v.value.type, type]));
                        fi

                        types.add(type);
                        values.add(_value_boxer.box_if_needed(v.value, type));
                    else
                        types.add(v.value.type);
                        values.add(v.value);
                    fi
                else
                    values.add(IR.Values.DUMMY(Semantic.Types.ERROR(), v.location));
                    types.add(Semantic.Types.ERROR());
                fi
            od

            if !seen_any_named then
                names = null;
            fi

            let type = _innate_symbol_lookup.get_tuple_type(types, names);
            tuple.value = TUPLE(type, values);
        si

        pre(sequence: Trees.Expressions.SEQUENCE) -> bool is
            return true;
        si

        visit(sequence: Trees.Expressions.SEQUENCE) is
            // let mark = _logger.mark();

            try
                // _logger.speculate();

                super.pre(sequence);

                sequence.type_expression.walk(self);

                // have we been given a type constraint? if so the
                // constraint will be some kind of list type. We need
                // to extract the element type and then push that
                // type as a constraint down into each of the elements

                let element_constraint = 
                    if sequence.constraint? then
                        sequence.constraint.get_element_type();
                    else
                        null;
                    fi;

                
                if element_constraint? then
                    for e in sequence.elements do
                        e.upgrade_constraint(element_constraint, "element type {{0}} not compatible with expected type {{1}}");
                    od
                else
                    // TODO may not want to do this
                    // removing an existing constraint might 
                    // take us backwards
                    for e in sequence.elements do
                        e.clear_constraint();
                    od                        
                fi

                sequence.elements.walk(self);

                _visit(sequence);

                // _logger.commit();
            catch e: Exception
                sequence.value = DUMMY(Semantic.Types.ERROR(), sequence.location);
                // _logger.release(mark);
 
                _logger.exception(sequence.location, e, "exception compiling list literal");
            yrt
        si

        _visit(sequence: Trees.Expressions.SEQUENCE) is
            let use debug_dispose = debug_enter();
            debug("sequence {sequence} {sequence.compile_count} constraint {sequence.constraint}");

            sequence.compile_count = sequence.compile_count + 1;

            let type: Type;
            let have_explicit_type: bool;

            let elements = Collections.LIST[Trees.Expressions.Expression](sequence.elements);

            let concrete_constraint = sequence.concrete_constraint;

            if sequence.type_expression? /\ !isa Trees.TypeExpressions.INFER(sequence.type_expression) then
                // explicit element type overrides all other sources of element type
                if sequence.type_expression.type? then
                    type = sequence.type_expression.type;

                    have_explicit_type = true;
                else
                    // FIXME probably not needed - type pass will have given an error
                    _logger.error(sequence.type_expression.location, "bad explicit type expression");
                    return;
                fi
            elif concrete_constraint? then
                // next preference is a concrete type constraint
                type = concrete_constraint.get_element_type();

                assert type? else "list literal has been given a type constraint {concrete_constraint} that has no element type";

                have_explicit_type = true;
            elif elements.count == 0 then
                // if we've not been given an explicit type or a type constraint and we have no
                // elements then we can't infer a type

                _logger.error(sequence.location, "cannot infer type of list literal with no elements");

                sequence.value = DUMMY(_innate_symbol_lookup.get_array_type(Semantic.Types.ERROR()), sequence.location);

                return; 
            else
                // we have no explicit type or concrete type constraint but we do have
                // elements. attempt to infer a common element type from the element types
                // using our least upper bound heuristic

                let seen_any = false;
                let seen_error = false;
                let all_tuple_literals = elements.count > 0; // assume all tuples until proved otherwise
                let tuples_element_count = -1;
                let lub = LEAST_UPPER_BOUND_MAP();

                for v in elements do
                    if !v.is_tuple_literal then
                        all_tuple_literals = false;
                    fi

                    if v.value? /\ v.value.type? then
                        debug("value {v.value} of type {v.value.type}");
                        if v.value.check_is_consumable(_logger, v.location) then
                            if !v.value.type.is_null then
                                seen_any = true;
                                lub.add(v.value.type);
                            elif v.value.type.is_error then
                                seen_error = true;
                            else
                                _logger.warn(v.location, "is null {v.value.type.is_null}");
                            fi

                            if v.is_tuple_literal then
                                if tuples_element_count == -1 then
                                    tuples_element_count = v.value.type.arguments.count;
                                elif v.value.type.arguments.count != tuples_element_count then
                                    all_tuple_literals = false;
                                fi
                            fi
                        else
                            seen_error = true;
                        fi
                    else
                        seen_error = true;
                    fi
                od

                if type? then
                    debug("before LUB type any count is {type.any_count}");
                fi

                if !type? \/ type.any_count > 0 then
                    debug("no type: get LUB result...");

                    type = lub.get_result();

                    debug("type now {type}");

                    // FIXME factor this out - it's duplicated between here and if branches
                    if all_tuple_literals /\ (!type? \/ !type.is_value_tuple) then
                        // all the elements were tuple literals but LUB did not infer
                        // a tuple type. this means that at least some of the tuples
                        // have different element types. .NET value tuples are not
                        // naturally covariant but we can get the effect of covariance
                        // by coercing the tuple element types to the best common type

                        // we need to re-do the LUB heuristic for each tuple element type
                        // separately

                        // TODO this only handles one level of tuple-in-list nesting, which
                        // is useful as far as it goes, but ideally we'd somehow do this
                        // recursively all the way down into arbitrary nestings of tuple
                        // and list literals

                        // one LUB map per tuple element
                        let lubs = Collections.LIST[LEAST_UPPER_BOUND_MAP]();
    
                        for element in elements do
                            if !element.value? \/ !element.value.type? then
                                continue;
                            fi
    
                            for (index, e) in element.value.type.arguments | .index() do
                                if index >= lubs.count then
                                    lubs.add(LEAST_UPPER_BOUND_MAP());
                                fi
    
                                lubs[index].add(e);
                            od
                        od
   
                        type = 
                            _innate_symbol_lookup.get_tuple_type(
                                lubs |
                                    .map(l => 
                                        let r: Type = l.get_result() in if r? then r else _innate_symbol_lookup.get_object_type() fi) 
                                    .collect(),
                                lub.element_names
                            );

                        let constraint_error_message =
                            if sequence.constraint_error_message? then
                                sequence.constraint_error_message
                            else
                                // TODO maybe we should always push a contraint message
                                // down the tree even if no constraint is ever set
                                // at the moment at least the messages are always the same
                                // for a given constraint source
                                "element type {{0}} not compatible with expected type {{1}}"
                            fi;

                        sequence.upgrade_constraint(type, constraint_error_message);

                        // now push the hopefully narrower type constraint down into the sequence elements:
                        for e in sequence.elements do
                            e.upgrade_constraint(type, "element type {{0}} not compatible with inferred list type {{1}}");
                        od
                    fi
                fi

                if !type? then
                    if seen_error then
                        sequence.value = DUMMY(_innate_symbol_lookup.get_array_type(Semantic.Types.ERROR()), sequence.location);
                        return;
                    elif seen_any then
                        _logger.hint(sequence.location, "specify explicit list literal type to avoid infering object type here");
                        type = _innate_symbol_lookup.get_object_type();
                    else
                        _logger.error(sequence.location, "cannot infer type of list literal with only null elements");
   
                        sequence.value = DUMMY(_innate_symbol_lookup.get_array_type(Semantic.Types.ERROR()), sequence.location);
                        return;
                    fi
                fi
            fi

            let values = Collections.LIST[Value](sequence.elements.expressions.count);
            
            for v in sequence.elements do
                if v.value? /\ v.value.type? then
                    debug("apply type {type} to {v} of type {v.value}");

                    // FIXME should push explicit type into element as constraint and retry
                    if have_explicit_type /\ !type.is_assignable_from(v.value.type) then

                        debug("not assignable {type} from {v.value}");
                        if sequence.constraint_error_message? then
                            debug("error {v.location} {string.format(sequence.constraint_error_message, [v.value.type, type])}");

                            _logger.error(v.location, string.format(sequence.constraint_error_message, [v.value.type, type]));                            
                        else
                            _logger.error(v.location, "element type {v.value.type} not compatible with explicit type {type}");
                        fi
                    fi

                    values.add(v.value);
                else
                    values.add(DUMMY(Semantic.Types.ERROR(), v.location));
                fi
            od
                        
            sequence.value = 
                SEQUENCE(_innate_symbol_lookup.get_array_type(type), type, values);

            debug("sequence result {type} {sequence.value}");
        si        

        visit(`self: Trees.Expressions.SELF) is
            let s = current_instance_context;

            let type: Type;

            if s? then
                let f = current_function;
                
                if !f? \/ !f.is_instance then
                    _logger.error(`self.location, "cannot access self from non-instance context");
                fi

                if s.argument_names.count > 0 then
                    let arguments = Collections.LIST[Type]();

                    for n in s.argument_names do
                        let argument = s.find_member(n);

                        if argument? /\ argument.is_type_variable then
                            arguments.add(argument.type);
                        fi
                    od
                    
                    if arguments.count == s.argument_names.count then
                        type = Semantic.Types.GENERIC(
                            `self.location,
                            cast Semantic.Symbols.Classy(s),
                            arguments);
                    fi
                fi

                if s.is_value_type then
                    `self.value =
                        Load.VALUE_SELF(
                            s, type
                        );
                else
                    `self.value =
                        Load.REFERENCE_SELF(
                            s, type
                        );
                fi

                // FIXME: this breaks VSCode rename symbol: 
                // _symbol_use_locations.add_symbol_use(`self.location, s);
            else
                _logger.error(`self.location, "cannot access self from non-instance context");
            fi
        si

        visit(`super: Trees.Expressions.SUPER) is
            // FIXME:
            let s = _symbol_table.current_instance_context;

            if s? then
                if s.is_trait then
                    _logger.error(`super.location, "trait {s.description} does not have a super class");
                    
                    return;
                fi
                
                `super.value =
                    Load.SUPER(
                        s, cast Semantic.Symbols.Classy(s).ancestors[0]
                    );

                // FIXME: breaks VSCode rename symbol:
                // _symbol_use_locations.add_symbol_use(`super.location, s);
            fi
        si

        visit(`cast: Trees.Expressions.CAST) is
            `cast.value = null;

            let type = `cast.type_expression.type;

            if !type? then
                `cast.value = DUMMY(Semantic.Types.ERROR(), `cast.location);
                _logger.error(`cast.type_expression.location, "cast has no type");
                return;
            fi

            `cast.type_expression.check_is_not_reference(_logger, "cannot cast to a reference type");

            if !`cast.right.value? then
                _logger.poison(`cast.right.location, "cast has no value");

                `cast.value =
                    DUMMY(
                        type,
                        `cast.right.location
                    );

                return;
            fi

            if type.is_value_type /\ `cast.right.value.type.is_value_type then
                let instruction = _value_converter.get_instruction(type);

                if !instruction? then
                    let enum_type = _innate_symbol_lookup.get_enum_type();

                    if 
                        !enum_type.is_assignable_from(type) /\
                        !enum_type.is_assignable_from(`cast.right.value.type)
                    then
                        _logger.error(`cast.location, "cannot convert {`cast.right.value.type} to {`cast.type_expression.type}");
                    fi
                    
                    `cast.value =
                        CONVERT(
                            type,
                            `cast.right.value,
                            "conv.i4"
                        );                    
               else
                    `cast.value =
                        CONVERT(
                            type,
                            `cast.right.value,
                            instruction
                        );                    
                fi
                
                return;
            fi
            
            if type.is_value_type then
                `cast.value =
                    TYPE_WRAPPER(
                        type,
                        UNBOX(
                            `cast.right.value
                        )
                    );

                return;
            fi
            
            `cast.value =
                CAST(
                    type,
                    `cast.right.value
                );
        si

        visit(`isa: Trees.Expressions.ISA) is
            `isa.value = null;

            let isa_type = `isa.type_expression.type;

            if isa_type == null then
                _logger.error(`isa.type_expression.location, "isa has no type");
                `isa.value = DUMMY(Semantic.Types.ERROR(), `isa.location);
                return;
            fi

            let bool_type = _innate_symbol_lookup.get_bool_type();

            `isa.value =
                ISA(
                    bool_type,
                    isa_type,                     
                    `isa.right.value
                );
        si

        visit(`typeof: Trees.Expressions.TYPEOF) is
            `typeof.value = null;

            let typeof_type = `typeof.type_expression.type;

            if !typeof_type? then
                _logger.error(`typeof.type_expression.location, "typeof has no type");
                `typeof.value = DUMMY(Semantic.Types.ERROR(), `typeof.location);
                return;
            fi

            let type_type = _innate_symbol_lookup.get_type_type();

            `typeof.value =
                TYPEOF(
                    type_type,
                    typeof_type
                );
        si

        visit(`new: Trees.Expressions.NEW) is
            // TODO call resolve_constructor() instead

            `new.value = null;

            let type = `new.type_expression.type;

            if type == null then     
                _logger.poison(`new.type_expression.location, "has no type");
                `new.value = DUMMY(Semantic.Types.ERROR(), `new.location);
                return;
            fi

            if !isa Semantic.Types.NAMED(type) then
                _logger.error(`new.type_expression.location, "cannot instantiate this: {type}");
                `new.value = DUMMY(Semantic.Types.ERROR(), `new.location);
                return;
            fi

            `new.type_expression.check_is_not_void(_logger, "cannot use void type here");

            let named_type = cast Semantic.Types.NAMED(type);
            let type_symbol = named_type.symbol;

            let symbol = named_type.scope.find_direct("init");

            let function_group = cast Semantic.Symbols.FUNCTION_GROUP(symbol);

            let arguments = Collections.LIST[Value]();
            let argument_types = Collections.LIST[Type]();

            for a in `new.arguments do
                if a? /\ a.value? /\ a.value.type? /\ a.value.check_is_consumable(_logger, a.location) then
                    arguments.add(a.value);
                    argument_types.add(a.value.type);
                else
                    let t = Semantic.Types.ERROR();

                    if a? then
                        arguments.add(DUMMY(t, a.location));
                    else
                        arguments.add(DUMMY(t, `new.arguments.location));
                    fi
                    
                    argument_types.add(t);
                fi
            od

            if !function_group? then
                `new.value =
                    DUMMY(
                        type,
                        `new.location
                    );

                _logger.error(`new.location, "no constructor found init({argument_types|})");                

                return;
            fi

            let overload_result = _overload_resolver.resolve(`new.location, function_group, argument_types, false, true, true);

            if overload_result == null then
                `new.value =
                    DUMMY(
                        type,
                        `new.location
                    );
    
                return;
            fi

            let function = overload_result.function;

            let is_directly_owned = false;

            if isa Semantic.Symbols.GENERIC(type_symbol) /\ isa Semantic.Symbols.Symbol(function.owner) then
                is_directly_owned = cast Semantic.Symbols.GENERIC(type_symbol) =~ cast Semantic.Symbols.Symbol(function.owner);
            else
                is_directly_owned = type_symbol == function.owner;
            fi
            
            if !is_directly_owned then
                _logger.error(`new.location, "cannot call superclass constructor {function}");
            fi
            
            _symbol_use_locations.add_symbol_use(`new.type_expression.right_location, function);
            _symbol_use_locations.add_symbol_use(`new.type_expression.right_location, type_symbol.root_unspecialized_symbol);

            `new.value =
                NEW(
                    type,
                    function,
                    arguments
                );
        si

        // must be called with logger speculating
        resolve_constructor(location: LOCATION, left_location: LOCATION, right_location: LOCATION, type: Semantic.Types.Type, argument_expressions: Trees.Expressions.LIST) -> (Value, Value) is
            let result: Value;

            let named_type = cast Semantic.Types.NAMED(type);
            let type_symbol = named_type.symbol;

            let symbol = named_type.scope.find_direct("init");

            let function_group = cast Semantic.Symbols.FUNCTION_GROUP(symbol);

            let arguments = Collections.LIST[Value]();
            let argument_types = Collections.LIST[Type]();

            for a in argument_expressions do
                if a? /\ a.value? /\ a.value.type? /\ a.value.check_is_consumable(_logger, a.location) then
                    arguments.add(a.value);
                    argument_types.add(a.value.type);
                else
                    let t = Semantic.Types.ERROR();

                    if a? then
                        arguments.add(DUMMY(t, a.location));
                    else
                        arguments.add(DUMMY(t, argument_expressions.location));
                    fi
                    
                    argument_types.add(t);
                fi
            od

            if !function_group? then
                _logger.error(location, "no constructor found init({argument_types|})");                

                return (cast Value(DUMMY(type, location)), cast Value(DUMMY(type, location)));
            fi

            let overload_result = _overload_resolver.resolve(location, function_group, argument_types, true, true, true);

            if overload_result == null then
                return (cast Value(Load.SYMBOL(null, function_group)), cast Value(DUMMY(type, location)));
            fi

            if overload_result.score == Semantic.Types.MATCH.PARTIAL then
                // _logger.roll_back();
                // _logger.speculate();

                for (index, a) in argument_expressions | .index() do
                    // let use debug_despose = debug_enter();
                    if !a? then
                        continue;
                    elif a.value? /\ a.value.check_is_consumable(_logger, a.location) then
                        let required_argument_type = overload_result.function.arguments[index];

                        a.upgrade_constraint(required_argument_type, "actual argument type {{0}} not compatible with expected type {{1}}");

                        // FIXME shouldn't rewalk
                        a.walk(self);
                        
                        argument_types[index] = a.value.type;
                    else
                        // ensure any error messages are committed
                        a.clear_constraint();
                        // FIXME shouldn't rewalk
                        a.walk(self);
                    fi

                    arguments[index] = a.value;
                od

                // overload_result = _overload_resolver.resolve(location, function_group, argument_types, false, true, true);

                // if !overload_result? then
                //     return (cast Value(Load.SYMBOL(null, function_group)), cast Value(DUMMY(type, location)));
                // fi
            fi

            let function = overload_result.function;

            if isa Semantic.Symbols.GENERIC(function.owner) then
                type_symbol = cast Semantic.Symbols.Symbol(function.owner);
                type = function.owner.type;
            fi;

            let is_directly_owned = false;

            if isa Semantic.Symbols.GENERIC(type_symbol) /\ isa Semantic.Symbols.Symbol(function.owner) then
                is_directly_owned = cast Semantic.Symbols.GENERIC(type_symbol) =~ cast Semantic.Symbols.Symbol(function.owner);
            else
                is_directly_owned = type_symbol == function.owner;
            fi
            
            if !is_directly_owned then
                _logger.error(location, "cannot call superclass constructor {function}");
            fi

            if type.is_unsafe_constraints then
                // TODO this could result in a duplicate message if the left hand
                // side is an explicit generic specialization
                _logger.warn(left_location, "type {type} has unchecked constraints");
            fi
            
            _symbol_use_locations.add_symbol_use(right_location, function);
            _symbol_use_locations.add_symbol_use(right_location, type_symbol.root_unspecialized_symbol);

            return (cast Value(Load.SYMBOL(null, function_group)), cast Value(NEW(type, function, arguments)));
        si

        visit(unary: Trees.Expressions.UNARY) is
            unary.value = null;

            if unary.right.value? then
                let arguments = Collections.LIST[Type]([unary.right.value.type]);

                // TODO do we need to search members and globals like we do with binary operators
                // or if not, can we simplify the binary operator function search to match this?

                let function_group = find(unary.operation);

                if function_group == null \/ !isa Semantic.Symbols.FUNCTION_GROUP(function_group) then
                    _logger.error(unary.operation.location, "no unary operator {unary.operation} found");

                    unary.value = DUMMY(Semantic.Types.ERROR(), unary.location);
                    return;
                fi

                let overload_result =
                    _overload_resolver.resolve(
                        unary.location,
                        cast Semantic.Symbols.FUNCTION_GROUP(function_group),
                        arguments,
                        false,
                        unary.right.value.is_consumable, // FIXME: this doesn't seem right
                        false
                    );

                if overload_result == null then
                    unary.value = DUMMY(Semantic.Types.ERROR(), unary.location);
                    return;
                fi

                let function = overload_result.function;

                if function.is_unsafe_constraints then
                    _logger.warn(unary.location, "call to {function} has unchecked constraints");
                fi

                _symbol_use_locations.add_symbol_use(unary.operation.location, function);

                let value = function.call(unary.location, null, Collections.LIST[Value]([unary.right.value]), null, _function_caller);

                unary.right.upgrade_constraint(function.arguments[0], "{{0}} blurb {{1}}");

                unary.value = value;
            fi
        si        

        visit(binary: Trees.Expressions.BINARY) is
            try
                _visit(binary);
            catch ex: Exception
                _logger.exception(binary.location, ex, "exception compiling binary operator (called from {System.Diagnostics.StackTrace().to_string().replace_line_endings(" ")})");
            yrt            
        si

        _visit(binary: Trees.Expressions.BINARY) is
            binary.value = null;

            if !binary.left? \/ !binary.left.value? \/ !binary.right? \/ !binary.right.value? then
                binary.value = DUMMY(Semantic.Types.ERROR(), binary.location);
                return;
            fi

            let left_is_consumable = binary.left.value.check_is_consumable(_logger, binary.left.location);
            let right_is_consumable = binary.right.value.check_is_consumable(_logger, binary.right.location);
            
            let binary_function_group: Semantic.Symbols.FUNCTION_GROUP;
            let binary_overload_result: Semantic.OVERLOAD_RESOLVE_RESULT;
            let binary_errors: Logging.DIAGNOSTICS_STATE;

            let binary_name = binary.operation.name.to_string();

            let binary_function_symbol = find(binary.operation.name);

            if binary_function_symbol? /\ isa Semantic.Symbols.FUNCTION_GROUP(binary_function_symbol) then
                binary_function_group = cast Semantic.Symbols.FUNCTION_GROUP(binary_function_symbol);

                let use logger_snapshot = _logger.speculate_then_backtrack();

                binary_overload_result =
                    _overload_resolver
                        .resolve(
                            binary.location,
                            binary_function_group,
                            Collections.LIST[Type]([binary.left.value.type, binary.right.value.type]),
                            false,
                            _symbol_table.current_instance_context?,
                            false
                        );
                        
                binary_errors = logger_snapshot.backtrack();
            fi

            let member_overload_result: Semantic.OVERLOAD_RESOLVE_RESULT;
            let member_function_group: Semantic.Symbols.FUNCTION_GROUP;
            let member_errors: Logging.DIAGNOSTICS_STATE;

            if binary.left.value.type? then
                let member_function_symbol = 
                    binary.left.value.type.find_member(binary.operation.name);

                if member_function_symbol? /\ isa Semantic.Symbols.FUNCTION_GROUP(member_function_symbol) then
                    member_function_group = cast Semantic.Symbols.FUNCTION_GROUP(member_function_symbol);
    
                    let use logger_snapshot = _logger.speculate_then_backtrack();

                    member_overload_result = 
                        _overload_resolver
                            .resolve(
                                binary.location,
                                cast Semantic.Symbols.FUNCTION_GROUP(member_function_group),
                                Collections.LIST[Type]([binary.right.value.type]),
                                false,
                                binary.left.value.is_consumable,
                                false
                            );

                    member_errors = logger_snapshot.backtrack();
                fi
            fi

            let function: Semantic.Symbols.Function;

            if member_overload_result? /\ binary_overload_result? then
                if cast int(member_overload_result.score) <= cast int(binary_overload_result.score) then
                    function = member_overload_result.function;
                else
                    function = binary_overload_result.function;
                fi              
            elif member_overload_result? then
                function = member_overload_result.function;
            elif binary_overload_result? then
                function = binary_overload_result.function;
            fi
        
            if function? then
                _symbol_use_locations.add_symbol_use(binary.operation.location, function);

                let force_type: Type;
                let want_not = false;

                if binary.operation.name =~ "<>" then                        
                    if function.return_type !~ _innate_symbol_lookup.get_int_type() then
                        // FIXME: do this check on the definition:
                        _logger.error(binary.location, "<> order operator must return int");
                    fi

                    // FIXME: for non-innate implementations of <> operator, need to translate the result to bool
                    // based on actual operation

                    force_type = _innate_symbol_lookup.get_bool_type();
                elif binary.operation.name =~ "==" then
                    if 
                        left_is_consumable /\ right_is_consumable /\
                        cast int(binary.left.value.type.compare(binary.right.value.type)) > cast int(Semantic.Types.MATCH.ASSIGNABLE) /\
                        cast int(binary.right.value.type.compare(binary.left.value.type)) > cast int(Semantic.Types.MATCH.ASSIGNABLE) 
                    then
                        if binary.actual_operation =~ "==" then
                            _logger.error(binary.location, "== cannot be applied to values of non-assignable types");
                        else
                            _logger.error(binary.location, "!= cannot be applied to values of non-assignable types");
                        fi
                    fi
                elif !function.is_innate /\ binary.actual_operation =~ "!~" then
                    want_not = true;
                fi

                let value: Value;

                if function.is_unsafe_constraints then
                    _logger.warn(binary.location, "call to {function} has unchecked constraints");
                fi
                
                if function.is_instance then
                    value = function.call(binary.location, binary.left.value, Collections.LIST[Value]([binary.right.value]), force_type,_function_caller);
                else
                    value = function.call(binary.location, null, Collections.LIST[Value]([binary.left.value, binary.right.value]), force_type,_function_caller);

                    if isa Call.INNATE(value) then
                        let innate_value = cast Call.INNATE(value);

                        innate_value.actual_operation = binary.actual_operation;

                        value = innate_value.lower();
                    fi
                fi
                
                if want_not then
                    value = NOT(value);
                fi

                binary.left.upgrade_constraint(function.arguments[0], "{{0}} blurb {{1}}");
                binary.right.upgrade_constraint(function.arguments[0], "{{0}} blurb {{1}}");
                
                binary.value = value;
            else
                if binary_errors? /\ binary_errors.count > 0 then
                    _logger.merge(binary_errors);
                fi

                if member_errors? /\ member_errors.count > 0 then
                    _logger.merge(member_errors);
                fi

                if (!binary_errors? \/ binary_errors.count == 0) /\ (!member_errors? \/ member_errors.count == 0) then
                    _logger.error(binary.operation.location, "operator {binary.left.value.type} {binary.operation} {binary.right.value.type} not found");
                fi

                // FIXME QQ should probably do this
                binary.value = DUMMY(Semantic.Types.ERROR(), binary.location);
            fi
        si

        visit(index: Trees.Expressions.INDEX) is
            try
                _visit(index);
            catch e: Exception
                index.value = null;

                _logger.exception(index.location, e, "exception compiling index");
            yrt
        si

        _visit(index: Trees.Expressions.INDEX) is
            let need_store = index.value? /\ index.value.is_need_store;

            if index.left.value? /\ index.index.value? then
                let type = index.left.value.type;

                if type == null \/ type.is_error then
                    _logger.poison(index.left.location, "index left has no type");

                    index.value = DUMMY(Semantic.Types.ERROR(), index.location);
                    return;
                fi

                if !isa Semantic.Types.NAMED(type) then
                    _logger.error(index.left.location, "cannot index {type}");

                    index.value = DUMMY(Semantic.Types.ERROR(), index.location);
                    return;
                fi

                let named_type = cast Semantic.Types.NAMED(type);

                let function_name: string;
                let arguments: Collections.LIST[Value];
                let argument_types: Collections.LIST[Type];

                if need_store then
                    function_name = "set_Item";

                    let need_store_value = cast Need.STORE(index.value).value;

                    arguments = Collections.LIST[Value]([index.index.value, need_store_value]);
                    argument_types = Collections.LIST[Type]([index.index.value.type, need_store_value.type]);
                else
                    function_name = "get_Item";
                    arguments = Collections.LIST[Value]([index.index.value]);
                    argument_types = Collections.LIST[Type]([index.index.value.type]);
                fi

                let symbol = named_type.scope.find_member(function_name);

                if symbol == null then
                    if need_store then
                        if named_type.scope.find_member("get_Item")? then
                            _logger.error(index.location, "indexer is read-only in {type}");
                        else
                            _logger.error(index.location, "no indexer found in {type}");
                        fi
                    else
                        _logger.error(index.location, "no indexer found in {type}");
                    fi
                    
                    if isa Semantic.Symbols.GENERIC(named_type.scope) then
                        let g = cast Semantic.Symbols.GENERIC(named_type.scope);
                    fi
                    
                    index.value = DUMMY(Semantic.Types.ERROR(), index.location);
                    return;
                fi

                if !isa Semantic.Symbols.FUNCTION_GROUP(symbol) then
                    _logger.poison(index.index.location, "indexer is not a function group: {symbol}");
                fi

                let overload_result: Semantic.OVERLOAD_RESOLVE_RESULT;

                let use logger_snapshot = _logger.speculate_then_backtrack();

                overload_result =
                    _overload_resolver.resolve(
                        index.location,
                        cast Semantic.Symbols.FUNCTION_GROUP(symbol),
                        argument_types,
                        false,
                        true,
                        false
                    );

                logger_snapshot.backtrack();

                if overload_result == null then
                    if need_store then
                        _logger.error(index.location, "indexer [{argument_types[0]}] = {argument_types[1]} not found in {type}");
                    else
                        _logger.error(index.location, "indexer [{argument_types[0]}] not found in {type}");
                    fi

                    index.value = DUMMY(Semantic.Types.ERROR(), index.location);
                    return;
                fi

                let function = overload_result.function;

                _symbol_use_locations.add_symbol_use(
                    LOCATION(
                        index.left.location.file_name,
                        index.left.location.end_line,
                        index.left.location.end_column+1,
                        index.index.location.start_line,
                        index.index.location.end_column-1
                    ), function);

                if function.is_unsafe_constraints then
                    _logger.warn(index.location, "call to {function} has unchecked constraints");
                fi
    
                if need_store then
                    index.value = 
                    TYPE_WRAPPER(
                        function.arguments[1],
                        function.call(index.location, index.left.value, arguments, null, _function_caller));
                else
                    index.value = function.call(index.location, index.left.value, arguments, null, _function_caller);
                fi
            fi
        si

        visit(member: Trees.Expressions.MEMBER) is
            let need_store = member.value? /\ isa Need.STORE(member.value);
            let need_deref = false;
            
            if member.identifier == null then
                member.value = DUMMY(Semantic.Types.ERROR(), member.location);
                return;
            fi

            if member.left? /\ member.left.value? then
                let type = member.left.value.type;

                if type == null then
                    _logger.poison(member.left.location, "member left has no type");

                    member.value = DUMMY(Semantic.Types.ERROR(), member.location);
                    return;
                fi

                // TODO we could loop here to handle multiple levels of dereferencing
                if type.is_ref then
                    need_deref = true;
                    type = type.get_element_type();

                    member.left.value = DEREF(member.left.value, type);
                fi

                if !isa Semantic.Types.NAMED(type) then
                    if !isa Semantic.Types.ERROR(type) then
                        _logger.poison(member.left.location, "type has no members: {type}");
                    fi
                    
                    member.value = DUMMY(Semantic.Types.ERROR(), member.location);
                    return;
                fi

                let named_type = cast Semantic.Types.NAMED(type);

                if named_type.scope == null then
                    _logger.poison(member.left.location, "member left type has no type: {type}");

                    member.value = DUMMY(Semantic.Types.ERROR(), member.location);
                    return;
                fi

                let symbol = named_type.scope.find_member(member.identifier.name);

                if !symbol? then
                    _logger.error(member.identifier.location, "member {member.identifier.name} not found in {named_type}");

                    member.value = DUMMY(Semantic.Types.ERROR(), member.location);
                    return;
                fi

                _symbol_use_locations.add_symbol_use(member.identifier.right_location, symbol);

                if symbol.is_instance /\ !member.left.value.is_consumable then
                    _logger.error(member.identifier.location, "cannot access instance member {member.identifier.name} in {named_type}");                    
                fi

                _symbol_loader.find_symbol = 
                    (name: string) is
                        let result = named_type.scope.find_member(name);

                        return result;
                    si;

                let value: Value;

                if need_store then
                    let store_value = cast Need.STORE(member.value).value;

                    if check_store_access(member.location, member.left.value, symbol, named_type) then
                        value = symbol.store(member.location, member.left.value, store_value, _symbol_loader, false);
                    fi
                else
                    if check_load_access(member.location, member.left.value, symbol, named_type) then
                        value = symbol.load(member.location, member.left.value, _symbol_loader);
                    fi
                fi

                member.value = value;
            fi
        si

        check_load_access(location: LOCATION, from: Value, symbol: Semantic.Symbols.Symbol, type: Type) -> bool is
            if symbol.is_public_readable then
                return true;
            fi

            if from? /\ from.is_self then
                return true;
            fi

            let instance_context = _symbol_table.current_instance_context;

            if instance_context? /\ instance_context.type.is_assignable_from(type) then
                return true;
            fi

            _logger.error(location, "{symbol} is not publicly readable");

            return false;            
        si        

        check_store_access(location: LOCATION, from: Value, symbol: Semantic.Symbols.Symbol, type: Type) -> bool is
            if !symbol.is_private /\ !symbol.is_field then
                return true;
            fi

            if from? /\ from.is_self then
                return true;
            fi

            let instance_context = _symbol_table.current_instance_context;

            if instance_context? /\ instance_context.type.is_assignable_from(type) then
                return true;
            fi

            _logger.error(location, "{symbol} is not publicly assignable");

            return false;
        si

        visit(explicit_specialization: Trees.Expressions.EXPLICIT_SPECIALIZATION) is
            if 
                !explicit_specialization.left? \/
                !explicit_specialization.left.value? \/
                !explicit_specialization.left.value.type? \/
                !explicit_specialization.left.value.type.symbol? \/
                !explicit_specialization.types?
            then
                explicit_specialization.value = DUMMY(Semantic.Types.ERROR(), explicit_specialization.location);

                return;
            fi

            if !explicit_specialization.left.value.has_symbol then
                _logger.error(explicit_specialization.location, "can't explicitly specialize this");
                return;
            fi

            let symbol = explicit_specialization.left.value.symbol;

            symbol = 
                symbol.try_specialize(
                    explicit_specialization.location,
                    _logger,
                    explicit_specialization.types.elements | 
                        .map(t => t.type).collect()
                );

            let from: IR.Values.Value;

            if isa IR.Values.Load.SYMBOL(explicit_specialization.left.value) then
                let load = cast IR.Values.Load.SYMBOL(explicit_specialization.left.value);

                from = load.from;
            fi

            if symbol? then
                explicit_specialization.value =
                    IR.Values.Load.SYMBOL(from, symbol);
            else
                explicit_specialization.value = DUMMY(Semantic.Types.ERROR(), explicit_specialization.location);
            fi
        si

        pre(ambiguous_expression: Trees.Expressions.AMBIGUOUS_EXPRESSION) -> bool is
            if ambiguous_expression.result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.INDEX then
                if ambiguous_expression.value? /\ ambiguous_expression.value.is_need_store then
                    ambiguous_expression.index.value = ambiguous_expression.value;
                fi

                ambiguous_expression.index.walk(self);

                ambiguous_expression.value = ambiguous_expression.index.value;

                return true;
            fi

            let arg = ambiguous_expression.type_arguments.elements[0];

            arg.walk(self);

            let symbol: Semantic.Symbols.Symbol;

            if ambiguous_expression.left? then
                ambiguous_expression.left.walk(self);

                if ambiguous_expression.left.value? then
                    symbol = ambiguous_expression.left.value.type.find_member(ambiguous_expression.identifier.name);

                    // find member will not report an error for not found
                    if !symbol? then
                        _logger.error(ambiguous_expression.identifier.location, "member {ambiguous_expression.identifier.name} not found in {ambiguous_expression.left.value.type}");
                    fi
                fi
            else
                symbol = find(ambiguous_expression.identifier);
            fi
            
            if !symbol? then
                return true;
            fi

            _symbol_use_locations.add_symbol_use(ambiguous_expression.identifier.location, symbol);

            let result_type: Semantic.Types.Type;
            let result_symbol: Semantic.Symbols.Symbol;

            if symbol.is_type then
                ambiguous_expression.result = Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.TYPE;
                result_type = 
                    specialize_type(
                        ambiguous_expression.location,
                        symbol,
                        ambiguous_expression.type_arguments
                    );
            elif symbol.is_function \/ symbol.is_function_group then
                ambiguous_expression.result = Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.FUNCTION;
                result_symbol = 
                    specialize_symbol(
                        ambiguous_expression.location,
                        symbol,
                        ambiguous_expression.type_arguments
                    );
            else
                _logger.error(ambiguous_expression.location, "cannot apply type arguments here");
                return true;
            fi

            let result = ambiguous_expression.result;

            if result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.UNKNOWN then
                // we didn't resolve what this was in the resolve type expressions phase
                // don't report another error here, just produce a propagating error value:
                ambiguous_expression.value = DUMMY(Semantic.Types.ERROR(), ambiguous_expression.location);
            elif result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.INDEX then
                // if the ambiguous expression resolved to an indexer
                // call then walk that
                ambiguous_expression.index.walk(self);

                // our value is whatever value the index expression produced
                ambiguous_expression.value = ambiguous_expression.index.value;
            elif result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.TYPE then
                ambiguous_expression.value = TYPE_EXPRESSION(result_type, ambiguous_expression.location);
            elif result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.FUNCTION then
                let left_value: Value =
                    if ambiguous_expression.left? then
                        ambiguous_expression.left.value;
                    else
                        null
                    fi;

                ambiguous_expression.value = result_symbol.load(ambiguous_expression.location, left_value, _symbol_loader);
            else 
                assert false else "result variant is something unexpected {result}";
            fi

            return true;
        si

        visit(ambiguous_expression: Trees.Expressions.AMBIGUOUS_EXPRESSION) is
        si

        pre(generic_application: Trees.Expressions.GENERIC_APPLICATION) -> bool is
            generic_application.type_arguments.walk(self);

            let symbol: Semantic.Symbols.Symbol;

            if generic_application.left? then
                generic_application.left.walk(self);

                if generic_application.left.value? then
                    symbol = generic_application.left.value.type.find_member(generic_application.identifier.name);

                    // find member will not report an error for not found
                    if !symbol? then
                        _logger.error(generic_application.identifier.location, "member {generic_application.identifier.name} not found in {generic_application.left.value.type}");
                    fi
                fi
            else
                // find will report an error for not found
                symbol = find(generic_application.identifier);
            fi
            
            if !symbol? then
                return true;
            fi

            _symbol_use_locations.add_symbol_use(generic_application.identifier.location, symbol);

            let result_type: Semantic.Types.Type;
            let result_symbol: Semantic.Symbols.Symbol;

            if symbol.is_type then
                generic_application.result = Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.TYPE;

                result_type = 
                    specialize_type(
                        generic_application.location,
                        symbol,
                        generic_application.type_arguments
                    );
            elif symbol.is_function \/ symbol.is_function_group then
                generic_application.result = Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.FUNCTION;

                result_symbol = 
                    specialize_symbol(
                        generic_application.location,
                        symbol,
                        generic_application.type_arguments
                    );
            else
                _logger.error(generic_application.location, "cannot apply type arguments here");
                return true;
            fi

            let result = generic_application.result;

            if result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.UNKNOWN then
                // we didn't resolve what this was in the resolve type expressions phase
                // don't report another error here, just produce a propagating error value:
                generic_application.value = DUMMY(Semantic.Types.ERROR(), generic_application.location);
            elif result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.TYPE then
                generic_application.value = TYPE_EXPRESSION(result_type, generic_application.location);
            elif result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.FUNCTION then
                let left_value: Value =
                    if generic_application.left? then
                        generic_application.left.value;
                    else
                        null
                    fi;

                generic_application.value = result_symbol.load(generic_application.location, left_value, _symbol_loader);
            else 
                assert false else "result is something unexpected {result}";
            fi

            return true;
        si

        visit(generic_application: Trees.Expressions.GENERIC_APPLICATION) is
        si

        pre(left: Trees.Variables.SIMPLE_VARIABLE_LEFT) -> bool is
            return false;
        si

        visit(left: Trees.Variables.SIMPLE_VARIABLE_LEFT) is
            let use debug_dispose = debug_enter();
            let symbol = find(left.name);
    
            if symbol? /\ isa Semantic.Types.SettableTyped(symbol) then
                debug("variable left {symbol}");


                symbol.define();

                let right_location =
                    if left.right_location? then
                        left.right_location;
                    else
                        left.location;
                    fi;

                if symbol.type == null \/ symbol.type.is_inferred \/ symbol.type.any_count > 0 then
                    let typed_symbol = cast Semantic.Types.SettableTyped(symbol);
                    debug("symbol type is null ({symbol.type == null}) or inferred ({symbol.type.is_inferred}) or any ({symbol.type.any_count})");
                    if left.explicit_type? then
                        debug("have explicit type {left.explicit_type}");
                        typed_symbol.set_type(left.explicit_type);
                    elif left.right_value? then
                        debug("have initializer {left.right_value}");

                        if Value.check_is_consumable(_logger, right_location, left.right_value) then
                            debug("is consumable {left.right_value}");
                            typed_symbol.set_type(symbol.try_get_inferred_type(symbol.location, _logger));

                            debug("type is now {symbol.type}");

                            symbol.add_constraint(left.right_value.type);
                        else
                            debug("type is error");
                            typed_symbol.set_type(Semantic.Types.ERROR());                            
                        fi
                    else
                        debug("neither explicit type or initializer");
                        typed_symbol.set_type(symbol.try_get_inferred_type(symbol.location, _logger));
                        debug("type is now {symbol.type}");
                    fi
                elif
                    left.explicit_type? /\
                    left.right_value? /\
                    Value.check_is_consumable(_logger, right_location, left.right_value)
                then
                    debug("have explicit type and initializer");
                    if
                        !left.explicit_type.is_assignable_from(left.right_value.type)
                    then
                        _logger.error(
                            left.variable_location, 
                            "{left.right_value.type} is not assignable to {left.explicit_type}");
                    fi
                else
                    debug("something else: type {symbol.type} is inferred {symbol.type.is_inferred} explicit type {left.explicit_type} right value {left.right_value}");
                fi

                if left.right_value? then
                    left.value = symbol.store(left.location, null, left.right_value, _symbol_loader, true);
                fi

                if !symbol.type? \/ symbol.type.is_inferred \/ symbol.type.any_count > 0 then
                    _logger.mark_consumed_any();
                fi
            else
                _logger.error(left.name.location, "couldn't find typed symbol for variable {left.name}");
            fi
        si

        pre(left: Trees.Variables.DESTRUCTURING_VARIABLE_LEFT) -> bool is
            let from = left.right_value;

            if !from? then
                _logger.error(left.location, "cannot destructure without initializer");
                return true;
            fi

            let from_type =
                if left.explicit_type? then
                    left.explicit_type;
                else
                    from.type;
                fi;

            if !from_type? then
                _logger.error(left.location, "oops: null type");

                from_type = Semantic.Types.ERROR();
            fi

            let from_types =
                if from_type.is_value_tuple then
                    from_type.arguments;
                else
                    get_conventionally_named_destructure_member_types(from_type);
                fi;

            if from_types.count == 0 then
                _logger.error(left.location, "cannot destructure {from_type}");
                return true;
            fi

            let elements = left.elements;
            let count = elements.count;

            if count != from_types.count then
                _logger.error(left.location, "expected {count} destructuring elements but found {from_types.count}");

                if count > from_types.count then
                    count = from_types.count;
                fi
            fi

            let block = IR.Values.BLOCK();
            let get_from = from.get_temp_copier(block, "destructure");

            for i in 0..count do
                let element = elements[i];
                assert element? else "missing destructure element {i}";

                let member = from_type.find_destructure_member(i);
                assert member? else "missing destructure member {i} in {from_type} of {from_type.get_type()}";

                element.right_value = member.load(LOCATION.internal, get_from(), _symbol_loader);

                element.variable_location = left.variable_location;
                element.right_location = left.right_location;

                element.walk(self);

                if element.value? then
                    block.add(element.value);
                fi
            od

            block.close();

            left.value = block;

            return true;
        si

        visit(destructure_left: Trees.Variables.DESTRUCTURING_VARIABLE_LEFT) is
        si

        pre(variable: Trees.Variables.VARIABLE) -> bool is
            if variable.type_expression? then
                variable.type_expression.walk(self);

                // push explicit type down into the variable left
                if variable.is_explicit_type /\ variable.type_expression.type? then
                    variable.left.explicit_type = variable.type_expression.type;
                fi
            fi

            if variable.initializer? then
                let want_upgrade_constraint_from_value_type = true;

                if variable.type_expression? /\ variable.type_expression.type? /\ !isa Trees.TypeExpressions.INFER(variable.type_expression) then
                    // if we have both an explicit type and an initializer, we
                    // can push a type constraint down into the initializer

                    want_upgrade_constraint_from_value_type = false;
                    variable.initializer.upgrade_constraint(variable.type_expression.type, "{{0}} is not assignable to {{1}}");
                fi

                variable.initializer.walk(self);

                // push the initializer value down into the variable left
                if variable.initializer.value? then
                    variable.left.right_value = variable.initializer.value;

                    if want_upgrade_constraint_from_value_type then
                        variable.initializer.upgrade_constraint(variable.initializer.value.type, "{{0}} is not assignable to {{1}}");
                    fi
                else
                    variable.left.right_value = IR.Values.DUMMY(Semantic.Types.ERROR(), variable.initializer.location);
                fi

                variable.left.variable_location = variable.location;
                variable.left.right_location = variable.initializer.location;
            fi

            if 
                !variable.is_poisoned /\ 
                (!variable.type_expression? \/ isa Trees.TypeExpressions.INFER(variable.type_expression))
                /\ !variable.initializer?
            then
                // _logger.error(variable.location, "variable must have explict type or initializer");
            fi

            variable.left.walk(self);

            return true;
        si

        visit(variable: Trees.Variables.VARIABLE) is
        si

        // TODO used by for loop - needs removing
        set_symbol_type(left: Trees.Variables.VariableLeft, type: Type) is
            if !left? then
                return;
            fi

            if left.is_simple_name then
                let symbol = find(left.name);

                if symbol? /\ isa Semantic.Types.SettableTyped(symbol) then
                    let typed_symbol = cast Semantic.Types.SettableTyped(symbol);

                    symbol.define();

                    typed_symbol.set_type(type);
                else
                    _logger.error(left.location, "couldn't find typed symbol for variable {left.name}");
                fi
            else
                set_symbol_destructure_types(left, type);
            fi
        si

        // TODO used by for loop - needs removing
        set_symbol_destructure_types(left: Trees.Variables.VariableLeft, from_type: Type) is
            if !from_type? then
                return;
            fi

            let from_types: Collections.List[Type];

            if from_type.is_value_tuple then
                from_types = from_type.arguments;
            else
                from_types = get_conventionally_named_destructure_member_types(from_type);
            fi

            if from_types.count == 0 then
                _logger.error(left.location, "cannot destructure {from_type}");
                return;
            fi

            let elements = left.elements;

            let count = elements.count;

            if elements.count != from_types.count then
                _logger.error(left.location, "expected {elements.count} destructuring elements but found {from_types.count}");

                if elements.count > from_types.count then
                    count = from_types.count;
                fi
            fi

            for i in 0..count do
                let element = elements[i];
                let type = from_types[i];

                if !element? then
                    return;
                elif element? /\ element.is_simple_name then
                    let symbol = find(element.name);

                    if symbol? /\ isa Semantic.Types.SettableTyped(symbol) then
                        let typed_symbol = cast Semantic.Types.SettableTyped(symbol);

                        symbol.define();

                        typed_symbol.set_type(type);
                    else
                        _logger.error(element.location, "couldn't find typed symbol for destructuring element {element.name}");
                    fi
                else
                    set_symbol_destructure_types(element, type);
                fi
            od
        si
        
        // TODO used by for loop - needs removing
        get_destructure_types(type: Type) -> Collections.List[Type] is
            let result = Collections.LIST[Type]();

            if !type? \/ !type.is_value_tuple then
                return result;                
            fi

            get_destructure_types_into(type, result);

            return result;
        si
        
        // TODO used by for loop - needs removing
        get_destructure_types_into(type: Type, into: Collections.MutableList[Type]) is
            let result = Collections.LIST[Type]();

            for t in type.arguments do
                if t.is_value_tuple then
                    get_destructure_types_into(t, into);
                else
                    into.add(t);
                fi
            od
        si

        visit(integer: Trees.Expressions.Literals.INTEGER) is
            let type: Type;
            let suffix = "i4";

            let value_string = integer.value_string;
            let conv: string;

            let last_char = value_string.get_chars(value_string.length-1);

            if "bBcCsSiIlLwWuU".contains(last_char) then
                let is_unsigned = false;

                let cutoff = value_string.length;

                if last_char == 'u' \/ last_char == 'U' then
                    is_unsigned = true;

                    cutoff = cutoff - 1;
                elif value_string.length > 2 then
                    let sign_char = value_string.get_chars(value_string.length - 2);

                    if sign_char == 'u' \/ sign_char == 'U' then
                        is_unsigned = true;

                        cutoff = cutoff - 1;
                    elif sign_char == 's' \/ sign_char == 'S' then
                        cutoff = cutoff - 1;
                    fi
                fi

                case last_char
                when 'b', 'B': 
                    if is_unsigned then
                        type = _innate_symbol_lookup.get_ubyte_type();
                    else
                        type = _innate_symbol_lookup.get_byte_type();
                    fi
                    
                    cutoff = cutoff - 1;

                when 'c', 'C':
                    if is_unsigned then
                        _logger.error(integer.location, "numeric character literal cannot be unsigned");
                    else
                        type = _innate_symbol_lookup.get_char_type();
                    fi

                    cutoff = cutoff - 1;

                when 's', 'S':
                    if is_unsigned then
                        type = _innate_symbol_lookup.get_ushort_type();
                    else
                        type = _innate_symbol_lookup.get_short_type();
                    fi

                    cutoff = cutoff - 1;

                when 'i', 'I':
                    if is_unsigned then
                        type = _innate_symbol_lookup.get_uint_type();
                    else
                        type = _innate_symbol_lookup.get_int_type();
                    fi

                    cutoff = cutoff - 1;

                when 'l', 'L':
                    suffix = "i8";

                    if is_unsigned then
                        type = _innate_symbol_lookup.get_ulong_type();
                    else
                        type = _innate_symbol_lookup.get_long_type();
                    fi

                    cutoff = cutoff - 1;

                when 'w', 'W':
                    suffix = "i8";

                    if is_unsigned then
                        type = _innate_symbol_lookup.get_uword_type();
                        conv = "conv.u";
                    else
                        type = _innate_symbol_lookup.get_word_type();
                        conv = "conv.i";
                    fi

                    cutoff = cutoff - 1;

                default
                    if is_unsigned then
                        type = _innate_symbol_lookup.get_uint_type();
                    else
                        type = _innate_symbol_lookup.get_int_type();
                    fi
                esac

                value_string = value_string.substring(0, cutoff);
            else
                type = _innate_symbol_lookup.get_int_type();                
            fi 
            
            integer.value = Literal.NUMBER(
                value_string,
                type,
                suffix,
                conv
            );
        si

        visit(float: Trees.Expressions.Literals.FLOAT) is
            let type: Type;
            let suffix: string;

            let value_string = float.value_string;

            if
                value_string.ends_with('D') \/
                value_string.ends_with('d')
            then
                type = _innate_symbol_lookup.get_double_type();
                suffix = "r8";
            else
                type = _innate_symbol_lookup.get_single_type();
                suffix = "r4";
            fi
            
            float.value = Literal.NUMBER(
                value_string.substring(0, value_string.length -1),
                type,
                suffix
            );
        si

        visit(interpolation: Trees.Expressions.STRING_INTERPOLATION) is
            interpolation.value = IR.Values.BLOCK(_innate_symbol_lookup.get_string_type());
        si

        visit(`string: Trees.Expressions.Literals.STRING) is
            `string.value = Literal.STRING(
                `string.value_string,
                _innate_symbol_lookup.get_string_type()
            );
        si        

        visit(character: Trees.Expressions.Literals.CHARACTER) is
            let value_string = character.value_string;
            let c: int = 0;

            if value_string.length < 1 \/ value_string.length > 1 then
                _logger.error(character.location, "invalid character literal");
            else
                c = cast int(value_string.get_chars(0));
            fi
            
            character.value = Literal.NUMBER(
                "{c}",
                _innate_symbol_lookup.get_char_type(),
                "i4"
            );
        si

        visit(boolean: Trees.Expressions.Literals.BOOLEAN) is
            let value_string = boolean.value_string;

            let value: string;

            if value_string =~ "true" then
                value = "1";
            elif value_string =~ "false" then
                value = "0";
            else
                throw System.Exception("invalid value for boolean literal: {value_string}");
            fi
                        
            boolean.value = Literal.NUMBER(
                value,
                _innate_symbol_lookup.get_bool_type(),
                "i4"
            );
        si

        pre(call: Trees.Expressions.CALL) -> bool is
            return true;
        si

        visit(call: Trees.Expressions.CALL) is
            let mark = _logger.mark();

            try
                // _logger.speculate();

                super.pre(call);

                call.arguments.walk(self);
                call.function.walk(self);

                _visit(call);

                // _logger.commit();
            catch e: Exception
                call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                _logger.release(mark);
 
                _logger.exception(call.location, e, "exception compiling call");
            yrt
        si

        _visit(call: Trees.Expressions.CALL) is
            if !call.function.value? \/ !call.function.value.type? then
                call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                return;
            fi

            let use debug_dispose = debug_enter();
            debug("compile call {call.to_string().replace_line_endings(" ")}");
            
            let location = call.arguments.location;

            if call.function.value.is_type_expression then
                (call.function.value, call.value) = resolve_constructor(location, call.function.location, call.right_location, call.function.value.type, call.arguments);

                return;
            fi

            let arguments = Collections.LIST[Value]();
            let argument_types = Collections.LIST[Type]();

            let buffer: IO.TextWriter;

            let outer_state: (writer: IO.TextWriter, error_count: int);

            for (index, a) in call.arguments | .index() do
                if a? then
                    debug("arg #{index} {a.to_string().replace_line_endings(" ")}");
                fi

                if a? /\ a.value? /\ a.value.type? /\ a.value.check_is_consumable(_logger, a.location) then
                    a.upgrade_constraint(a.value.type, "{{0}} blah {{1}}");

                    arguments.add(a.value);
                    argument_types.add(a.value.type);
                    debug("arg #{index} value has type {a.value.type} (from {a.value})");

                elif a? /\ a.constraint? /\ a.constraint.any_count == 0 then
                    // FIXME need to check type compatibility 
                    arguments.add(a.value);
                    argument_types.add(a.constraint);
                    debug("arg #{index} already constrained to {a.constraint}");
                elif a? /\ a.value? /\ a.value.type? /\ a.value.check_is_consumable(_logger, a.location) then
                    arguments.add(a.value);
                    argument_types.add(a.value.type);
                    debug("arg #{index} value has type {a.value.type} (from {a.value})");
                else
                    let t = Semantic.Types.ERROR();

                    if a? then
                        arguments.add(DUMMY(t, a.location));
                    else
                        arguments.add(DUMMY(t, call.arguments.location));
                    fi
                    
                    argument_types.add(t);
                fi
            od

            debug("have argument types {argument_types|}");

            let load_symbol: Semantic.Symbols.Symbol;

            // TODO factor out common parts from this and resolve constructor
            if isa Load.SYMBOL(call.function.value) then
                let load = cast Load.SYMBOL(call.function.value);
                load_symbol = load.symbol;

                if load_symbol? /\ load_symbol.is_function_group then
                    let want_instance: bool;

                    want_instance = 
                        if load.from? then 
                            load.from.is_consumable
                        else 
                            _symbol_table.current_instance_context?
                        fi;

                    
                    let function_group = cast Semantic.Symbols.FUNCTION_GROUP(load_symbol);
                    let overload_result = _overload_resolver.resolve(location, function_group, argument_types, true, want_instance, false);

                    if overload_result == null then
                        call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                        return;
                    fi

                    debug("overload result {overload_result}");

                    if overload_result.score == Semantic.Types.MATCH.PARTIAL then
                        debug("partial result {overload_result} try again");

                        // _logger.roll_back();
                        // _logger.speculate();                            

                        for (index, a) in call.arguments | .index() do
                            debug("arg #{index} {a}...");

                            if !a? then
                                debug("bad arg");
                                continue;
                            elif a.value? /\ a.value.check_is_consumable(_logger, a.location) then
                                debug("have a consumable arg value");

                                let required_argument_type = overload_result.function.arguments[index];

                                debug("arg #{index} {a.to_string().replace_line_endings(" ")} set constraint {required_argument_type}");

                                a.upgrade_constraint(required_argument_type, "actual argument type {{0}} not compatible with expected type {{1}}");

                                // TODO need to ensure a is walked again but not yet
                                // a.walk(self);
                                
                                // assume that when we re-walk the argument, the constraint will be applied
                                // argument_types[index] = argument_constraint;
                            else
                                a.clear_constraint();
                                // a.walk(self);
                            fi

                            arguments[index] = a.value;
                        od
                    fi

                    if !overload_result? then
                        debug("no overload result");
                        call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                        // caller will commit any error messages
                        return;
                    fi

                    let function = overload_result.function;

                    if function.is_unsafe_constraints then
                        _logger.warn(call.location, "call to {function} has unchecked constraints");
                    fi    

                    _symbol_use_locations.add_symbol_use(call.function.right_location, function);

                    call.value = function.call(call.function.location, load.from, arguments, null, _function_caller);
                    return;
                fi
            fi

            let function_type = call.function.value.type;

            if function_type? /\ function_type.is_error then
                debug("function type is error: cannot call");
                call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                return;
            elif !function_type? \/ !isa Semantic.Types.NAMED(function_type) then
                debug("function type is null or not a type {function_type}: cannot call");

                _logger.error(call.function.location, "cannot call value of non-function type {call.function.value.type}");
                call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                return;
            fi

            let function_generic_type = cast Semantic.Types.NAMED(function_type);

            let function_type_arguments = function_generic_type.arguments;

            debug("function argument types {function_type_arguments}");

            if function_type.is_action then
                if function_type_arguments.count != arguments.count then
                    debug("wrong number of arguments");
                    _logger.error(
                        call.arguments.location, 
                        "expected {function_type_arguments.count} arguments but {arguments.count} supplied");
                    call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                    return;
                fi
            elif function_type.is_function then
                if function_type_arguments.count != arguments.count + 1 then
                    debug("wrong number of arguments");
                    _logger.error(
                        call.arguments.location, 
                        "expected {function_type_arguments.count - 1} arguments but {arguments.count} supplied");
                    call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                    return;
                fi
            else
                if load_symbol? /\ load_symbol.is_type then
                    debug("maybe constructor {load_symbol}");
                    (call.function.value, call.value) = resolve_constructor(location, call.function.location, call.right_location, load_symbol.type, call.arguments);
                else
                    debug("not a function type {function_type}");
                    _logger.error(call.function.location, "cannot call value of non-function type {call.function.value.type}");
                    call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                fi

                return;                    
            fi

            let ok = true;

            for i in 0..arguments.count do
                if cast int(function_generic_type.arguments[i].compare(argument_types[i])) > cast int(Semantic.Types.MATCH.CONVERTABLE)
                then
                    debug("bad argument #{i} {function_generic_type.arguments[i]} vs {argument_types[i]}");

                    ok = false;
                    _logger.error(call.arguments.expressions[i].location, "expected argument of type {function_type_arguments[i]} but {argument_types[i]} supplied");
                fi
            od

            if !ok then
                debug("unusable result");
                call.value = DUMMY(Semantic.Types.ERROR(), call.location);
                return;
            fi

            let result_type =
                if function_type.is_action then                    
                    _innate_symbol_lookup.get_void_type();
                else
                    function_generic_type.arguments[function_type_arguments.count - 1];
                fi;

            debug("closure call args {function_generic_type.arguments|} result type {result_type}");

            call.value =
                Call.CLOSURE(
                    call.function.value,
                    result_type,
                    function_type.is_action,
                    function_generic_type,
                    arguments
                );
        si

        visit(identifier: Trees.Expressions.IDENTIFIER) is
            let mark = _logger.mark();
            
            try
                _visit(identifier);

            catch ex: Exception
                _logger.release(mark);
                _logger.exception(identifier.location, ex, "something went wrong with identifier");

            finally 
                _logger.release(mark);
            yrt            
        si

        _visit(identifier: Trees.Expressions.IDENTIFIER) is
            let need_store = identifier.value? /\ isa Need.STORE(identifier.value);
        
            let symbol = find(identifier.identifier);

            if symbol.is_local_variable /\ identifier.concrete_constraint? then
                symbol.add_constraint(identifier.constraint);
            fi

            if symbol? then
                _symbol_use_locations.add_symbol_use(identifier.right_location, symbol);

                if symbol.is_type then
                    identifier.value = TYPE_EXPRESSION(symbol.type, identifier.location);
                else
                    _symbol_loader.find_symbol = (name: string) => find(name);

                    if need_store then
                        let store_value = cast Need.STORE(identifier.value).value;
                        identifier.value = symbol.store(identifier.location, null, store_value, _symbol_loader, false);
                    else
                        identifier.value = symbol.load(identifier.location, null, _symbol_loader);
                    fi    
                fi

            else
                identifier.value = DUMMY(Semantic.Types.ERROR(), identifier.location);
            fi                
        si

        visit(has_value: Trees.Expressions.HAS_VALUE) is

            if !has_value.left? then
                _logger.poison(has_value.location, "has value expression has no left expression");
                has_value.value = DUMMY(_innate_symbol_lookup.get_bool_type(), has_value.location);
                return;
            elif !has_value.left.value? then
                _logger.poison(has_value.left.location, "has value expression has no value");
                has_value.value = DUMMY(_innate_symbol_lookup.get_bool_type(), has_value.location);
                return;                
            fi

            if 
                !has_value.left.value.check_is_consumable(_logger, has_value.left.location)
            then
                _logger.error(has_value.left.location, "cannot use this here");
                has_value.value = DUMMY(_innate_symbol_lookup.get_bool_type(), has_value.location);
                return;
            fi

            let has_value_member = has_value.left.value.type.find_member("has_value");

            if !has_value.left.value.type.is_value_type then
                has_value.value = HAS_VALUE(has_value.left.value, _innate_symbol_lookup.get_bool_type());               
            elif has_value_member? then
                has_value.value = has_value_member.load(has_value.location, has_value.left.value, _symbol_loader);
            else
                _logger.error(has_value.left.location, "must be a reference type or provide a has_value property");
                has_value.value = DUMMY(_innate_symbol_lookup.get_bool_type(), has_value.location);
            fi
        si

        visit(unwrap: Trees.Expressions.UNWRAP) is
            if !unwrap.left? then
                _logger.poison(unwrap.location, "unwrap expression has no left expression");
                unwrap.value = DUMMY(Semantic.Types.ERROR(), unwrap.location);
                return;
            elif !unwrap.left.value? then
                _logger.poison(unwrap.left.location, "unwrap expression has no value");
                unwrap.value = DUMMY(Semantic.Types.ERROR(), unwrap.location);
                return;                
            fi

            if 
                !unwrap.left.value.check_is_consumable(_logger, unwrap.left.location)
            then
                _logger.error(unwrap.left.location, "cannot use this here");
                unwrap.value = DUMMY(Semantic.Types.ERROR(), unwrap.location);
                return;
            fi

            let value_member = unwrap.left.value.type.find_member("value");

            if !unwrap.left.value.type.is_value_type then
                // on a reference type, it's a no-op
                // TODO we could do an explicit null check here: 
                unwrap.value = unwrap.left.value;
            elif value_member? then
                // TODO we could do an explicit has-value check here:
                unwrap.value = value_member.load(unwrap.location, unwrap.left.value, _symbol_loader);
            else
                _logger.error(unwrap.left.location, "must be a reference type or provide a value property");
                unwrap.value = DUMMY(Semantic.Types.ERROR(), unwrap.location);
            fi

            // TODO, we could handle ref and ptr here as well
        si

        visit(reference: Trees.Expressions.REFERENCE) is
            if !reference.left? then
                _logger.poison(reference.location, "reference expression has no left expression");
                reference.value = DUMMY(Semantic.Types.ERROR(), reference.location);
                return;
            elif !reference.left.value? \/ !reference.left.value.type? then
                _logger.poison(reference.left.location, "reference expression has no value");
                reference.value = DUMMY(Semantic.Types.ERROR(), reference.location);
                return;                
            elif !reference.left.value.has_address then
                _logger.warn(reference.left.location, "reference to an expression");                
            fi

            reference.left.value.check_is_consumable(_logger, reference.left.location);
            
            reference.value = ADDRESS(reference.left.value, _innate_symbol_lookup.get_reference_type(reference.left.value.type));
        si
        
        visit(`null: Trees.Expressions.NULL) is
            `null.value = NULL(Semantic.Types.NULL());
        si

        pre(statement: Trees.Expressions.STATEMENT) -> bool is
            super.pre(statement);

            statement.statement.want_value = true;

            return false;
        si

        visit(statement: Trees.Expressions.STATEMENT) is
            if !statement.statement.value? then
                _logger.warn(statement.location, "statement expression has no value");                  
            fi

            statement.value = statement.statement.value;
        si

        pre(list: Trees.Statements.LIST) -> bool is
            super.pre(list);
            return true;
        si

        visit(list: Trees.Statements.LIST) is
            let enclosing_statement_list = current_statement_list;
            current_statement_list = list;

            try
                if !list? then
                    return;
                fi

                if list.last? then
                    list.last.want_value = list.want_value;
                fi

                for s in list.statements do
                    s.walk(self);
                od

                if !list.want_value then
                    return;
                fi
                    
                if list.is_empty then
                    _logger.error(list.location, "expected a value");
                    return;
                fi
    
                let last = list.last;
    
                if !last? then
                    return;
                fi
    
                if !last.provides_value then
                    _logger.error(last.location, "expected a value");
                    return;
                fi
    
                if !last.value? then
                    return;
                fi
    
                list.value = IR.Values.BLOCK(last.value.type);
            finally
                current_statement_list = enclosing_statement_list
            yrt
        si

        pre(`if: Trees.Statements.IF) -> bool is
            super.pre(`if);

            if `if.want_value then
                if `if.constraint? then
                    for i in `if.branches do
                        i.body.want_value = true;
                        i.body.upgrade_constraint(`if.constraint, `if.constraint_error_message);
                    od
                else
                    for i in `if.branches do
                        i.body.want_value = true;
                        i.body.clear_constraint();
                    od
                fi    
            fi

            return false;
        si

        visit(`if: Trees.Statements.IF) is
            for i in `if.branches do
                if i.condition? then
                    IR.Values.Value.check_is_consumable(_logger, i.condition.location, i.condition.value);
                fi
            od

            if !`if.want_value then
                return;
            fi

            if `if.is_poisoned then
                // if the if is syntactically incomplete don't bother reporting any
                // semantic errors:
                `if.value = DUMMY_BLOCK(Semantic.Types.ERROR(), `if.location, "if is poisoned");

                return;
            fi

            if 
                !`if.branches | .any(b => b? /\ !b.condition?) /\
                !(`if.constraint? /\ `if.constraint.is_void)
            then
                // if the if has no else branch, then don't bother reporting any
                // semantic errors:
                _logger.error(`if.location, "expected else in if expression");
                `if.value = DUMMY_BLOCK(Semantic.Types.ERROR(), `if.location, "no else");
                return;
            fi

            let type = if `if.constraint? /\ `if.constraint.any_count == 0 then `if.constraint else null fi;

            let seen_any_values = false;
            let seen_non_null_values = false;
            let seen_null_values = false;
            let all_tuple_literals = true;

            let lub = LEAST_UPPER_BOUND_MAP();

            let use debug_dispose = debug_enter();

            debug("expression if {`if.compile_count} {`if.to_string().replace_line_endings(" ")}");

            `if.compile_count = `if.compile_count + 1;

            for i in `if.branches do
                let use debug_dispose = debug_enter();
                debug("if branch {i}");
                let branch = i.body;

                if !branch.value? then                    
                    continue;
                fi

                if !branch.value.type? then
                    continue;
                fi

                if `if.constraint? then
                    if !branch.value.check_is_consumable_allow_void(_logger, branch.location) then
                        continue;
                    fi
                else
                    if !branch.value.check_is_consumable(_logger, branch.location) then
                        continue;
                    fi
                fi

                if type? then
                    debug("enforce constraint {type}");
                    if !type.is_void /\ !type.is_assignable_from(branch.value.type) then
                        debug("error {branch.location} {string.format(`if.constraint_error_message, [branch.value.type, type])}");
                        _logger.error(branch.location, string.format(`if.constraint_error_message, [branch.value.type, type]));
                    fi
                elif branch.value.type.is_null then
                    // could also be error
                    seen_null_values = true;
                else
                    seen_non_null_values = true;

                    if !branch.is_tuple_literal then
                        all_tuple_literals = false;
                    fi
                    debug("add type {branch.value.type} to LUB");

                    lub.add(branch.value.type);
                fi

                seen_any_values = true;
            od

            if !`if.constraint? \/ `if.constraint.any_count > 0 then
                type = lub.get_result();

                debug("no constraint lub result {type}");

                // FIXME factor this out - it's duplicated between here and list literal elements
                if all_tuple_literals /\ seen_non_null_values /\ (!type? \/ !type.is_value_tuple) then
                    let lubs = Collections.LIST[LEAST_UPPER_BOUND_MAP]();

                    for i in `if.branches do
                        let branch = i.body;

                        if !branch.value? \/ !branch.value.type? then
                            continue;
                        fi

                        for (index, e) in branch.value.type.arguments | .index() do
                            if index >= lubs.count then
                                lubs.add(LEAST_UPPER_BOUND_MAP());
                            fi

                            lubs[index].add(e);
                        od
                    od

                    type = 
                        _innate_symbol_lookup.get_tuple_type(
                            lubs |
                                .map(l => 
                                    let r: Type = l.get_result() in if r? then r else _innate_symbol_lookup.get_object_type() fi) 
                                .collect(),
                            lub.element_names
                        );
                fi

                if type? /\ type.is_value_type /\ seen_null_values then
                    debug("apply type {type} to branches");

                    let use debug_dispose = debug_enter();

                    for i in `if.branches do
                        let branch = i.body;
        
                        if !branch.value? \/ !branch.value.type? then
                            continue;
                        fi
        
                        if branch.value.type.is_null then
                            _logger.error(branch.location, "incompatible types in if branches: {branch.value.type} and {type}");                                                    
                        fi
                    od
                fi
            fi

            debug("after maybe apply constraint");

            if !type? then
                debug("still no type");
                if seen_any_values then
                    if seen_non_null_values then
                        _logger.error(`if.location, "no type inferred for if expression");
                    else
                        _logger.error(`if.location, "all branch values are null");                        
                    fi
                fi

                `if.value = DUMMY_BLOCK(Semantic.Types.ERROR(), `if.location, "no type inferred");
                return;
            else
                debug("create value of type {type}");
                `if.value = IR.Values.BLOCK(type);
            fi
        si

        // Do not descend into properties (otherwise accessor functions will be walked twice)
        pre(property: Trees.Definitions.PROPERTY) -> bool => true;

        visit(property: Trees.Definitions.PROPERTY) is
        si

        specialize_type(location: Source.LOCATION, symbol: Semantic.Symbols.Symbol, arguments: Trees.TypeExpressions.LIST) -> Semantic.Types.Type is
            if !isa Semantic.Symbols.Classy(symbol) then
                _logger.error(location, "cannot supply type arguments here");
                return Semantic.Types.ERROR();
            fi

            for a in arguments do
                a.check_is_not_void(_logger, "cannot use void type here");

                let t = a.type;

                if t? /\ t.is_named /\ cast Semantic.Types.NAMED(t).symbol.is_unsafe_constraints then
                    _logger.warn(a.location, "type {t} has unchecked constraints");
                fi
            od

            let result = Semantic.Types.GENERIC(
                location,
                cast Semantic.Symbols.Classy(symbol),
                arguments | .map(
                    // FIXME type inference issue
                    a -> Type => if a? /\ a.type? then a.type else Semantic.Types.ERROR() fi
                ).collect()
            );

            if symbol.is_unsafe_constraints then
                _logger.warn(location, "type {result} has unchecked constraints");            
            fi
            
            return result;
        si

        specialize_symbol(location: Source.LOCATION, symbol: Semantic.Symbols.Symbol, arguments: Trees.TypeExpressions.LIST) -> Semantic.Symbols.Symbol is
            return 
                symbol.try_specialize(
                    location,
                    _logger,
                    arguments.elements | 
                        .map(t => t.type).collect()
                );
        si
    si

    // TODO move these into he runtime library
    struct WHILE_ITERATOR[T]: Collections.Iterator[T] is
        _generator: () -> T;
        _predicate: (T) -> bool;

        current: T;

        init(generator: () -> T, predicate: T -> bool) is
            _generator = generator;
            _predicate = predicate;
        si

        move_next() -> bool is
            current = _generator();

            return _predicate(current);
        si

        reset() is
            // should maybe throw, but Pipe[T] may
            // call reset in circumstances where it
            // would be better to just ignore it
        si

        dispose() is
            // nothing to do
        si        
    si

    struct WHILE_ITERABLE[T]: Collections.Iterable[T] is
        _generator: () -> T;
        _predicate: (T) -> bool;

        iterator: Collections.Iterator[T] =>
            WHILE_ITERATOR[T](_generator, _predicate);

        init(generator: () -> T, predicate: T -> bool) is
            _generator = generator;
            _predicate = predicate;
        si
    si

    struct WHILE_INDEXED_ITERATOR[T]: Collections.Iterator[T] is
        _generator: (int) -> T;
        _predicate: (T) -> bool;
        _index: int;

        current: T;

        init(generator: (int) -> T, predicate: T -> bool) is
            _index = -1;
            _generator = generator;
            _predicate = predicate;
        si

        move_next() -> bool is
            _index = _index + 1;
            current = _generator(_index);
            return _predicate(current);
        si

        reset() is
            _index = -1;
        si

        dispose() is
            // nothing to do
        si        
    si

    struct WHILE_INDEXED_ITERABLE[T]: Collections.Iterable[T] is
        _generator: (int) -> T;
        _predicate: (T) -> bool;

        iterator: Collections.Iterator[T] =>
            WHILE_INDEXED_ITERATOR[T](_generator, _predicate);

        init(generator: (int) -> T, predicate: T -> bool) is
            _generator = generator;
            _predicate = predicate;
        si
    si

    do_while[T](generator: () -> T, predicate: T -> bool) -> Collections.Iterable[T] =>
        WHILE_ITERABLE[T](generator, predicate);

    iter_while[T](generator: (int) -> T, predicate: T -> bool) -> Collections.Iterable[T] =>
        WHILE_INDEXED_ITERABLE[T](generator, predicate);
si