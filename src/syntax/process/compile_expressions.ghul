namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Source;

    class COMPILE_EXPRESSIONS: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _generic_cache: Semantic.GENERIC_CACHE;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            generic_cache: Semantic.GENERIC_CACHE,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _generic_cache = generic_cache;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _system_symbol_lookup = system_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        get_iterator_type_for(location: LOCATION, type: Semantic.Type.BASE, recursing: bool) -> Semantic.Type.BASE is
            if type == null then
                return null;
            fi

            let next_element = type.find_member("nextElement");

            if next_element? && isa Semantic.Symbol.FUNCTION_GROUP(next_element) then
                let next_element_function_group = cast Semantic.Symbol.FUNCTION_GROUP(next_element);

                for f in next_element_function_group.functions do
                    if f.arguments.Length == 0 then
                        return f.return_type;
                    fi
                od
            fi

            if !recursing then
                let iterator = type.find_member("Iterator");

                if iterator? && isa Semantic.Type.Typed(iterator) then
                    let result = get_iterator_type_for(location, cast Semantic.Type.Typed(iterator).type, true);

                    if result? then
                        return result;
                    fi
                fi
            fi

            _logger.error(location, "no iterator found");
        si

        pre(for_: Tree.Statement.FOR) -> bool is
            super.pre(for_);

            var symbol = find(for_.variable.name);

            if symbol? && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                // if typed_symbol.type == null then
                    if for_.variable.type_expression? && !isa Tree.TypeExpression.INFER(for_.variable.type_expression) then
                        if for_.variable.type_expression.type? then
                            typed_symbol.type = for_.variable.type_expression.type;
                        fi
                    elif for_.variable.initializer? then
                        _logger.error(for_.variable.initializer.location, "cannot initialize variable here");
                    elif for_.expression? then
                        for_.expression.walk(self);

                        if for_.expression.value? && for_.expression.value.type? then
                            typed_symbol.type = get_iterator_type_for(for_.expression.location, for_.expression.value.type, false);
                        fi
                    else
                        _logger.error(for_.location, "can't figure out what to do with for variable");
                    fi
                // else
                //     IO.Std.err.println("weird: for variable already has type: " + typed_symbol.type);
                // fi
            else
                _logger.error(for_.variable.name.location, "couldn't find typed symbol for variable " + for_.variable.name);
            fi        

            for_.body.walk(self);

            return true;
        si        

        pre(assignment: Tree.Statement.ASSIGNMENT) -> bool is
            assignment.right.walk(self);

            if assignment.right.value? then
                assignment.left.value = new Semantic.Graph.Value.Need.STORE(assignment.right.value);

                assignment.left.walk(self);
            else
                assignment.left.value = null;
                return true;
            fi

            if !assignment.left.value? || !assignment.left.value.type? || !assignment.right.value.type? then
                return true;
            fi
            
            if assignment.left.value.type.compare(assignment.right.value.type) > Semantic.Type.MATCH.ASSIGNABLE then
                _logger.error(assignment.location, "" + assignment.right.value.type + " is not assignable to " + assignment.left.value.type);
            fi
            
            return true;
        si

        pre(function: Tree.Expression.FUNCTION) -> bool is
            super.pre(function);

            // FIXME: should this be in visit?
            function.body.walk(self);

            return true;
        si

        visit(function: Tree.Expression.FUNCTION) is
            let closure = cast Semantic.Symbol.CLOSURE(scope_for(function));

            let owning_class = _symbol_table.current_instance_context;

            owning_class.add_closure(closure);

            let argument_names = new Vector[String]();
            let argument_types = new Vector[Semantic.Type.BASE]();

            if !isa Tree.TypeExpression.INFER(function.type_expression) then
                var any_errors: bool;

                for a in function.arguments.elements do
                    if isa Tree.Expression.VARIABLE(a) then
                        let argument = cast Tree.Expression.VARIABLE(a);

                        if !isa Tree.TypeExpression.INFER(argument.type_expression) then
                            argument_names.add(argument.name.name);
                            argument_types.add(argument.type_expression.type);
                        else
                            _logger.error(a.location, "cannot infer type here");
                            any_errors = true;
                        fi

                    else
                        _logger.error(a.location, "expected a formal argument");
                        any_errors = true;
                    fi
                od
                
                if !any_errors then
                    closure.arguments = cast List[Semantic.Type.BASE](argument_types.clone());

                    argument_types.add(function.type_expression.type);

                    closure.argument_names = argument_names;

                    closure.type = _ghul_symbol_lookup.get_function_type(argument_types);
                    closure.return_type = function.type_expression.type;
                fi
            fi
            
            function.value = closure.load(function.location, new Semantic.Graph.Value.DUMMY(new Semantic.Type.ANY()), _symbol_loader);

            super.visit(function);
        si

        visit(tuple: Tree.Expression.TUPLE) is
            let values = new Vector[Semantic.Graph.Value.BASE]();
            let types = new Vector[Semantic.Type.BASE]();

            for v in tuple.elements do
                if v.value? && v.value.type? then
                    values.add(v.value);
                    types.add(v.value.type);
                else
                    return;
                fi
            od

            let type = _ghul_symbol_lookup.get_tuple_type(types);
                        
            tuple.value = new Semantic.Graph.Value.TUPLE(type, values);
        si

        visit(sequence: Tree.Expression.SEQUENCE) is
            var type: Semantic.Type.BASE;
            var have_explicit_type: bool;

            let elements = new Vector[Tree.Expression.NODE](sequence.elements);

            if sequence.type_expression? && !isa Tree.TypeExpression.INFER(sequence.type_expression) then
                if sequence.type_expression.type? then
                    type = sequence.type_expression.type;

                    have_explicit_type = true;
                else
                    _logger.error(sequence.type_expression.location, "bad explicit type expression");
                    return;
                fi
            elif elements.Length == 0 then
                _logger.error(sequence.location, "cannot infer type of list literal with no elements");

                return; 
            else

                for v in elements do
                    if v.value? && v.value.type? then
                        type = v.value.type;

                        break;
                    fi
                od

                if type == null then
                    _logger.error(sequence.location, "cannot infer type of list literal with only null elements");
                    return;
                fi                
            fi
            
            for v in sequence.elements do
                if v.value? && v.value.type? then
                    let u = v.value.type;

                    var match = type.compare(u);

                    if match > Semantic.Type.MATCH.ASSIGNABLE then
                        if have_explicit_type then
                            _logger.error(v.location, "element not compatible with explicit type");
                        else
                            match = u.compare(type);

                            if match <= Semantic.Type.MATCH.ASSIGNABLE then
                                type = u;
                            else
                                type = _system_symbol_lookup.get_object_type();
                                break;
                            fi
                        fi
                    fi
                fi
            od

            type = _ghul_symbol_lookup.get_array_type(type);
                        
            sequence.value = new Semantic.Graph.Value.DUMMY(type);
        si        

        visit(self_: Tree.Expression.SELF) is
            let s = _symbol_table.current_instance_context;

            let type: Semantic.Type.BASE;

            if s? then
                if s.argument_names.Length > 0 then
                    let arguments = new Vector[Semantic.Type.BASE]();

                    for n in s.argument_names do
                        let argument = s.find_member(n);

                        if argument? && isa Semantic.Symbol.TYPE(argument) then
                            arguments.add(cast Semantic.Symbol.TYPE(argument).type);
                        fi
                    od
                    
                    if arguments.Length == s.argument_names.Length then
                        type = new Semantic.Type.GENERIC(
                            self_.location,
                            cast Semantic.Symbol.ScopedWithInheritance(s),
                            arguments);
                    fi
                fi

                self_.value =
                    new Semantic.Graph.Value.Load.SELF(
                        s, type
                    );

                _symbol_use_locations.add_symbol_use(self_.location, s);
            fi
        si

        visit(super_: Tree.Expression.SUPER) is
            // FIXME:
            let s = _symbol_table.current_instance_context;

            if s? then
                if s.is_trait then
                    _logger.error(super_.location, "trait " + s.description + " does not have a super class");
                    
                    return;
                fi
                
                super_.value =
                    new Semantic.Graph.Value.Load.SELF(
                        s, cast Semantic.Symbol.ScopedWithInheritance(s).ancestors[0]
                    );

                _symbol_use_locations.add_symbol_use(super_.location, s);
            fi
        si

        visit(native_: Tree.Expression.NATIVE) is
            native_.value =
                new Semantic.Graph.Value.NATIVE(new Semantic.Type.ANY());
        si        

        visit(cast_: Tree.Expression.CAST) is
            cast_.value = null;

            var type = cast_.type_expression.type;

            if type == null then
                _logger.error(cast_.type_expression.location, "cast has no type");                
                return;
            fi

            // type = type.specialize(_generic_cache);
            
            cast_.value =
                new Semantic.Graph.Value.CAST(
                    type,
                    cast_.right.value
                );
        si

        visit(isa_: Tree.Expression.ISA) is
            isa_.value = null;

            let isa_type = isa_.type_expression.type;

            if isa_type == null then
                _logger.error(isa_.type_expression.location, "isa has no type");
                return;
            fi

            let bool_type = _ghul_symbol_lookup.get_bool_type();

            isa_.value =
                new Semantic.Graph.Value.ISA(
                    bool_type,
                    isa_type,                     
                    isa_.right.value
                );
        si

        visit(new_: Tree.Expression.NEW) is
            new_.value = null;

            var type = new_.type_expression.type;

            if type == null then
                _logger.info(new_.type_expression.location, "new has no type");
                return;
            fi

            // type = type.specialize(_generic_cache);

            if !isa Semantic.Type.NAMED(type) then
                _logger.error(new_.type_expression.location, "cannot instantiate this: " + type);
                return;
            fi

            let named_type = cast Semantic.Type.NAMED(type);

            let symbol = named_type.scope.find_member("init");

            let function_group = cast Semantic.Symbol.FUNCTION_GROUP(symbol);

            let arguments = new Vector[Semantic.Graph.Value.BASE]();
            let argument_types = new Vector[Semantic.Type.BASE]();

            for a in new_.arguments do
                if a? && a.value? && a.value.type? then
                    // _logger.error(a.location, "argument has no type");
                    arguments.add(a.value);
                    argument_types.add(a.value.type);                    
                else
                    let t = new Semantic.Type.ANY();
                    arguments.add(new Semantic.Graph.Value.DUMMY(type));
                    argument_types.add(t);
                fi
            od

            let overload_result = _overload_resolver.resolve(new_.location, function_group, argument_types, true);

            if overload_result == null then
                new_.value =
                    new Semantic.Graph.Value.DUMMY(
                        type
                    );
                return;
            fi

            let function = overload_result.function;

            _symbol_use_locations.add_symbol_use(new_.type_expression.location, function);

            new_.value =
                new Semantic.Graph.Value.NEW(
                    type,
                    function,
                    arguments
                );
        si

        visit(unary: Tree.Expression.UNARY) is
            unary.value = null;

            if unary.right.value? then
                let arguments = [unary.right.value.type];

                let function_group = find(unary.operation);

                if function_group == null || !isa Semantic.Symbol.FUNCTION_GROUP(function_group) then
                    return;
                fi

                let overload_result =
                    _overload_resolver.resolve(
                        unary.location,
                        cast Semantic.Symbol.FUNCTION_GROUP(function_group),
                        arguments,
                        true);

                if overload_result == null then
                    return;
                fi

                let function = overload_result.function;

                _symbol_use_locations.add_symbol_use(unary.operation.location, function);

                let value = function.call(null, [unary.right.value], null, _function_caller);

                unary.value = value;
            fi
        si        

        visit(binary: Tree.Expression.BINARY) is
            binary.value = null;

            if binary.left.value? && binary.right.value? then
                var binary_function_group: Semantic.Symbol.FUNCTION_GROUP;
                var binary_overload_result: Semantic.OVERLOAD_RESOLVE_RESULT;

                let binary_function_symbol = find(binary.operation.name);
                
                if binary_function_symbol? && isa Semantic.Symbol.FUNCTION_GROUP(binary_function_symbol) then
                    binary_function_group = cast Semantic.Symbol.FUNCTION_GROUP(binary_function_symbol);

                    binary_overload_result =
                        _overload_resolver
                            .resolve(
                                binary.location,
                                binary_function_group,
                                [binary.left.value.type, binary.right.value.type],
                                false
                            );
                fi

                var member_overload_result: Semantic.OVERLOAD_RESOLVE_RESULT;
                var member_function_group: Semantic.Symbol.FUNCTION_GROUP;

                if binary.left.value.type? then
                    let member_function_symbol = 
                        binary.left.value.type.find_member(binary.operation.name);

                    if member_function_symbol? && isa Semantic.Symbol.FUNCTION_GROUP(member_function_symbol) then
                        member_function_group = cast Semantic.Symbol.FUNCTION_GROUP(member_function_symbol);

                        member_overload_result = 
                            _overload_resolver
                                .resolve(
                                    binary.location,
                                    cast Semantic.Symbol.FUNCTION_GROUP(member_function_group),
                                    [binary.right.value.type],
                                    false
                                );
                    fi
                fi

                var function: Semantic.Symbol.Function;

                if member_overload_result? && binary_overload_result? then
                    if member_overload_result.score <= binary_overload_result.score then
                        function = member_overload_result.function;
                    else
                        function = binary_overload_result.function;
                    fi              
                elif member_overload_result? then
                    function = member_overload_result.function;
                elif binary_overload_result? then
                    function = binary_overload_result.function;
                fi
            
                if function? then
                    // FIXME: add uses for overridden methods as well here:
                    _symbol_use_locations.add_symbol_use(binary.operation.location, function);
                    let force_type: Semantic.Type.BASE;

                    if binary.operation.name == "<>" then                        
                        if function.return_type !~ _ghul_symbol_lookup.get_int_type() then
                            _logger.error(binary.location, "<> order operator must return int");
                        fi

                        force_type = _ghul_symbol_lookup.get_bool_type();
                    fi

                    let value: Semantic.Graph.Value.BASE;
                    
                    if isa Semantic.Symbol.INSTANCE_METHOD(function) then
                        value = function.call(binary.left.value, [binary.right.value], force_type,_function_caller);
                    else                        
                        value = function.call(null, [binary.left.value, binary.right.value], force_type,_function_caller);

                        if isa Semantic.Graph.Value.Call.INNATE(value) then
                            cast Semantic.Graph.Value.Call.INNATE(value).actual_operation = binary.actual_operation;
                        fi
                    fi
                    
                    binary.value = value;
                else
                    // retry overload resolution (which will fail) for error reporting:
                    var reported_error_for_binary_or_member = false;

                    if binary_function_group? then
                        reported_error_for_binary_or_member = true;

                        _overload_resolver
                            .resolve(
                                binary.location,
                                cast Semantic.Symbol.FUNCTION_GROUP(binary_function_group),
                                [binary.left.value.type, binary.right.value.type],
                                true
                            );
                    fi

                    if member_function_group? then
                        reported_error_for_binary_or_member = true;

                        member_overload_result = 
                            _overload_resolver
                                .resolve(
                                    binary.location,
                                    cast Semantic.Symbol.FUNCTION_GROUP(member_function_group),
                                    [binary.right.value.type],
                                    true
                                );                        
                    fi

                    if !reported_error_for_binary_or_member then
                        _logger.error(binary.operation.location, "operator '" + binary.operation + "' not found");
                    fi
                fi
            fi
        si

        visit(index: Tree.Expression.INDEX) is
            try
                _visit(index);
            catch e: Exception
                index.value = null;

                _logger.fatal(index.location, "internal error compiling indexer call: " + index + "\n" + e);
            yrt
        si

        _visit(index: Tree.Expression.INDEX) is
            let need_store = index.value? && isa Semantic.Graph.Value.Need.STORE(index.value);

            if index.left.value? && index.index.value? then
                let type = index.left.value.type;

                if type == null then
                    _logger.info(index.left.location, "index left has no type");
                    return;
                fi

                if !isa Semantic.Type.NAMED(type) then
                    _logger.info(index.left.location, "type has no members: " + type);
                    return;
                fi

                let named_type = cast Semantic.Type.NAMED(type);

                var function_name: String;
                var arguments: List[Semantic.Graph.Value.BASE];
                var argument_types: List[Semantic.Type.BASE];

                if need_store then
                    function_name = "__assign";

                    let need_store_value = cast Semantic.Graph.Value.Need.STORE(index.value).value;

                    arguments = [index.index.value, need_store_value];
                    argument_types = [index.index.value.type, need_store_value.type];
                else
                    function_name = "__read";
                    arguments = [index.index.value];
                    argument_types = [index.index.value.type];
                fi

                let symbol = named_type.scope.find_member(function_name);

                if symbol == null then
                    _logger.error(index.location, "indexer not found in " + type);
                    return;
                fi

                if !isa Semantic.Symbol.FUNCTION_GROUP(symbol) then
                    _logger.info(index.index.location, "indexer is not a function group: " + symbol);
                fi

                let overload_result =
                    _overload_resolver.resolve(
                        index.location,
                        cast Semantic.Symbol.FUNCTION_GROUP(symbol),
                        argument_types,
                        false);

                if overload_result == null then
                    if need_store then
                        _logger.error(index.location, "indexer [" + argument_types[0] + "] = " + argument_types[1] + " not found in " + type);
                    else
                        _logger.error(index.location, "indexer [" + argument_types[0] + "] not found in " + type);
                    fi

                    return;
                fi

                let function = overload_result.function;

                // FIXME: add uses for overridden methods as well here:
                _symbol_use_locations.add_symbol_use(
                    new LOCATION(
                        index.left.location.file_name,
                        index.left.location.end_line,
                        index.left.location.end_column+1,
                        index.index.location.start_line,
                        index.index.location.end_column-1
                    ), function);                

                if need_store then
                    index.value = 
                    new Semantic.Graph.Value.TYPE_WRAPPER(
                        function.arguments[1],
                        function.call(index.left.value, arguments, null, _function_caller));
                else
                    index.value = function.call(index.left.value, arguments, null, _function_caller);
                fi                
            fi
        si

        visit(member: Tree.Expression.MEMBER) is
            let need_store = member.value? && isa Semantic.Graph.Value.Need.STORE(member.value);
            
            if member.identifier == null then
                return;
            fi

            if member.left? && member.left.value? then
                let type = member.left.value.type;

                if type == null then
                    // _logger.info(member.left.location, "member left has no type");
                    return;
                fi

                if !isa Semantic.Type.NAMED(type) then
                    if !isa Semantic.Type.ANY(type) then
                        _logger.info(member.left.location, "type has no members: " + type);
                    fi
                    
                    return;
                fi

                let named_type = cast Semantic.Type.NAMED(type);

                if named_type.scope == null then
                    _logger.info(member.left.location, "member left type has no type: " + type);
                    return;
                fi

                let symbol = named_type.scope.find_member(member.identifier.name);

                if symbol == null then
                    _logger.error(member.identifier.location, "member " + member.identifier.name + " not found in " + named_type);
                    return;
                fi

                _symbol_use_locations.add_symbol_use(member.identifier.location, symbol);

                _symbol_loader.find_symbol = 
                    (name: String) -> Semantic.Symbol.BASE use named_type is
                        let result = named_type.scope.find_member(name);

                        if result == null then
                            IO.Std.err.println("property function " + name + " not found in type: " + named_type + ", scope: " + named_type.scope);
                        fi

                        return result;
                    si;

                var value: Semantic.Graph.Value.BASE;

                if need_store then
                    let store_value = cast Semantic.Graph.Value.Need.STORE(member.value).value;

                    value = symbol.store(member.location, member.left.value, store_value, _symbol_loader);
                else
                    value = symbol.load(member.location, member.left.value, _symbol_loader);
                fi

                member.value = value;
            // else
            //    _logger.info(member.left.location, "member left has no value");
            fi
        si
        
        visit(variable: Tree.Variable.NODE) is
            var symbol = find(variable.name);

            if symbol? && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                if typed_symbol.type == null then
                    if variable.type_expression? && !isa Tree.TypeExpression.INFER(variable.type_expression) then
                        if variable.type_expression.type? then
                            typed_symbol.type = variable.type_expression.type;
                        fi
                    elif variable.initializer? then
                        if variable.initializer.value? then
                            typed_symbol.type = variable.initializer.value.type;
                        fi
                    else
                        _logger.error(variable.location, "variable must have explict type or initializer");
                    fi
                fi
            else
                _logger.error(variable.name.location, "couldn't find typed symbol for variable " + variable.name);
            fi        
        si

        visit(integer: Tree.Expression.Literal.INTEGER) is
            var type: Semantic.Type.BASE;

            let string = integer.string;

            if string.endsWith('L') || string.endsWith('l') then
                string = string.substring(0, string.Length-1);
                type = _ghul_symbol_lookup.get_type("long");
            else
                type = _ghul_symbol_lookup.get_type("int");
            fi
            
            integer.value = new Semantic.Graph.Value.Literal.INTEGER(
                string,
                type
            );
        si

        visit(string: Tree.Expression.Literal.STRING) is
            string.value = new Semantic.Graph.Value.Literal.STRING(
                string.string,
                _system_symbol_lookup.get_type("String")
            );
        si        

        visit(character: Tree.Expression.Literal.CHARACTER) is
            let string = character.string;
            let c: int = 0;

            if string.Length < 1 || string.Length > 1 then
                _logger.error(character.location, "invalid character literal");
            else
                c = cast int(string[0]);
            fi
            
            character.value = new Semantic.Graph.Value.Literal.INTEGER(
                "" + c,
                _ghul_symbol_lookup.get_char_type()
            );
        si

        visit(call: Tree.Expression.CALL) is
            try
                _visit(call);
            catch e: Exception
                call.value = null;

                IO.Std.err.println("something went wrong inferring type for call: " + call + "\n" + e);
            yrt
        si

        _visit(call: Tree.Expression.CALL) is
            if call.function.value == null then
                // _logger.error(call.function.location, "cannot call this");
                return;
            fi

            let arguments = new Vector[Semantic.Graph.Value.BASE]();
            let argument_types = new Vector[Semantic.Type.BASE]();

            for a in call.arguments do
                if a? && a.value? && a.value.type? then
                    arguments.add(a.value);
                    argument_types.add(a.value.type);                    
                else
                    _logger.info(a.location, "argument has no type");

                    let type = new Semantic.Type.ANY();
                    arguments.add(new Semantic.Graph.Value.DUMMY(type));
                    argument_types.add(type);
                fi
            od

            if isa Semantic.Graph.Value.Load.SYMBOL(call.function.value) then
                let load = cast Semantic.Graph.Value.Load.SYMBOL(call.function.value);

                if load.symbol? && isa Semantic.Symbol.FUNCTION_GROUP(load.symbol) then
                    let function_group = cast Semantic.Symbol.FUNCTION_GROUP(load.symbol);

                    let overload_result = _overload_resolver.resolve(call.location, function_group, argument_types, true);

                    if overload_result == null then
                        // _logger.error(call.location, "no overload found");
                        return;
                    fi

                    let function = overload_result.function;

                    // FIXME: add uses for overridden methods as well here:
                    _symbol_use_locations.add_symbol_use(call.function.location, function);

                    call.value = function.call(load.from, arguments, null, _function_caller);

                    return;
                fi
            fi

            argument_types.add(new Semantic.Type.ANY());
            let expected_type = _ghul_symbol_lookup.get_function_type(argument_types);

            if expected_type == null then
                _logger.info(call.location, "no innate function type found");
                return;
            fi

            if call.function.value.type == null then
                IO.Std.err.println("call.function.value.type is null: " + call);
                return;
            fi

            let function_type = call.function.value.type;            

            if function_type? && isa Semantic.Type.GENERIC(function_type) then
                let function_generic_type = cast Semantic.Type.GENERIC(function_type);

                let function_type_arguments = function_generic_type.arguments;

                var ok = true;

                if function_type_arguments.Length != arguments.Length + 1 then
                    _logger.error(call.arguments.location, "expected % arguments but % supplied" % [function_type_arguments.Length - 1, arguments.Length]: Object);
                    
                    return;
                elif function_generic_type.name =~ "FUNCTION_" + arguments.Length then
                    for i in 0..arguments.Length do
                        if function_generic_type.arguments[i]
                            .compare(argument_types[i])
                                > Semantic.Type.MATCH.CONVERTABLE
                        then
                            ok = false;

                            _logger.error(call.arguments.expressions[i].location, "expected argument of type % but % supplied" % [function_type_arguments[i], argument_types[i]]: Object);
                        fi
                    od

                    if ok then
                        let result_type = function_generic_type.arguments[function_type_arguments.Length-1];

                        call.value =
                            new Semantic.Graph.Value.Call.CLOSURE(
                                call.function.value,
                                result_type,
                                arguments
                            );
                    fi

                    return;
                fi
            fi

            _logger.error(call.function.location, "cannot call value of non-function type " + call.function.value.type);
        si

        visit(identifier: Tree.Expression.IDENTIFIER) is
            let need_store = identifier.value? && isa Semantic.Graph.Value.Need.STORE(identifier.value);
        
            var symbol = find(identifier.identifier);

            if symbol? then
                _symbol_use_locations.add_symbol_use(identifier.location, symbol);

                // _symbol_loader.find_symbol = (name: String) -> Semantic.Symbol.BASE => find(name);

                _symbol_loader.find_symbol = 
                    (name: String) -> Semantic.Symbol.BASE is
                        let result = find(name);

                        return result;
                    si;

                if need_store then
                    var store_value = cast Semantic.Graph.Value.Need.STORE(identifier.value).value;
                    identifier.value = symbol.store(identifier.location, null, store_value, _symbol_loader);
                else
                    identifier.value = symbol.load(identifier.location, null, _symbol_loader);
                fi
            else
                identifier.value = null;
            fi                
        si

        visit(has_value: Tree.Expression.HAS_VALUE) is
            has_value.value = new Semantic.Graph.Value.HAS_VALUE(has_value.left.value, _ghul_symbol_lookup.get_bool_type());
        si
        
        visit(null_: Tree.Expression.NULL) is
            null_.value = new Semantic.Graph.Value.NULL(new Semantic.Type.ANY());
        si
    si
si
