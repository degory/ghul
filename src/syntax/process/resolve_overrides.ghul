namespace Syntax.Process is
    use Queue = Collections.Queue`1;

    use System.Threading;
    use System.Threading.Tasks;

    use Logging;
    use Trees;
    use Source;

    class RESOLVE_OVERRIDES: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;

        _done_object: bool;

        _duplicate_method_checker: Semantic.DUPLICATE_METHOD_CHECKER;
        _work_queue: Queue[() -> void];

        want_threads: bool public;

        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES
        )
        is
            super.init(logger, stable_symbols, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;

            _duplicate_method_checker = new Semantic.DUPLICATE_METHOD_CHECKER(logger);
            _work_queue = new Queue[() -> void]();

            IO.Std.error.write_line("XXXXXX TaskScheduler: " + TaskScheduler.current);
            IO.Std.error.write_line("XXXXXX TaskScheduler max concurrency: " + TaskScheduler.current.maximum_concurrency_level);
        si

        apply(root: Trees.Node) is
            // FIXME: this isn't needed 

            if !_done_object then
                let lookup = IoC.CONTAINER.instance.innate_symbol_lookup;

                lookup.get_object_type().symbol.pull_down_super_symbols();
                lookup.get_value_type().symbol.pull_down_super_symbols();

                _done_object = true;
            fi            

            root.walk(self);
        si

        _job: int;
        _concurrency: int;

        drain() is
            let wi: () -> void;

            if true then
                let tasks = new Collections.LIST[Task]();

                let started_at = System.DateTime.now;

                IO.Std.error.write_line("start " + _work_queue.count + " tasks...");

                let b = new System.Text.StringBuilder();

                while _work_queue.try_dequeue(wi ref) do
                    tasks.add(Task.run(() is
                        // let job = Interlocked.increment(_job ref);
                        // let concurrency = Interlocked.increment(_concurrency ref);
                        // b.append_line(">>>> concurrent " + concurrency + " job #" + job);
                        
                        wi();

                        // b.append_line("<<<< concurrent " + concurrency + " job #" + job);
                        // Interlocked.decrement(_concurrency ref);
                    si));
                od

                IO.Std.error.write_line("started " + tasks.count + " tasks in " + System.DateTime.now.subtract(started_at));

                Task.wait_all(tasks.to_array());

                IO.Std.error.write_line("completed " + tasks.count + " tasks in " + System.DateTime.now.subtract(started_at));

                // IO.Std.error.write_line(b);
            else
                while _work_queue.try_dequeue(wi ref) do
                    wi();
                od
            fi            
        si        

        check_duplicate_global_functions() is
            for ns in _namespaces do
                _work_queue.enqueue(() =>
                    _duplicate_method_checker.check(ns, "duplicate function")
                );
            od
        si

        pre(`class: Trees.Definitions.CLASS) -> bool => true;

        visit(`class: Definitions.CLASS) is
            let symbol = symbol_for(`class);

            if symbol? /\ isa Semantic.Symbols.Classy(symbol) then
                let classy = cast Semantic.Symbols.Classy(symbol);

                _work_queue.enqueue(() is
                    classy.read_lock();
                    _duplicate_method_checker.check(symbol, "duplicate method");
                    classy.exit_lock();

                    classy.pull_down_super_symbols();
                si);
            fi
        si

        pre(`trait: Trees.Definitions.TRAIT) -> bool => true;

        visit(`trait: Definitions.TRAIT) is
            let symbol = symbol_for(`trait);

            if symbol? /\ isa Semantic.Symbols.Classy(symbol) then
                let classy = cast Semantic.Symbols.Classy(symbol);

                _work_queue.enqueue(() is
                    classy.read_lock();
                    _duplicate_method_checker.check(symbol, "duplicate method");
                    classy.exit_lock();

                    classy.pull_down_super_symbols();
                si);
            fi
        si

        pre(`struct: Trees.Definitions.STRUCT) -> bool => true;

        visit(`struct: Definitions.STRUCT) is
            let symbol = symbol_for(`struct);

            if symbol? /\ isa Semantic.Symbols.Classy(symbol) then
                _work_queue.enqueue(() =>
                    cast Semantic.Symbols.Classy(symbol).pull_down_super_symbols()
                );
            fi
        si

        pre(`enum: Trees.Definitions.ENUM) -> bool => true;

        visit(`enum: Definitions.ENUM) is
            let symbol = symbol_for(`enum);

            if symbol? /\ isa Semantic.Symbols.Classy(symbol) then
                _work_queue.enqueue(() =>
                    cast Semantic.Symbols.Classy(symbol).pull_down_super_symbols()
                );
            fi
        si
    si
si
