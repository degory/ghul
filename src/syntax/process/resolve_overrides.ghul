namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Tree;
    use Source;

    class RESOLVE_OVERRIDES: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;

        _stub_depth: int;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        pre(pragma_: Definition.PRAGMA) -> bool is
            process_pragma(pragma_.pragma_, true);
        si

        visit(pragma_: Definition.PRAGMA) is
            process_pragma(pragma_.pragma_, false);
        si

        process_pragma(pragma_: Pragma.NODE, is_enter: bool) is
            if !pragma_? then
                System.Console.error.write_line("pragma is null");
                return;
            fi

            let name = pragma_.name.toString();

            if name =~ "IL.stub" then
                if is_enter then
                    _stub_depth = _stub_depth + 1;
                else
                    _stub_depth = _stub_depth - 1;
                fi
            fi            
        si

        pre(function: Definition.FUNCTION) -> bool is
            let symbol = current_scope.find_direct(function.name.name);

            if !symbol? then
                return true;
            elif !isa Semantic.Symbol.FUNCTION_GROUP(symbol) then
                return true;
            fi
            
            let function_group = cast Semantic.Symbol.FUNCTION_GROUP(symbol);
            function_group.resolve_overrides();

            return true;
        si

        visit(function: Definition.FUNCTION) is
        si

        check_overrides(node: Definition.NODE, location: Source.LOCATION) is
            if _stub_depth > 0 then
                return;
            fi            

            let symbol = symbol_for(node);

            if !symbol? || !isa Semantic.Symbol.Classy(symbol) then
                _logger.info(location, "oops: could not check overrides: no symbol found");
                return;
            fi
            
            cast Semantic.Symbol.Classy(symbol).check_overrides(_logger, location);            
        si        

        visit(class_: Definition.CLASS) is
            check_overrides(class_, class_.name.location);
        si

        visit(struct_: Definition.STRUCT) is
            check_overrides(struct_, struct_.name.location);
        si
    si
si
