namespace Syntax.Process is
    use IO.Std;

    use Logging;

    use Semantic.Symbols.Symbol;
    use Semantic.Types.Type;
    use Semantic.Types.NAMED;

    class RESOLVE_TYPE_EXPRESSIONS: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;
        _innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;

        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup    
        )
        is
            super.init(logger, stable_symbols, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_use_locations = symbol_use_locations;
            _innate_symbol_lookup = innate_symbol_lookup;
        si

        apply(root: Trees.Node) is
            root.walk(self);
        si

        pre(`class: Trees.Definitions.CLASS) -> bool is
            super.pre(`class);
            return is_stable(`class);
        si

        pre(`trait: Trees.Definitions.TRAIT) -> bool is
            super.pre(`trait);
            return is_stable(`trait);
        si        

        pre(`struct: Trees.Definitions.STRUCT) -> bool is
            super.pre(`struct);
            return is_stable(`struct);            
        si

        pre(`union: Trees.Definitions.UNION) -> bool is
            super.pre(`union);
            return is_stable(`union);
        si

        pre(variant: Trees.Definitions.VARIANT) -> bool is
            super.pre(variant);
            return is_stable(variant);
        si

        visit(named: Trees.TypeExpressions.NAMED) is
            named.type = null;

            let symbol = find(named.name);

            if symbol? then
                if symbol.is_type /\ isa Semantic.Types.Typed(symbol) then
                    _symbol_use_locations.add_symbol_use(named.name.right_location, symbol);

                    named.type = cast Semantic.Types.Typed(symbol).type;
                else
                    named.type = new Semantic.Types.ERROR();
                    _logger.error(named.name.location, "cannot use this as a type");
                fi
            fi
        si

        visit(element: Trees.TypeExpressions.NAMED_TUPLE_ELEMENT) is
            element.type_expression.accept(self);            
        si

        visit(generic: Trees.TypeExpressions.GENERIC) is
            generic.type = null;

            let symbol = find(generic.name);

            if symbol? then
                _symbol_use_locations.add_symbol_use(generic.name.right_location, symbol);

                if !isa Semantic.Symbols.Classy(symbol) then
                    generic.type = new Semantic.Types.ERROR();
                    _logger.error(generic.location, "cannot supply type arguments here");
                    return;
                fi

                let arguments = new Collections.LIST[Type]();

                for a in generic.arguments do
                    if a.type? then
                        arguments.add(a.type);
                    else
                        arguments.add(new Semantic.Types.ERROR());
                    fi
                od

                generic.type = new Semantic.Types.GENERIC(
                    generic.location,
                    cast Semantic.Symbols.Classy(symbol),
                    arguments);

                if symbol.is_unsafe_constraints then
                    _logger.warn(generic.location, "type {generic.type} has unchecked constraints");
                fi    
            else
                generic.type = new Semantic.Types.ERROR();
            fi
        si

        explicit_specialize_symbol(
            location: Source.LOCATION, 
            left_value: IR.Values.Value,
            symbol: Semantic.Symbols.Symbol, 
            type_arguments: Collections.List[Semantic.Types.Type]
        ) -> IR.Values.Value
        is
            symbol = 
                symbol.try_specialize(
                    location,
                    _logger,
                    type_arguments
                );

            let from: IR.Values.Value;

            if isa IR.Values.Load.SYMBOL(left_value) then
                let load = cast IR.Values.Load.SYMBOL(left_value);

                from = load.from;
            fi

            if symbol? then
                return
                    new IR.Values.Load.SYMBOL(from, symbol);
            else
                return 
                    new IR.Values.DUMMY(new Semantic.Types.ERROR(), location);
            fi
        si

        visit(structured: Trees.TypeExpressions.Structured) is
            Std.error.write_line("visit TypeExpressions.Structured called");
        si

        get_type_or_any(element: Type) -> Type is
            if element? then
                return element;
            else
                return new Semantic.Types.ERROR();
            fi
        si
        
        visit(array: Trees.TypeExpressions.ARRAY_) is
            array.type =
                _innate_symbol_lookup.get_array_type(
                    get_type_or_any(array.element.type));                        
        si

        visit(pointer: Trees.TypeExpressions.POINTER) is
            pointer.type =
                _innate_symbol_lookup.get_pointer_type(
                    get_type_or_any(pointer.element.type));
        si

        visit(reference: Trees.TypeExpressions.REFERENCE) is
            reference.type =
                _innate_symbol_lookup.get_reference_type(
                    get_type_or_any(reference.element.type));                        
        si

        pre(member: Trees.TypeExpressions.MEMBER) -> bool is
            super.pre(member);
        si

        visit(member: Trees.TypeExpressions.MEMBER) is
            // we have something like
            //    Namespace.TYPE[type-arguments].member
            // we need to translate it to
            //    Namespace.TYPE.member[type-arguments]

            try
                if !member.left? then
                    member.type = new Semantic.Types.ERROR();
                    return;
                fi

                let qualified = member.left.qualify_member(member.name);

                qualified.walk(self);
        
                member.type = qualified.type;
            catch ex: System.Exception 
                _logger.exception(member.location, ex, "exception resolving types in type member expression");
                member.type = new Semantic.Types.ERROR();
            yrt
        si

        visit(function: Trees.TypeExpressions.FUNCTION) is
            let types = new Collections.LIST[Type]();

            for a in function.arguments do
                types.add(get_type_or_any(a.type));
            od
            
            types.add(get_type_or_any(function.result.type));

            function.type =
                _innate_symbol_lookup.get_function_type(types);
        si

        visit(tuple: Trees.TypeExpressions.TUPLE) is
            let names = new Collections.LIST[string]();
            let types = new Collections.LIST[Type]();

            let seen_any_named = false;

            for (index, a) in tuple.elements | .index() do
                if isa Trees.TypeExpressions.NAMED_TUPLE_ELEMENT(a) then
                    let element = cast Trees.TypeExpressions.NAMED_TUPLE_ELEMENT(a);

                    names.add(element.name.name);
                    seen_any_named = true;

                    if element.type_expression? then
                        types.add(get_type_or_any(element.type_expression.type));
                    else
                        types.add(new Semantic.Types.ERROR());
                    fi
                else
                    names.add("`{index}");
                    types.add(get_type_or_any(a.type));
                fi
            od

            if !seen_any_named then
                names = null;
            fi
            
            tuple.type =
                _innate_symbol_lookup.get_tuple_type(types, names);
        si

        pre(type_expression: Trees.Expressions.AMBIGUOUS_EXPRESSION) -> bool is
            let use debug_dispose = debug_enter();

/*
            this TYPE_EXPRESSION could turn out be one of three things:
            1. application of type arguments to a named-type type expression
            2. application of type arguments to a function name
            3. an indexer operation where the left-hand side is an identifier

            we need to figure out which

            we have:
            1. an index expression, that may be null if the parser already
            determined that this cannot be an index expression
            2. an identifier, which is the left hand side, if this is not an
            index expression
            3. a list of type arguments, which are to be applied to the left
            hand side, if this is not an index expression

            if the parser determined 

 */

            debug("resolve ambiguous type expression...");

            debug("value expression: {type_expression.expression}");

            debug("identifier: {type_expression.identifier}");
            debug("type arguments: {type_expression.type_arguments}");

            let symbol = find(type_expression.identifier);

            if !symbol? then
                _logger.error(type_expression.identifier.location, "symbol not found");
            elif symbol.is_type \/ symbol.is_function then
                type_expression.type_arguments.walk(self);            

                if symbol.is_type then
                    _logger.info(type_expression.location, "generic type arguments");
    
                    let generic_type = specialize_type(type_expression.location, symbol, type_expression.type_arguments);
    
                    type_expression.result = new Trees.Expressions.AmbiguousExpressionResult.TYPE(generic_type);
                elif symbol.is_function then
                    _logger.info(type_expression.location, "generic function arguments");
                    let function_symbol = specialize_symbol(type_expression.location, symbol, type_expression.type_arguments);
    
                    type_expression.result = new Trees.Expressions.AmbiguousExpressionResult.FUNCTION(function_symbol);
                fi
                
            else
                _logger.info(type_expression.location, "assume indexer");

                type_expression.expression.walk(self);

                type_expression.result = new Trees.Expressions.AmbiguousExpressionResult.INDEX();
            fi

            return true;
        si

        visit(type_expression: Trees.Expressions.AMBIGUOUS_EXPRESSION) is
        si

        pre(generic_application: Trees.Expressions.GENERIC_APPLICATION) -> bool is
            let use debug_dispose = debug_enter();

            debug("resolve generic application expression...");

            debug("identifier: {generic_application.identifier} of type {generic_application.identifier.get_type()}");
            debug("type arguments: {generic_application.type_arguments}");

            let symbol = find(generic_application.identifier);

            if !symbol? then
                _logger.error(generic_application.identifier.location, "symbol not found");
                return true;
            fi

            debug("symbol {symbol} is type {symbol.is_type} is function {symbol.is_function}");

            generic_application.type_arguments.walk(self);            

            if symbol.is_type then
                debug("symbol is type: try to apply arguments giving a type result");

                _logger.info(generic_application.location, "generic type arguments");

                let generic_type = specialize_type(generic_application.location, symbol, generic_application.type_arguments);

                generic_application.result = new Trees.Expressions.GenericApplicationResult.TYPE(generic_type);
            elif symbol.is_function then
                debug("symbol is type: try to apply arguments giving a symbol result");

                _logger.info(generic_application.location, "generic function arguments");
                let function_symbol = specialize_symbol(generic_application.location, symbol, generic_application.type_arguments);

                generic_application.result = new Trees.Expressions.GenericApplicationResult.FUNCTION(function_symbol);
            else
                debug("symbol is something else: report an error");

                _logger.error(generic_application.identifier.location, "cannot apply type arguments to this")
            fi

            debug("result is: {generic_application.result}");

            return true;
        si

        visit(type_expression: Trees.Expressions.GENERIC_APPLICATION) is
        si

        specialize_type(location: Source.LOCATION, symbol: Semantic.Symbols.Symbol, arguments: Trees.TypeExpressions.LIST) -> Semantic.Types.Type is
            // _symbol_use_locations.add_symbol_use(generic.name.right_location, symbol);

            if !isa Semantic.Symbols.Classy(symbol) then
                _logger.error(location, "cannot supply type arguments here");
                return new Semantic.Types.ERROR();
            fi

            let result = new Semantic.Types.GENERIC(
                location,
                cast Semantic.Symbols.Classy(symbol),
                arguments | .map(
                    a => if a? /\ a.type? then a.type else new Semantic.Types.ERROR() fi
                ).collect()
            );

            if symbol.is_unsafe_constraints then
                _logger.warn(location, "type {result} has unchecked constraints");
            fi    

            return result;
        si

        specialize_symbol(location: Source.LOCATION, symbol: Semantic.Symbols.Symbol, arguments: Trees.TypeExpressions.LIST) -> Semantic.Symbols.Symbol is
            return 
                symbol.try_specialize(
                    location,
                    _logger,
                    arguments.elements | 
                        .map(t => t.type).collect()
                );
        si
    si
si
