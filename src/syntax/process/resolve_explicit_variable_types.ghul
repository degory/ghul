namespace Syntax.Process is
    use IO.Std;

        
    use Logging;

    use Semantic.Types.Type;

    class RESOLVE_EXPLICIT_TYPES: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;

        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup
        )
        is
            super.init(logger, stable_symbols, symbol_table, namespaces);

            _symbol_table = symbol_table;
            _logger = logger;
            _innate_symbol_lookup = innate_symbol_lookup;
        si

        apply(root: Trees.Node) is
            root.walk(self);
        si

        pre(`class: Trees.Definitions.CLASS) -> bool is
            let result = super.pre(`class);

            if is_stable(`class) then
                return true;
            fi            

            set_generic_argument_types(`class.arguments);

            return result;
        si

        pre(`trait: Trees.Definitions.TRAIT) -> bool is
            super.pre(`trait);
            return is_stable(`trait);            
        si        

        pre(`struct: Trees.Definitions.STRUCT) -> bool is
            super.pre(`struct);
            return is_stable(`struct);            
        si
        
        visit(function: Trees.Definitions.FUNCTION) is
            let symbol = _symbol_table.current_function;

            if symbol == null then
                super.visit(function);
                return;
            fi

            let types = new Collections.LIST[Type]();
            let names = new Collections.LIST[string]();

            for argument in function.arguments do
                let type = argument.type_expression.type;

                types.add(type);
                names.add(argument.name.name);
            od

            if !isa Trees.TypeExpressions.INFER(function.type_expression) then
                symbol.return_type = function.type_expression.type;
            else
                symbol.set_void_return_type();
            fi

            symbol.arguments = types;
            symbol.argument_names = names;

            super.visit(function);
        si

        pre(property: Trees.Definitions.PROPERTY) -> bool is
            return true;
        si

        visit(property: Trees.Definitions.PROPERTY) is            
            if property.name == null \/ property.name.name == null \/ property.type_expression == null then
                super.visit(property);
                return;
            fi

            let f = find(property.name);

            if f == null \/ !isa Semantic.Types.SettableTyped(f) then
                super.visit(property);
                return;
            fi

            let symbol = cast Semantic.Types.SettableTyped(f);

            if symbol? /\ !isa Trees.TypeExpressions.INFER(property.type_expression) then
                if f.is_field then
                    property.type_expression.check_is_not_reference(_logger, "field cannot be of reference type");
                else
                    property.type_expression.check_is_not_reference(_logger, "property cannot be of reference type");
                fi
                
                symbol.set_type(property.type_expression.type);
            fi

            super.visit(property);
        si        
        
        // FIXME: think we're doing this twice:
        visit(variable: Trees.Variables.Variable) is
            if variable.name == null then
                return;
            fi

            let symbol = find(variable.name);

            if symbol? /\ isa Semantic.Types.SettableTyped(symbol) then
                let typed_symbol = cast Semantic.Types.SettableTyped(symbol);

                if typed_symbol.type? then
                    _logger.poison(variable.location, "set type twice for variable " + symbol);
                    return;
                fi

                if variable.type_expression? then
                    if !isa Trees.TypeExpressions.INFER(variable.type_expression) then
                        if variable.type_expression.type? then
                            if !symbol.is_argument /\ !symbol.is_internal then
                                variable.type_expression.check_is_not_reference(_logger, "variable cannot be of reference type");
                            fi

                            typed_symbol.set_type(variable.type_expression.type);
                        fi
                    fi
                    
                else
                    _logger.poison(variable.location, "variable has no type expression");
                    typed_symbol.set_type(new Semantic.Types.ERROR());
                fi
            else
                _logger.poison(variable.name.location, "cannot locate typed symbol for variable");
            fi       
        si

        visit(variable: Trees.Expressions.VARIABLE) is
            if variable.name == null then
                return;
            fi

            let symbol = find(variable.name);
            
            if symbol? /\ isa Semantic.Types.SettableTyped(symbol) then
                let typed_symbol = cast Semantic.Types.SettableTyped(symbol);
                
                // FIXME: #549 Setting types twice for anonymous function arguments
                if typed_symbol.type == null then
                    if variable.type_expression? /\ !isa Trees.TypeExpressions.INFER(variable.type_expression) then                    
                        typed_symbol.set_type(variable.type_expression.type);
                    // else
                    //     _logger.poison(variable.location, "something went wrong with variable type");
                    fi
                fi
            else
                _logger.poison(variable.name.location, "cannot locate symbol for variable");
            fi        
        si

        set_type_ancestors(a: Trees.TypeExpressions.TypeExpression) is
            let symbol: Semantic.Symbols.Symbol;
            let type: Type;

            if isa Trees.TypeExpressions.NAMED(a) then
                let named = cast Trees.TypeExpressions.NAMED(a);                

                symbol = find(named.name);
                type = _innate_symbol_lookup.get_object_type();
            elif isa Trees.TypeExpressions.NAMED_TUPLE_ELEMENT(a) then
                let named = cast Trees.TypeExpressions.NAMED_TUPLE_ELEMENT(a);

                symbol = find(named.name);
                type = named.type_expression.type;
            fi

            if symbol? /\ type? /\ isa Semantic.Symbols.TYPE(symbol) then
                let type_symbol = cast Semantic.Symbols.TYPE(symbol);
                type_symbol.ancestor = type.scope;
                
                if type.scope? /\ isa Semantic.Symbols.TYPE(type.scope) then
                    Std.error.write_line("FIXME: ancestor may need to be fixed up: " + type.scope);
                fi                
            fi
        si
                
        set_generic_argument_types(arguments: Trees.TypeExpressions.LIST) is
            if arguments? then
                for a in arguments do
                    set_type_ancestors(a);
                od
            fi            
        si
    si
si
