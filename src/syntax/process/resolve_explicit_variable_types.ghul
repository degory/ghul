namespace Syntax.Process is
    use System;
        
    use Logging;

    class RESOLVE_EXPLICIT_TYPES: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _generic_cache: Semantic.GENERIC_CACHE;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            generic_cache: Semantic.GENERIC_CACHE,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP
        )
        is
            super.init(logger, symbol_table, namespaces);

            _symbol_table = symbol_table;
            _logger = logger;
            _generic_cache = generic_cache;
            _system_symbol_lookup = system_symbol_lookup;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si
        
        visit(function: Tree.Definition.FUNCTION) is
            let symbol = _symbol_table.current_function;

            if symbol == null then
                super.visit(function);
                return;
            fi

            let types = new Collections.LIST[Semantic.Type.BASE]();
            let names = new Collections.LIST[String]();

            for argument in function.arguments do
                let type = argument.type_expression.type;

                types.add(type);
                names.add(argument.name.name);
            od

            // FIXME: this should be a structured function type
            // encompassing arguments and return type:
            if !isa Tree.TypeExpression.INFER(function.type_expression) then
                symbol.return_type = function.type_expression.type;
            else
                symbol.return_type = IoC.CONTAINER.instance.ghul_symbol_lookup.get_void_type();
            fi

            symbol.arguments = types;
            symbol.argument_names = names;

            super.visit(function);
        si

        visit(property: Tree.Definition.PROPERTY) is            
            if property.name == null || property.name.name == null || property.type_expression == null then
                super.visit(property);
                return;
            fi

            let f = find(property.name);

            @IF.debug()
            if f? && !isa Semantic.Type.SettableTyped(f) then
                System.Console.write_line("case 3: symbol is: " + f);
                System.Console.write_line("symbol type: " + f.get_type());
                System.Console.write_line("symbol isa settable: " + isa Semantic.Type.SettableTyped(f));    
                System.Console.write_line("symbol isa variable: " + isa Semantic.Symbol.Variable(f));
                System.Console.write_line("symbol isa BASE: " + isa Semantic.Symbol.BASE(f));
            fi

            if f == null || !isa Semantic.Type.SettableTyped(f) then
                super.visit(property);
                return;
            fi

            let symbol = cast Semantic.Type.SettableTyped(f);

            if symbol? && !isa Tree.TypeExpression.INFER(property.type_expression) then
                symbol.set_type(property.type_expression.type);
            fi

            super.visit(property);
        si        
        
        // FIXME: think we're doing this twice:
        visit(variable: Tree.Variable.NODE) is
            if variable.name == null then
                return;
            fi

            var symbol = find(variable.name);

            @IF.debug()
            if symbol? && !isa Semantic.Type.SettableTyped(symbol) then
                System.Console.write_line("case 4: symbol is: " + symbol);
                System.Console.write_line("symbol type: " + symbol.get_type());
                System.Console.write_line("symbol isa settable: " + isa Semantic.Type.SettableTyped(symbol));
                System.Console.write_line("symbol isa variable: " + isa Semantic.Symbol.Variable(symbol));
                System.Console.write_line("symbol isa BASE: " + isa Semantic.Symbol.BASE(symbol));

                let x = cast Semantic.Symbol.Variable(symbol);

                System.Console.write_line("variable type: " + x.get_type());
                System.Console.write_line("variable isa settable: " + isa Semantic.Type.SettableTyped(x));
                System.Console.write_line("variable isa variable: " + isa Semantic.Symbol.Variable(x));
                System.Console.write_line("variable isa BASE: " + isa Semantic.Symbol.BASE(x));
            fi

            if symbol? && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);

                if typed_symbol.type? then
                    _logger.info(variable.location, "set type twice for variable");

                    // assert(typed_symbol.type.is_assignable_from(_system_symbol_lookup.get_exception_type()), "variable already has type set"); 

                    return;
                fi

                if variable.type_expression? then
                    if !isa Tree.TypeExpression.INFER(variable.type_expression) then                    
                        if variable.type_expression.type? then
                            typed_symbol.set_type(variable.type_expression.type);
                        fi
                    fi
                    
                else                
                    _logger.info(variable.location, "variable has no type expression");
                    typed_symbol.set_type(new Semantic.Type.ANY());
                fi
            else
                _logger.info(variable.name.location, "cannot locate typed symbol for variable");
            fi       
        si

        visit(variable: Tree.Expression.VARIABLE) is
            if variable.name == null then
                return;
            fi

            var symbol = find(variable.name);
            
            if symbol? && !isa Semantic.Type.SettableTyped(symbol) then
                System.Console.write_line("case 5: symbol is: " + symbol);
                System.Console.write_line("symbol type: " + symbol.get_type());
                System.Console.write_line("symbol isa settable: " + isa Semantic.Type.SettableTyped(symbol));
                System.Console.write_line("symbol isa variable: " + isa Semantic.Symbol.Variable(symbol));
                System.Console.write_line("symbol isa BASE: " + isa Semantic.Symbol.BASE(symbol));
            fi

            if symbol? && isa Semantic.Type.SettableTyped(symbol) then
                var typed_symbol = cast Semantic.Type.SettableTyped(symbol);
                
                // FIXME: #549 Setting types twice for anonymous function arguments
                if typed_symbol.type == null then
                    if variable.type_expression? && !isa Tree.TypeExpression.INFER(variable.type_expression) then                    
                        typed_symbol.set_type(variable.type_expression.type);
                    else
                        _logger.info(variable.location, "something went wrong with variable type");
                    fi
                fi
            else
                _logger.info(variable.name.location, "cannot locate typed symbol for variable");
            fi        
        si

        set_type_ancestors(a: Tree.TypeExpression.NODE) is
            let symbol: Semantic.Symbol.BASE;
            let type: Semantic.Type.BASE;

            if isa Tree.TypeExpression.NAMED(a) then
                let named = cast Tree.TypeExpression.NAMED(a);                

                symbol = find(named.name);
                type = _system_symbol_lookup.get_object_type();
            elif isa Tree.TypeExpression.NAMED_TUPLE_ELEMENT(a) then
                let named = cast Tree.TypeExpression.NAMED_TUPLE_ELEMENT(a);

                symbol = find(named.name);
                type = named.type_expression.type;
            fi

            if symbol? && type? && isa Semantic.Symbol.TYPE(symbol) then
                let type_symbol = cast Semantic.Symbol.TYPE(symbol);
                type_symbol.ancestor = type.scope;
                
                if type.scope? && isa Semantic.Symbol.TYPE(type.scope) then
                    System.Console.error.write_line("FIXME: ancestor may need to be fixed up: " + type.scope);
                fi                
            fi
        si
                
        set_generic_argument_types(arguments: Tree.TypeExpression.LIST) is
            if arguments? then
                for a in arguments do
                    set_type_ancestors(a);
                od
            fi            
        si
        
        pre(class_: Tree.Definition.CLASS) -> bool is
            let result = super.pre(class_);

            set_generic_argument_types(class_.arguments);

            return result;
        si
    si
si
