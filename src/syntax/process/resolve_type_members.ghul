namespace Syntax.Process is
    use IO.Std;

    
    use Logging;

    use Semantic.Symbols.Symbol;
    use Semantic.Types.Type;
    use Semantic.Types.NAMED;

    class RESOLVE_TYPE_MEMBERS: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup    
        )
        is
            super.init(logger, stable_symbols, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_use_locations = symbol_use_locations;
        si

        apply(root: Trees.Node) is
            root.walk(self);
        si

        pre(member: Trees.TypeExpressions.MEMBER) -> bool is
            debug_enter();
            debug("pre member: {member.left} {member.name}...");

            super.pre(member);
        si

        visit(member: Trees.TypeExpressions.MEMBER) is
            try
                debug("visit member: {member.left} {member.name}...");

                if !member.left? \/ !member.name? then
                    debug("no member left or no name");                
    
                    member.type = new Semantic.Types.ERROR();
    
                    return;
                fi
   
                let left_type = member.left.type;

                if !left_type? then
                    debug("no member left type");
    
                    member.type = new Semantic.Types.ERROR();
    
                    _logger.error(member.left.location, "no type for {member.left}");
    
                    return;
                fi

                debug("left has a type");

                let symbol = left_type.find_member(member.name.name);

                if !symbol? then
                    debug("no member symbol");
    
                    member.type = new Semantic.Types.ERROR();
    
                    _logger.error(member.name.location, "member {member.name.name} not found in left type");
    
                    return;
                fi

                debug("member symbol: {symbol}");

                if !symbol.is_type then
                    debug("member symbol is not a type");
    
                    member.type = new Semantic.Types.ERROR();
    
                    _logger.error(member.name.location, "{member.name.name} is not a type");
    
                    return;
                fi

                debug("member symbol type: {symbol.type}");
        
                member.type = symbol.type;

                debug("done member: {member.left} {member.name}");

            catch ex: System.Exception 
                debug("type member caught exception: {ex}");
                member.type = new Semantic.Types.ERROR();
            finally
                debug_exit();
            yrt
        si
    si
si
