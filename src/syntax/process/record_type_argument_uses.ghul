namespace Syntax.Process is
    use IO.Std;

    use Logging;

    use Semantic.Types.Type;

    // TODO make sure we only do this if we're actually generating IL -
    // it shouldn't be needed for the language extension
    class RECORD_TYPE_ARGUMENT_USES: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;

        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup
        )
        is
            super.init(logger, stable_symbols, symbol_table, namespaces);

            _symbol_table = symbol_table;
            _logger = logger;
            _innate_symbol_lookup = innate_symbol_lookup;
        si

        apply(root: Trees.Node) is
            root.walk(self);
        si

        pre(ambiguous_expression: Trees.Expressions.AMBIGUOUS_EXPRESSION) -> bool is
            if ambiguous_expression.result == Trees.Expressions.AMBIGUOUS_EXPRESSION_RESULT.INDEX then
                return false;
            fi

            ambiguous_expression.type_arguments.walk(self);

            return true;
        si

        pre(function: Trees.Expressions.FUNCTION) -> bool is
            super.pre(function);
            debug_enter();
            debug("enter lambda at {function.location}");
        si

        visit(function: Trees.Expressions.FUNCTION) is
            debug("exit lambda at {function.location}");
            debug_exit();
            super.visit(function);
        si

        visit(named: Trees.TypeExpressions.NAMED) is  
            if !named.type? then
                return;
            fi
            
            if !named.type.is_type_variable then
                return;
            fi

            let use debug_dispose = debug_enter();

            let closure = current_closure;

            if !closure? then
                debug_always("ignore type variable: {named} ({named.get_type()}) not in closure at {named.location}");
                return;
            fi

            debug_always("closure at {closure.location} captures type variable {named}");

            closure.add_type_argument_reference(named.type.symbol);
        si
    si
si
