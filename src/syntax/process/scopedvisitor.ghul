namespace Syntax.Process is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System;
        
    use Logging;
    use Trees;

    class ScopedVisitor: ScopeVisitorBase is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES
        )
        is
            super.init(
                symbol_table,
                namespaces
            );

            _logger = logger;
            _symbol_table = symbol_table;
        si

        find(name: string) -> Semantic.Symbols.Symbol is
            return _symbol_table.current_scope.find_enclosing(name);
        si

        find_matches(prefix: string, matches: Collections.MAP[string,Semantic.Symbols.Symbol]) is
            _symbol_table.current_scope.find_enclosing_matches(prefix, matches);
        si
        
        find(identifier: Identifiers.Identifier) -> Semantic.Symbols.Symbol is
            if identifier.name == null then
                return null;
            fi

            var result: Semantic.Symbols.Symbol;

            if identifier.qualifier? then
                let qualifier = find(identifier.qualifier);

                if qualifier == null then
                    return null;
                fi

                result = qualifier.find_member(identifier.name);
            else
                result =
                    _symbol_table
                        .current_scope
                        .find_enclosing(identifier.name);
            fi

            if result == null then
                _logger.error(identifier.location, "symbol not found: " + identifier);
            fi

            return result;
        si

        pre(namespace_: Definitions.NAMESPACE) -> bool is
            enter_namespace(namespace_.name);
            enter_uses(namespace_);
        si

        visit(namespace_: Definitions.NAMESPACE) is
            leave_uses(namespace_);
            leave_namespace(namespace_.name);
        si

        pre(class_: Definitions.CLASS) -> bool is
            enter_scope(class_);
        si

        visit(class_: Definitions.CLASS) is
            leave_scope(class_);
        si

        pre(trait_: Definitions.TRAIT) -> bool is
            enter_scope(trait_);
        si

        visit(trait_: Definitions.TRAIT) is
            leave_scope(trait_);
        si

        pre(struct_: Definitions.STRUCT) -> bool is
            enter_scope(struct_);
        si

        visit(struct_: Definitions.STRUCT) is
            leave_scope(struct_);
        si        

        pre(enum_: Definitions.ENUM) -> bool is
            enter_scope(enum_);
        si

        visit(enum_: Definitions.ENUM) is
            leave_scope(enum_);
        si

        pre(function: Definitions.FUNCTION) -> bool is
            enter_scope(function);
        si

        visit(function: Definitions.FUNCTION) is
            leave_scope(function);
        si

        pre(property: Definitions.PROPERTY) -> bool is
            // enter_scope(property);
            // return true;
        si

        visit(property: Definitions.PROPERTY) is
            // leave_scope(property);
        si

        pre(indexer: Definitions.INDEXER) -> bool is
            // enter_scope(indexer);
            return true;
        si

        visit(indexer: Definitions.INDEXER) is
            // leave_scope(indexer);
        si        

        pre(if_branch: Statements.IF_BRANCH) -> bool is
            enter_scope(if_branch);
        si

        visit(if_branch: Statements.IF_BRANCH) is
            leave_scope(if_branch);
        si

        pre(case_: Statements.CASE) -> bool is
            enter_scope(case_);
        si

        visit(case_: Statements.CASE) is
            leave_scope(case_);
        si

        pre(case_match: Statements.CASE_MATCH) -> bool is
            enter_scope(case_match);
        si

        visit(case_match: Statements.CASE_MATCH) is
            leave_scope(case_match);
        si

        pre(try_: Statements.TRY) -> bool is
            enter_scope(try_);
        si

        visit(try_: Statements.TRY) is
            leave_scope(try_);
        si

        pre(catch_: Statements.CATCH) -> bool is
            enter_scope(catch_);
        si

        visit(catch_: Statements.CATCH) is
            leave_scope(catch_);
        si

        pre(do_: Statements.DO) -> bool is
            enter_scope(do_);
        si

        visit(do_: Statements.DO) is
            leave_scope(do_);
        si

        pre(for_: Statements.FOR) -> bool is
            enter_scope(for_);
        si

        visit(for_: Statements.FOR) is
            leave_scope(for_);
        si

        pre(labelled: Statements.LABELLED) -> bool is
            enter_scope(labelled);
        si

        visit(labelled: Statements.LABELLED) is
            leave_scope(labelled);
        si

        pre(function: Expressions.FUNCTION) -> bool is
            enter_scope(function);
        si

        visit(function: Expressions.FUNCTION) is
            leave_scope(function);
        si

        pre(expression: Bodies.EXPRESSION) -> bool is
            enter_scope(expression);
        si

        visit(expression: Bodies.EXPRESSION) is
            leave_scope(expression);
        si

        pre(block: Bodies.BLOCK) -> bool is
            enter_scope(block);
        si

        visit(block: Bodies.BLOCK) is
            leave_scope(block);
        si
    si
si
