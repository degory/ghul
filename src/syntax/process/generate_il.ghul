namespace Syntax.Process is
    use IO.Std;

    use System.Text.StringBuilder;
        
    use Logging;
    use Trees;
    use Source;

    use IR;
    use IR.Values;

    class GENERATE_IL: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Types.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        _context: CONTEXT;
        _brancher: BRANCHER;
        _boilerplate_generator: BOILERPLATE_GENERATOR;
        _boxer: VALUE_BOXER;
        _loops: LOOP_LABEL_STACK;

        _stub_depth: int;
        _il_output_depth: int;

        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;        

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            context: CONTEXT,
            brancher: BRANCHER,
            boilerplate_generator: BOILERPLATE_GENERATOR,
            boxer: VALUE_BOXER
        )
        is
            super.init(logger, null, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _innate_symbol_lookup = innate_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;
            _context = context;
            _brancher = brancher;
            _boilerplate_generator = boilerplate_generator;
            _boxer = boxer;

            _loops = new LOOP_LABEL_STACK();
        si

        apply(root: Trees.Node) is
            if _logger.any_errors then
                return;
            fi

            _logger.reset();

            root.walk(self);

            _logger.reset();
        si

        println(value: object) is
            _context.write_line(value);
        si

        println(value: object, comment: object) is
            _context.write_line(value, comment);
        si

        println_comment(value: object) is
            _context.write_comment_line(value);
        si

        gen(value: Value) is
            Value.gen(value, _context);
        si

        enter_class(symbol: Semantic.Symbols.Classy) is
            ADDRESS.reset_id();
            TEMP.reset_id();
            LABEL.reset_id();
        si

        leave_class(symbol: Semantic.Symbols.Classy) is
        si        
        
        print_class_def(symbol: Semantic.Symbols.Symbol) is
            println_comment("define " + symbol.description);

            let buffer = new System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);

            println(buffer);

            println("{");            
        si

        pre(`namespace: Definitions.NAMESPACE) -> bool is
            super.pre(`namespace);
        si

        visit(`namespace: Definitions.NAMESPACE) is
            let context = _symbol_table.current_closure_context;
            
            gen_anon_functions(context.get_closures());
            gen_closures(context.get_closures());

            super.visit(`namespace);
        si
        
        pre(`class: Definitions.CLASS) -> bool is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`class));

            @IF.debug() Std.error.write_line("define " + symbol.description);

            enter_class(symbol);

            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            print_class_def(symbol);

            enter_scope(`class);

            _context.indent();
        si
        
        visit(`class: Definitions.CLASS) is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`class));

            gen_ienumerable_boilerplate(symbol);
            gen_ienumerator_boilerplate(symbol);
            gen_anon_functions(symbol.closures);

            _context.outdent();
            println("}");

            leave_class(symbol);

            leave_scope(`class);

            gen_closures(symbol.closures);
        si

        pre(`trait: Definitions.TRAIT) -> bool is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`trait));
            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            @IF.debug() Std.error.write_line("define " + symbol.description);

            enter_class(symbol);

            print_class_def(symbol);

            enter_scope(`trait);

            _context.indent();
        si

        visit(`trait: Definitions.TRAIT) is
            _context.outdent();
            println("}");

            let symbol = cast Semantic.Symbols.Classy(symbol_for(`trait));

            leave_class(symbol);

            leave_scope(`trait);
        si

        pre(`struct: Definitions.STRUCT) -> bool is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`struct));
            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            enter_class(symbol);

            print_class_def(symbol);

            _context.indent();

            enter_scope(`struct);            
        si

        visit(`struct: Definitions.STRUCT) is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`struct));

            gen_ienumerable_boilerplate(symbol);
            gen_ienumerator_boilerplate(symbol);
            gen_anon_functions(symbol.closures);

            _context.outdent();
            println("}");

            leave_class(symbol);

            leave_scope(`struct);

            gen_closures(symbol.closures);
        si        

        gen_ienumerable_boilerplate(symbol: Semantic.Symbols.Classy) is            
            if symbol.is_derived_from_iterable_trait then
                // FIXME: check if class implements these methods and don't emit them if they're not needed:

                _boilerplate_generator.gen("ienumerable-boilerplate");
            fi            
        si
        
        gen_ienumerator_boilerplate(symbol: Semantic.Symbols.Classy) is            
            if symbol.is_derived_from_iterator_trait then
                // FIXME: check if class implements these methods and don't emit them if they're not needed:

                _boilerplate_generator.gen("ienumerator-boilerplate");
            fi
        si

        gen_anon_functions(closures: Collections.Iterable[Semantic.Symbols.Closure]) is
            if closures? then
                for anon_function in closures | .filter(c => c.is_anon_func_or_delegate) do
                    let buffer = new StringBuilder();
                    anon_function.gen_definition_header(buffer);
                    _context.write_line(buffer);

                    _context.write_line("{");
                    _context.indent();
    
                    _context.write_line(anon_function.il_body);
    
                    _context.outdent();
                    _context.write_line("}");
                od
            fi
        si

        gen_closures(closures: Collections.Iterable[Semantic.Symbols.Closure]) is
            if closures? then
                for closure in closures | .filter(c => !c.is_anon_func_or_delegate) do                   
                    closure.gen_frame(_context, _symbol_loader);
                od
            fi
        si

        pre(`enum: Definitions.ENUM) -> bool is
            let symbol = cast Semantic.Symbols.Symbol(symbol_for(`enum));

            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            @IF.debug() Std.error.write_line("define " + symbol.description);

            @IF.debug() debug_enter_file(symbol);

            print_class_def(symbol);

            enter_scope(`enum);

            _context.indent();

            _context.write_line(".field public specialname rtspecialname int32 value__ ");
        si

        visit(`enum: Definitions.ENUM) is
            _context.outdent();
            println("}");

            @IF.debug() let symbol = cast Semantic.Symbols.Symbol(symbol_for(`enum));
            @IF.debug() debug_leave_file(symbol);

            leave_scope(`enum);
        si

        pre(enum_member: Definitions.ENUM_MEMBER) -> bool is
            let symbol = current_scope.find_member(enum_member.name.name);

            @IF.debug() Std.error.write_line("define " + symbol.description);

            let buffer = new System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);
            println(buffer);
        si

        pre(function: Definitions.FUNCTION) -> bool is
            let symbol = function_for(function);

            println_comment("define " + symbol.description);

            @IF.debug() Std.error.write_line("define " + symbol.description);

            let buffer = new System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);
            println(buffer);

            println("{");
            _context.indent();

            enter_scope(function);

            symbol.gen_body_header(_context);
        si

        visit(function: Definitions.FUNCTION) is
            let symbol = symbol_for(function);

            if symbol? /\ isa Semantic.Symbols.Function(symbol) then
                let function_symbol = cast Semantic.Symbols.Function(symbol);

                if !function_symbol.is_abstract then
                    if function.body? /\ isa Bodies.NULL(function.body) then
                        _context.write_line("newobj instance void class [System.Runtime]System.NotImplementedException::'.ctor'()");
                        _context.write_line("throw");
                    elif
                        function_symbol.return_type? /\
                        function_symbol.return_type.compare(self._innate_symbol_lookup.get_void_type()) != Semantic.Types.MATCH.SAME
                    then
                        _context.write_line(".locals init (" + function_symbol.return_type.get_il_type() + " '.default')");
                        _context.write_line("ldloc '.default'");
                    fi

                    _context.write_line("ret");
                fi
            fi

            leave_scope(function);

            _context.outdent();
            println("}");
        si

        pre(body: Bodies.BLOCK) -> bool is
            _context.write_line(".maxstack 64");

            return super.pre(body);
        si
        
        pre(expression_body: Bodies.EXPRESSION) -> bool is
            return super.pre(expression_body);            
        si
        
        visit(expression_body: Bodies.EXPRESSION) is
            _context.write_line(".maxstack 64");

            if
                expression_body.expression.value? /\
                expression_body.expression.value.type?
            then
                let value =
                    _boxer.box_if_needed(
                        expression_body.expression.value,
                        current_function.return_type
                    );

                gen(value);
            fi

            _context.write_line("ret");

            super.visit(expression_body);
        si

        pre(property: Definitions.PROPERTY) -> bool is
            let symbol = symbol_for(property);

            if !symbol? then
                return true;
            fi

            let buffer = new System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);
            println(buffer.to_string());            

            return true;
        si
       
        // FIXME: #500 Pragma handling code is duplicated across multiple visitors
        pre(pragma: Definitions.PRAGMA) -> bool is
            process_pragma(pragma.pragma, true);
        si

        visit(pragma: Definitions.PRAGMA) is
            process_pragma(pragma.pragma, false);
        si

        process_pragma(pragma: Pragmas.PRAGMA, is_enter: bool) is
            if !pragma? then
                Std.error.write_line("pragma is null");
                return;
            fi

            let name = pragma.name.to_string();

            if name =~ "IL.output" then
                if !pragma.arguments? \/ pragma.arguments.expressions.count != 1 then
                    _logger.error(pragma.arguments.location, "expected 1 argument");
                    return;
                fi

                let argument = pragma.arguments.expressions[0];

                if !argument? \/ !isa Expressions.Literals.STRING(argument) then
                    _logger.error(pragma.arguments.location, "expected a string literal argument");
                    return;
                fi

                let file_name = cast Expressions.Literals.STRING(argument).value_string;

                if is_enter then
                    _il_output_depth = _il_output_depth + 1;
                    _context.enter_file(file_name, false);
                else
                    _il_output_depth = _il_output_depth - 1;
                    _context.leave_file(file_name);
                fi
            elif name =~ "IL.stub" then
                if is_enter then
                    _stub_depth = _stub_depth + 1;
                    _context.enter_stub();
                else
                    _stub_depth = _stub_depth - 1;
                    _context.leave_stub();
                fi
            elif name =~ "IL.entrypoint" \/ name =~ "entry" then
                if is_enter then
                    if _context.seen_entrypoint then
                        _logger.error(pragma.location, "duplicate entrypoint");
                    else
                        _context.seen_entrypoint = true;
                        _context.write_line(".entrypoint");
                    fi
                fi
            elif name =~ "test" then
                if is_enter then
                    if current_function? then
                        _boilerplate_generator.gen("test-method");
                    else
                        _boilerplate_generator.gen("test-class");
                    fi
                fi
            elif name =~ "test_class" then
                if is_enter then
                    _boilerplate_generator.gen("test-class");
                fi
            elif name =~ "test_method" then
                if is_enter then
                    _boilerplate_generator.gen("test-method");
                fi
            fi
        si

        pre(function: Trees.Expressions.FUNCTION) -> bool is
            super.pre(function);
            return true;
        si

        visit(function: Trees.Expressions.FUNCTION) is
            _context.enter_buffer(true);

            let closure = cast Semantic.Symbols.Closure(scope_for(function));

            function.body.walk(self);

            if 
                closure.return_type? /\
                closure.return_type.compare(self._innate_symbol_lookup.get_void_type()) != Semantic.Types.MATCH.SAME
            then
                _context.write_line(".locals init (" + closure.return_type.get_il_type() + " '.default')");
                _context.write_line("ldloc '.default'");
            fi

            _context.write_line("// end IL body " + closure);

            _context.write_line("ret");

            let body_assembler = _context.leave_buffer();

            closure.il_body = body_assembler;

            super.visit(function);
        si

        visit(assign: Statements.ASSIGNMENT) is
            super.visit(assign);

            gen(assign.left.value);
        si

        visit(expression: Statements.EXPRESSION) is
            super.visit(expression);

            try
                gen(expression.expression.value);

                if 
                    expression.expression.value? /\
                    expression.expression.value.type? /\
                    expression.expression.value.type !~ _innate_symbol_lookup.get_void_type()
                then
                    _context.write_line("pop");                    
                fi
            catch e: System.Exception
                _logger.exception(expression.location, e, "caught exception generating IL for expression");
            yrt
        si

        pre(v: Variables.Variable) -> bool is
            super.pre(v);

            let symbol = find(v.name);

            if !symbol? then
                return false;
            fi

            let buffer = new System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);

            if buffer.length > 0 then
                println(buffer.to_string());
            fi
            
            if v.initializer? /\ v.initializer.value? then
                let store = symbol.store(v.location, null, v.initializer.value, _symbol_loader, true);

                gen(store);
            fi            
        si
       
        visit(r: Statements.RETURN) is
            super.visit(r);

            let function = current_function;

            let value: Value;

            if
                r.expression? /\
                r.expression.value? /\
                r.expression.value.type?
            then
                value =
                    _boxer.box_if_needed(
                        r.expression.value,
                        current_function.return_type
                    );

            fi

            let current_try = _loops.get_current_try();

            if current_try? then
                if value? then
                    current_try.return_value.store(value);                    
                fi
                
                if current_try.is_in_finally then
                    current_try.return_needed.store(new Literal.NUMBER("1", _innate_symbol_lookup.get_bool_type(), "i4"));
                    _brancher.branch(current_try.middle);
                else
                    _brancher.leave(current_try.start);
                fi
            else
                if value? then
                    gen(value);
                fi

                _context.write_line("ret");
            fi            
        si

        visit(`throw: Statements.THROW) is
            super.visit(`throw);

            gen(
                _boxer.box_if_value(
                    `throw.expression.value
                )
            );

            _context.write_line("throw");
        si

        visit(`assert: Statements.ASSERT) is
            super.visit(`assert);

            let end = new LABEL();

            _brancher.branch(
                BRANCH.NZ,
                `assert.expression.value,
                end
            );

            let need_exception_wrapper = true;

            if `assert.message? then
                let message_value = `assert.message.value; 
                if !_innate_symbol_lookup.get_exception_type().is_assignable_from(message_value.type) then
                    gen(
                        new Literal.STRING(
                            "" + `assert.location + ": ",
                            _innate_symbol_lookup.get_string_type()
                        )
                    );

                    gen(message_value);

                    _context.write_line("call string string::Concat(object,object)");
                else
                    need_exception_wrapper = false;
                fi
            else
                gen(
                    new Literal.STRING(
                        "" + `assert.location + ": " + `assert.expression,
                        _innate_symbol_lookup.get_string_type()
                    )
                );
            fi

            if need_exception_wrapper then
                _context.write_line("newobj instance void class [System.Runtime]System.Exception::.ctor(class [System.Runtime]System.String)");
            fi
            
            _context.write_line("throw");

            _brancher.label(end);
        si

        pre(i: Statements.IF) -> bool is
            super.pre(i);

            return true;
        si
        
        visit(i: Statements.IF) is
            let is_first = true;
            let seen_else = false;

            let end = new LABEL();

            for b in i.branches do
                let next = new LABEL();

                if b.condition? then
                    if is_first then
                        _brancher.branch(BRANCH.Z, b.condition.value, next, "if");
                    else
                        _brancher.branch(BRANCH.Z, b.condition.value, next, "elif");
                    fi
                else
                    seen_else = true;
                fi

                b.walk(self);

                _brancher.branch(end);
                _brancher.label(next);

                is_first = false;
            od

            _brancher.label(end);

            super.visit(i);
        si

        pre(`case: Statements.CASE) -> bool is
            super.pre(`case);

            return true;
        si

        visit(`case: Statements.CASE) is
            assert `case.expression?;
            assert `case.matches?;

            let temp = new TEMP(_context, `case.expression.value);

            let labels = _loops.enter_loop();

            for m in `case.matches do
                let next = new LABEL();
    
                if m.expressions? then
                    if m.expressions.expressions.count == 1 then
                        _brancher.branch(BRANCH.NE, temp.load(), m.expressions.expressions[0].value, next);
                    elif m.expressions.expressions.count > 1 then
                        let match = new LABEL();

                        for e in m.expressions do
                            _brancher.branch(BRANCH.EQ, temp.load(), e.value, match);
                        od    

                        _brancher.branch(next);

                        _brancher.label(match);
                    fi
                fi
                pre(m);
                               
                m.statements.walk(self);

                visit(m);

                _brancher.branch(_loops.get_current_loop().end);

                _brancher.label(next);
            od

            _brancher.label(_loops.get_current_loop().end);

            _loops.leave_loop();

            super.visit(`case);
        si

        pre(match: Statements.CASE_MATCH) -> bool is
            super.pre(match);

            return true;
        si        

        visit(match: Statements.CASE_MATCH) is
            match.statements.accept(self);

            super.visit(match);
        si

        pre(`try: Statements.TRY) -> bool is
            super.pre(`try);

            return true;
        si

        visit(`try: Statements.TRY) is
            if
                (!`try.catches? \/ `try.catches.count == 0) /\
                !`try.`finally?
            then
                `try.body.walk(self);

                super.visit(`try);

                return;
            fi

            let return_type = current_function.return_type;

            let return_needed = new TEMP(_context, 1, _innate_symbol_lookup.get_bool_type());
            let return_value: TEMP;

            if return_type? /\ return_type !~ _innate_symbol_lookup.get_void_type() then
                return_value = new TEMP(_context, return_type);                
            fi
            
            let label = _loops.enter_try(return_needed, return_value);

            let need_double_try = `try.catches? /\ `try.catches.count > 0 /\ `try.`finally?;

            if need_double_try then
                _context.write_line(".try {");
                _context.indent();                    
            fi
                        
            _context.write_line(".try {");
            _context.indent();

            `try.body.walk(self);

            _brancher.leave(label.end);

            _context.outdent();

            _context.write_line("}");

            for c in `try.catches do
                c.walk(self);
            od

            if need_double_try then
                _context.outdent();
                _context.write_line("}");                
            fi
            
            if `try.`finally? then
                label.is_in_finally = true;

                _context.write_line("finally {");
                _context.indent();
                `try.`finally.walk(self);

                _brancher.label(label.middle);

                _context.write_line("endfinally");
                _context.outdent();

                _context.write_line("}");
            fi

            _loops.leave_loop();

            _brancher.branch(BRANCH.Z, label.return_needed.load(), label.end);

            _brancher.label(label.start);
            
            let outer_try = _loops.get_current_try();

            if outer_try? then
                if return_value? then
                    assert outer_try.return_value? else "outer try has no return value temporary";
                    outer_try.return_value.store(return_value.load());
                fi
                
                if outer_try.is_in_finally then
                    outer_try.return_needed.store(new Literal.NUMBER("1", _innate_symbol_lookup.get_bool_type(), "i4"));
                    _brancher.branch(outer_try.middle);
                else
                    _brancher.leave(outer_try.start);
                fi
            else
                if return_value? then
                    return_value.load().gen(_context);                    
                fi                

                _context.write_line("ret");                
            fi

            _brancher.label(label.end);

            super.visit(`try);
        si

        pre(`catch: Statements.CATCH) -> bool is
            super.pre(`catch);

            return true;
        si

        visit(`catch: Statements.CATCH) is
            _context.write_line("catch " + `catch.variable.type_expression.type.get_il_type() + " {");
            _context.indent();

            `catch.variable.walk(self);

            let symbol = find(`catch.variable.name);

            _context.write_line("stloc " + symbol.get_il_reference());

            `catch.body.walk(self);

            _brancher.leave(_loops.get_current_try().end);

            _context.outdent();
            _context.write_line("}");

            super.visit(`catch);
        si

        pre(`do: Statements.DO) -> bool is
            super.pre(`do);

            return true;
        si

        visit(`do: Statements.DO) is
            let loop = _loops.enter_loop();

            _brancher.label(loop.start);

            if `do.condition? then
                _brancher.branch(BRANCH.Z, `do.condition.value, loop.end, "while");
            fi

            `do.body.walk(self);

            _brancher.branch(loop.start);

            _brancher.label(loop.end);

            super.visit(`do);

            _loops.leave_loop();
        si

        pre(`for: Statements.FOR) -> bool is
            super.pre(`for);

            return true;
        si

        visit(`for: Statements.FOR) is
            let loop = _loops.enter_loop();

            let iterator: Value;

            if `for.read_iterator? then
                iterator = `for.read_iterator.call(`for.expression.location, `for.expression.value, new Collections.LIST[Value](0), null, _function_caller);
            else
                iterator = `for.expression.value;
            fi

            `for.variable.walk(self);
            
            let temp = new TEMP(_context, iterator);

            _brancher.label(loop.start);

            let has_next = `for.move_next.call(`for.expression.location, temp.load(), new Collections.LIST[Value](0), null, _function_caller);

            _brancher.branch(BRANCH.Z, has_next, loop.end);

            let current = `for.read_current.call(`for.expression.location, temp.load(), new Collections.LIST[Value](0), null, _function_caller);

            let variable = find(`for.variable.name);

            let store = variable.store(`for.variable.location, null, current, _symbol_loader, true);

            store.gen(_context);

            // not to generate code for the expression itself, but to capture IL for any anonymous function bodies:
            `for.expression.walk(self);
            
            `for.body.walk(self);

            _brancher.branch(loop.start);
            _brancher.label(loop.end);

            super.visit(`for);

            _loops.leave_loop();
        si

        pre(pragma: Statements.PRAGMA) -> bool is
            process_pragma(pragma.pragma, true);
        si

        visit(pragma: Statements.PRAGMA) is
            process_pragma(pragma.pragma, false);
        si

        pre(labelled: Statements.LABELLED) -> bool is
            super.pre(labelled);

            return true;            
        si
        
        visit(labelled: Statements.LABELLED) is
            _loops.next_name(labelled.label.name);

            labelled.statement.walk(self);

            super.visit(labelled);
        si

        visit(`break: Statements.BREAK) is
            if !_loops.is_in_loop then
                _logger.error(`break.location, "break outside of loop");

                return;
            fi

            if _loops.is_in_try then
                _brancher.leave(_loops.get_current_loop().end);            
            else
                _brancher.branch(_loops.get_current_loop().end);                                            
            fi            
        si

        visit(`continue: Statements.CONTINUE) is
            if !_loops.is_in_loop then
                _logger.error(`continue.location, "continue outside of loop");

                return;
            fi

            if _loops.is_in_try then
                _brancher.leave(_loops.get_current_loop().start);
            else
                _brancher.branch(_loops.get_current_loop().start);                
            fi
        si
    si

    class LOOP_LABELS is
        is_try: bool;
        is_in_finally: bool public;
        is_loop: bool => !is_try;

        name: string;
        start: LABEL;
        middle: LABEL;
        end: LABEL;

        return_needed: TEMP;
        return_value: TEMP;

        init(name: string) is
            is_try = false;
            self.name = name;
            start = new LABEL();
            end = new LABEL();
        si

        init(return_needed: TEMP, return_value: TEMP) is
            is_try = true;
            self.return_needed = return_needed;
            self.return_value = return_value;
            start = new LABEL();
            middle = new LABEL();
            end = new LABEL();
        si

        matches(name: string) -> bool => self.name? /\ self.name =~ name;
    si

    class LOOP_LABEL_STACK is
        _next_name: string;

        loops: Collections.MutableList[LOOP_LABELS];
        is_in_loop: bool => get_current_loop() != null;
        is_in_try: bool => get_current_try() != null;

        get_current_try() -> LOOP_LABELS is
            let index: int = loops.count - 1;
            
            while index >= 0 do
                let result = loops[index];

                if result.is_try then
                    return result;
                fi

                index = index - 1;
            od
        si

        get_current_loop() -> LOOP_LABELS is
            let index: int = loops.count - 1;
            
            while index >= 0 do
                let result = loops[index];

                if result.is_loop then
                    return result;    
                fi

                index = index - 1;
            od
        si

        init() is
            loops = new Collections.LIST[LOOP_LABELS]();
        si
        
        next_name(name: string) is
            _next_name = name;
        si

        find(name: string) -> LOOP_LABELS is
            for i in loops.count..0 do
                Std.error.write_line("try loop " + i + " out of " + loops.count);

                let loop = loops[i];

                if loop.matches(name) then
                    return loop;
                fi
            od         
        si

        enter_try(return_needed: TEMP, return_value: TEMP) -> LOOP_LABELS is
            let result = new LOOP_LABELS(return_needed, return_value);

            loops.add(result);

            return result;
        si        

        enter_loop() -> LOOP_LABELS is            
            let result = new LOOP_LABELS(_next_name);

            loops.add(result);

            return result;
        si        

        leave_loop() is
            loops.remove_at(loops.count - 1);
            _next_name = null;
        si
    si
si
