namespace Syntax.Process is
    use IO.Std;

    use System.Text.StringBuilder;
        
    use Logging;
    use Trees;
    use Source;

    use IR;
    use IR.Values;

    class GENERATE_IL: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Types.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        _context: CONTEXT;
        _brancher: BRANCHER;
        _boilerplate_generator: BOILERPLATE_GENERATOR;
        _boxer: VALUE_BOXER;
        _loops: LOOP_LABEL_STACK;
        _block_context: BlockContext;

        _stub_depth: int;
        _il_output_depth: int;

        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;
        
        _interpolation_handler: Semantic.Types.Type;
        _constructor: Semantic.Symbols.Function;
        _append_literal: Semantic.Symbols.Function;
        _append_formatted_generic: Semantic.Symbols.Function;
        _append_formatted_generic_alignment: Semantic.Symbols.Function;
        _append_formatted_generic_format: Semantic.Symbols.Function;
        _append_formatted_generic_alignment_format: Semantic.Symbols.Function;
        _to_string_and_clear: Semantic.Symbols.Function;
        _dispose: Semantic.Symbols.Function;

        current_block: Values.BLOCK => _block_context.current_block;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            context: CONTEXT,
            block_context: BlockContext,
            brancher: BRANCHER,
            boilerplate_generator: BOILERPLATE_GENERATOR,
            boxer: VALUE_BOXER
        )
        is
            super.init(logger, null, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _innate_symbol_lookup = innate_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;
            _context = context;
            _block_context = block_context;
            _brancher = brancher;
            _boilerplate_generator = boilerplate_generator;
            _boxer = boxer;

            _loops = LOOP_LABEL_STACK();
        si

        ensure_runtime_symbols_are_materialized() is
            if _interpolation_handler? then
                return;
            fi

            let string_type = _innate_symbol_lookup.get_string_type();
            let int_type = _innate_symbol_lookup.get_int_type();


            // Materialize IDisposable.Dispose()
            let idisposable_type = _innate_symbol_lookup.get_idisposable_type();
 
            // there is only one overload of dispose:
            _dispose = cast Semantic.Symbols.FUNCTION_GROUP(idisposable_type.find_member("dispose")).functions[0];

            // Materialize the various methods of the string interpolation handler:
            _interpolation_handler = _innate_symbol_lookup.get_interpolated_string_handler_type();
            
            // the constructor overload we want is the only one with 2 arguments:
            _constructor = cast Semantic.Symbols.FUNCTION_GROUP(_interpolation_handler.find_member("init")).functions |
                .filter(f => f.arguments.count == 2)
                .only();

            // there is only one overload of append_literal:
            _append_literal = cast Semantic.Symbols.FUNCTION_GROUP(_interpolation_handler.find_member("append_literal")).functions[0];

            // the first overload of append_formatted we want is the only one that is both generic and with 1 argument:
            _append_formatted_generic = cast Semantic.Symbols.FUNCTION_GROUP(_interpolation_handler.find_member("append_formatted")).functions |
                .filter(f => f.is_generic /\ f.arguments.count == 1)
                .only();

            // there are two overloads of append_formatted with 2 arguments, we want the one where the second argument is an int:
            _append_formatted_generic_alignment = cast Semantic.Symbols.FUNCTION_GROUP(_interpolation_handler.find_member("append_formatted")).functions |
                .filter(f => f.is_generic /\ f.arguments.count == 2 /\ f.arguments[1].type.compare(int_type) == Semantic.Types.MATCH.SAME)
                .only();

            // there are two overloads of append_formatted with 2 arguments, we want the one where the second argument is a string:
            _append_formatted_generic_format = cast Semantic.Symbols.FUNCTION_GROUP(_interpolation_handler.find_member("append_formatted")).functions |
                .filter(f => f.is_generic /\ f.arguments.count == 2 /\ f.arguments[1].type.compare(string_type) == Semantic.Types.MATCH.SAME)
                .only();

            // there is only one overload of append_formatted with 3 arguments:
            _append_formatted_generic_alignment_format = cast Semantic.Symbols.FUNCTION_GROUP(_interpolation_handler.find_member("append_formatted")).functions |
                .filter(f => f.is_generic /\ f.arguments.count == 3)
                .only();

            // there is only one overload of to_string_and_clear:
            _to_string_and_clear = cast Semantic.Symbols.FUNCTION_GROUP(_interpolation_handler.find_member("to_string_and_clear")).functions[0];
        si

        apply(root: Trees.Node) is
            if _logger.any_errors then
                return;
            fi

            LABEL.set_pass("_");

            root.walk(self);
        si

        enter_block(block: Values.BLOCK) is
            _block_context.enter_block(block);
        si

        enter_block() is
            _block_context.enter_block();
        si

        leave_block() is
            _block_context.leave_block();
        si

        get_brancher_for_block() -> BLOCK_BRANCHER =>
            _brancher.get_for(_block_context.current_block);

        add(value: Values.Value) is
            current_block.add(value);
        si

        add(raw: string) is
            current_block.add(raw);
        si

        add(type: Semantic.Types.Type, raw: string) is
            current_block.add(type, raw);
        si

        println(value: object) is
            _context.write_line(value);
        si

        println(value: object, comment: object) is
            _context.write_line(value, comment);
        si

        println_comment(value: object) is
            _context.write_comment_line(value);
        si

        enter_class(symbol: Semantic.Symbols.Classy) is
            ADDRESS.reset_id();
            TEMP.reset_id();
            LABEL.reset_id();
        si

        leave_class(symbol: Semantic.Symbols.Classy) is
        si
        
        print_class_def(symbol: Semantic.Symbols.Symbol) is
            println_comment("define {symbol.description}");

            let buffer = System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);

            println(buffer);

            println("{{");
        si

        pre(`namespace: Definitions.NAMESPACE) -> bool is
            super.pre(`namespace);
        si

        visit(`namespace: Definitions.NAMESPACE) is
            let context = _symbol_table.current_closure_context;
            
            gen_anon_functions(context.get_closures());
            gen_closures(context.get_closures());

            super.visit(`namespace);
        si
        
        pre(`class: Definitions.CLASS) -> bool is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`class));

            enter_class(symbol);

            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            print_class_def(symbol);

            enter_scope(`class);

            _context.indent();
        si
        
        visit(`class: Definitions.CLASS) is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`class));

            let closures = symbol.get_closures();

            gen_delegates(closures);

            gen_ienumerable_boilerplate(symbol);
            gen_ienumerator_boilerplate(symbol);

            _context.outdent();
            println("}}");

            leave_class(symbol);

            leave_scope(`class);

            gen_anon_functions(closures);
            gen_closures(closures);
        si

        pre(`trait: Definitions.TRAIT) -> bool is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`trait));
            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            enter_class(symbol);

            print_class_def(symbol);

            enter_scope(`trait);

            _context.indent();
        si

        visit(`trait: Definitions.TRAIT) is
            _context.outdent();
            println("}}");

            let symbol = cast Semantic.Symbols.Classy(symbol_for(`trait));

            leave_class(symbol);

            leave_scope(`trait);
        si

        pre(`struct: Definitions.STRUCT) -> bool is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`struct));
            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            enter_class(symbol);

            print_class_def(symbol);

            _context.indent();

            enter_scope(`struct);            
        si

        visit(`struct: Definitions.STRUCT) is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`struct));           

            let closures = symbol.get_closures();

            gen_ienumerable_boilerplate(symbol);
            gen_ienumerator_boilerplate(symbol);
            gen_anon_functions(closures);

            _context.outdent();
            println("}}");

            leave_class(symbol);

            leave_scope(`struct);

            gen_closures(closures);
        si        

        pre(`union: Definitions.UNION) -> bool is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(`union));

            enter_class(symbol);

            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            print_class_def(symbol);

            enter_scope(`union);
            _context.indent();

            `union.name.walk(self);

            if `union.arguments? then
                `union.arguments.walk(self);
            fi

            `union.modifiers.walk(self);

            for member in `union.body | .filter(m => !isa Definitions.VARIANT(m)) do
                member.walk(self);
            od

            _context.indent();

            gen_ienumerable_boilerplate(symbol);
            gen_ienumerator_boilerplate(symbol);

            _context.outdent();
            println("}}");

            println("// variants for {`union.name}");

            _context.indent();

            leave_class(symbol);

            leave_scope(`union);

            for member in `union.body | .filter(m => isa Definitions.VARIANT(m)) do
                member.walk(self);
            od

            _context.outdent();

            return true;
        si
        
        visit(`union: Definitions.UNION) is
            // all done in pre
        si

        pre(variant: Definitions.VARIANT) -> bool is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(variant));

            enter_class(symbol);

            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            print_class_def(symbol);

            enter_scope(variant);

            _context.indent();
        si
        
        visit(variant: Definitions.VARIANT) is
            let symbol = cast Semantic.Symbols.Classy(symbol_for(variant));

            let closures = symbol.get_closures();

            gen_ienumerable_boilerplate(symbol);
            gen_ienumerator_boilerplate(symbol);
            gen_anon_functions(closures);

            _context.outdent();
            println("}}");

            leave_class(symbol);

            leave_scope(variant);

            gen_closures(closures);
        si

        gen_ienumerable_boilerplate(symbol: Semantic.Symbols.Classy) is            
            if symbol.is_derived_from_iterable_trait then
                // FIXME: check if class implements these methods and don't emit them if they're not needed:

                _boilerplate_generator.gen("ienumerable-boilerplate");
            fi            
        si
        
        gen_ienumerator_boilerplate(symbol: Semantic.Symbols.Classy) is            
            if symbol.is_derived_from_iterator_trait then
                // FIXME: check if class implements these methods and don't emit them if they're not needed:

                _boilerplate_generator.gen("ienumerator-boilerplate");
            fi
        si


        // FIXME: 
        gen_delegates(closures: Collections.Iterable[Semantic.Symbols.Closure]) is
            if closures? then
                for anon_function in closures | .filter(c => c.is_delegate) do
                    let buffer = StringBuilder();

                    anon_function.map_type_arguments();
                    anon_function.set_type_arguments();
                    anon_function.gen_definition_header(buffer);
                    anon_function.unmap_type_arguments();
                    _context.write_line(buffer);

                    _context.write_line("{{");
                    _context.indent();
    
                    _context.write_line(anon_function.il_body);
    
                    _context.outdent();
                    _context.write_line("}}");
                od
            fi
        si


        gen_anon_functions(closures: Collections.Iterable[Semantic.Symbols.Closure]) is
            if closures? then
                for anon_function in closures | .filter(c => c.is_anon_func) do
                    let buffer = StringBuilder();

                    anon_function.map_type_arguments();
                    anon_function.set_type_arguments();
                    anon_function.gen_definition_header(buffer);
                    anon_function.unmap_type_arguments();
                    _context.write_line(buffer);

                    _context.write_line("{{");
                    _context.indent();
    
                    _context.write_line(anon_function.il_body);
    
                    _context.outdent();
                    _context.write_line("}}");
                od
            fi
        si

        gen_closures(closures: Collections.Iterable[Semantic.Symbols.Closure]) is
            if closures? then
                for closure in closures | .filter(c => !c.is_anon_func /\ !c.is_delegate) do
                    closure.map_type_arguments();
                    closure.gen_frame(_context, _symbol_loader);
                    closure.unmap_type_arguments();
                od
            fi
        si

        pre(`enum: Definitions.ENUM) -> bool is
            let symbol = cast Semantic.Symbols.Symbol(symbol_for(`enum));

            let owner = cast Semantic.Symbols.Symbol(symbol.owner);

            print_class_def(symbol);

            enter_scope(`enum);

            _context.indent();

            _context.write_line(".field public specialname rtspecialname int32 value__ ");
        si

        visit(`enum: Definitions.ENUM) is
            _context.outdent();
            println("}}");

            leave_scope(`enum);
        si

        pre(enum_member: Definitions.ENUM_MEMBER) -> bool is
            let symbol = current_scope.find_member(enum_member.name.name);

            let buffer = System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);
            println(buffer);
        si

        pre(function: Definitions.FUNCTION) -> bool is
            let symbol = function_for(function);

            println_comment("define {symbol.description}");

            let buffer = System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);
            println(buffer);

            println("{{");
            _context.indent();

            enter_scope(function);

            symbol.gen_body_header(_context);

            enter_block();
        si

        visit(function: Definitions.FUNCTION) is
            let symbol = symbol_for(function);

            current_block.gen(_context);
            leave_block();

            if symbol? /\ isa Semantic.Symbols.Function(symbol) then
                let function_symbol = cast Semantic.Symbols.Function(symbol);

                if !function_symbol.is_abstract then
                    if function.body? /\ isa Bodies.NULL(function.body) then
                        _context.write_line("newobj instance void class [System.Runtime]System.NotImplementedException::'.ctor'()");
                        _context.write_line("throw");
                    elif
                        function_symbol.return_type? /\
                        function_symbol.return_type.compare(_innate_symbol_lookup.get_void_type()) != Semantic.Types.MATCH.SAME
                    then
                        _context.write_line(".locals init ({function_symbol.return_type.get_il_type()} '.default')");
                        _context.write_line("ldloc '.default'");
                    fi

                    _context.write_line("ret");
                fi
            fi

            leave_scope(function);

            _context.outdent();
            println("}}");
        si

        pre(body: Bodies.BLOCK) -> bool is
            add(".maxstack 64");

            return super.pre(body);
        si
        
        pre(expression_body: Bodies.EXPRESSION) -> bool is
            add(".maxstack 64");

            return super.pre(expression_body);            
        si
        
        visit(expression_body: Bodies.EXPRESSION) is
            if
                expression_body.expression.value? /\
                expression_body.expression.value.type?
            then
                let value =
                    _boxer.box_if_needed(
                        expression_body.expression.value,
                        current_function.return_type
                    );

                add(value);
            fi

            add("ret");

            super.visit(expression_body);
        si

        pre(property: Definitions.PROPERTY) -> bool is
            let symbol = symbol_for(property);

            if !symbol? then
                return true;
            fi

            let buffer = System.Text.StringBuilder();
            symbol.gen_definition_header(buffer);
            println(buffer.to_string());            

            return true;
        si
       
        // FIXME: #500 Pragma handling code is duplicated across multiple visitors
        pre(pragma: Definitions.PRAGMA) -> bool is
            process_pragma(pragma.pragma, true);
        si

        visit(pragma: Definitions.PRAGMA) is
            process_pragma(pragma.pragma, false);
        si

        process_pragma(pragma: Pragmas.PRAGMA, is_enter: bool) is
            if !pragma? then
                Std.error.write_line("pragma is null");
                return;
            fi

            let name = pragma.name.to_string();

            if name =~ "IL.output" then
                if !pragma.arguments? \/ pragma.arguments.expressions.count != 1 then
                    _logger.error(pragma.arguments.location, "expected 1 argument");
                    return;
                fi

                let argument = pragma.arguments.expressions[0];

                if !argument? \/ !isa Expressions.Literals.STRING(argument) then
                    _logger.error(pragma.arguments.location, "expected a string literal argument");
                    return;
                fi

                let file_name = cast Expressions.Literals.STRING(argument).value_string;

                if is_enter then
                    _il_output_depth = _il_output_depth + 1;

                    if _block_context.is_in_block then
                        current_block.add(Values.ENTER_FILE(file_name));
                    else
                        _context.enter_file(file_name, false);
                    fi
                else
                    _il_output_depth = _il_output_depth - 1;

                    if _block_context.is_in_block then
                        current_block.add(Values.LEAVE_FILE(file_name));
                    else
                        _context.leave_file(file_name);
                    fi                        
                fi
            elif name =~ "IL.stub" then
                if is_enter then
                    _stub_depth = _stub_depth + 1;
                    _context.enter_stub();
                else
                    _stub_depth = _stub_depth - 1;
                    _context.leave_stub();
                fi
            elif name =~ "IL.entrypoint" \/ name =~ "entry" then
                if is_enter then
                    if _context.seen_entrypoint then
                        _logger.error(pragma.location, "duplicate entrypoint");
                    else
                        _context.seen_entrypoint = true;
                        _context.write_line(".entrypoint");
                    fi
                fi
            elif name =~ "test" then
                if is_enter then
                    if current_function? then
                        _boilerplate_generator.gen("test-method");
                    else
                        _boilerplate_generator.gen("test-class");
                    fi
                fi
            elif name =~ "test_class" then
                if is_enter then
                    _boilerplate_generator.gen("test-class");
                fi
            elif name =~ "test_method" then
                if is_enter then
                    _boilerplate_generator.gen("test-method");
                fi
            fi
        si

        pre(function: Trees.Expressions.FUNCTION) -> bool is
            super.pre(function);

            let closure = cast Semantic.Symbols.Closure(scope_for(function));

            if !closure? then
                return true;                
            fi

            closure.map_type_arguments();

            return true;
        si

        visit(function: Trees.Expressions.FUNCTION) is
            enter_block();

            let closure = cast Semantic.Symbols.Closure(scope_for(function));

            function.body.walk(self);

            if 
                closure.return_type? /\
                closure.return_type.compare(_innate_symbol_lookup.get_void_type()) != Semantic.Types.MATCH.SAME
            then
                add(".locals init ({closure.return_type.get_il_type()} '.default')");
                add("ldloc '.default'");
            fi

            add("// end IL body {closure}");

            add("ret");

            _context.enter_buffer(false);

            current_block.gen(_context);

            leave_block();

            let body_assembler = _context.leave_buffer();

            closure.il_body = body_assembler;

            super.visit(function);

            closure.unmap_type_arguments();
        si

        pre(statement: Expressions.STATEMENT) -> bool is
            super.pre(statement);

            return false;
        si

        visit(statement: Expressions.STATEMENT) is
        si

        visit(assign: Statements.ASSIGNMENT) is
            super.visit(assign);

            if assign.value? then
                add(assign.value);
            fi
        si

        visit(expression: Statements.EXPRESSION) is
            super.visit(expression);

            try
                if !expression.want_value /\ expression.expression.value? then
                    add(expression.expression.value);

                    if
                        expression.expression.value.type? /\
                        expression.expression.value.type !~ _innate_symbol_lookup.get_void_type()
                    then
                        add("pop");
                    fi
                fi
            catch e: System.Exception
                _logger.exception(expression.location, e, "caught exception generating IL for expression");
            yrt
        si

        pre(variable: Variables.VARIABLE) -> bool is
            super.pre(variable);

            if variable.want_dispose then
                // variable will be declared outside the enclosing .try
                // so don't declare it here
                return false;
            fi

            let buffer = System.Text.StringBuilder();

            for name in variable.names do
                let symbol = find(name);

                if !symbol? then
                    continue;
                fi
                
                symbol.gen_definition_header(buffer);
            od

            if buffer.length > 0 then
                if _block_context.is_in_block then
                    current_block.add(buffer.to_string());
                else
                    println(buffer.to_string());
                fi
            fi
        si
        
        visit(v: Variables.VARIABLE) is
            if !v.initializer? \/ !v.initializer.value? then    
                return;
            fi

            gen_destructuring_initialize(v.left, v.initializer.value);
        si

        // TODO use Pre/Visit instead
        gen_destructuring_initialize(left: Variables.VariableLeft, value: Value) is
            if left.is_simple_name then
                let symbol = find(left.name);

                if !symbol? then
                    return;
                fi

                let store = symbol.store(left.location, null, value, _symbol_loader, true);

                add(store);
            else
                let from_type = value.type;

                let get_from = 
                    if value.is_lightweight_pure then
                        () => value
                    else
                        let temp = TEMP(current_block, "destructure", value);
                        () => temp.load();
                    fi;
        
                for (i, e) in left.elements | .index() do
                    let member = from_type.find_destructure_member(i);

                    let member_value = member.load(LOCATION.internal, get_from(), _symbol_loader);

                    gen_destructuring_initialize(e, member_value);
                od
            fi
        si
       
        visit(r: Statements.RETURN) is
            super.visit(r);

            let function = current_function;
            let value: Value;

            if
                r.expression? /\
                r.expression.value? /\
                r.expression.value.type?
            then
                value =
                    _boxer.box_if_needed(
                        r.expression.value,
                        current_function.return_type
                    );

            fi

            let current_try = _loops.get_current_try();

            if current_try? then
                if value? then
                    current_try.return_value.store(value);                    
                fi

                current_try.return_needed.store(Literal.NUMBER("1", _innate_symbol_lookup.get_bool_type(), "i4"));

                let brancher = get_brancher_for_block();
                
                if current_try.is_in_finally then
                    brancher.branch(current_try.middle);
                else
                    brancher.leave(current_try.start);
                fi
            else
                if value? then
                    add(value);
                fi

                add("ret");
            fi            
        si

        visit(`throw: Statements.THROW) is
            super.visit(`throw);

            add(
                _boxer.box_if_value(
                    `throw.expression.value
                )
            );

            add("throw");
        si

        visit(`assert: Statements.ASSERT) is
            super.visit(`assert);

            let brancher = get_brancher_for_block();

            let end = LABEL();

            brancher.branch(
                BRANCH.NZ,
                `assert.expression.value,
                end
            );

            let need_exception_wrapper = true;

            if `assert.message? then
                let message_value = `assert.message.value; 
                if !_innate_symbol_lookup.get_exception_type().is_assignable_from(message_value.type) then
                    add(
                        Literal.STRING(
                            "{`assert.location}: ",
                            _innate_symbol_lookup.get_string_type()
                        )
                    );

                    add(message_value);

                    add("call string string::Concat(object,object)");
                else
                    need_exception_wrapper = false;
                fi
            else
                add(
                    Literal.STRING(
                        "{`assert.location}: {`assert.expression}",
                        _innate_symbol_lookup.get_string_type()
                    )
                );
            fi

            if need_exception_wrapper then
                add("newobj instance void class ['ghul-runtime']Ghul.AssertFailedException::.ctor(class [System.Runtime]System.String)");
            fi
            
            add("throw");

            brancher.label(end);
        si

        pre(list: Statements.LIST) -> bool is
            super.pre(list);
            return true;
        si

        visit(list: Statements.LIST) is
            if list.value? then
                enter_block(cast IR.Values.BLOCK(list.value))
            fi;

            let return_type = current_function.return_type;

            let return_needed: TEMP;
            let return_value: TEMP;
            let label: LOOP_LABELS;

            let outer_try: LOOP_LABELS;

            let brancher = get_brancher_for_block();

            if list.want_dispose then
                (outer_try, return_needed, return_value) = get_exception_handler_temps();
        
                for v in list.variables_to_dispose do
                    let buffer = System.Text.StringBuilder();
                    v.gen_definition_header(buffer);

                    add(buffer.to_string());
                od

                label = _loops.enter_try(return_needed, return_value);

                add(".try {{ // RAII ");
            fi

            for s in list.statements do
                s.walk(self);
            od

            if list.value? then
                if list.last? /\ list.last.value? then
                    add(list.last.value);
                fi
            fi

            if list.want_dispose then
                ensure_runtime_symbols_are_materialized();

                label.is_in_finally = true;

                brancher.leave(label.start);

                add("}}");
                add("finally {{");

                let to_dispose = list.variables_to_dispose;

                let i = to_dispose.count - 1;

                while i >= 0 do
                    let v = to_dispose[i];

                    let skip_label: LABEL = null;

                    if !v.type.is_value_type then
                        skip_label = LABEL();
 
                        brancher.branch(BRANCH.Z, _symbol_loader.load_local_variable(list.location, v), skip_label);
                    fi

                    let variable_value = v.load(list.location, null, _symbol_loader); // _symbol_loader.load_local_variable(list.location, v);
                    let dispose_call = _dispose.call(list.location, variable_value, System.Array.empty`[Value](), null, _function_caller);

                    add(dispose_call);

                    if skip_label? then
                        brancher.label(skip_label);
                    fi

                    i = i - 1;
                od

                // TODO this is duplicated from try statement handling - needs to be refactored
                brancher.label(label.middle);

                add("endfinally");
                add("}}");

                _loops.leave_loop();
                                
                gen_exception_handler_exit(outer_try, label, return_value);
            fi

            if list.value? then    
                leave_block();
            fi
        si

        pre(i: Statements.IF) -> bool is
            super.pre(i);

            return true;
        si
        
        visit(`if: Statements.IF) is
            let is_first = true;
            let seen_else = false;

            let end = LABEL();

            if `if.value? then
                enter_block(cast IR.Values.BLOCK(`if.value));
            fi

            let brancher = get_brancher_for_block();

            for b in `if.branches do
                let next = LABEL();

                if b.condition? then
                    b.condition.walk(self);

                    if is_first then
                        brancher.branch(BRANCH.Z, b.condition.value, next, "if");
                    else
                        brancher.branch(BRANCH.Z, b.condition.value, next, "elif");
                    fi
                else
                    seen_else = true;
                fi

                // enter if block scope:
                self.pre(b);
    
                if b.body? then
                    b.body.walk(self);
                fi

                // no-op?
                b.accept(self);

                if `if.want_value /\ b.body.value? then
                    add(b.body.value);
                fi

                brancher.branch(end);
                brancher.label(next);

                is_first = false;
            od

            brancher.label(end);

            super.visit(`if);

            if `if.value? then
                leave_block();
            fi
        si

        pre(`case: Statements.CASE) -> bool is
            super.pre(`case);

            return true;
        si

        visit(`case: Statements.CASE) is
            assert `case.expression?;
            assert `case.matches?;

            let temp = TEMP(current_block, "case", `case.expression.value);

            let brancher = get_brancher_for_block();

            let labels = _loops.enter_loop();

            for m in `case.matches do
                let next = LABEL();
   
                if m.expressions? then
                    if m.expressions.expressions.count == 1 then
                        m.expressions.expressions[0].walk(self);
                        brancher.branch(BRANCH.NE, temp.load(), m.expressions.expressions[0].value, next);
                    elif m.expressions.expressions.count > 1 then
                        let match = LABEL();

                        for e in m.expressions do
                            e.walk(self);

                            brancher.branch(BRANCH.EQ, temp.load(), e.value, match);
                        od    

                        brancher.branch(next);

                        brancher.label(match);
                    fi
                fi
                
                m.walk(self);

                brancher.branch(_loops.get_current_loop().end);

                brancher.label(next);
            od

            brancher.label(_loops.get_current_loop().end);

            _loops.leave_loop();

            super.visit(`case);
        si

        pre(match: Statements.CASE_MATCH) -> bool is
            super.pre(match);

            return true;
        si        

        visit(match: Statements.CASE_MATCH) is
            match.statements.accept(self);

            super.visit(match);
        si

        pre(`try: Statements.TRY) -> bool is
            super.pre(`try);

            return true;
        si

        get_exception_handler_temps() -> (outer_try: LOOP_LABELS, return_needed: TEMP, return_value: TEMP) is
            let return_type = current_function.return_type;

            let return_needed: TEMP;
            let return_value: TEMP;

            let outer_try = _loops.get_current_try();

            if outer_try? then
                return_needed = outer_try.return_needed;
                return_value = outer_try.return_value;
            else
                return_needed = TEMP(current_block, "need_return", 1, _innate_symbol_lookup.get_bool_type());

                if return_type? /\ return_type !~ _innate_symbol_lookup.get_void_type() then
                    return_value = TEMP(current_block, "return", return_type);                
                fi
            fi

            return (outer_try, return_needed, return_value);
        si

        gen_exception_handler_exit(outer_try: LOOP_LABELS, label: LOOP_LABELS, return_value: TEMP) is
            let brancher = get_brancher_for_block();

            brancher.label(label.start);
            brancher.branch(BRANCH.Z, label.return_needed.load(), label.end);
            
            if outer_try? then
                if return_value? then
                    assert outer_try.return_value? else "outer try has no return value temporary";
                    outer_try.return_value.store(return_value.load());
                fi
                
                if outer_try.is_in_finally then
                    outer_try.return_needed.store(Literal.NUMBER("1", _innate_symbol_lookup.get_bool_type(), "i4"));
                    brancher.branch(outer_try.middle);
                else
                    brancher.leave(outer_try.start);
                fi
            else
                if return_value? then
                    add(return_value.load());                    
                fi                

                add("ret");                
            fi

            brancher.label(label.end);
        si

        visit(`try: Statements.TRY) is
            if
                (!`try.catches? \/ `try.catches.count == 0) /\
                !`try.`finally?
            then
                `try.body.walk(self);

                super.visit(`try);

                return;
            fi

            let brancher = get_brancher_for_block();

            let return_type = current_function.return_type;
            
            let (outer_try, return_needed, return_value) = get_exception_handler_temps();
        
            let label = _loops.enter_try(return_needed, return_value);

            let need_double_try = `try.catches? /\ `try.catches.count > 0 /\ `try.`finally?;

            if need_double_try then
                add(".try {{");
            fi

            add(".try {{");

            `try.body.walk(self);

            brancher.leave(label.start);

            add("}}");

            for c in `try.catches do
                c.walk(self);
            od

            if need_double_try then
                add("}}");                
            fi
            
            // TODO a lot of this is duplicated in the list statement handling - needs to be refactored
            if `try.`finally? then
                label.is_in_finally = true;

                add("finally {{");
                `try.`finally.walk(self);

                brancher.label(label.middle);

                add("endfinally");
                add("}}");
            fi

            _loops.leave_loop();
            
            // let outer_try = _loops.get_current_try();
            gen_exception_handler_exit(outer_try, label, return_value);

            super.visit(`try);
        si

        pre(`catch: Statements.CATCH) -> bool is
            super.pre(`catch);

            return true;
        si

        visit(`catch: Statements.CATCH) is
            add("catch {`catch.variable.type_expression.type.get_il_type()} {{");

            let brancher = get_brancher_for_block();

            `catch.variable.walk(self);

            let symbol = find(`catch.variable.name);

            add("stloc {symbol.get_il_reference()}");

            `catch.body.walk(self);

            brancher.leave(_loops.get_current_try().start);

            add("}}");

            super.visit(`catch);
        si

        pre(`do: Statements.DO) -> bool is
            super.pre(`do);

            return true;
        si

        visit(`do: Statements.DO) is
            let brancher = get_brancher_for_block();

            let loop = _loops.enter_loop();

            brancher.label(loop.start);

            if `do.condition? then
                `do.condition.walk(self);

                brancher.branch(BRANCH.Z, `do.condition.value, loop.end, "while");
            fi

            `do.body.walk(self);

            brancher.branch(loop.start);

            brancher.label(loop.end);

            super.visit(`do);

            _loops.leave_loop();
        si

        pre(`for: Statements.FOR) -> bool is
            super.pre(`for);

            return true;
        si

        visit(`for: Statements.FOR) is
            let brancher = get_brancher_for_block();
            let loop = _loops.enter_loop();

            let iterator: Value;

            if `for.read_iterator? then
                iterator = `for.read_iterator.call(`for.expression.location, `for.expression.value, Collections.LIST[Value](0), null, _function_caller);
            else
                iterator = `for.expression.value;
            fi

            `for.variable.walk(self);
            
            let temp = TEMP(current_block, "iterator", iterator);

            brancher.label(loop.start);

            let has_next = `for.move_next.call(`for.expression.location, temp.load(), Collections.LIST[Value](0), null, _function_caller);

            brancher.branch(BRANCH.Z, has_next, loop.end);

            let current = `for.read_current.call(`for.expression.location, temp.load(), Collections.LIST[Value](0), null, _function_caller);

            gen_destructuring_initialize(`for.variable.left, current);

            // not to generate code for the expression itself, but to capture IL for any anonymous function bodies:
            // TODO check that if expressions within the expression are emitted correctly
            `for.expression.walk(self);
            
            `for.body.walk(self);

            brancher.branch(loop.start);

            brancher.label(loop.end);

            super.visit(`for);

            _loops.leave_loop();
        si

        pre(pragma: Statements.PRAGMA) -> bool is
            process_pragma(pragma.pragma, true);
        si

        visit(pragma: Statements.PRAGMA) is
            process_pragma(pragma.pragma, false);
        si

        pre(labelled: Statements.LABELLED) -> bool is
            super.pre(labelled);

            return true;            
        si
        
        visit(labelled: Statements.LABELLED) is
            _loops.next_name(labelled.label.name);

            labelled.statement.walk(self);

            super.visit(labelled);
        si

        visit(`break: Statements.BREAK) is
            if !_loops.is_in_loop then
                _logger.error(`break.location, "break outside of loop");

                return;
            fi

            let brancher = get_brancher_for_block();

            if _loops.is_in_try then
                brancher.leave(_loops.get_current_loop().end);            
            else
                brancher.branch(_loops.get_current_loop().end);                                            
            fi            
        si

        visit(`continue: Statements.CONTINUE) is
            if !_loops.is_in_loop then
                _logger.error(`continue.location, "continue outside of loop");

                return;
            fi

            let brancher = get_brancher_for_block();

            if _loops.is_in_try then
                brancher.leave(_loops.get_current_loop().start);
            else
                brancher.branch(_loops.get_current_loop().start);                
            fi
        si

        visit(interpolation: Expressions.STRING_INTERPOLATION) is
            ensure_runtime_symbols_are_materialized();

            enter_block(cast IR.Values.BLOCK(interpolation.value));

            let string_type = _innate_symbol_lookup.get_string_type();

            let literal_length = Literal.NUMBER("{interpolation.literal_length}", _innate_symbol_lookup.get_int_type(), "i4");
            let expression_count = Literal.NUMBER("{interpolation.expression_count}", _innate_symbol_lookup.get_int_type(), "i4");

            let interpolator = 
                TEMP(
                    current_block,
                    "interpolator",
                    IR.Values.NEW(
                        _interpolation_handler, 
                        _constructor, [
                            literal_length,
                            expression_count
                        ]:Value
                    )
                );

            for eaf in interpolation.values do
                let expression = eaf.expression;
                let alignment = eaf.alignment;
                let format = eaf.format;

                let args = Collections.LIST[Value](1);

                args.add(expression.value);

                if isa Expressions.Literals.STRING(expression) then
                    if cast Expressions.Literals.STRING(expression).value_string.length == 0 then
                        continue;
                    fi

                    let call = _append_literal.call(interpolation.location, interpolator.load(), args, null, _function_caller);

                    add(call);
                else
                    let append_formatted: Semantic.Symbols.Symbol;
                    let args = Collections.LIST[Value](3);

                    args.add(expression.value);

                    if format? /\ alignment? then
                        args.add(alignment.value);
                        args.add(Literal.STRING(format, string_type));

                        append_formatted = _append_formatted_generic_alignment_format.specialize([expression.value.type]);

                    elif format? then
                        args.add(Literal.STRING(format, string_type));

                        append_formatted = _append_formatted_generic_format.specialize([expression.value.type]);
                    elif alignment? then
                        args.add(alignment.value);

                        append_formatted = _append_formatted_generic_alignment.specialize([expression.value.type]);
                    else
                        append_formatted = _append_formatted_generic.specialize([expression.value.type]);
                    fi

                    let call = append_formatted.call(interpolation.location, interpolator.load(), args, null, _function_caller);

                    add(call);
                fi
            od

            let result = _to_string_and_clear.call(interpolation.location, interpolator.load(), System.Array.empty`[Value](), null, _function_caller);
            add(result);

            leave_block();
        si        
    si

    class LOOP_LABELS is
        is_try: bool;
        is_in_finally: bool public;
        is_loop: bool => !is_try;

        name: string;
        start: LABEL;
        middle: LABEL;
        end: LABEL;

        return_needed: TEMP;
        return_value: TEMP;

        init(name: string) is
            is_try = false;
            self.name = name;
            start = LABEL();
            end = LABEL();
        si

        init(return_needed: TEMP, return_value: TEMP) is
            is_try = true;
            self.return_needed = return_needed;
            self.return_value = return_value;
            start = LABEL();
            middle = LABEL();
            end = LABEL();
        si

        matches(name: string) -> bool => self.name? /\ self.name =~ name;
    si

    class LOOP_LABEL_STACK is
        _next_name: string;

        loops: Collections.MutableList[LOOP_LABELS];
        is_in_loop: bool => get_current_loop() != null;
        is_in_try: bool => get_current_try() != null;

        get_current_try() -> LOOP_LABELS is
            let index: int = loops.count - 1;
            
            while index >= 0 do
                let result = loops[index];

                if result.is_try then
                    return result;
                fi

                index = index - 1;
            od
        si

        get_current_loop() -> LOOP_LABELS is
            let index: int = loops.count - 1;
            
            while index >= 0 do
                let result = loops[index];

                if result.is_loop then
                    return result;    
                fi

                index = index - 1;
            od
        si

        init() is
            loops = Collections.LIST[LOOP_LABELS]();
        si
        
        next_name(name: string) is
            _next_name = name;
        si

        find(name: string) -> LOOP_LABELS is
            for i in loops.count..0 do
                Std.error.write_line("try loop {i} out of {loops.count}");

                let loop = loops[i];

                if loop.matches(name) then
                    return loop;
                fi
            od         
        si

        enter_try(return_needed: TEMP, return_value: TEMP) -> LOOP_LABELS is
            let result = LOOP_LABELS(return_needed, return_value);

            loops.add(result);

            return result;
        si        

        enter_loop() -> LOOP_LABELS is            
            let result = LOOP_LABELS(_next_name);

            loops.add(result);

            return result;
        si        

        leave_loop() is
            loops.remove_at(loops.count - 1);
            _next_name = null;
        si
    si
si
