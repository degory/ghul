namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Tree;
    use Source;

    class GENERATE_IL: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _generic_cache: Semantic.GENERIC_CACHE;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        _context: IR.CONTEXT;

        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            generic_cache: Semantic.GENERIC_CACHE,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            context: IR.CONTEXT
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _generic_cache = generic_cache;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _system_symbol_lookup = system_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;
            _context = context;
        si

        apply(root: Tree.NODE) is
            root.walk(self);
        si

        println(value: Object) is
            _context.println(value);
        si

        gen(value: Semantic.Graph.Value.BASE) is
            Semantic.Graph.Value.BASE.gen(value, _context);
        si

        print_class_def(symbol: Semantic.Symbol.BASE) is
            let class_ = cast Semantic.Symbol.ScopedWithInheritance(symbol);
            println(class_.il_def);

            println("{");            
        si

        pre(namespace_: Definition.NAMESPACE) -> bool is
            super.pre(namespace_);

            println(".namespace " + namespace_.name + " {");

            _context.indent();
        si

        visit(namespace_: Definition.NAMESPACE) is
            _context.outdent();

            println("}");

            super.visit(namespace_);
        si
        
        pre(class_: Definition.CLASS) -> bool is
            let symbol = symbol_for(class_);

            print_class_def(symbol);

            enter_scope(class_);

            _context.indent();
        si

        visit(class_: Definition.CLASS) is
            _context.outdent();

            println("}");

            leave_scope(class_);
        si

        pre(trait_: Definition.TRAIT) -> bool is
            let symbol = symbol_for(trait_);
            
            print_class_def(symbol);

            enter_scope(trait_);

            _context.indent();
        si

        visit(trait_: Definition.TRAIT) is
            _context.outdent();

            println("}");

            leave_scope(trait_);
        si

        pre(struct_: Definition.STRUCT) -> bool is
            let symbol = symbol_for(struct_);

            print_class_def(symbol);

            _context.indent();

            enter_scope(struct_);            
        si

        visit(struct_: Definition.STRUCT) is
            _context.indent();

            println("}");

            leave_scope(struct_);
        si        

        pre(enum_: Definition.ENUM) -> bool is
            enter_scope(enum_);
        si

        visit(enum_: Definition.ENUM) is
            leave_scope(enum_);
        si

        pre(function: Definition.FUNCTION) -> bool is
            let symbol = symbol_for(function);

            println(symbol.il_def);

            println("{");

            enter_scope(function);

            _context.indent();
        si

        visit(function: Definition.FUNCTION) is
            _context.outdent();

            println("}");

            leave_scope(function);            
        si

        pre(property: Definition.PROPERTY) -> bool is
            let symbol = symbol_for(property);

            if symbol? then
                println(symbol.il_def);
                println("{");
    
                _context.indent();
    
                _context.outdent();
            else
                // assume variable
                symbol = find(property.name);

                if !symbol? then
                    return false;
                fi

                println(symbol.il_def);
            fi
        si
       
        pre(pragma_: Definition.PRAGMA) -> bool is
            process_pragma(pragma_.pragma_, true);
        si

        visit(pragma_: Definition.PRAGMA) is
            process_pragma(pragma_.pragma_, false);
        si

        process_pragma(pragma_: Pragma.NODE, is_enter: bool) is
            if !pragma_? then
                IO.Std.err.println("pragma is null");
                return;
            fi

            let name = pragma_.name.toString();

            if name =~ "IL.output" then
                if !pragma_.arguments? || pragma_.arguments.expressions.Length != 1 then
                    _logger.error(pragma_.arguments.location, "expected 1 argument");
                    return;
                fi

                let argument = pragma_.arguments.expressions[0];

                if !argument? || !isa Expression.Literal.STRING(argument) then
                    _logger.error(pragma_.arguments.location, "expected a string literal argument");
                    return;
                fi

                let file_name = cast Expression.Literal.STRING(argument).string;

                if is_enter then
                    _context.enter_file(file_name);
                else
                    _context.leave_file(file_name);
                fi
            elif name =~ "IL.stub" then
                if is_enter then
                    _context.enter_stub();
                else
                    _context.leave_stub();
                fi
            fi            
        si

        visit(assign: Statement.ASSIGNMENT) is
            super.visit(assign);

            gen(assign.left.value);
        si

        visit(expression: Statement.EXPRESSION) is
            super.visit(expression);

            gen(expression.expression.value);
        si

        pre(v: Variable.NODE) -> bool is
            super.pre(v);

            let symbol = find(v.name);

            if !symbol? then
                return false;
            fi

            _context.println(symbol.il_def);

            if v.initializer? && v.initializer.value? then
                symbol.store(null, v.initializer.value, _symbol_loader);
            fi
        si

        visit(r: Statement.RETURN) is
            super.visit(r);

            if r.expression? then
                gen(r.expression.value);
            fi

            _context.println("ret");
        si

        visit(t: Statement.THROW) is
            super.visit(t);

            if t.expression? then
                gen(t.expression.value);
            fi

            _context.println("throw");
        si

        pre(i: Statement.IF) -> bool is
            super.pre(i);

            return true;
        si
        
        visit(i: Statement.IF) is
            var is_first = true;
            var seen_else = false;

            for b in i.branches do
                if b.condition? then
                    gen(b.condition.value);

                    if is_first then
                        _context.println("if");
                    else
                        _context.println("elif");
                    fi
                else
                    seen_else = true;
                    _context.println("else");
                fi

                b.walk(self);

                is_first = false;
            od
            _context.println("fi");

            super.visit(i);
        si

        pre(case_: Statement.CASE) -> bool is
            super.pre(case_);

            return true;
        si

        visit(case_: Statement.CASE) is
            gen(case_.expression.value);

            _context.println("case");
            for m in case_.matches do
                for e in m.expressions do
                    gen(e.value);
                    _context.println("match");
                od
                
                _context.println("case");
                m.walk(self);
            od
            println("esac");

            super.visit(case_);
        si

        pre(match: Statement.CASE_MATCH) -> bool is
            super.pre(match);

            return true;
        si        

        visit(match: Statement.CASE_MATCH) is
            if match.expressions? then
                _context.println("when");
                match.expressions.accept(self);
            else
                _context.println("default");
            fi
            match.statements.accept(self);
            _context.println("endwhen");

            super.visit(match);
        si

        /*
        visit(try_: Statement.TRY) is
            println("try");
            indent();
            try_.body.accept(self);
            outdent();
            for c in try_.catches do
                c.accept(self);
            od
            if try_.finally_? then
                println("finally");
                indent();
                try_.finally_.accept(self);
                outdent();
            fi
            println("yrt");
        si

        visit(catch_: Statement.CATCH) is
            print("catch ");
            catch_.variable.accept(self);
            println();
            indent();
            catch_.body.accept(self);
            outdent();
        si
        */

        pre(do_: Statement.DO) -> bool is
            super.pre(do_);

            return true;
        si

        visit(do_: Statement.DO) is
            if do_.condition? then
                gen(do_.condition.value);
                _context.println("while");
            else
                _context.println("do");
            fi

            do_.body.walk(self);
            _context.println("od");

            super.visit(do_);
        si

        pre(pragma_: Statement.PRAGMA) -> bool is
            process_pragma(pragma_.pragma_, true);
        si

        visit(pragma_: Statement.PRAGMA) is
            process_pragma(pragma_.pragma_, false);
        si

        /*
        visit(labelled: Statement.LABELLED) is
            labelled.label.accept(self);
            print(": ");
            labelled.statement.accept(self);
        si

        visit(break_: Statement.BREAK) is
            print("break");
            if break_.label? then
                print(' ');
                break_.label.accept(self);
            fi
            println(";");
        si

        visit(continue_: Statement.CONTINUE) is
            print("continue");
            if continue_.label? then
                print(' ');
                continue_.label.accept(self);
            fi
            println(";");
        si
        */
    si
si
