namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Tree;
    use Source;

    // FIXME: this is tactical, just to get the compiler bootstrapped: we can't call DotNET directly to build CIL module in memory, so instead
    // we're generating assembly language in a file, which is then assembled with mono's ilasm. Once the compiler is bootstrapped this will need
    // to be re-done

    class GENERATE_IL: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _generic_cache: Semantic.GENERIC_CACHE;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        _context: IR.CONTEXT;
        _brancher: IR.BRANCHER;
        _boilerplate_generator: IR.BOILERPLATE_GENERATOR;
        _boxer: IR.VALUE_BOXER;
        _loops: LOOP_LABEL_STACK;

        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            generic_cache: Semantic.GENERIC_CACHE,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            context: IR.CONTEXT,
            brancher: IR.BRANCHER,
            boilerplate_generator: IR.BOILERPLATE_GENERATOR,
            boxer: IR.VALUE_BOXER
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _generic_cache = generic_cache;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _system_symbol_lookup = system_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;
            _context = context;
            _brancher = brancher;
            _boilerplate_generator = boilerplate_generator;
            _boxer = boxer;

            _loops = new LOOP_LABEL_STACK();
        si

        apply(root: Tree.NODE) is
            if _logger.any_errors then
                return;
            fi
            
            root.walk(self);
        si

        println(value: Object) is
            _context.write_line(value);
        si

        gen(value: Semantic.Graph.Value.BASE) is
            Semantic.Graph.Value.BASE.gen(value, _context);
        si

        print_class_def(symbol: Semantic.Symbol.BASE) is
            println(symbol.il_def);

            println("{");            
        si

        pre(namespace_: Definition.NAMESPACE) -> bool is
            super.pre(namespace_);

            // println(".namespace " + namespace_.name + " {");

            // _context.indent();
        si

        visit(namespace_: Definition.NAMESPACE) is
            // _context.outdent();

            // println("}");

            super.visit(namespace_);
        si
        
        pre(class_: Definition.CLASS) -> bool is
            let symbol = cast Semantic.Symbol.BASE(symbol_for(class_));
            let owner = cast Semantic.Symbol.BASE(symbol.owner);

            _context.write_line(".namespace " + owner.il_qualified_name + " {");
            _context.indent();

            print_class_def(symbol);

            enter_scope(class_);

            _context.indent();
        si
        

        visit(class_: Definition.CLASS) is
            let symbol = cast Semantic.Symbol.Classy(symbol_for(class_));

            gen_ienumerable_boilerplate(symbol);
            gen_ienumerator_boilerplate(symbol);
            gen_closures(symbol);

            _context.outdent();
            println("}");
            _context.outdent();
            println("}");

            leave_scope(class_);
        si

        pre(trait_: Definition.TRAIT) -> bool is
            let symbol = cast Semantic.Symbol.BASE(symbol_for(trait_));
            let owner = cast Semantic.Symbol.BASE(symbol.owner);

            _context.write_line(".namespace " + owner.il_qualified_name + " { // fixed");
            _context.indent();
            
            print_class_def(symbol);

            enter_scope(trait_);

            _context.indent();
        si

        visit(trait_: Definition.TRAIT) is
            _context.outdent();
            println("}");
            _context.outdent();
            println("}");

            leave_scope(trait_);
        si

        pre(struct_: Definition.STRUCT) -> bool is
            let symbol = cast Semantic.Symbol.BASE(symbol_for(struct_));
            let owner = cast Semantic.Symbol.BASE(symbol.owner);

            _context.write_line(".namespace " + owner.il_qualified_name + " { // fixed");
            _context.indent();

            print_class_def(symbol);

            _context.indent();

            enter_scope(struct_);            
        si

        visit(struct_: Definition.STRUCT) is
            let symbol = cast Semantic.Symbol.Classy(symbol_for(struct_));

            gen_ienumerable_boilerplate(symbol);
            gen_ienumerator_boilerplate(symbol);
            gen_closures(symbol);

            _context.outdent();
            println("}");
            _context.outdent();
            println("}");

            leave_scope(struct_);
        si        

        gen_ienumerable_boilerplate(symbol: Semantic.Symbol.Classy) is            
            if symbol.is_derived_from_iterable_trait then
                // FIXME: check if class implements these methods and don't emit them if they're not needed:

                _boilerplate_generator.gen("ienumerable-boilerplate");
            fi            
        si
        
        gen_ienumerator_boilerplate(symbol: Semantic.Symbol.Classy) is            
            if symbol.is_derived_from_iterator_trait then
                // FIXME: check if class implements these methods and don't emit them if they're not needed:

                _boilerplate_generator.gen("ienumerator-boilerplate");
            fi            
        si

        gen_closures(symbol: Semantic.Symbol.Classy) is
            if symbol.closures? then
                for closure in symbol.closures do
                    _context.write_line(closure.il_def);
                    _context.write_line("{");
                    _context.indent();
    
                    _context.write_line(closure.il_body);
    
                    _context.outdent();
                    _context.write_line("}");
                od                    
            fi
        si

        pre(enum_: Definition.ENUM) -> bool is
            let symbol = cast Semantic.Symbol.BASE(symbol_for(enum_));

            let owner = cast Semantic.Symbol.BASE(symbol.owner);

            _context.write_line(".namespace " + owner.il_qualified_name + " {");
            _context.indent();

            print_class_def(symbol);

            enter_scope(enum_);

            _context.indent();

            _context.write_line(".field public specialname rtspecialname int32 value__");  
        si

        visit(enum_: Definition.ENUM) is

            // let symbol = cast Semantic.Symbol.Classy(symbol_for(enum_));

            _context.outdent();
            println("}");
            _context.outdent();
            println("}");

            leave_scope(enum_);
        si

        pre(enum_member: Definition.ENUM_MEMBER) -> bool is
            let symbol = current_scope.find_member(enum_member.name.name);

            _context.write_line(symbol.il_def);
        si

        pre(function: Definition.FUNCTION) -> bool is
            let symbol = symbol_for(function);

            println(symbol.il_def);

            println("{");
            _context.indent();

            enter_scope(function);
        si

        visit(function: Definition.FUNCTION) is
            let symbol = symbol_for(function);

            if symbol? && isa Semantic.Symbol.Function(symbol) then
                let function_symbol = cast Semantic.Symbol.Function(symbol);

                if !function_symbol.is_abstract then
                    if 
                        function_symbol.return_type? &&
                        function_symbol.return_type.compare(self._ghul_symbol_lookup.get_void_type()) != Semantic.Type.MATCH.SAME
                    then
                        _context.write_line(".locals init (" + function_symbol.return_type.il_type_name + " '.default')");
                        _context.write_line("ldloc '.default'");
                    fi

                    _context.write_line("ret");
                fi
            fi

            leave_scope(function);

            _context.outdent();
            println("}");
        si

        pre(expression_body: Body.EXPRESSION) -> bool is
            return super.pre(expression_body);            
        si
        
        visit(expression_body: Body.EXPRESSION) is
            if
                expression_body.expression.value? &&
                expression_body.expression.value.type?
            then
                let value =
                    _boxer.box_if_needed(
                        expression_body.expression.value,
                        current_function.return_type
                    );

                gen(value);
            fi

            _context.write_line("ret");

            super.visit(expression_body);
        si

        pre(property: Definition.PROPERTY) -> bool is
            let symbol = symbol_for(property);

            if symbol? then
                // FIXME: incorrect IL names for properties in generic traits causes assembler error

                /*                
                let property_symbol = cast Semantic.Symbol.Property(symbol);

                println(symbol.il_def);
                println("{");
    
                _context.indent();

                if property_symbol.read_function? then
                    println(".get " + property_symbol.read_function.il_property_def);
                fi
                
                if property_symbol.assign_function? then
                    println(".set " + property_symbol.assign_function.il_property_def);
                fi

                _context.outdent();
                println("}");
                */
            else
                // assume variable
                symbol = find(property.name);

                if !symbol? then
                    return false;
                fi

                println(symbol.il_def);
            fi

            return true;
        si
       
        pre(pragma_: Definition.PRAGMA) -> bool is
            process_pragma(pragma_.pragma_, true);
        si

        visit(pragma_: Definition.PRAGMA) is
            process_pragma(pragma_.pragma_, false);
        si

        process_pragma(pragma_: Pragma.NODE, is_enter: bool) is
            if !pragma_? then
                System.Console.error.write_line("pragma is null");
                return;
            fi

            let name = pragma_.name.toString();

            if name =~ "IL.output" then
                if !pragma_.arguments? || pragma_.arguments.expressions.count != 1 then
                    _logger.error(pragma_.arguments.location, "expected 1 argument");
                    return;
                fi

                let argument = pragma_.arguments.expressions[0];

                if !argument? || !isa Expression.Literal.STRING(argument) then
                    _logger.error(pragma_.arguments.location, "expected a string literal argument");
                    return;
                fi

                let file_name = cast Expression.Literal.STRING(argument).string;

                if is_enter then
                    _context.enter_file(file_name, false);
                else
                    _context.leave_file(file_name);
                fi
            elif name =~ "IL.stub" then
                if is_enter then
                    _context.enter_stub();
                else
                    _context.leave_stub();
                fi
            elif name =~ "IL.entrypoint" then
                if is_enter then
                    _context.write_line(".entrypoint");
                fi
                
            fi            
        si

        pre(function: Tree.Expression.FUNCTION) -> bool is
            super.pre(function);
            return true;
        si

        visit(function: Tree.Expression.FUNCTION) is
            _context.enter_buffer(true);

            let closure = cast Semantic.Symbol.Closure(scope_for(function));

            function.body.walk(self);

            if 
                closure.return_type? &&
                closure.return_type.compare(self._ghul_symbol_lookup.get_void_type()) != Semantic.Type.MATCH.SAME
            then
                _context.write_line(".locals init (" + closure.return_type.il_type_name + " '.default')");
                _context.write_line("ldloc '.default'");
            fi

            _context.write_line("ret");

            let body_assembler = _context.leave_buffer();

            closure.il_body = body_assembler;

            super.visit(function);
        si

        visit(assign: Statement.ASSIGNMENT) is
            super.visit(assign);

            gen(assign.left.value);
        si

        visit(expression: Statement.EXPRESSION) is
            super.visit(expression);

            try
                gen(expression.expression.value);

                if 
                    expression.expression.value? &&
                    expression.expression.value.type? &&
                    expression.expression.value.type !~ _ghul_symbol_lookup.get_void_type()
                then
                    _context.write_line("pop");                    
                fi
            catch e: System.Exception
                System.Console.error.write_line("expression statement:\n" + expression.expression);  
                System.Console.error.write_line("expression value:\n" + expression.expression.value);  
                System.Console.error.write_line("caught: " + e);
            yrt
        si

        pre(v: Variable.NODE) -> bool is
            super.pre(v);

            let symbol = find(v.name);

            if !symbol? then
                return false;
            fi

            let il_def = symbol.il_def;

            // symbol may not need any definition emitting - e.g. function argument, in which case il_def will be null
            if il_def? then
                _context.write_line(symbol.il_def);
            fi

            if v.initializer? && v.initializer.value? then
                let store = symbol.store(v.location, null, v.initializer.value, _symbol_loader);

                gen(store);
            fi            
        si
       
        visit(r: Statement.RETURN) is
            super.visit(r);

            let function = current_function;

            let value: Semantic.Graph.Value.BASE;

            if
                r.expression? &&
                r.expression.value? &&
                r.expression.value.type?
            then
                value =
                    _boxer.box_if_needed(
                        r.expression.value,
                        current_function.return_type
                    );

            fi

            let current_try = _loops.get_current_try();

            if current_try? then
                if value? then
                    current_try.return_value.store(value);                    
                fi
                
                if current_try.is_in_finally then
                    current_try.return_needed.store(new Semantic.Graph.Value.Literal.INTEGER("1", _ghul_symbol_lookup.get_bool_type(), "i4"));
                    _brancher.branch(current_try.middle);
                else
                    _brancher.leave(current_try.start);
                fi
            else
                if value? then
                    gen(value);
                fi

                _context.write_line("ret");
            fi            
        si

        visit(throw_: Statement.THROW) is
            super.visit(throw_);

            gen(
                _boxer.box_if_value(
                    throw_.expression.value
                )
            );

            _context.write_line("throw");
        si

        visit(assert_: Statement.ASSERT) is
            super.visit(assert_);

            let end = new IR.LABEL();

            _brancher.branch(
                IR.BRANCH.NZ,
                assert_.expression.value,
                end
            );

            let need_exception_wrapper = true;

            if assert_.message? then
                let message_value = assert_.message.value; 
                if !_system_symbol_lookup.get_exception_type().is_assignable_from(message_value.type) then
                    gen(
                        new Semantic.Graph.Value.Literal.STRING(
                            "" + assert_.location + ": ",
                            _system_symbol_lookup.get_string_type()
                        )
                    );

                    gen(message_value);

                    _context.write_line("call string string::Concat(object,object)");
                else
                    need_exception_wrapper = false;
                fi
            else
                gen(
                    new Semantic.Graph.Value.Literal.STRING(
                        "" + assert_.location + ": " + assert_.expression,
                        _system_symbol_lookup.get_string_type()
                    )
                );
            fi

            if need_exception_wrapper then
                _context.write_line("newobj instance void class [mscorlib]System.Exception::.ctor(class [mscorlib]System.String)");
            fi
            
            _context.write_line("throw");

            _brancher.label(end);
        si

        pre(i: Statement.IF) -> bool is
            super.pre(i);

            return true;
        si
        
        visit(i: Statement.IF) is
            var is_first = true;
            var seen_else = false;

            let end = new IR.LABEL();

            for b in i.branches do
                let next = new IR.LABEL();

                if b.condition? then
                    if is_first then
                        _brancher.branch(IR.BRANCH.Z, b.condition.value, next, "if");
                    else
                        _brancher.branch(IR.BRANCH.Z, b.condition.value, next, "elif");
                    fi
                else
                    seen_else = true;
                fi

                b.walk(self);

                _brancher.branch(end);
                _brancher.label(next);

                is_first = false;
            od

            _brancher.label(end);

            super.visit(i);
        si

        pre(case_: Statement.CASE) -> bool is
            super.pre(case_);

            return true;
        si

        visit(case_: Statement.CASE) is
            _assert case_.expression?;
            _assert case_.matches?;

            let temp = new IR.TEMP(_context, case_.id, case_.expression.value);

            let labels = _loops.enter_loop();

            for m in case_.matches do
                let next = new IR.LABEL();
    
                if m.expressions? then
                    if m.expressions.expressions.count == 1 then
                        _brancher.branch(IR.BRANCH.NE, temp.load(), m.expressions.expressions[0].value, next);
                    else
                        let match = new IR.LABEL();

                        for e in m.expressions do
                            _brancher.branch(IR.BRANCH.EQ, temp.load(), e.value, match);
                        od    

                        _brancher.branch(next);

                        _brancher.label(match);
                    fi
                fi

                pre(m);
                               
                m.statements.walk(self);

                visit(m);

                _brancher.label(next);
            od

            super.visit(case_);
        si

        pre(match: Statement.CASE_MATCH) -> bool is
            super.pre(match);

            return true;
        si        

        visit(match: Statement.CASE_MATCH) is
            match.statements.accept(self);

            super.visit(match);
        si

        pre(try_: Statement.TRY) -> bool is
            super.pre(try_);

            return true;
        si

        visit(try_: Statement.TRY) is
            let return_type = current_function.return_type;

            let return_needed = new IR.TEMP(_context, try_.id, 1, _ghul_symbol_lookup.get_bool_type());
            let return_value: IR.TEMP;

            if return_type? && return_type !~ _ghul_symbol_lookup.get_void_type() then
                return_value = new IR.TEMP(_context, try_.id, return_type);                
            fi
            
            let label = _loops.enter_try(return_needed, return_value);

            let need_double_try = try_.catches? && try_.catches.count > 0 && try_.finally_?;

            if need_double_try then
                _context.write_line(".try {");
                _context.indent();                    
            fi
                        
            _context.write_line(".try {");
            _context.indent();

            try_.body.walk(self);

            _brancher.leave(label.end);

            _context.outdent();

            _context.write_line("}");

            for c in try_.catches do
                c.walk(self);
            od

            if need_double_try then
                _context.outdent();
                _context.write_line("}");                
            fi
            
            if try_.finally_? then
                label.is_in_finally = true;

                _context.write_line("finally {");
                _context.indent();
                try_.finally_.walk(self);

                _brancher.label(label.middle);

                _context.write_line("endfinally");
                _context.outdent();

                _context.write_line("}");
            fi

            _loops.leave_loop();

            _brancher.branch(IR.BRANCH.Z, label.return_needed.load(), label.end);

            _brancher.label(label.start);
            
            let outer_try = _loops.get_current_try();

            if outer_try? then
                if return_value? then
                    _assert outer_try.return_value? else "outer try has no return value temporary";
                    outer_try.return_value.store(return_value.load());
                fi
                
                if outer_try.is_in_finally then
                    outer_try.return_needed.store(new Semantic.Graph.Value.Literal.INTEGER("1", _ghul_symbol_lookup.get_bool_type(), "i4"));
                    _brancher.branch(outer_try.middle);
                else
                    _brancher.leave(outer_try.start);
                fi
            else
                if return_value? then
                    return_value.load().gen(_context);                    
                fi                

                _context.write_line("ret");                
            fi

            _brancher.label(label.end);

            super.visit(try_);
        si

        pre(catch_: Statement.CATCH) -> bool is
            super.pre(catch_);

            return true;
        si

        visit(catch_: Statement.CATCH) is
            _context.write_line("catch " + catch_.variable.type_expression.type.il_type_name + " {");
            _context.indent();

            catch_.variable.walk(self);

            let symbol = find(catch_.variable.name);

            _context.write_line("stloc " + symbol.il_name);

            catch_.body.walk(self);

            _brancher.leave(_loops.get_current_try().end);

            _context.outdent();
            _context.write_line("}");

            super.visit(catch_);
        si

        pre(do_: Statement.DO) -> bool is
            super.pre(do_);

            return true;
        si

        visit(do_: Statement.DO) is
            let loop = _loops.enter_loop();

            _brancher.label(loop.start);

            if do_.condition? then
                _brancher.branch(IR.BRANCH.Z, do_.condition.value, loop.end, "while");
            fi

            do_.body.walk(self);

            _brancher.branch(loop.start);

            _brancher.label(loop.end);

            super.visit(do_);

            _loops.leave_loop();
        si

        pre(for_: Statement.FOR) -> bool is
            super.pre(for_);

            return true;
        si

        visit(for_: Statement.FOR) is
            let loop = _loops.enter_loop();

            let iterator: Semantic.Graph.Value.BASE;

            if for_.read_iterator? then
                iterator = for_.read_iterator.call(for_.expression.location, for_.expression.value, new Collections.LIST[Semantic.Graph.Value.BASE](0), null, _function_caller);
            else
                iterator = for_.expression.value;
            fi

            for_.variable.walk(self);
            
            let temp = new IR.TEMP(_context, for_.id, iterator);

            _brancher.label(loop.start);

            let has_next = for_.move_next.call(for_.expression.location, temp.load(), new Collections.LIST[Semantic.Graph.Value.BASE](0), null, _function_caller);

            _brancher.branch(IR.BRANCH.Z, has_next, loop.end);

            let current = for_.read_current.call(for_.expression.location, temp.load(), new Collections.LIST[Semantic.Graph.Value.BASE](0), null, _function_caller);

            var variable = find(for_.variable.name);

            let store = variable.store(for_.variable.location, null, current, _symbol_loader);

            store.gen(_context);
            
            for_.body.walk(self);

            _brancher.branch(loop.start);
            _brancher.label(loop.end);

            super.visit(for_);

            _loops.leave_loop();
        si

        pre(pragma_: Statement.PRAGMA) -> bool is
            process_pragma(pragma_.pragma_, true);
        si

        visit(pragma_: Statement.PRAGMA) is
            process_pragma(pragma_.pragma_, false);
        si

        pre(labelled: Statement.LABELLED) -> bool is
            super.pre(labelled);

            return true;            
        si
        
        visit(labelled: Statement.LABELLED) is
            _loops.next_name(labelled.label.name);

            labelled.statement.walk(self);

            super.visit(labelled);
        si

        visit(break_: Statement.BREAK) is
            if !_loops.is_in_loop then
                _logger.error(break_.location, "break outside of loop");

                return;
            fi

            if _loops.is_in_try then
                _brancher.leave(_loops.get_current_loop().end);            
            else
                _brancher.branch(_loops.get_current_loop().end);                                            
            fi            
        si

        visit(continue_: Statement.CONTINUE) is
            if !_loops.is_in_loop then
                _logger.error(continue_.location, "continue outside of loop");

                return;
            fi

            if _loops.is_in_try then
                _brancher.leave(_loops.get_current_loop().start);
            else
                _brancher.branch(_loops.get_current_loop().start);                
            fi
        si
    si

    class LOOP_LABELS is
        is_try: bool;
        is_in_finally: bool public;
        is_loop: bool => !is_try?;

        name: String;
        start: IR.LABEL;
        middle: IR.LABEL;
        end: IR.LABEL;

        return_needed: IR.TEMP;
        return_value: IR.TEMP;

        init(name: String) is
            is_try = false;
            self.name = name;
            start = new IR.LABEL();
            end = new IR.LABEL();
        si

        init(return_needed: IR.TEMP, return_value: IR.TEMP) is
            is_try = true;
            self.return_needed = return_needed;
            self.return_value = return_value;
            start = new IR.LABEL();
            middle = new IR.LABEL();
            end = new IR.LABEL();
        si

        matches(name: String) -> bool => self.name? && self.name =~ name;
    si

    class LOOP_LABEL_STACK is
        _next_name: String;

        loops: Collections.LIST[LOOP_LABELS];
        is_in_loop: bool => get_current_loop() != null;
        is_in_try: bool => get_current_try() != null;

        get_current_try() -> LOOP_LABELS is
            let index: int = loops.count - 1;
            
            while index >= 0 do
                let result = loops[index];

                if result.is_try then
                    return result;
                fi

                index = index - 1;
            od
        si

        get_current_loop() -> LOOP_LABELS is
            let index: int = loops.count - 1;
            
            while index >= 0 do
                let result = loops[index];

                if result.is_loop then
                    return result;    
                fi

                index = index - 1;
            od
        si

        init() is
            loops = new Collections.LIST[LOOP_LABELS]();
        si
        
        next_name(name: String) is
            _next_name = name;
        si

        find(name: String) -> LOOP_LABELS is
            for i in loops.count..0 do
                System.Console.error.write_line("try loop " + i + " out of " + loops.count);

                let loop = loops[i];

                if loop.matches(name) then
                    return loop;
                fi
            od         
        si

        enter_try(return_needed: IR.TEMP, return_value: IR.TEMP) -> LOOP_LABELS is
            let result = new LOOP_LABELS(return_needed, return_value);

            loops.add(result);

            return result;
        si        

        enter_loop() -> LOOP_LABELS is            
            let result = new LOOP_LABELS(_next_name);

            loops.add(result);

            return result;
        si        

        leave_loop() is
            loops.remove_at(loops.count - 1);
            _next_name = null;
        si
    si
si
