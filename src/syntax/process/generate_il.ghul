namespace Syntax.Process is
    use System;
    use Generic;
    
    use Logging;
    use Tree;
    use Source;

    // FIXME: this is tactical, just to get the compiler bootstrapped: we can't call DotNET directly to build CIL module in memory, so instead
    // we're generating assembly language in a file, which is then assembled with mono's ilasm. Once the compiler is bootstrapped this will need
    // to be re-done

    class GENERATE_IL: ScopedVisitor is
        _logger: Logger;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _int_type: Semantic.Type.NAMED;
        _symbol_loader: Semantic.SYMBOL_LOADER;
        _ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP;
        _system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP;
        _function_caller: Semantic.FUNCTION_CALLER;
        _overload_resolver: Semantic.OVERLOAD_RESOLVER;
        _generic_cache: Semantic.GENERIC_CACHE;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        _context: IR.CONTEXT;
        _brancher: IR.BRANCHER;
        _loops: LOOP_LABEL_STACK;

        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;

        init(
            logger: Logger,
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES,
            symbol_loader: Semantic.SYMBOL_LOADER,
            ghul_symbol_lookup: Semantic.GHUL_SYMBOL_LOOKUP,
            system_symbol_lookup: Semantic.SYSTEM_SYMBOL_LOOKUP,
            function_caller: Semantic.FUNCTION_CALLER,
            overload_resolver: Semantic.OVERLOAD_RESOLVER,
            generic_cache: Semantic.GENERIC_CACHE,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            context: IR.CONTEXT,
            brancher: IR.BRANCHER
        )
        is
            super.init(logger, symbol_table, namespaces);

            _logger = logger;
            _symbol_table = symbol_table;
            _symbol_loader = symbol_loader;
            _generic_cache = generic_cache;
            _ghul_symbol_lookup = ghul_symbol_lookup;
            _system_symbol_lookup = system_symbol_lookup;
            _function_caller = function_caller;
            _overload_resolver = overload_resolver;
            _symbol_use_locations = symbol_use_locations;
            _context = context;
            _brancher = brancher;

            _loops = new LOOP_LABEL_STACK();
        si

        apply(root: Tree.NODE) is
            if _logger.any_errors then
                return;
            fi
            
            root.walk(self);
        si

        println(value: Object) is
            _context.println(value);
        si

        gen(value: Semantic.Graph.Value.BASE) is
            Semantic.Graph.Value.BASE.gen(value, _context);
        si

        print_class_def(symbol: Semantic.Symbol.BASE) is
            println(symbol.il_def);

            println("{");            
        si

        pre(namespace_: Definition.NAMESPACE) -> bool is
            super.pre(namespace_);

            // println(".namespace " + namespace_.name + " {");

            // _context.indent();
        si

        visit(namespace_: Definition.NAMESPACE) is
            // _context.outdent();

            // println("}");

            super.visit(namespace_);
        si
        
        pre(class_: Definition.CLASS) -> bool is
            let symbol = cast Semantic.Symbol.BASE(symbol_for(class_));
            let owner = cast Semantic.Symbol.BASE(symbol.owner);

            _context.println(".namespace " + owner.il_qualified_name + " {");
            _context.indent();

            print_class_def(symbol);

            enter_scope(class_);

            _context.indent();
        si
        

        visit(class_: Definition.CLASS) is
            let symbol = cast Semantic.Symbol.ScopedWithInheritance(symbol_for(class_));

            gen_closures(symbol);

            _context.outdent();
            println("}");
            _context.outdent();
            println("}");

            leave_scope(class_);
        si

        pre(trait_: Definition.TRAIT) -> bool is
            let symbol = cast Semantic.Symbol.BASE(symbol_for(trait_));
            let owner = cast Semantic.Symbol.BASE(symbol.owner);

            _context.println(".namespace " + owner.il_qualified_name + " { // fixed");
            _context.indent();
            
            print_class_def(symbol);

            enter_scope(trait_);

            _context.indent();
        si

        visit(trait_: Definition.TRAIT) is
            _context.outdent();
            println("}");
            _context.outdent();
            println("}");

            leave_scope(trait_);
        si

        pre(struct_: Definition.STRUCT) -> bool is
            let symbol = cast Semantic.Symbol.BASE(symbol_for(struct_));
            let owner = cast Semantic.Symbol.BASE(symbol.owner);

            _context.println(".namespace " + owner.il_qualified_name + " { // fixed");
            _context.indent();

            print_class_def(symbol);

            _context.indent();

            enter_scope(struct_);            
        si

        visit(struct_: Definition.STRUCT) is
            let symbol = cast Semantic.Symbol.ScopedWithInheritance(symbol_for(struct_));

            gen_closures(symbol);

            _context.outdent();
            println("}");
            _context.outdent();
            println("}");

            leave_scope(struct_);
        si        
        
        gen_closures(symbol: Semantic.Symbol.ScopedWithInheritance) is
            if symbol.closures? then
                for closure in symbol.closures do
                    _context.println(closure.il_def);
                    _context.println("{");
                    _context.indent();
    
                    _context.println(closure.il_body);
    
                    _context.outdent();
                    _context.println("}");
                od                    
            fi
        si

        pre(enum_: Definition.ENUM) -> bool is
            IO.Std.err.FlushOnPrintln = true;

            let symbol = cast Semantic.Symbol.BASE(symbol_for(enum_));

            let owner = cast Semantic.Symbol.BASE(symbol.owner);

            _context.println(".namespace " + owner.il_qualified_name + " {");
            _context.indent();

            print_class_def(symbol);

            enter_scope(enum_);

            _context.indent();

            _context.println(".field public specialname rtspecialname int32 value__");  
        si

        visit(enum_: Definition.ENUM) is

            // let symbol = cast Semantic.Symbol.ScopedWithInheritance(symbol_for(enum_));

            _context.outdent();
            println("}");
            _context.outdent();
            println("}");

            leave_scope(enum_);
        si

        pre(enum_member: Definition.ENUM_MEMBER) -> bool is
            let symbol = current_scope.find_member(enum_member.name.name);

            _context.println(symbol.il_def);
        si

        pre(function: Definition.FUNCTION) -> bool is
            let symbol = symbol_for(function);

            println(symbol.il_def);

            println("{");
            _context.indent();

            enter_scope(function);
        si

        visit(function: Definition.FUNCTION) is
            let symbol = symbol_for(function);

            if symbol? && isa Semantic.Symbol.Function(symbol) then
                let function_symbol = cast Semantic.Symbol.Function(symbol);

                if !function_symbol.is_abstract then
                    if 
                        function_symbol.return_type? &&
                        function_symbol.return_type.compare(self._ghul_symbol_lookup.get_void_type()) != Semantic.Type.MATCH.SAME
                    then
                        _context.println(".locals init (" + function_symbol.return_type.il_type_name + " '.default')");
                        _context.println("ldloc '.default'");
                    fi

                    _context.println("ret");
                fi
            fi

            leave_scope(function);

            _context.outdent();
            println("}");
        si

        pre(property: Definition.PROPERTY) -> bool is
            let symbol = symbol_for(property);

            if symbol? then
                let property_symbol = cast Semantic.Symbol.Property(symbol);

                println(symbol.il_def);
                println("{");
    
                _context.indent();

                if property_symbol.read_function? then
                    println(".get " + property_symbol.read_function.il_property_def);
                fi
                
                if property_symbol.assign_function? then
                    println(".set " + property_symbol.assign_function.il_property_def);
                fi

                _context.outdent();
                println("}");
            else
                // assume variable
                symbol = find(property.name);

                if !symbol? then
                    return false;
                fi

                println(symbol.il_def);
            fi

            return true;
        si
       
        pre(pragma_: Definition.PRAGMA) -> bool is
            process_pragma(pragma_.pragma_, true);
        si

        visit(pragma_: Definition.PRAGMA) is
            process_pragma(pragma_.pragma_, false);
        si

        process_pragma(pragma_: Pragma.NODE, is_enter: bool) is
            if !pragma_? then
                IO.Std.err.println("pragma is null");
                return;
            fi

            let name = pragma_.name.toString();

            if name =~ "IL.output" then
                if !pragma_.arguments? || pragma_.arguments.expressions.Length != 1 then
                    _logger.error(pragma_.arguments.location, "expected 1 argument");
                    return;
                fi

                let argument = pragma_.arguments.expressions[0];

                if !argument? || !isa Expression.Literal.STRING(argument) then
                    _logger.error(pragma_.arguments.location, "expected a string literal argument");
                    return;
                fi

                let file_name = cast Expression.Literal.STRING(argument).string;

                if is_enter then
                    _context.enter_file(file_name, false);
                else
                    _context.leave_file(file_name);
                fi
            elif name =~ "IL.stub" then
                if is_enter then
                    _context.enter_stub();
                else
                    _context.leave_stub();
                fi
            elif name =~ "IL.entrypoint" then
                if is_enter then
                    _context.println(".entrypoint");
                fi
                
            fi            
        si

        pre(function: Tree.Expression.FUNCTION) -> bool is
            super.pre(function);
            return true;
        si

        visit(function: Tree.Expression.FUNCTION) is
            _context.enter_buffer(true);

            let closure = cast Semantic.Symbol.CLOSURE(scope_for(function));

            function.body.walk(self);

            let body_assembler = _context.leave_buffer();

            closure.il_body = body_assembler;

            super.visit(function);
        si

        visit(assign: Statement.ASSIGNMENT) is
            super.visit(assign);

            gen(assign.left.value);
        si

        visit(expression: Statement.EXPRESSION) is
            super.visit(expression);

            try
                gen(expression.expression.value);

                if expression.expression.value.type !~ _ghul_symbol_lookup.get_void_type() then
                    _context.println("pop");                    
                fi                
            catch e: System.Exception
                IO.Std.err.println("expression statement:\n" + expression.expression);  
                IO.Std.err.println("expression value:\n" + expression.expression.value);  
                IO.Std.err.println("caught: " + e);
            yrt
            
        si

        pre(v: Variable.NODE) -> bool is
            super.pre(v);

            let symbol = find(v.name);

            if !symbol? then
                return false;
            fi

            let il_def = symbol.il_def;

            // symbol may not need any definition emitting - e.g. function argument, in which case il_def will be null
            if il_def? then
                _context.println(symbol.il_def);
            fi

            if v.initializer? && v.initializer.value? then
                let store = symbol.store(v.location, null, v.initializer.value, _symbol_loader);

                gen(store);
            fi            
        si
       
        visit(r: Statement.RETURN) is
            super.visit(r);

            if r.expression? then
                gen(r.expression.value);
            fi

            _context.println("ret");
        si

        visit(t: Statement.THROW) is
            super.visit(t);

            if t.expression? then
                gen(t.expression.value);
            fi

            _context.println("throw");
        si

        pre(i: Statement.IF) -> bool is
            super.pre(i);

            return true;
        si
        
        visit(i: Statement.IF) is
            var is_first = true;
            var seen_else = false;

            let end = new IR.LABEL();

            for b in i.branches do
                let next = new IR.LABEL();

                if b.condition? then
                    if is_first then
                        _brancher.branch(IR.BRANCH.Z, b.condition.value, next, "if");
                    else
                        _brancher.branch(IR.BRANCH.Z, b.condition.value, next, "elif");
                    fi
                else
                    seen_else = true;
                fi

                b.walk(self);

                _brancher.branch(end);
                _brancher.label(next);

                is_first = false;
            od

            _brancher.label(end);

            super.visit(i);
        si

        pre(case_: Statement.CASE) -> bool is
            super.pre(case_);

            return true;
        si

        visit(case_: Statement.CASE) is
            assert(case_.expression?, "case expression is null: " + self);
            assert(case_.matches?, "case matches is null: " + self);

            let temp = new IR.TEMP(_context, case_.id, case_.expression.value);

            let labels = _loops.enter_loop();

            for m in case_.matches do
                let next = new IR.LABEL();
    
                if m.expressions? then
                    if m.expressions.expressions.Length == 1 then
                        _brancher.branch(IR.BRANCH.NE, temp.load(), m.expressions.expressions[0].value, next);
                    else
                        let match = new IR.LABEL();

                        for e in m.expressions do
                            _brancher.branch(IR.BRANCH.EQ, temp.load(), e.value, match);
                        od    

                        _brancher.branch(next);

                        _brancher.label(match);
                    fi
                fi

                pre(m);
                               
                m.statements.walk(self);

                visit(m);

                _brancher.label(next);
            od

            super.visit(case_);
        si

        pre(match: Statement.CASE_MATCH) -> bool is
            super.pre(match);

            return true;
        si        

        visit(match: Statement.CASE_MATCH) is
            /*
            if match.expressions? then
                _context.println("when");
                match.expressions.accept(self);
            else
                _context.println("default");
            fi
            */
            match.statements.accept(self);

            super.visit(match);
        si

        /*
        visit(try_: Statement.TRY) is
            println("try");
            indent();
            try_.body.accept(self);
            outdent();
            for c in try_.catches do
                c.accept(self);
            od
            if try_.finally_? then
                println("finally");
                indent();
                try_.finally_.accept(self);
                outdent();
            fi
            println("yrt");
        si

        visit(catch_: Statement.CATCH) is
            print("catch ");
            catch_.variable.accept(self);
            println();
            indent();
            catch_.body.accept(self);
            outdent();
        si
        */

        pre(do_: Statement.DO) -> bool is
            super.pre(do_);

            return true;
        si

        visit(do_: Statement.DO) is
            let loop = _loops.enter_loop();

            _brancher.label(loop.start);

            if do_.condition? then
                _brancher.branch(IR.BRANCH.Z, do_.condition.value, loop.end, "while");
            fi

            do_.body.walk(self);

            _brancher.branch(loop.start);

            _brancher.label(loop.end);

            super.visit(do_);

            _loops.leave_loop();
        si

        pre(for_: Statement.FOR) -> bool is
            super.pre(for_);

            return true;
        si

        visit(for_: Statement.FOR) is
            let loop = _loops.enter_loop();

            let iterator: Semantic.Graph.Value.BASE;

            if for_.read_iterator? then
                iterator = for_.read_iterator.call(for_.expression.value, new Semantic.Graph.Value.BASE[](0), null, _function_caller);
            else
                iterator = for_.expression.value;
            fi

            for_.variable.walk(self);
            
            let temp = new IR.TEMP(_context, for_.id, iterator);

            _brancher.label(loop.start);

            let has_next = for_.move_next.call(temp.load(), new Semantic.Graph.Value.BASE[](0), null, _function_caller);

            _brancher.branch(IR.BRANCH.Z, has_next, loop.end);

            let current = for_.read_current.call(temp.load(), new Semantic.Graph.Value.BASE[](0), null, _function_caller);

            var variable = find(for_.variable.name);

            let store = variable.store(for_.variable.location, null, current, _symbol_loader);

            store.gen(_context);
            
            for_.body.walk(self);

            _brancher.branch(loop.start);
            _brancher.label(loop.end);

            super.visit(for_);

            _loops.leave_loop();
        si

        pre(pragma_: Statement.PRAGMA) -> bool is
            process_pragma(pragma_.pragma_, true);
        si

        visit(pragma_: Statement.PRAGMA) is
            process_pragma(pragma_.pragma_, false);
        si

        pre(labelled: Statement.LABELLED) -> bool is
            super.pre(labelled);

            return true;            
        si
        
        visit(labelled: Statement.LABELLED) is
            _loops.next_name(labelled.label.name);

            labelled.statement.walk(self);

            super.visit(labelled);
        si

        visit(break_: Statement.BREAK) is
            if !_loops.is_in_loop then
                _logger.error(break_.location, "break outside of loop");

                return;
            fi

            _brancher.branch(_loops.current.end);            
        si

        visit(continue_: Statement.CONTINUE) is
            if !_loops.is_in_loop then
                _logger.error(continue_.location, "continue outside of loop");

                return;
            fi

            _brancher.branch(_loops.current.start);
        si
    si

    class LOOP_LABELS is
        name: String;
        start: IR.LABEL;
        end: IR.LABEL;

        init(name: String) is
            self.name = name;
            start = new IR.LABEL();
            end = new IR.LABEL();
        si        
    si

    class LOOP_LABEL_STACK is
        _next_name: String;

        loops: Vector[LOOP_LABELS];
        is_in_loop: bool => loops.Length > 0;
        current: LOOP_LABELS => loops.Top;

        init() is
            loops = new Vector[LOOP_LABELS]();
        si
        
        next_name(name: String) is
            _next_name = name;
        si

        find(name: String) -> LOOP_LABELS is
            for i in loops.Length..0 do
                IO.Std.err.println("try loop " + i + " out of " + loops.Length);

                let loop = loops[i];

                if loop.name? && loop.name =~ name then
                    return loop;
                fi
            od         
        si

        enter_loop() -> LOOP_LABELS is            
            let result = new LOOP_LABELS(_next_name);

            loops.add(result);

            return result;
        si        

        leave_loop() is
            loops.pop();
            _next_name = null;
        si
    si
si
