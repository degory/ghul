namespace Syntax.Process.Printer is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System;

    use Trees;

    class GHUL: Base  is
        init() is
            super.init(false);
        si

        visit(variable: Variables.Variable) is
            variable.name.accept(self);
            if !isa TypeExpressions.INFER(variable.type_expression) then
                write(": ");
                variable.type_expression.accept(self);
            fi
            if variable.initializer? then
                write(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(namespace_: Definitions.NAMESPACE) is
            write("namespace ");
            namespace_.name.accept(self);
            write_line(" is");
            indent();
            namespace_.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(use_: Definitions.USE) is
            write("use ");
            var seen_any = false;
            if use_.name then
                use_.name.accept(self);
                write(" = ");
            fi

            if use_.use_ then
                use_.use_.accept(self);                
            fi

            write_line(";");
        si

        visit(class_: Definitions.CLASS) is
            write("class ");
            class_.name.accept(self);
            if class_.arguments? then
                write("[");
                class_.arguments.accept(self);
                write("]");
            fi
            if class_.ancestors? then
                write(": ");
                class_.ancestors.accept(self);
            fi
            class_.modifiers.accept(self);
            write_line(" is");
            indent();
            class_.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(trait_: Definitions.TRAIT) is
            write("trait ");
            trait_.name.accept(self);
            if trait_.arguments? then
                write("[");
                trait_.arguments.accept(self);
                write("]");
            fi
            if trait_.ancestors? then
                write(": ");
                trait_.ancestors.accept(self);
            fi
            trait_.modifiers.accept(self);
            write_line(" is");
            indent();
            trait_.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(struct_: Definitions.STRUCT) is
            write("trait ");
            struct_.name.accept(self);
            
            if struct_.arguments? then
                write("[");
                struct_.arguments.accept(self);
                write("]");
            fi

            struct_.modifiers.accept(self);
            write_line(" is");
            indent();
            struct_.body.accept(self);
            outdent();
            write_line("si");
        si        

        after_body(node: Bodies.Body) is
            if node==null || !node.is_block then
                write(";");
            fi
            write_line();
        si

        visit(function: Definitions.FUNCTION) is
            function.name.accept(self);
            write("(");
            function.arguments.accept(self);
            write(")");
            if !isa TypeExpressions.INFER(function.type_expression) then
                write(" -> ");
                function.type_expression.accept(self);
                function.modifiers.accept(self);
            elif !function.modifiers.is_empty then
                function.modifiers.accept(self);
            fi
            if function.body? then
                write(" ");
                function.body.accept(self);
            fi
            after_body(function.body);
        si

        write_member_type_and_modifiers(type_expression: TypeExpressions.TypeExpression, modifiers: Modifiers.LIST) is
            if type_expression? && !isa TypeExpressions.INFER(type_expression) then
                write(": ");
                type_expression.accept(self);
                write(" ");
                modifiers.accept(self);
            elif !modifiers.is_empty then
                modifiers.accept(self);
            fi
        si

        indent_property(has_getter: bool, has_setter: bool) -> bool is
            if has_getter && has_setter!=null then
                write_line();
                indent();
                return true;
            elif has_getter || has_setter!=null then
                write(" ");
            fi
            return false;
        si

        visit(property: Definitions.PROPERTY) is
            if property.name? then
                property.name.accept(self);
            fi
            
            write_member_type_and_modifiers(property.type_expression, property.modifiers);
            var out_again = indent_property(property.read_body?, property.assign_body?);
            if property.read_body? then
                property.read_body.accept(self);
                if property.assign_body? then
                    write_line(",");
                else
                    after_body(property.read_body);
                fi
            else
                write(" ");
            fi
            if property.assign_body? then
                write("= ");
                property.assign_argument.accept(self);
                property.assign_body.accept(self);
                after_body(property.assign_body);
            fi
            if out_again then
                outdent();
            fi
        si

        visit(indexer: Definitions.INDEXER) is
            if indexer.name? then
                indexer.name.accept(self);
            fi
            write("[");
            indexer.index_argument.accept(self);
            write("]");
            write_member_type_and_modifiers(indexer.type_expression, indexer.modifiers);
            var out_again = indent_property(indexer.read_body?, indexer.assign_body?);
            if indexer.read_body? then
                indexer.read_body.accept(self);
                if indexer.assign_body? then
                    write_line(",");
                else
                    after_body(indexer.read_body);
                fi
            else
                write(' ');
            fi
            if indexer.assign_body? then
                write("= ");
                indexer.assign_argument.accept(self);
                write(' ');
                indexer.assign_body.accept(self);
                after_body(indexer.assign_body);
            fi
            if out_again then
                outdent();
            fi
        si

        visit(generic: TypeExpressions.GENERIC) is
            generic.name.accept(self);
            write('[');
            generic.arguments.accept(self);
            write(']');
        si

        visit(function: TypeExpressions.FUNCTION) is
            write("(");
            function.arguments.accept(self);
            write(")");
            if !isa TypeExpressions.INFER(function.result) then
                write(" -> ");
                function.result.accept(self);
            fi
        si

        visit(tuple: TypeExpressions.TUPLE) is
            write("(");
            tuple.elements.accept(self);
            write(")");
        si

        visit(element: TypeExpressions.NAMED_TUPLE_ELEMENT) is
            element.name.accept(self);
            write(": ");
            element.type_expression.accept(self);
        si

        visit(null_: Expressions.NULL) is
            write("null");
        si

        visit(self_: Expressions.SELF) is
            write("self");
        si

        visit(variable: Expressions.VARIABLE) is
            variable.name.accept(self);

            if !isa TypeExpressions.INFER(variable.type_expression) then
                write(": ");
                variable.type_expression.accept(self);
            fi
            
            if variable.initializer? then
                write(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(function: Syntax.Trees.Expressions.FUNCTION) is
            function.arguments.accept(self);
            if !isa TypeExpressions.INFER(function.type_expression) then
                write(" -> ");
                function.type_expression.accept(self);
            fi
            function.body.accept(self);
        si

        visit(sequence: Expressions.SEQUENCE) is
            write('[');
            sequence.elements.accept(self);
            write(']');
            if !isa Trees.TypeExpressions.INFER(sequence.type_expression) then
                write(": ");
                sequence.type_expression.accept(self);
            fi
        si

        visit(has_value: Expressions.HAS_VALUE) is
            has_value.left.accept(self);
            write("?");
        si

        visit(has_value: Expressions.REFERENCE) is
            has_value.left.accept(self);
            write(" ref ");
        si

        visit(l: Statements.LET) is
            write("let ");
            l.variables.accept(self);
            write_line(";");
        si

        visit(for_: Statements.FOR) is
            write_line("for ");
            for_.variable.accept(self);
            write(" in ");
            for_.expression.accept(self);
            write_line(" do");
            indent();
            for_.body.accept(self);
            outdent();
            write_line("od");
        si

        visit(expression: Bodies.EXPRESSION) is
            write("=> ");
            expression.expression.accept(self);
        si

        visit(block: Bodies.BLOCK) is
            write_line("is");
            indent();
            block.statements.accept(self);
            outdent();
            write("si");
        si

        visit(innate_: Bodies.INNATE) is
            write("innate ");
            innate_.name.accept(self);
        si
    si
si
