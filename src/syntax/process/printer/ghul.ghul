namespace Syntax.Process.Printer is
    use System;

    use Tree;

    class GHUL: BASE  is
        init() is
            super.init(false);
        si

        visit(variable: Variable.NODE) is
            variable.name.accept(self);
            if !isa TypeExpression.INFER(variable.type_expression) then
                write(": ");
                variable.type_expression.accept(self);
            fi
            if variable.initializer? then
                write(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(import_: Definition.IMPORT) is
            write("import ");
            var seen_any = false;
            for i in import_.imports do
                if seen_any then
                    write(", ");
                fi
                i.accept(self);
                seen_any = true;
            od
            write_line(";");
        si

        visit(namespace_: Definition.NAMESPACE) is
            write("namespace ");
            namespace_.name.accept(self);
            write_line(" is");
            indent();
            namespace_.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(use_: Definition.USE) is
            write("use ");
            var seen_any = false;
            for u in use_.uses do
                if seen_any then
                    write(", ");
                fi
                u.accept(self);
                seen_any = true;
            od
            write_line(";");
        si

        visit(class_: Definition.CLASS) is
            write("class ");
            class_.name.accept(self);
            if class_.arguments? then
                write("[");
                class_.arguments.accept(self);
                write("]");
            fi
            if class_.ancestors? then
                write(": ");
                class_.ancestors.accept(self);
            fi
            class_.modifiers.accept(self);
            write_line(" is");
            indent();
            class_.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(trait_: Definition.TRAIT) is
            write("trait ");
            trait_.name.accept(self);
            if trait_.arguments? then
                write("[");
                trait_.arguments.accept(self);
                write("]");
            fi
            if trait_.ancestors? then
                write(": ");
                trait_.ancestors.accept(self);
            fi
            trait_.modifiers.accept(self);
            write_line(" is");
            indent();
            trait_.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(struct_: Definition.STRUCT) is
            write("trait ");
            struct_.name.accept(self);
            
            if struct_.arguments? then
                write("[");
                struct_.arguments.accept(self);
                write("]");
            fi

            struct_.modifiers.accept(self);
            write_line(" is");
            indent();
            struct_.body.accept(self);
            outdent();
            write_line("si");
        si        

        after_body(node: Body.NODE) is
            if node==null || !node.is_block then
                write(";");
            fi
            write_line();
        si

        visit(function: Definition.FUNCTION) is
            function.name.accept(self);
            write("(");
            function.arguments.accept(self);
            write(")");
            if !isa TypeExpression.INFER(function.type_expression) then
                write(" -> ");
                function.type_expression.accept(self);
                function.modifiers.accept(self);
            elif !function.modifiers.is_empty then
                function.modifiers.accept(self);
            fi
            if function.body? then
                write(" ");
                function.body.accept(self);
            fi
            after_body(function.body);
        si

        write_member_type_and_modifiers(type_expression: TypeExpression.NODE, modifiers: Modifier.LIST) is
            if type_expression? && !isa TypeExpression.INFER(type_expression) then
                write(": ");
                type_expression.accept(self);
                write(" ");
                modifiers.accept(self);
            elif !modifiers.is_empty then
                modifiers.accept(self);
            fi
        si

        indent_property(has_getter: bool, has_setter: bool) -> bool is
            if has_getter && has_setter!=null then
                write_line();
                indent();
                return true;
            elif has_getter || has_setter!=null then
                write(" ");
            fi
            return false;
        si

        visit(property: Definition.PROPERTY) is
            if property.name? then
                property.name.accept(self);
            fi
            
            write_member_type_and_modifiers(property.type_expression, property.modifiers);
            var out_again = indent_property(property.read_body?, property.assign_body?);
            if property.read_body? then
                property.read_body.accept(self);
                if property.assign_body? then
                    write_line(",");
                else
                    after_body(property.read_body);
                fi
            else
                write(" ");
            fi
            if property.assign_body? then
                write("= ");
                property.assign_argument.accept(self);
                property.assign_body.accept(self);
                after_body(property.assign_body);
            fi
            if out_again then
                outdent();
            fi
        si

        visit(indexer: Definition.INDEXER) is
            if indexer.name? then
                indexer.name.accept(self);
            fi
            write("[");
            indexer.index_argument.accept(self);
            write("]");
            write_member_type_and_modifiers(indexer.type_expression, indexer.modifiers);
            var out_again = indent_property(indexer.read_body?, indexer.assign_body?);
            if indexer.read_body? then
                indexer.read_body.accept(self);
                if indexer.assign_body? then
                    write_line(",");
                else
                    after_body(indexer.read_body);
                fi
            else
                write(' ');
            fi
            if indexer.assign_body? then
                write("= ");
                indexer.assign_argument.accept(self);
                write(' ');
                indexer.assign_body.accept(self);
                after_body(indexer.assign_body);
            fi
            if out_again then
                outdent();
            fi
        si

        visit(generic: TypeExpression.GENERIC) is
            generic.name.accept(self);
            write('[');
            generic.arguments.accept(self);
            write(']');
        si

        visit(function: TypeExpression.FUNCTION) is
            write("(");
            function.arguments.accept(self);
            write(")");
            if !isa TypeExpression.INFER(function.result) then
                write(" -> ");
                function.result.accept(self);
            fi
        si

        visit(tuple: TypeExpression.TUPLE) is
            write("(");
            tuple.elements.accept(self);
            write(")");
        si

        visit(element: TypeExpression.NAMED_TUPLE_ELEMENT) is
            element.name.accept(self);
            write(": ");
            element.type_expression.accept(self);
        si

        visit(null_: Expression.NULL) is
            write("null");
        si

        visit(self_: Expression.SELF) is
            write("self");
        si

        visit(variable: Expression.VARIABLE) is
            variable.name.accept(self);

            if !isa TypeExpression.INFER(variable.type_expression) then
                write(": ");
                variable.type_expression.accept(self);
            fi
            
            if variable.initializer? then
                write(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(function: Syntax.Tree.Expression.FUNCTION) is
            function.arguments.accept(self);
            if !isa TypeExpression.INFER(function.type_expression) then
                write(" -> ");
                function.type_expression.accept(self);
            fi
            function.body.accept(self);
        si

        visit(sequence: Expression.SEQUENCE) is
            write('[');
            sequence.elements.accept(self);
            write(']');
            if !isa Tree.TypeExpression.INFER(sequence.type_expression) then
                write(": ");
                sequence.type_expression.accept(self);
            fi
        si

        visit(has_value: Expression.HAS_VALUE) is
            has_value.left.accept(self);
            write("?");
        si

        visit(has_value: Expression.REFERENCE) is
            has_value.left.accept(self);
            write(" ref ");
        si

        visit(l: Statement.LET) is
            write("let ");
            l.variables.accept(self);
            write_line(";");
        si

        visit(for_: Statement.FOR) is
            write_line("for ");
            for_.variable.accept(self);
            write(" in ");
            for_.expression.accept(self);
            write_line(" do");
            indent();
            for_.body.accept(self);
            outdent();
            write_line("od");
        si

        visit(expression: Body.EXPRESSION) is
            write("=> ");
            expression.expression.accept(self);
        si

        visit(block: Body.BLOCK) is
            write_line("is");
            indent();
            block.statements.accept(self);
            outdent();
            write("si");
        si

        visit(innate_: Body.INNATE) is
            write("innate ");
            innate_.name.accept(self);
        si
    si
si
