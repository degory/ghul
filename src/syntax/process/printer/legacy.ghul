namespace Syntax.Process.Printer is
    use System;
    use Logging;

    use Source;
    use Tree;

    class LEGACY: BASE  is
        _logger: Logger;

        _in_trait: bool;

        _stub_depth: int;

        init(logger: Logger) is
            super.init(true);

            _logger = logger;
        si

        error(location: LOCATION, message: String) is
            _logger.error(location, message);
        si

        apply(node: NODE) is
            node.accept(self);
        si

        write(value: String) is
            if _stub_depth == 0 then
                super.write(value);
            fi
        si
        
        write(location: LOCATION, type_expression: TypeExpression.NODE) is
            if !isa TypeExpression.INFER(type_expression) then
                type_expression.accept(self);
            else
                write("void");
            fi
        si

        write_name(name: String) is
            var c = Shim.STR.get_at(name,0);

            if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' then
                write(name);
            else
                write("operator");
                write(name);
            fi
        si

        enter_stub() is
            _stub_depth = _stub_depth + 1;
        si

        leave_stub() is
            _stub_depth = _stub_depth - 1;
        si

        visit(variable: Variable.NODE) is
            if Shim.STR.starts_with(variable.name.name, "__") then
                return;
            fi
            
            if !isa TypeExpression.INFER(variable.type_expression) then
                variable.type_expression.accept(self);
                write(' ');
            else
                write("var ");
            fi
            variable.name.accept(self);
            if variable.initializer? then
                write(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(import_: Definition.IMPORT) is
            for i in import_.imports do
                write("import ");
                i.accept(self);
                write_line(";");
            od
        si

        visit(namespace_: Definition.NAMESPACE) is
            if _stub_depth > 0 then
                super.write("namespace __Dummy__ is si\n");
                return;
            fi
            
            var seen_any = false;
            for ns in namespace_.name do
                if seen_any then
                    write(' ');
                fi
                write("namespace ");
                write(ns);
                write(" is");
                seen_any = true;
            od
            write_line();
            indent();
            namespace_.body.accept(self);
            outdent();
            seen_any = false;
            for ns in namespace_.name do
                if seen_any then
                    write(' ');
                fi
                write("si");
                seen_any = true;
            od
            write_line();
        si

        visit(use_: Definition.USE) is
            for u in use_.uses do
                write("use ");
                u.accept(self);
                write_line(";");
            od
        si

        visit(class_: Definition.CLASS) is
            write("class ");

            class_.name.accept(self);

            if class_.arguments? then
                write('<');
                let first = true;
                for a in class_.arguments do
                    if !first then
                        write(",");
                    fi

                    if isa TypeExpression.NAMED_TUPLE_ELEMENT(a) then
                        let named = cast TypeExpression.NAMED_TUPLE_ELEMENT(a);

                        named.name.accept(self);
                    else
                        a.accept(self);
                    fi

                    first = false;
                od

                write('>');
            fi

            if class_.ancestors? then
                var count = 0;

                for ancestor in class_.ancestors do
                    if count == 0 then
                        write(" isa ");
                    elif count == 1 then
                        write(" do ");
                    else
                        write(", ");
                    fi
                    ancestor.accept(self);
                    count = count + 1;
                od
            fi
            write_line(" is");
            indent();

            class_.body.accept(self);
            
            outdent();
            write_line("si");
        si

        visit(trait_: Definition.TRAIT) is
            write("interface ");
            trait_.name.accept(self);

            if trait_.arguments? then
                write('<');
                trait_.arguments.accept(self);
                write('>');
            fi

            if trait_.ancestors? then
                write(" isa ");
                trait_.ancestors.accept(self);
            fi

            write_line(" is");
            indent();
            _in_trait = true;
            trait_.body.accept(self);
            _in_trait = false;
            outdent();
            write_line("si");
        si

        visit(struct_: Definition.STRUCT) is
            write("class ");

            struct_.name.accept(self);

            if struct_.arguments? then
                write('<');
                struct_.arguments.accept(self);
                write('>');
            fi

            write_line(" is");
            indent();

            struct_.body.accept(self);
            
            outdent();
            write_line("si");
        si        

        write_newline_after_body(body: Body.NODE) is
            if !body.is_block then
                write_line();
            fi
        si

        visit(function: Definition.FUNCTION) is
            if Shim.STR.starts_with(function.name.name, "__") then
                return;
            fi

            if function.modifiers? then
                function.modifiers.accept(self);
                write(' ');
            fi

            write(function.location, function.type_expression);
            write(' ');
            function.name.accept(self);
            write('(');
            function.arguments.accept(self);
            write(')');

            if function.body? then
                write(' ');
                function.body.accept(self);
                write_line();
            else
                write_line(";");
            fi
        si

        write_getter_modifiers(modifiers: Modifier.LIST, name: Identifier.NODE) is
            if modifiers.is_explicit_access then
                modifiers.access_modifier.accept(self);
                write(' ');
            elif 
                name != null && Shim.STR.starts_with(name.name, '_')
            then
                write("private ");
            fi

            if modifiers.storage_class? then
                modifiers.storage_class.accept(self);
                write(' ');
            fi
        si

        write_setter_modifiers(modifiers: Modifier.LIST) is
            if modifiers.is_explicit_access then
                modifiers.access_modifier.accept(self);
                write(' ');
            elif !_in_trait then
                write("private ");
            fi

            if modifiers.storage_class? then
                modifiers.storage_class.accept(self);
                write(' ');
            fi
        si

        write_backing_field_modifiers(modifiers: Modifier.LIST) is
            write("private ");
            if modifiers.storage_class? then
                modifiers.storage_class.accept(self);
                write(' ');
            fi
        si

        visit(property: Definition.PROPERTY) is
            if property.is_auto_property then
                write_backing_field_modifiers(property.modifiers);
                write(property.location, property.type_expression);
                write(" __backing_");
                property.name.accept(self);
                write_line(";");

                write_getter_modifiers(property.modifiers, property.name);
                write("get ");
                write(property.location, property.type_expression);
                write(" ");

                property.name.accept(self);
                write(" is return __backing_");
                property.name.accept(self);
                write_line("; si");
                write_setter_modifiers(property.modifiers);
                write("set ");
                write(property.location, property.type_expression);
                write(" ");
                property.name.accept(self);
                write(" = __value is __backing_");
                property.name.accept(self);
                write_line(" = __value; si");
            elif property.read_body? || property.assign_body? then
 
                if property.read_body? then
                    write_getter_modifiers(property.modifiers, property.name);
                    write("get ");
                    write(property.location, property.type_expression);
                    write(' ');
                    property.name.accept(self);
                    write(' ');
                    property.read_body.accept(self);
                    write_line();
                fi

                if property.assign_body? then
                    write_setter_modifiers(property.modifiers);
                    write("set ");
                    write(property.location, property.type_expression);
                    write(' ');
                    property.name.accept(self);
                    write(' ');
                    write(" = ");
                    property.assign_argument.accept(self);
                    write(' ');
                    property.assign_body.accept(self);
                    write_line();
                fi
            else
                property.modifiers.accept(self);
                write(property.location, property.type_expression);
                write(" ");
                property.name.accept(self);
                write_line(";");
            fi
        si

        visit(indexer: Definition.INDEXER) is
            if indexer.read_body!=null || indexer.assign_body!=null then
                if indexer.read_body? then
                    write_getter_modifiers(indexer.modifiers, indexer.name);
                    write("get ");
                    write(indexer.location, indexer.type_expression);
                    if indexer.name? then
                        write(' ');
                        indexer.name.accept(self);
                    fi
                    write("[");
                    indexer.index_argument.accept(self);
                    write("]");
                    indexer.read_body.accept(self);
                    write_line();
                fi

                if indexer.assign_body? then
                    write_setter_modifiers(indexer.modifiers);
                    write("set ");
                    write(indexer.location, indexer.type_expression);
                    if indexer.name? then
                        write(' ');
                        indexer.name.accept(self);
                    fi
                    write("[");
                    indexer.index_argument.accept(self);
                    write("] =");
                    indexer.assign_argument.accept(self);
                    write(" ");
                    indexer.assign_body.accept(self);
                    write_line();
                fi
            else
                error(indexer.location, "indexer must have at at least read or assign body");
            fi
        si

        visit(pragma_: Definition.PRAGMA) is
            process_pragma(pragma_.pragma_, true);

            pragma_.definition.accept(self);

            process_pragma(pragma_.pragma_, false);
        si

        process_pragma(pragma_: Pragma.NODE, is_enter: bool) is
            if !pragma_? then
                System.Console.error.write_line("pragma is null");
                return;
            fi

            let name = Shim.STR.format(pragma_.name);

            if name =~ "IL.stub" then
                if is_enter then
                    enter_stub();
                else
                    leave_stub();
                fi
            fi            
        si

        visit(type_expression: TypeExpression.BUILT_IN) is
            write(type_expression.name);
        si

        visit(array: TypeExpression.ARRAY_) is
            array.element.accept(self);
            write("[]");
        si

        visit(pointer: TypeExpression.POINTER) is
            pointer.element.accept(self);
            write(" ptr");
        si

        visit(reference: TypeExpression.REFERENCE) is
            reference.element.accept(self);
            write(" ref");
        si

        visit(named: TypeExpression.NAMED) is
            named.name.accept(self);
        si

        visit(generic: TypeExpression.GENERIC) is
            generic.name.accept(self);
            write('<');
            generic.arguments.accept(self);
            write('>');
        si

        visit(function: TypeExpression.FUNCTION) is
            write(function.location, function.result);
            write(" proc(");
            function.arguments.accept(self);
            write(")");
        si

        visit(tuple: TypeExpression.TUPLE) is
            write("(");
            tuple.elements.accept(self);
            write(")");
        si

        visit(types: TypeExpression.LIST) is
            var seen_any = false;
            for t in types do
                if seen_any then
                    write(',');
                fi
                t.accept(self);
                seen_any = true;
            od
        si

        visit(null_: Expression.NULL) is
            write("null");
        si

        visit(self_: Expression.SELF) is
            write("this");
        si

        visit(new_: Expression.NEW) is
            location(new_);
            write("new ");

            if isa Tree.TypeExpression.ARRAY_(new_.type_expression) then
                cast Tree.TypeExpression.ARRAY_(new_.type_expression).element.accept(self);
                write('[');
                new_.arguments.accept(self);
                write(']');
            else
                new_.type_expression.accept(self);
                write('(');
                new_.arguments.accept(self);
                write(')');
            fi
        si

        visit(unary: Expression.UNARY) is
            location(unary);
            write(unary.operation.name);
            write(' ');
            unary.right.accept(self);
        si

        visit(binary: Expression.BINARY) is
            location(binary);
            binary.left.accept(self);
            write(' ');
            write(binary.actual_operation);
            write(' ');
            binary.right.accept(self);
        si

        visit(variable: Expression.VARIABLE) is
            if !isa TypeExpression.INFER(variable.type_expression) then
                variable.type_expression.accept(self);
                write(' ');
            else
                _logger.error(variable.location, "legacy compiler cannot infer type_expression here");
            fi

            variable.name.accept(self);

            if variable.initializer? then
                write(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(function: Syntax.Tree.Expression.FUNCTION) is
            write(function.location, function.type_expression);
            write(" proc");
            function.arguments.accept(self);

            if function.uses? then
                write(" use ");
                var seen_any = false;
                for u in function.uses do
                    if seen_any then
                        write(",");
                    fi
                    u.accept(self);
                od
            fi

            write(" ");
            function.body.accept(self);
        si

        visit(sequence: Expression.SEQUENCE) is
            if !isa Tree.TypeExpression.INFER(sequence.type_expression) then
                sequence.type_expression.accept(self);
            fi
            
            write('{');
            sequence.elements.accept(self);
            write('}');
        si

        visit(has_value: Expression.HAS_VALUE) is
            write("((");
            has_value.left.accept(self);
            write(")!=null)");
        si

        visit(l: Statement.LET) is
            l.variables.accept(self);
            write_line(";");
        si

        visit(match: Statement.CASE_MATCH) is
            if match.expressions? then
                write("is ");
                match.expressions.accept(self);
                write_line(":");
            else
                write_line("default:");
            fi
            
            indent();
            match.statements.accept(self);
            outdent();
        si

        visit(for_: Statement.FOR) is
            write("foreach ");
            for_.variable.accept(self);
            write("; ");
            for_.expression.accept(self);
            write_line(" do");
            indent();
            for_.body.accept(self);
            outdent();
            write_line("od");
        si

        visit(t: Statement.ASSERT) is
            location(t);
            write("if !(");
            if t.expression? then
                t.expression.accept(self);
            else
                write("true");
            fi

            write_line(") then");
            indent();

            if !t.message? || t.needs_exception_wrapper then
                let message: String = "" + t.location + ": ";

                if !t.message? then
                    message = message + t.expression;
                fi                

                write("var message = ");

                write(cast char(34));
                for c in message do
                    write_escape_char(c);
                od

                write(cast char(34));

                if t.message? then
                    write(" + (");
                    write(t.message);
                    write(")");
                fi

                write_line(";");

                write_line("var exception = new System.Exception(message);");
            else
                write_line("var exception = " + t.message + ";");
            fi

            write_line("throw exception;");

            outdent();
            
            write_line("fi");
        si

        visit(expression: Body.EXPRESSION) is
            write(" is return ");
            expression.expression.accept(self);
            write("; si");
        si

        visit(block: Body.BLOCK) is
            write_line("is");
            indent();
            block.statements.accept(self);
            outdent();
            write("si");
        si
    si
si
