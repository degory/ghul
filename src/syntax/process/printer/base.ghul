namespace Syntax.Process.Printer is
    use System;
    use Tree;
    use Source;

    class BASE : StrictVisitor  is
        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;
        _want_locations: bool;
        _current_line: int;
        _result: System.Text.StringBuilder;
        
        init(want_locations: bool) is
            super.init();

            _want_locations = want_locations;
            _depth = 0;
            _indent = 2;
            _result = new System.Text.StringBuilder();
            _current_line = 1;
        si

        result: String is
            return _result.to_string();
        si

        write_line(string: String) is
            write(string);
            write_line();
        si

        write(string: String) is
            write_indent();
            _result.append(string);
        si

        write(c: char) is
            write_indent();
            _result.append(c);
        si

        write_line() is
            _current_line = _current_line + 1;
            _indent_needed = true;
            _result.append('\n');
        si

        indent() is
            _depth = _depth + 1;
        si

        outdent() is
            _depth = _depth - 1;
        si

        write_indent() is
            if _indent_needed then
                var i = 0;
                while i < _indent*_depth do
                    _result.append(' ');
                    i = i + 1;
                od
                _indent_needed = false;
            fi
        si

        location(node: NODE) is
            location(node.location);
        si

        location(location: LOCATION) is
            var new_line = location.start_line;
            if new_line != _current_line then
                _current_line = new_line;
                if _want_locations then
                    write("#" + _current_line + " ");
                fi
            fi
        si

        write(node: NODE) is
            node.accept(self);
        si

        write_name(name: String) is
            write(name);
        si

        visit(identifier: Identifier.NODE) is
            location(identifier);
            write_name(identifier.name);
        si

        visit(identifier: Identifier.QUALIFIED) is
            location(identifier);
            identifier.qualifier.accept(self);
            write('.');
            write_name(identifier.name);
        si

        visit(modifier: Modifier.NODE) is
            location(modifier);
            write(modifier.name);
        si

        visit(modifiers: Modifier.LIST) is
            location(modifiers);
            if modifiers.access_modifier? then
                modifiers.access_modifier.accept(self);
                write(' ');
            fi
            if modifiers.storage_class? then
                modifiers.storage_class.accept(self);
                write(' ');
            fi
        si

        visit(variables: Variable.LIST) is
            location(variables);
            var first = true;
            for v in variables do
                if !first then
                    write(", ");
                fi
                v.accept(self);
                first = false;
            od
        si

        visit(definitions: Definition.LIST) is
            location(definitions);
            for d in definitions do
                d.accept(self);

                // yuck...
                if isa Variable.NODE(d) then
                    if !Shim.STR.starts_with(cast Variable.NODE(d).name.name, "__") then
                        write_line(";");
                    fi
                fi
            od
        si

        visit(enum_: Definition.ENUM) is
            location(enum_);
            write("enum ");
            enum_.name.accept(self);
            write_line(" is");
            indent();
            var seen_any = false;
            for member in enum_.members do
                if seen_any then
                    write_line(",");
                fi
                member.accept(self);
                seen_any = true;
            od
            write_line();
            outdent();
            write_line("si");
        si

        visit(member: Definition.ENUM_MEMBER) is
            location(member);
            member.name.accept(self);
            if member.initializer? then
                write(" = ");
                member.initializer.accept(self);
            fi
        si

        visit(functions: Definition.FUNCTION_GROUP) is
            write_line("function group ");
            indent();
            for f in functions.functions do
                f.accept(self);
            od
            outdent();
        si
        
        visit(pragma_: Definition.PRAGMA) is
            pragma_.definition.accept(self);
        si

        visit(type_expression: TypeExpression.INFER) is
            write("infer");
        si

        visit(type_expression: TypeExpression.BUILT_IN) is
            write(type_expression.name);
        si

        visit(array: TypeExpression.ARRAY_) is
            array.element.accept(self);
            write("[]");
        si

        visit(pointer: TypeExpression.POINTER) is
            pointer.element.accept(self);
            write(" ptr");
        si

        visit(reference: TypeExpression.REFERENCE) is
            reference.element.accept(self);
            write(" ref");
        si

        visit(functions: TypeExpression.FUNCTION_GROUP) is
            write("function group ");
            for f in functions.functions do
                f.accept(self);
                write(' ');
            od
        si

        visit(named: TypeExpression.NAMED) is
            location(named);
            named.name.accept(self);
        si

        visit(tuple: TypeExpression.TUPLE) is
            location(tuple);
            write("(");
            tuple.elements.accept(self);
            write(")");
        si

        visit(element: TypeExpression.NAMED_TUPLE_ELEMENT) is
            location(element);
            element.name.accept(self);
            write(": ");
            element.type_expression.accept(self);
        si

        visit(types: TypeExpression.LIST) is
            location(types);
            var seen_any = false;
            for t in types do
                if seen_any then
                    write(',');
                fi
                t.accept(self);
                seen_any = true;
            od
        si

        visit(none_: Expression.Literal.NONE) is
            location(none_);
            write("none");
        si

        visit(identifier: Expression.IDENTIFIER) is
            location(identifier);
            identifier.identifier.accept(self);
        si

        visit(super_: Expression.SUPER) is
            location(super_);
            write("super");
        si

        visit(native_: Expression.NATIVE) is
            location(native_);
            write("native");
        si        

        visit(new_: Expression.NEW) is
            location(new_);
            write("new ");
            new_.type_expression.accept(self);
            write('(');
            new_.arguments.accept(self);
            write(')');
        si

        visit(cast_: Expression.CAST) is
            location(cast_);
            write("cast ");
            cast_.type_expression.accept(self);
            write('(');
            cast_.right.accept(self);
            write(')');
        si

        visit(isa_: Expression.ISA) is
            location(isa_);
            write("isa ");
            isa_.type_expression.accept(self);
            write('(');
            isa_.right.accept(self);
            write(')');
        si

        visit(tuple: Expression.TUPLE) is
            location(tuple);
            write('(');
            tuple.elements.accept(self);
            write(')');
        si

        visit(call: Expression.CALL) is
            location(call);
            call.function.accept(self);
            write('(');
            call.arguments.accept(self);
            write(')');
        si

        visit(member: Expression.MEMBER) is
            location(member);
            member.left.accept(self);
            write('.');
            member.identifier.accept(self);
        si

        visit(index: Expression.INDEX) is
            location(index);
            index.left.accept(self);
            write('[');
            index.index.accept(self);
            write(']');
        si

        visit(unary: Expression.UNARY) is
            location(unary);
            unary.operation.accept(self);
            write(' ');
            unary.right.accept(self);
        si

        visit(binary: Expression.BINARY) is
            location(binary);
            binary.left.accept(self);
            write(' ');
            binary.operation.accept(self);
            write(' ');
            binary.right.accept(self);
        si

        visit(expressions: Expression.LIST) is
            location(expressions);
            var seen_any = false;
            for e in expressions do
                if seen_any then
                    write(',');
                fi
                e.accept(self);
                seen_any = true;
            od
        si

        visit(literal: Expression.Literal.NODE) is
            location(literal);
            write(literal.string);
        si

        @IF.legacy()
        write_escape_char(c: char) is
            var ci = cast int(c);
            if ci < 32 then
                write("\\");
                var b = new StringBuffer(5);
                b.append(ci & 0xFF, 8);
                write(b);
            elif ci == 34 then
                write("\\");
                write(cast char(34));
            elif ci == 39 then
                write("'");
            elif ci == 92 then
                write("\\\\");
            else
                write(c);
            fi
        si

        @IF.dotnet()
        write_escape_char(c: char) is
            var ci = cast int(c);
            if ci < 32 then
                write("\\" + System.String.format("X", ci));
            elif ci == 34 then
                write("\\");
                write(cast char(34));
            elif ci == 39 then
                write("'");
            elif ci == 92 then
                write("\\\\");
            else
                write(c);
            fi
        si

        visit(string: Expression.Literal.STRING) is
            location(string);
            write(cast char(34));
            for c in string.string do
                write_escape_char(c);
            od
            write(cast char(34));
        si

        visit(integer: Expression.Literal.INTEGER) is
            location(integer);
            write(integer.string);
        si        

        visit(character: Expression.Literal.CHARACTER) is
            location(character);
            write("'");
            write_escape_char(Shim.STR.get_at(character.string, 0));
            write("'");
        si

        visit(boolean: Expression.Literal.BOOLEAN) is
            location(boolean);
            write(boolean.string);
        si

        visit(list: Statement.LIST) is
            location(list);
            for s in list do
                s.accept(self);
            od
        si

        visit(assign: Statement.ASSIGNMENT) is
            location(assign);
            assign.left.accept(self);
            write(" = ");
            assign.right.accept(self);
            write_line(";");
        si

        visit(expression: Statement.EXPRESSION) is
            location(expression);
            expression.expression.accept(self);
            write_line(";");
        si

        visit(v: Statement.VAR) is
            location(v);
            v.variables.accept(self);
            write_line(";");
        si

        visit(r: Statement.RETURN) is
            location(r);
            write("return");
            if r.expression? then
                write(' ');
                r.expression.accept(self);
            fi
            write_line(";");
        si

        visit(t: Statement.THROW) is
            location(t);
            write("throw");
            if t.expression? then
                write(' ');
                t.expression.accept(self);
            fi
            write_line(";");
        si

        visit(t: Statement.ASSERT) is
            location(t);
            write("assert");
            if t.expression? then
                write(' ');
                t.expression.accept(self);
            fi

            if t.message? then
                write(" else ");
                t.message.accept(self);
            fi

            write_line(";");
        si

        visit(i: Statement.IF) is
            location(i);
            var is_first = true;
            var seen_else = false;            
            assert(i?);
            assert(i.branches?);
            for b in i.branches do
                location(b);

                if seen_else then
                    IoC.CONTAINER.instance.logger.error(b.location, "broken if statement");
                fi

                assert(!seen_else);
                if b.condition? then
                    if is_first then
                        write("if ");
                    else
                        write("elif ");
                    fi
                    b.condition.accept(self);
                    write_line(" then");
                else
                    seen_else = true;
                    write_line("else");
                fi
                indent();
                b.body.accept(self);
                outdent();
                is_first = false;
            od
            write_line("fi");
        si

        visit(case_: Statement.CASE) is
            location(case_);
            write("case ");
            case_.expression.accept(self);
            write_line();
            for m in case_.matches do
                m.accept(self);
            od
            write_line("esac");
        si

        visit(match: Statement.CASE_MATCH) is
            location(match);
            if match.expressions? then
                write("when ");
                match.expressions.accept(self);
                write_line(":");
            else
                write_line("default");
            fi
            indent();
            match.statements.accept(self);
            outdent();
        si

        visit(try_: Statement.TRY) is
            location(try_);
            write_line("try");
            indent();
            try_.body.accept(self);
            outdent();
            for c in try_.catches do
                c.accept(self);
            od
            if try_.finally_? then
                write_line("finally");
                indent();
                try_.finally_.accept(self);
                outdent();
            fi
            write_line("yrt");
        si

        visit(catch_: Statement.CATCH) is
            location(catch_);
            write("catch ");
            catch_.variable.accept(self);
            write_line();
            indent();
            catch_.body.accept(self);
            outdent();
        si

        visit(do_: Statement.DO) is
            location(do_);
            if do_.condition? then
                write("while ");
                do_.condition.accept(self);
                write(" ");
            fi
            write_line("do");
            indent();
            do_.body.accept(self);
            outdent();
            write_line("od");
        si

        visit(labelled: Statement.LABELLED) is
            location(labelled);
            labelled.label.accept(self);
            write(": ");
            labelled.statement.accept(self);
        si

        visit(break_: Statement.BREAK) is
            location(break_);
            write("break");
            if break_.label? then
                write(' ');
                break_.label.accept(self);
            fi
            write_line(";");
        si

        visit(continue_: Statement.CONTINUE) is
            location(continue_);
            write("continue");
            if continue_.label? then
                write(' ');
                continue_.label.accept(self);
            fi
            write_line(";");
        si

        visit(pragma_: Statement.PRAGMA) is
            if pragma_.statement? then
                pragma_.statement.accept(self);                
            fi
        si

        visit(block: Body.NULL) is
            write_line(";");
        si       
    si
si
