namespace Syntax.Process.Printer is
    use IO.Std;

    use Trees;
    use Source;

    class Base : StrictVisitor  is
        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;
        _want_locations: bool;
        _current_line: int;
        _result: System.Text.StringBuilder;
        
        init(want_locations: bool) is
            super.init();

            _want_locations = want_locations;
            _depth = 0;
            _indent = 2;
            _result = new System.Text.StringBuilder();
            _current_line = 1;
        si

        result: string is
            return _result.to_string();
        si

        write_line(value: string) is
            write(value);
            write_line();
        si

        write(value: string) is
            write_indent();
            _result.append(value);
        si

        write(c: char) is
            write_indent();
            _result.append(c);
        si

        write_line() is
            _current_line = _current_line + 1;
            _indent_needed = true;
            _result.append('\n');
        si

        indent() is
            _depth = _depth + 1;
        si

        outdent() is
            _depth = _depth - 1;
        si

        write_indent() is
            if _indent_needed then
                var i = 0;
                while i < _indent*_depth do
                    _result.append(' ');
                    i = i + 1;
                od
                _indent_needed = false;
            fi
        si

        location(node: Node) is
            location(node.location);
        si

        location(location: LOCATION) is
            var new_line = location.start_line;
            if new_line != _current_line then
                _current_line = new_line;
                if _want_locations then
                    write("#" + _current_line + " ");
                fi
            fi
        si

        write(node: Node) is
            node.accept(self);
        si

        write_name(name: string) is
            write(name);
        si

        visit(identifier: Identifiers.Identifier) is
            location(identifier);
            write_name(identifier.name);
        si

        visit(identifier: Identifiers.QUALIFIED) is
            location(identifier);
            identifier.qualifier.accept(self);
            write('.');
            write_name(identifier.name);
        si

        visit(modifier: Modifiers.Modifier) is
            location(modifier);
            write(modifier.name);
        si

        visit(modifiers: Modifiers.LIST) is
            location(modifiers);
            if modifiers.access_modifier? then
                modifiers.access_modifier.accept(self);
                write(' ');
            fi
            if modifiers.storage_class? then
                modifiers.storage_class.accept(self);
                write(' ');
            fi
        si

        visit(variables: Variables.LIST) is
            location(variables);
            var first = true;
            for v in variables do
                if !first then
                    write(", ");
                fi
                v.accept(self);
                first = false;
            od
        si

        visit(definitions: Definitions.LIST) is
            location(definitions);
            for d in definitions do
                d.accept(self);

                // yuck...
                if isa Variables.Variable(d) then
                    if !cast Variables.Variable(d).name.name.starts_with("$") then
                        write_line(";");
                    fi
                fi
            od
        si

        visit(enum_: Definitions.ENUM) is
            location(enum_);
            write("enum ");
            enum_.name.accept(self);
            write_line(" is");
            indent();
            var seen_any = false;
            for member in enum_.members do
                if seen_any then
                    write_line(",");
                fi
                member.accept(self);
                seen_any = true;
            od
            write_line();
            outdent();
            write_line("si");
        si

        visit(member: Definitions.ENUM_MEMBER) is
            location(member);
            member.name.accept(self);
            if member.initializer? then
                write(" = ");
                member.initializer.accept(self);
            fi
        si

        visit(functions: Definitions.FUNCTION_GROUP) is
            write_line("function group ");
            indent();
            for f in functions.functions do
                f.accept(self);
            od
            outdent();
        si
        
        visit(pragma_: Pragmas.PRAGMA) is
            write("@");

            pragma_.name.accept(self);
            write("(");

            pragma_.arguments.accept(self);
            write_line(")");
        si

        visit(pragma_: Definitions.PRAGMA) is
            pragma_.definition.accept(self);
        si

        visit(type_expression: TypeExpressions.INFER) is
            write("infer");
        si

        visit(type_expression: TypeExpressions.BUILT_IN) is
            write(type_expression.name);
        si

        visit(array: TypeExpressions.ARRAY_) is
            array.element.accept(self);
            write("[]");
        si

        visit(pointer: TypeExpressions.POINTER) is
            pointer.element.accept(self);
            write(" ptr");
        si

        visit(reference: TypeExpressions.REFERENCE) is
            reference.element.accept(self);
            write(" ref");
        si

        visit(functions: TypeExpressions.FUNCTION_GROUP) is
            write("function group ");
            for f in functions.functions do
                f.accept(self);
                write(' ');
            od
        si

        visit(named: TypeExpressions.NAMED) is
            location(named);
            named.name.accept(self);
        si

        visit(tuple: TypeExpressions.TUPLE) is
            location(tuple);
            write("(");
            tuple.elements.accept(self);
            write(")");
        si

        visit(element: TypeExpressions.NAMED_TUPLE_ELEMENT) is
            location(element);
            element.name.accept(self);
            write(": ");
            element.type_expression.accept(self);
        si

        visit(types: TypeExpressions.LIST) is
            location(types);
            var seen_any = false;
            for t in types do
                if seen_any then
                    write(',');
                fi
                t.accept(self);
                seen_any = true;
            od
        si

        visit(none_: Expressions.Literals.NONE) is
            location(none_);
            write("none");
        si

        visit(identifier: Expressions.IDENTIFIER) is
            location(identifier);
            identifier.identifier.accept(self);
        si

        visit(super_: Expressions.SUPER) is
            location(super_);
            write("super");
        si

        visit(new_: Expressions.NEW) is
            location(new_);
            write("new ");
            new_.type_expression.accept(self);
            write('(');
            new_.arguments.accept(self);
            write(')');
        si

        visit(cast_: Expressions.CAST) is
            location(cast_);
            write("cast ");
            cast_.type_expression.accept(self);
            write('(');
            cast_.right.accept(self);
            write(')');
        si

        visit(isa_: Expressions.ISA) is
            location(isa_);
            write("isa ");
            isa_.type_expression.accept(self);
            write('(');
            isa_.right.accept(self);
            write(')');
        si

        visit(typeof_: Expressions.TYPEOF) is
            location(typeof_);
            write("typeof ");
            typeof_.type_expression.accept(self);
        si

        visit(tuple: Expressions.TUPLE) is
            location(tuple);
            write('(');
            tuple.elements.accept(self);
            write(')');
        si

        visit(call: Expressions.CALL) is
            location(call);
            call.function.accept(self);
            write('(');
            call.arguments.accept(self);
            write(')');
        si

        visit(member: Expressions.MEMBER) is
            location(member);
            member.left.accept(self);
            write('.');
            member.identifier.accept(self);
        si

        visit(index: Expressions.INDEX) is
            location(index);
            index.left.accept(self);
            write('[');
            index.index.accept(self);
            write(']');
        si

        visit(unary: Expressions.UNARY) is
            location(unary);
            unary.operation.accept(self);
            write(' ');
            unary.right.accept(self);
        si

        visit(binary: Expressions.BINARY) is
            location(binary);
            binary.left.accept(self);
            write(' ');
            binary.operation.accept(self);
            write(' ');
            binary.right.accept(self);
        si

        visit(expressions: Expressions.LIST) is
            location(expressions);
            var seen_any = false;
            for e in expressions do
                if seen_any then
                    write(',');
                fi
                e.accept(self);
                seen_any = true;
            od
        si

        visit(literal: Expressions.Literals.Literal) is
            location(literal);
            write(literal.value_string);
        si

        write_escape_char(c: char) is
            var ci = cast int(c);
            if ci < 32 then
                write("\\" + string.format("X", ci));
            elif ci == 34 then
                write("\\");
                write(cast char(34));
            elif ci == 39 then
                write("'");
            elif ci == 92 then
                write("\\\\");
            else
                write(c);
            fi
        si

        visit(string_: Expressions.Literals.STRING) is
            location(string_);
            write(cast char(34));
            for c in string_.value_string do
                write_escape_char(c);
            od
            write(cast char(34));
        si

        visit(integer: Expressions.Literals.INTEGER) is
            location(integer);
            write(integer.value_string);
        si        

        visit(float: Expressions.Literals.FLOAT) is
            location(float);
            write(float.value_string);
        si

        visit(character: Expressions.Literals.CHARACTER) is
            location(character);
            write("'");
            write_escape_char(character.value_string.get_chars(0));
            write("'");
        si

        visit(boolean: Expressions.Literals.BOOLEAN) is
            location(boolean);
            write(boolean.value_string);
        si

        visit(list: Statements.LIST) is
            location(list);
            for s in list do
                s.accept(self);
            od
        si

        visit(assign: Statements.ASSIGNMENT) is
            location(assign);
            assign.left.accept(self);
            write(" = ");
            assign.right.accept(self);
            write_line(";");
        si

        visit(expression: Statements.EXPRESSION) is
            location(expression);
            expression.expression.accept(self);
            write_line(";");
        si

        visit(v: Statements.VAR) is
            location(v);
            v.variables.accept(self);
            write_line(";");
        si

        visit(r: Statements.RETURN) is
            location(r);
            write("return");
            if r.expression? then
                write(' ');
                r.expression.accept(self);
            fi
            write_line(";");
        si

        visit(t: Statements.THROW) is
            location(t);
            write("throw");
            if t.expression? then
                write(' ');
                t.expression.accept(self);
            fi
            write_line(";");
        si

        visit(t: Statements.ASSERT) is
            location(t);
            write("assert");
            if t.expression? then
                write(' ');
                t.expression.accept(self);
            fi

            if t.message? then
                write(" else ");
                t.message.accept(self);
            fi

            write_line(";");
        si

        visit(i: Statements.IF) is
            location(i);
            var is_first = true;
            var seen_else = false;

            assert i?;
            assert i.branches?;

            for b in i.branches do
                location(b);

                if seen_else then
                    IoC.CONTAINER.instance.logger.error(b.location, "broken if statement");
                fi

                assert !seen_else;
                
                if b.condition? then
                    if is_first then
                        write("if ");
                    else
                        write("elif ");
                    fi
                    b.condition.accept(self);
                    write_line(" then");
                else
                    seen_else = true;
                    write_line("else");
                fi
                indent();
                b.body.accept(self);
                outdent();
                is_first = false;
            od
            write_line("fi");
        si

        visit(case_: Statements.CASE) is
            location(case_);
            write("case ");
            case_.expression.accept(self);
            write_line();
            for m in case_.matches do
                m.accept(self);
            od
            write_line("esac");
        si

        visit(match: Statements.CASE_MATCH) is
            location(match);
            if match.expressions? then
                write("when ");
                match.expressions.accept(self);
                write_line(":");
            else
                write_line("default");
            fi
            indent();
            match.statements.accept(self);
            outdent();
        si

        visit(try_: Statements.TRY) is
            location(try_);
            write_line("try");
            indent();
            try_.body.accept(self);
            outdent();
            for c in try_.catches do
                c.accept(self);
            od
            if try_.finally_? then
                write_line("finally");
                indent();
                try_.finally_.accept(self);
                outdent();
            fi
            write_line("yrt");
        si

        visit(catch_: Statements.CATCH) is
            location(catch_);
            write("catch ");
            catch_.variable.accept(self);
            write_line();
            indent();
            catch_.body.accept(self);
            outdent();
        si

        visit(do_: Statements.DO) is
            location(do_);
            if do_.condition? then
                write("while ");
                do_.condition.accept(self);
                write(" ");
            fi
            write_line("do");
            indent();
            do_.body.accept(self);
            outdent();
            write_line("od");
        si

        visit(labelled: Statements.LABELLED) is
            location(labelled);
            labelled.label.accept(self);
            write(": ");
            labelled.statement.accept(self);
        si

        visit(break_: Statements.BREAK) is
            location(break_);
            write("break");
            if break_.label? then
                write(' ');
                break_.label.accept(self);
            fi
            write_line(";");
        si

        visit(continue_: Statements.CONTINUE) is
            location(continue_);
            write("continue");
            if continue_.label? then
                write(' ');
                continue_.label.accept(self);
            fi
            write_line(";");
        si

        visit(pragma_: Statements.PRAGMA) is
            if pragma_.statement? then
                pragma_.statement.accept(self);                
            fi
        si

        visit(block: Bodies.NULL) is
            write_line(";");
        si       
    si
si
