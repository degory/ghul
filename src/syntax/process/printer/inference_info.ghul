namespace Syntax.Process.Printer is
    use IO.Std;

    use Logging;
    use Trees;

    class INFERENCE_INFO: ScopedVisitor is
        _indent: int;
        _depth: int;
        _run_on: bool;
        _indent_needed: bool;
        _want_locations: bool;
        _current_line: int;
        _result: System.Text.StringBuilder;
        
        init(
            logger: Logger,
            stable_symbols: Semantic.STABLE_SYMBOLS,            
            symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: Semantic.NAMESPACES
        ) is
            super.init(logger, stable_symbols, symbol_table, namespaces);

            _depth = 0;
            _indent = 2;
            _result = System.Text.StringBuilder();
            _current_line = 1;
        si

        result: string is
            return _result.to_string();
        si

        write_line(value: string) is
            write(value);
            write_line();
        si

        write(value: string) is
            write_indent();
            _result.append(value);
        si

        write(c: char) is
            write_indent();
            _result.append(c);
        si

        write_line() is
            _current_line = _current_line + 1;
            _indent_needed = true;
            _result.append('\n');
        si

        indent() is
            _depth = _depth + 1;
        si

        outdent() is
            _depth = _depth - 1;
        si

        write_indent() is
            if _indent_needed then
                let i = 0;
                while i < _indent * _depth do
                    _result.append(' ');
                    i = i + 1;
                od
                _indent_needed = false;
            fi
        si

        print(node: Node) -> string is
            node.accept(self);

            let result = _result.to_string();

            _result.clear();

            return result;
        si

        write_constraint(node: TypeConstrained) is
            if node.constraint? then
                write(" {{{node.constraint}}}");
            fi
        si

        visit(identifier: Identifiers.Identifier) is
            write(identifier.name);
        si

        visit(identifier: Identifiers.QUALIFIED) is
            identifier.qualifier.accept(self);
            write('.');
            write(identifier.name);
        si

        visit(modifier: Modifiers.Modifier) is
            write(modifier.name);
        si

        visit(modifiers: Modifiers.LIST) is
            if modifiers.access_modifier? then
                modifiers.access_modifier.accept(self);
                write(' ');
            fi
            if modifiers.storage_class? then
                modifiers.storage_class.accept(self);
                write(' ');
            fi
        si

        visit(variables: Variables.LIST) is
            let first = true;
            for v in variables do
                if !first then
                    write(", ");
                fi
                v.accept(self);
                first = false;
            od
        si

        visit(definitions: Definitions.LIST) is
            for d in definitions do
                d.accept(self);

                // yuck...
                if isa Variables.VARIABLE(d) then
                    let variable = cast Variables.VARIABLE(d);
                    if variable.name? /\ variable.name.name? /\ variable.name.name.starts_with("$") then
                        write_line(";");
                    fi
                fi
            od
        si

        visit(`enum: Definitions.ENUM) is
            write("enum ");
            `enum.name.accept(self);
            write_line(" is");
            indent();
            let seen_any = false;
            for member in `enum.members do
                if seen_any then
                    write_line(",");
                fi
                member.accept(self);
                seen_any = true;
            od
            write_line();
            outdent();
            write_line("si");
        si

        visit(member: Definitions.ENUM_MEMBER) is
            member.name.accept(self);
            if member.initializer? then
                write(" = ");
                member.initializer.accept(self);
            fi
        si

        visit(functions: Definitions.FUNCTION_GROUP) is
            write_line("function group ");
            indent();
            for f in functions.functions do
                f.accept(self);
            od
            outdent();
        si
        
        visit(pragma: Pragmas.PRAGMA) is
            write("@");

            pragma.name.accept(self);
            write("(");

            pragma.arguments.accept(self);
            write_line(")");
        si

        visit(pragma: Definitions.PRAGMA) is
            pragma.definition.accept(self);
        si

        visit(type_expression: TypeExpressions.UNDEFINED) is
            write("???");
        si

        visit(type_expression: TypeExpressions.INFER) is
            write("infer");
        si

        visit(array: TypeExpressions.ARRAY_) is
            array.element.accept(self);
            write("[]");
        si

        visit(pointer: TypeExpressions.POINTER) is
            pointer.element.accept(self);
            write(" ptr");
        si

        visit(reference: TypeExpressions.REFERENCE) is
            reference.element.accept(self);
            write(" ref");
        si

        pre(member: TypeExpressions.MEMBER) -> bool is
            return true;
        si

        visit(member: TypeExpressions.MEMBER) is
            member.left.walk(self);
            write('.');
            member.name.walk(self);
        si

        visit(functions: TypeExpressions.FUNCTION_GROUP) is
            write("function group ");
            for f in functions.functions do
                f.accept(self);
                write(' ');
            od
        si

        visit(named: TypeExpressions.NAMED) is
            named.name.accept(self);
        si

        visit(types: TypeExpressions.LIST) is
            let seen_any = false;
            for t in types do
                if seen_any then
                    write(',');
                fi
                t.accept(self);
                seen_any = true;
            od
        si

        visit(`none: Expressions.Literals.NONE) is
            write("none");
        si

        visit(identifier: Expressions.IDENTIFIER) is
            identifier.identifier.accept(self);
            write_constraint(identifier);
        si

        visit(`super: Expressions.SUPER) is
            write("super");
        si

        visit(`new: Expressions.NEW) is
            write("");
            `new.type_expression.accept(self);
            write('(');
            `new.arguments.accept(self);
            write(')');
            write_constraint(`new);
        si

        visit(`cast: Expressions.CAST) is
            write("cast ");
            `cast.type_expression.accept(self);
            write('(');
            `cast.right.accept(self);
            write(')');
            write_constraint(`cast);
        si

        visit(`isa: Expressions.ISA) is
            write("isa ");
            `isa.type_expression.accept(self);
            write('(');
            `isa.right.accept(self);
            write(')');
        si

        visit(`typeof: Expressions.TYPEOF) is
            write("typeof ");
            `typeof.type_expression.accept(self);
        si

        visit(tuple: Expressions.TUPLE) is
            write('(');
            tuple.elements.accept(self);
            write(')');
            write_constraint(tuple);
        si

        visit(call: Expressions.CALL) is
            call.function.accept(self);
            write('(');
            call.arguments.accept(self);
            write(')');
            write_constraint(call)
        si

        visit(member: Expressions.MEMBER) is
            member.left.accept(self);
            write('.');
            if member.identifier? then
                member.identifier.accept(self);
            fi
            write_constraint(member);
        si

        visit(explicit_specialization: Trees.Expressions.EXPLICIT_SPECIALIZATION) is
            explicit_specialization.left.accept(self);
            write("`[");
            explicit_specialization.types.accept(self);
            write("]");
        si

        visit(index: Expressions.INDEX) is
            index.left.accept(self);
            write('[');
            index.index.accept(self);
            write(']');
            write_constraint(index)
        si

        visit(unary: Expressions.UNARY) is
            unary.operation.accept(self);
            write(' ');
            unary.right.accept(self);
            write_constraint(unary)
        si

        visit(binary: Expressions.BINARY) is
            binary.left.accept(self);
            write(' ');

            if binary.actual_operation? then
                write(binary.actual_operation);
            else
                binary.operation.accept(self);
            fi
            
            write(' ');
            binary.right.accept(self);
            write_constraint(binary)
        si

        visit(expressions: Expressions.LIST) is
            let seen_any = false;
            for e in expressions do
                if seen_any then
                    write(',');
                fi
                e.accept(self);
                seen_any = true;
            od

            write_constraint(expressions)
        si

        visit(literal: Expressions.Literals.Literal) is
            write(literal.value_string);
        si

        write_escape_char(c: char) is
            let ci = cast int(c);
            if ci < 32 then
                write("\\" + string.format("X", ci));
            elif ci == 34 then
                write("\\");
                write(cast char(34));
            elif ci == 39 then
                write("'");
            elif ci == 92 then
                write("\\\\");
            else
                write(c);
            fi
        si

        visit(`string: Expressions.Literals.STRING) is
            write(cast char(34));
            for c in `string.value_string do
                write_escape_char(c);
            od
            write(cast char(34));
        si

        visit(interpolation: Expressions.STRING_INTERPOLATION) is
            let in_expression = false;

            write("\"");
            for e in interpolation.values do
                if in_expression then
                    write("{{");

                    e.expression.accept(self);

                    if e.format? then
                        write(":{e.format}");
                    fi

                    if in_expression then
                        write("}}");
                    fi
                else
                    // TODO: no quotes around string literals
                    e.expression.accept(self);                    
                fi

                in_expression = !in_expression;
            od
            write("\"");
        si

        visit(integer: Expressions.Literals.INTEGER) is
            write(integer.value_string);
        si        

        visit(float: Expressions.Literals.FLOAT) is
            write(float.value_string);
        si

        visit(character: Expressions.Literals.CHARACTER) is
            write("'");
            write_escape_char(character.value_string.get_chars(0));
            write("'");
        si

        visit(boolean: Expressions.Literals.BOOLEAN) is
            write(boolean.value_string);
        si

        visit(left: Trees.Expressions.SIMPLE_LEFT_EXPRESSION) is
            left.expression.accept(self);
        si

        visit(destructure_left: Trees.Expressions.DESTRUCTURING_LEFT_EXPRESSION) is
            let seen_any = false;
            write("(");
            for e in destructure_left.elements do
                if seen_any then
                    write(", ");
                fi

                e.accept(self);

                seen_any = true;
            od
            write(")");

            write_constraint(destructure_left)
        si

        visit(list: Statements.LIST) is
            for s in list do
                s.accept(self);
            od

            write_constraint(list)
        si

        visit(assign: Statements.ASSIGNMENT) is
            assign.left.accept(self);
            write(" = ");
            assign.right.accept(self);
            write_constraint(assign);
            write_line(";");
        si

        visit(expression: Statements.EXPRESSION) is
            expression.expression.accept(self);
            write_line(";");
        si

        visit(`return: Statements.RETURN) is
            write("return");
            if `return.expression? then
                write(' ');
                `return.expression.accept(self);
            fi
            write_constraint(`return);
            write_line(";");
        si

        visit(`throw: Statements.THROW) is
            write("throw");
            if `throw.expression? then
                write(' ');
                `throw.expression.accept(self);
            fi
            write_line(";");
        si

        visit(`assert: Statements.ASSERT) is
            write("assert");
            if `assert.expression? then
                write(' ');
                `assert.expression.accept(self);
            fi

            if `assert.message? then
                write(" else ");
                `assert.message.accept(self);
            fi

            write_line(";");
        si

        visit(`if: Statements.IF) is
            let is_first = true;
            let seen_else = false;

            assert `if?;
            assert `if.branches?;

            for b in `if.branches do
                if seen_else then
                    IoC.CONTAINER.instance.logger.error(b.location, "broken if statement");
                fi

                assert !seen_else;
                
                if b.condition? then
                    if is_first then
                        write("if ");
                    else
                        write("elif ");
                    fi
                    b.condition.accept(self);
                    write_line(" then");
                else
                    seen_else = true;
                    write_line("else");
                fi
                indent();
                b.body.accept(self);

                outdent();
                is_first = false;
            od
            write_constraint(`if);

            write_line("fi");
        si

        visit(`case: Statements.CASE) is
            write("case ");
            `case.expression.accept(self);
            write_line();
            for m in `case.matches do
                m.accept(self);
            od
            write_line("esac");
        si

        visit(match: Statements.CASE_MATCH) is
            if match.expressions? then
                write("when ");
                match.expressions.accept(self);
                write_line(":");
            else
                write_line("default");
            fi
            indent();
            match.statements.accept(self);
            outdent();
        si

        visit(`try: Statements.TRY) is
            write_line("try");
            indent();
            `try.body.accept(self);
            outdent();
            for c in `try.catches do
                c.accept(self);
            od
            if `try.`finally? then
                write_line("finally");
                indent();
                `try.`finally.accept(self);
                outdent();
            fi
            write_line("yrt");
        si

        visit(`catch: Statements.CATCH) is
            write("catch ");
            `catch.variable.accept(self);
            write_line();
            indent();
            `catch.body.accept(self);
            outdent();
        si

        visit(`do: Statements.DO) is
            if `do.condition? then
                write("while ");
                `do.condition.accept(self);
                write(" ");
            fi
            write_line("do");
            indent();
            `do.body.accept(self);
            outdent();
            write_line("od");
        si

        visit(labelled: Statements.LABELLED) is
            labelled.label.accept(self);
            write(": ");
            labelled.statement.accept(self);
        si

        visit(`break: Statements.BREAK) is
            write("break");
            if `break.label? then
                write(' ');
                `break.label.accept(self);
            fi
            write_line(";");
        si

        visit(`continue: Statements.CONTINUE) is
            write("continue");
            if `continue.label? then
                write(' ');
                `continue.label.accept(self);
            fi
            write_line(";");
        si

        visit(pragma: Statements.PRAGMA) is
            if pragma.statement? then
                pragma.statement.accept(self);                
            fi
        si

        visit(block: Bodies.NULL) is
            write_line(";");
        si

        visit(variable: Variables.VARIABLE) is
            variable.left.accept(self);
            if !isa TypeExpressions.INFER(variable.type_expression) then
                write(": ");
                variable.type_expression.accept(self);
            fi

            if variable.initializer? then
                write(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(destructure_element: Variables.SIMPLE_VARIABLE_LEFT) is
            if destructure_element.name? then
                destructure_element.name.accept(self);
            else
                write("_");
            fi
        si

        visit(destructure_element_list: Variables.DESTRUCTURING_VARIABLE_LEFT) is
            write("(");

            let seen_any = false;
            for e in destructure_element_list.elements do
                if seen_any then
                    write(", ");
                fi

                e.accept(self);

                seen_any = true;
            od

            write(")");
        si

        visit(`namespace: Definitions.NAMESPACE) is
            write("namespace ");
            `namespace.name.accept(self);
            write_line(" is");
            indent();
            `namespace.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(`use: Definitions.USE) is
            write("use ");
            let seen_any = false;
            if `use.name? then
                `use.name.accept(self);
                write(" = ");
            fi

            if `use.`use? then
                `use.`use.accept(self);                
            fi

            write_line(";");
        si

        visit(`class: Definitions.CLASS) is
            write("class ");
            `class.name.accept(self);
            if `class.arguments? then
                write("[");
                `class.arguments.accept(self);
                write("]");
            fi
            if `class.ancestors? then
                write(": ");
                `class.ancestors.accept(self);
            fi
            `class.modifiers.accept(self);
            write_line(" is");
            indent();
            `class.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(`trait: Definitions.TRAIT) is
            write("trait ");
            `trait.name.accept(self);
            if `trait.arguments? then
                write("[");
                `trait.arguments.accept(self);
                write("]");
            fi
            if `trait.ancestors? then
                write(": ");
                `trait.ancestors.accept(self);
            fi
            `trait.modifiers.accept(self);
            write_line(" is");
            indent();
            `trait.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(`struct: Definitions.STRUCT) is
            write("trait ");
            `struct.name.accept(self);
            
            if `struct.arguments? then
                write("[");
                `struct.arguments.accept(self);
                write("]");
            fi

            `struct.modifiers.accept(self);
            write_line(" is");
            indent();
            `struct.body.accept(self);
            outdent();
            write_line("si");
        si        

        visit(`union: Definitions.UNION) is
            write("union ");
            `union.name.accept(self);
            if `union.arguments? then
                write("[");
                `union.arguments.accept(self);
                write("]");
            fi
            `union.modifiers.accept(self);
            write_line(" is");
            indent();
            `union.body.accept(self);
            outdent();
            write_line("si");
        si

        visit(variant: Definitions.VARIANT) is
            variant.name.accept(self);

            if variant.fields? /\ variant.fields.count > 0 then
                write("(");
                variant.fields.accept(self);
                write(")");
            fi

            variant.modifiers.accept(self);

            if variant.body? then
                write_line(" is");
                indent();
                variant.body.accept(self);
                outdent();
                write_line("si");
            fi
        si

        after_body(node: Bodies.Body) is
            if node==null \/ !node.is_block then
                write(";");
            fi
            write_line();
        si

        visit(function: Definitions.FUNCTION) is
            function.name.accept(self);
            write("(");

            function.arguments.accept(self);
            write(")");

            if !isa TypeExpressions.INFER(function.type_expression) then
                write(" -> ");
                function.type_expression.accept(self);
                function.modifiers.accept(self);
            elif !function.modifiers.is_empty then
                function.modifiers.accept(self);
            fi

            if function.body? then
                write(" ");
                function.body.accept(self);
            fi

            after_body(function.body);
        si

        write_member_type_and_modifiers(type_expression: TypeExpressions.TypeExpression, modifiers: Modifiers.LIST) is
            if type_expression? /\ !isa TypeExpressions.INFER(type_expression) then
                write(": ");
                type_expression.accept(self);
                write(" ");
                modifiers.accept(self);
            elif !modifiers.is_empty then
                modifiers.accept(self);
            fi
        si

        indent_property(has_getter: bool, has_setter: bool) -> bool is
            if has_getter /\ has_setter then
                write_line();
                indent();
                return true;
            elif has_getter \/ has_setter then
                write(" ");
            fi
            return false;
        si

        visit(property: Definitions.PROPERTY) is
            if property.name? then
                property.name.accept(self);
            fi
            
            write_member_type_and_modifiers(property.type_expression, property.modifiers);
            let out_again = indent_property(property.read_body?, property.assign_body?);
            if property.read_body? then
                property.read_body.accept(self);
                if property.assign_body? then
                    write_line(",");
                else
                    after_body(property.read_body);
                fi
            else
                write(" ");
            fi
            if property.assign_body? then
                write("= ");
                property.assign_argument.accept(self);
                property.assign_body.accept(self);
                after_body(property.assign_body);
            fi
            if out_again then
                outdent();
            fi
        si

        visit(indexer: Definitions.INDEXER) is
            if indexer.name? then
                indexer.name.accept(self);
            fi
            write("[");
            indexer.index_argument.accept(self);
            write("]");
            write_member_type_and_modifiers(indexer.type_expression, indexer.modifiers);
            let out_again = indent_property(indexer.read_body?, indexer.assign_body?);
            if indexer.read_body? then
                indexer.read_body.accept(self);
                if indexer.assign_body? then
                    write_line(",");
                else
                    after_body(indexer.read_body);
                fi
            else
                write(' ');
            fi
            if indexer.assign_body? then
                write("= ");
                indexer.assign_argument.accept(self);
                write(' ');
                indexer.assign_body.accept(self);
                after_body(indexer.assign_body);
            fi
            if out_again then
                outdent();
            fi
        si

        visit(generic: TypeExpressions.GENERIC) is
            generic.name.accept(self);
            write('[');
            generic.arguments.accept(self);
            write(']');
        si

        visit(function: TypeExpressions.FUNCTION) is
            write("(");
            function.arguments.accept(self);
            write(")");
            if !isa TypeExpressions.INFER(function.result) then
                write(" -> ");
                function.result.accept(self);
            fi
        si

        visit(tuple: TypeExpressions.TUPLE) is
            write("(");
            tuple.elements.accept(self);
            write(")");
        si

        visit(element: TypeExpressions.NAMED_TUPLE_ELEMENT) is
            element.name.accept(self);
            write(": ");
            element.type_expression.accept(self);
        si

        visit(`null: Expressions.NULL) is
            write("null");
        si

        visit(`self: Expressions.SELF) is
            write("self");
        si

        visit(`rec: Expressions.RECURSE) is
            write("rec");
        si

        visit(variable: Expressions.VARIABLE) is
            variable.name.accept(self);

            if !isa TypeExpressions.INFER(variable.type_expression) then
                write(": ");
                variable.type_expression.accept(self);
            fi
            
            if variable.initializer? then
                write(" = ");
                variable.initializer.accept(self);
            fi
        si

        visit(element: Expressions.TUPLE_ELEMENT) is
            element.name.accept(self);

            if !isa TypeExpressions.INFER(element.type_expression) then
                write(": ");
                element.type_expression.accept(self);
            fi
            
            if element.initializer? then
                write(" = ");
                element.initializer.accept(self);
            fi

            write_constraint(element);
        si

        visit(ambiguous_expression: Expressions.AMBIGUOUS_EXPRESSION) is
            write("(ambiguous ");

            if ambiguous_expression.left? then
                ambiguous_expression.left.accept(self);
                write(".");
            fi
            ambiguous_expression.identifier.accept(self);
            write("[");
            ambiguous_expression.type_arguments.accept(self);
            write("] or ");
            ambiguous_expression.index.accept(self);
            write(")");
        si

        visit(generic_application: Expressions.GENERIC_APPLICATION) is
            if generic_application.left? then
                generic_application.left.accept(self);
                write(".");
            fi
            generic_application.identifier.accept(self);
            write("[");
            generic_application.type_arguments.accept(self);
            write("]");
        si

        visit(function: Syntax.Trees.Expressions.FUNCTION) is
            function.arguments.accept(self);
            if !isa TypeExpressions.INFER(function.type_expression) then
                write(" -> ");
                function.type_expression.accept(self);
            fi
            function.body.accept(self);

            write_constraint(function);
        si

        visit(sequence: Expressions.SEQUENCE) is
            write('[');
            sequence.elements.accept(self);
            write(']');
            if !isa Trees.TypeExpressions.INFER(sequence.type_expression) then
                write(": ");
                sequence.type_expression.accept(self);
            fi

            write_constraint(sequence);
        si

        visit(unwrap: Expressions.HAS_VALUE) is
            unwrap.left.accept(self);
            write("?");
        si

        visit(has_value: Expressions.UNWRAP) is
            has_value.left.accept(self);
            write("!");
        si

        visit(has_value: Expressions.REFERENCE) is
            has_value.left.accept(self);
            write(" ref ");
        si

        visit(statement: Expressions.STATEMENT) is
            if statement? then
                statement.statement.accept(self);
            fi
            write(";");

            if statement? then
                write_constraint(statement);
            fi
        si

        visit(l: Statements.LET) is
            write("let ");
            l.variables.accept(self);
            write_line(";");
        si

        visit(`for: Statements.FOR) is
            write_line("for ");
            `for.variable.accept(self);
            write(" in ");
            `for.expression.accept(self);
            write_line(" do");
            indent();
            `for.body.accept(self);
            outdent();
            write_line("od");
        si

        visit(expression: Bodies.EXPRESSION) is
            write(" => ");
            expression.expression.accept(self);
        si

        visit(block: Bodies.BLOCK) is
            write_line("is");
            indent();
            block.statements.accept(self);
            outdent();
            write("si");
        si

        visit(`innate: Bodies.INNATE) is
            `innate.name.accept(self);
        si
    si
si
