namespace Syntax.Parser.Pragma is
    use System;
    
    use Source;

    class NODE: BASE[Tree.Pragma.NODE] is
        qualified_identifier_parser: Parser[Tree.Identifier.NODE];
        expression_list_parser: Parser[Tree.Expression.LIST];

        init(
            qualified_identifier_parser: Parser[Tree.Identifier.NODE],
            expression_list_parser: Parser[Tree.Expression.LIST]
        ) is
            super.init();

            self.qualified_identifier_parser = qualified_identifier_parser;
            self.expression_list_parser = expression_list_parser;
        si

        parse(context: CONTEXT) -> Tree.Pragma.NODE is
            let fail = false;
            let expect_semicolon = false;
            
            let start = context.location;

            if !context.next_token(Lexical.TOKEN.AT) then
                return null;
            fi

            let name = qualified_identifier_parser.parse(context);

            if !name? then
                return null;
            fi

            if context.next_token(Lexical.TOKEN.PAREN_OPEN) then
                let arguments: Tree.Expression.LIST;
                
                if context.current.token != Lexical.TOKEN.PAREN_CLOSE then
                    arguments = expression_list_parser.parse(context);
                fi

                context.next_token(Lexical.TOKEN.PAREN_CLOSE);
                
                return new Tree.Pragma.NODE(start::context.location, name, arguments);
            fi
        si
    si
si
