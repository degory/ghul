namespace Syntax.Parser is
    use System;
    use Generic;

    trait Parser[T] is
        parse(context: CONTEXT) -> T;
    si

    class BASE[T]: Object, Parser[T] is
        _expected_tokens: Collections.MutableList[Lexical.TOKEN];
        parsers: Collections.MAP[Lexical.TOKEN, (CONTEXT) -> T];

        expected_tokens: Collections.Iterable[Lexical.TOKEN] is
            if _expected_tokens == null then
                populate_expected_tokens();
            fi
            return _expected_tokens;
        si

        description: String => null;

        syntax_error_message: String is
            var d = description;
            if d? then
                return "in " + d;
            else
                return "syntax error";
            fi
        si

        init() is
            parsers = new Collections.MAP[Lexical.TOKEN, (CONTEXT) -> T]();
        si

        add_parser(p: (CONTEXT) -> T, token: Lexical.TOKEN) is
            @IF.dotnet()
            System.Console.write_line("add parser: " + self + " " + token + " " + p);

            if parsers.contains_key(token) then
                @IF.legacy()
                throw new Exception("% already has a parser (%)" % [token, p] );

                @IF.dotnet()
                throw new Exception(String.format("{0} already has a parser ({1})", [token, p]));
            fi

            parsers[token] = p;
        si

        add_parser(p: (CONTEXT) -> T, tokens: Collections.Iterable[Lexical.TOKEN]) is
            for t in tokens do
                add_parser(p, t);
            od
        si

        parse(context: CONTEXT) -> T is
            let token = context.current.token;
            @IF.dotnet()
            System.Console.write_line("search parser: " + self + " " + token + "...");

            if parsers.contains_key(token) then
                let p = parsers[token];

                @IF.dotnet()
                System.Console.write_line("have parser: " + self + " " + token + " " + p);

                let result = p(context);

                @IF.dotnet()
                System.Console.write_line("have result: " + self + " " + token + " " + result);

                return result;
            else
                @IF.dotnet()
                System.Console.write_line("no parser: " + self + " " + token);

                let result = other_token(context);

                @IF.dotnet()
                System.Console.write_line("error result: " + self + " " + token + " " + result);

                return result;
            fi
        si

        other_token(context: CONTEXT) -> T is
            @IF.legacy()
            context.error(context.location, 
                "%: expected % but found %" % [syntax_error_message, Lexical.TOKEN_NAMES[expected_tokens], context.current_token_name]: Object 
            );

            @IF.dotnet()
            context.error(context.location, 
                String.format(
                    "{0}: expected {1} but found {2}",
                    [syntax_error_message, Lexical.TOKEN_NAMES[expected_tokens], context.current_token_name]: Object
                )
            );
        si

        populate_expected_tokens() private is
            var et = new Collections.LIST[Lexical.TOKEN]();

            for k in parsers.keys do
                et.add(k);
            od

            assert et.count > 0 else "should have at least one expected token";

            _expected_tokens = et;
        si
    si
si
