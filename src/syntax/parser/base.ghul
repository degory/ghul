namespace Syntax.Parser is
    use System;
    use Generic;

    trait Parser[T] is
        parse(context: CONTEXT) -> T;
    si

    class BASE[T]: Object, Parser[T] is
        _expected_tokens: Collections.MutableList[Lexical.TOKEN];
        parsers: Collections.MAP[Lexical.TOKEN, (CONTEXT) -> T];

        expected_tokens: Collections.Iterable[Lexical.TOKEN] is
            if _expected_tokens == null then
                populate_expected_tokens();
            fi
            return _expected_tokens;
        si

        description: String => null;

        syntax_error_message: String is
            var d = description;
            if d? then
                return "in " + d;
            else
                return "syntax error";
            fi
        si

        init() is
            parsers = new Collections.MAP[Lexical.TOKEN, (CONTEXT) -> T]();
        si

        add_parser(p: (CONTEXT) -> T, token: Lexical.TOKEN) is
            if parsers[token]? then
                @IF.legacy()
                throw new Exception("% already has a parser (%)" % [token, p] );

                @IF.dotnet()
                throw new Exception(String.format("{0} already has a parser ({1})", [token, p]));
            fi

            parsers[token] = p;
        si

        add_parser(p: (CONTEXT) -> T, tokens: Collections.Iterable[Lexical.TOKEN]) is
            for t in tokens do
                add_parser(p, t);
            od
        si

        parse(context: CONTEXT) -> T is
            let p = parsers[context.current.token];

            if p? then
                let result = p(context);

                return result;
            else
                let result = other_token(context);

                return result;
            fi
        si

        other_token(context: CONTEXT) -> T is
            @IF.legacy()
            context.error(context.location, 
                "%: expected % but found %" % [syntax_error_message, Lexical.TOKEN_NAMES[expected_tokens], context.current_token_name]: Object 
            );

            @IF.dotnet()
            context.error(context.location, 
                String.format(
                    "{0}: expected {1} but found {2}",
                    [syntax_error_message, Lexical.TOKEN_NAMES[expected_tokens], context.current_token_name]: Object
                )
            );
        si

        populate_expected_tokens() private is
            var et = new Collections.LIST[Lexical.TOKEN]();

            for k in parsers.keys do
                et.add(k);
            od

            _assert et.count > 0 else "should have at least one expected token";

            _expected_tokens = et;
        si
    si
si
