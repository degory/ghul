namespace Syntax.Parser.Expression is
    use System;
    
    use Logging;
    use Source;

    enum PRECEDENCE is
        NONE, 
        MIN, 
        UNDEFINED, 
        BOOLEAN, 
        RELATIONAL, 
        RANGE, 
        SHIFT, 
        BITWISE, 
        ADDITION, 
        MULTIPLICATION, 
        MEMBER, 
        PRIMARY
    si

    class NODE: BASE[Tree.Expression.NODE] is
        _precedence: Collections.MAP[String,PRECEDENCE];
        _real_operation: Collections.MAP[String,String];

        expression_tertiary_parser: Parser[Tree.Expression.NODE];

        init(expression_tertiary_parser: Parser[Tree.Expression.NODE]) is
            super.init();
            self.expression_tertiary_parser = expression_tertiary_parser;
            _precedence = new Collections.MAP[String,PRECEDENCE]();

            _precedence["*"] = PRECEDENCE.MULTIPLICATION;
            _precedence["/"] = PRECEDENCE.MULTIPLICATION;
            _precedence["%"] = PRECEDENCE.MULTIPLICATION;
            _precedence["+"] = PRECEDENCE.ADDITION;
            _precedence["-"] = PRECEDENCE.ADDITION;
            _precedence["&"] = PRECEDENCE.BITWISE;
            _precedence["|"] = PRECEDENCE.BITWISE;
            _precedence["^"] = PRECEDENCE.BITWISE;
            _precedence[".."] = PRECEDENCE.RANGE;
            _precedence["::"] = PRECEDENCE.RANGE;
            _precedence["<<"] = PRECEDENCE.SHIFT;
            _precedence[">>"] = PRECEDENCE.SHIFT;
            _precedence["=="] = PRECEDENCE.RELATIONAL;
            _precedence["!="] = PRECEDENCE.RELATIONAL;
            _precedence["=~"] = PRECEDENCE.RELATIONAL;
            _precedence["!~"] = PRECEDENCE.RELATIONAL;
            _precedence["<"] = PRECEDENCE.RELATIONAL;
            _precedence[">"] = PRECEDENCE.RELATIONAL;
            _precedence[">="] = PRECEDENCE.RELATIONAL;
            _precedence["<="] = PRECEDENCE.RELATIONAL;
            _precedence["&&"] = PRECEDENCE.BOOLEAN;
            _precedence["||"] = PRECEDENCE.BOOLEAN;

            _real_operation = new Collections.MAP[String,String]();

            _real_operation["!~"] = "=~";
            _real_operation["=~"] = "=~";
            _real_operation["!="] = "==";
            _real_operation["=="] = "==";
            _real_operation["<"] = "<>";
            _real_operation["<="] = "<>";
            _real_operation[">"] = "<>";
            _real_operation[">="] = "<>";
        si

        description: String => "expression";

        precedence(context: CONTEXT) -> PRECEDENCE is
            if context.current.token != Lexical.TOKEN.OPERATOR then
                return PRECEDENCE.NONE;
            fi

            if !_precedence.contains_key(context.current.string) then
                context.error(context.current.location, 
                "operator '" + context.current.string + "' has unknown precedence");
                return PRECEDENCE.UNDEFINED;
            fi

            return _precedence[context.current.string];
        si

        parse(context: CONTEXT) -> Tree.Expression.NODE is
            try
                return parse(context, expression_tertiary_parser.parse(context), PRECEDENCE.MIN);                                       
            catch e: Exception
                System.Console.error.write_line("" + context.current.location + ": caught exception parsing expression: " + e); 

                return new Tree.Expression.Literal.NONE(context.location);
            yrt
        si

        // precedence climbing expression parser:
        parse(context: CONTEXT, left: Tree.Expression.NODE, min_precedence: PRECEDENCE) -> Tree.Expression.NODE is
            do
                var left_precedence = precedence(context);

                if left_precedence < min_precedence then
                    break;
                fi

                let s = left_precedence.to_string();

                let apparent_op = context.current.string;

                let real_op = apparent_op;

                if _real_operation.contains_key(apparent_op) then
                    real_op = _real_operation[apparent_op];
                fi
                
                let op = new Tree.Identifier.NODE(context.location, real_op);

                context.next_token();

                let right: Tree.Expression.NODE = expression_tertiary_parser.parse(context);

                assert right? else "parse right failed";

                do
                    var right_precedence = precedence(context);

                    if right_precedence <= left_precedence then
                        break;
                    fi

                    right = parse(context, right, right_precedence);
                od

                left = new Tree.Expression.BINARY(left.location::right.location, op, apparent_op, left, right);
            od

            return left;
        si
    si
si
