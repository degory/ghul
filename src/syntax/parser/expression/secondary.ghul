namespace Syntax.Parser.Expression is
    use System;
    use Generic;

    use Source;

    class SECONDARY: BASE[Tree.Expression.NODE] is
        identifier_parser: Parser[Tree.Identifier.NODE];
        type_parser: Parser[Tree.TypeExpression.NODE];
        expression_parser: Parser[Tree.Expression.NODE];
        expression_primary_parser: Parser[Tree.Expression.NODE];
        expression_list_parser: Parser[Tree.Expression.LIST];
        body_parser: Parser[Tree.Body.NODE];
        description: String => "secondary expression";
        
        init(
            identifier_parser: Parser[Tree.Identifier.NODE],
            type_parser: Parser[Tree.TypeExpression.NODE],
            expression_parser: Parser[Tree.Expression.NODE],
            expression_primary_parser: Parser[Tree.Expression.NODE],
            expression_list_parser: Parser[Tree.Expression.LIST],
            body_parser: Parser[Tree.Body.NODE]
        )
        is
            super.init();

            self.identifier_parser = identifier_parser;
            self.type_parser = type_parser;
            self.expression_parser = expression_parser;
            self.expression_primary_parser = expression_primary_parser;
            self.expression_list_parser = expression_list_parser;
            self.body_parser = body_parser;
        si

        parse(context: CONTEXT) -> Tree.Expression.NODE is
            var start = context.location;
            var result: Tree.Expression.NODE = expression_primary_parser.parse(context);

            do
                case context.current.token
                when Lexical.TOKEN.PAREN_OPEN:
                    context.next_token();
                    var arguments: Tree.Expression.LIST;
                    if context.current.token != Lexical.TOKEN.PAREN_CLOSE then
                        arguments = expression_list_parser.parse(context);
                    else
                        arguments = new Tree.Expression.LIST(context.location, new Vector[Tree.Expression.NODE]());
                    fi
                    result = new Tree.Expression.CALL(start::context.location, result, arguments);
                    context.next_token(Lexical.TOKEN.PAREN_CLOSE, syntax_error_message);
                when Lexical.TOKEN.SQUARE_OPEN:
                    context.next_token();
                    var index = expression_parser.parse(context);
                    result = new Tree.Expression.INDEX(start::context.location, result, index);
                    context.next_token(Lexical.TOKEN.SQUARE_CLOSE, syntax_error_message);
                when Lexical.TOKEN.DOT:
                    let completion_target_start = context.location;

                    context.next_token();

                    if [Lexical.TOKEN.IDENTIFIER, Lexical.TOKEN.OPERATOR].contains(context.current.token) then
                        let member = identifier_parser.parse(context);
                        result = new Tree.Expression.MEMBER(start::member.location, result, member, completion_target_start::member.location);
                    else
                        result = new Tree.Expression.MEMBER(start..context.location, result, null, completion_target_start::context.location);
                    fi

                when Lexical.TOKEN.ARROW_THIN, Lexical.TOKEN.ARROW_FAT, Lexical.TOKEN.IS:
                    if isa Tree.Expression.TUPLE(result) || isa Tree.Expression.IDENTIFIER(result) || isa Tree.Expression.VARIABLE(result) then
                        var type_expression: Tree.TypeExpression.NODE;
                        var arguments: Tree.Expression.TUPLE;
                        if context.current.token == Lexical.TOKEN.ARROW_THIN then
                            context.next_token();
                            type_expression = type_parser.parse(context);
                        else
                            type_expression = new Tree.TypeExpression.INFER(start::result.location);
                        fi

                        var uses: Vector[Tree.Identifier.NODE];

                        if context.current.token == Lexical.TOKEN.USE then
                            context.next_token();

                            uses = new Vector[Tree.Identifier.NODE]();

                            do
                                uses.add(identifier_parser.parse(context));

                                if context.current.token != Lexical.TOKEN.COMMA then
                                    break;
                                fi

                                context.next_token(Lexical.TOKEN.COMMA);
                            od
                        fi

                        if context.expect_token([Lexical.TOKEN.ARROW_FAT, Lexical.TOKEN.IS]) then
                            if isa Tree.Expression.TUPLE(result) then
                                arguments = cast Tree.Expression.TUPLE(result);
                            else
                                var elements = new Vector[Tree.Expression.NODE]();
                                elements.add(result);
                                arguments = new Tree.Expression.TUPLE(start::result.location, new Tree.Expression.LIST(start::result.location, elements));
                            fi
                            var body = body_parser.parse(context);
                            result = new Tree.Expression.FUNCTION(start::body.location, arguments, type_expression, uses, body);
                        else
                            return new Tree.Expression.Literal.NONE(start::context.location);
                        fi
                    else
                        context.error(result.location, "expected a function formal argument");
                        return new Tree.Expression.Literal.NONE(start::context.location);
                    fi
                when Lexical.TOKEN.QUESTION:
                    result = new Tree.Expression.HAS_VALUE(start::context.location, result);
                    context.next_token();
                default
                    return result;
                esac
            od
        si
    si
si
