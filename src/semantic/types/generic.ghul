namespace Semantic.Types is
    use IO.Std;

    use Source.LOCATION;

    use Logging;

    enum TYPE_VARIANCE is
        INVARIANT,
        COVARIANT,
        CONTRAVARIANT
    si

    class GENERIC: NAMED is
        _is_wild: byte;

        arguments: Collections.List[Type] => symbol.arguments;

        is_error: bool => arguments | .has(a => a.is_error);

        // should be
        // is_wild: bool => arguments | .has(a => a.is_wild)
        // but the following shaves about 10% off compiler build time (nearly 10% at time of change)
        is_wild: bool is
            if _is_wild == 0b then
                let a = symbol.arguments;
                let c = a.count;

                let i = 0;

                while i < c do
                    if a[i].is_wild then
                        _is_wild = 1b;
                        return true;
                    fi

                    i = i + 1;
                od

                _is_wild = 2b;
                return false;
            fi

            return _is_wild == 1b;  
        si

        short_description: string is
            assert self? else "self is null";
            assert symbol? else "symbol is null";
            assert symbol.name? else "symbol.name is null";
            assert arguments? else "arguments is null";

            let result = new System.Text.StringBuilder();

            result
                .append(symbol.name)
                .append('[');

            let seen_any = false;

            for a in arguments do
                assert a? else "argument is null";

                if seen_any then
                    result.append(',');
                fi

                if a? then
                    result.append(a.short_description);
                fi

                seen_any = true;
            od

            result.append(']');

            return result.to_string();
        si

        is_function_with_any_implicit_argument_types: bool is
            if !is_function then
                return false;
            fi

            for i in 0..arguments.count -1 do
                if arguments[i].is_any then
                    return true;
                fi
            od
        si       

        init(
            symbol: Symbols.GENERIC
        ) is
            super.init(symbol);
        si
        
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.List[Type]
        ) is
            super.init(new Symbols.GENERIC(location, symbol, arguments));
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.List[Type]
        ) -> GENERIC
        is
            let result = new GENERIC(location, symbol, arguments);
            
            return result;
        si

        is_same_symbol(other: Type) -> bool is
            if !isa GENERIC(other) then
                return false;
            fi
            
            let other_generic = cast GENERIC(other);

            let generic_symbol = cast Symbols.GENERIC(symbol);
            let generic_other_symbol = cast Symbols.GENERIC(other_generic.symbol);

            return generic_symbol.symbol == generic_other_symbol.symbol;
        si

        get_argument_type_variance(index: int) -> TYPE_VARIANCE => TYPE_VARIANCE.INVARIANT;
        
        specialize_generic(type_map: Collections.Map[string,Type]) -> Types.GENERIC is
            let context = IoC.CONTAINER.instance.symbol_table.current_instance_context;

            let we_are_generic = context? /\ context.arguments.count > 0;
            
            let seen_any_new = false;

            let generic_symbol = cast Symbols.GENERIC(symbol);

            let new_arguments = new Collections.LIST[Type](arguments.count);

            for i in 0..arguments.count do
                let argument_name
                    = generic_symbol.symbol.argument_names[i];

                let mapped_type: Type;

                // FIXME: this seems to fix #118 but don't think this is the correct place to put this check:
                if we_are_generic /\ type_map.try_get_value(argument_name, mapped_type ref) then
                    new_arguments.add(mapped_type);

                    seen_any_new = true;
                else
                    let oa = generic_symbol.arguments[i];
                    let na = oa.specialize(type_map);

                    new_arguments.add(na);

                    if oa != na then
                        seen_any_new = true;
                    fi
                fi
            od

            if seen_any_new then
                let result = create(symbol.location, generic_symbol.symbol, new_arguments);

                return result;
            else
                return self;
            fi
        si

        specialize(type_map: Collections.Map[string,Type]) -> Type =>
            specialize_generic(type_map);

        =~(other: Type) -> bool is
            try
               debug_indent(); 

               debug("GENERIC =~: " + self + ", " + other);

               if other.is_any then
                   debug("GENERIC =~ ANY: " + self + ", " + other);
                   return true;
               fi
   
               if !isa GENERIC(other) then
                   debug("GENERIC !~ NOT GENERIC: " + self + ", " + other);                
                   return false;
               fi
   
               let generic_other = cast GENERIC(other);
   
               if symbol == generic_other.symbol then
                   debug("GENERIC =~ GENERIC: identical generic symbols: " + self + ", " + other);
                   return true;
               fi
   
               let generic_symbol = cast Symbols.GENERIC(symbol);
               let generic_other_symbol = cast Symbols.GENERIC(generic_other.symbol);
   
               if generic_symbol.symbol != generic_other_symbol.symbol then
                   debug("GENERIC !~ GENERIC: different underlying symbols: " + self + ", " + other);
                   return false;
               fi
   
               if generic_symbol.arguments.count != generic_other_symbol.arguments.count then
                   debug("GENERIC !~ GENERIC: different argument counts: " + self + ", " + other);
                   return false;
               fi
   
               for i in 0..generic_symbol.arguments.count do
                   // TODO: implement type variance here:
                   if generic_symbol.arguments[i] !~ generic_other_symbol.arguments[i] then
                       debug("GENERIC !~ GENERIC: different argument types at index " + i + " (" + generic_symbol.arguments[i] + " vs " + generic_other_symbol.arguments[i] + "): " + self + ", " + other);
   
                       return false;
                   fi
               od
   
               debug("GENERIC =~ GENERIC: generic symbol arguments match: " + self + ", " + other);
   
               return true;
   
            finally
                debug_unindent();
            yrt            
        si

        compare_direct(other: Type) -> Types.MATCH is
            try
                debug_indent();

                debug("GENERIC compare_direct: " + self + ", " + other);

                if other.is_any then
                    debug("GENERIC compare_direct: " + self + " is any");
                    return Types.MATCH.SAME;
                fi
    
                if !isa GENERIC(other) then
                    debug("GENERIC compare_direct: " + self + " is not generic");
                    return Types.MATCH.DIFFERENT;
                fi
    
                let generic_other = cast GENERIC(other);
    
                if symbol == generic_other.symbol then
                    debug("GENERIC compare_direct: " + self + " is same as " + other);
                    return Types.MATCH.SAME;
                fi
    
                let generic_symbol = cast Symbols.GENERIC(symbol);
                let generic_other_symbol = cast Symbols.GENERIC(generic_other.symbol);
    
                if generic_symbol.symbol != generic_other_symbol.symbol then
                    debug("GENERIC compare_direct: different generic symbols: " + self + " is different from " + other);
                    return Types.MATCH.DIFFERENT;
                fi
    
                if generic_symbol.arguments.count != generic_other_symbol.arguments.count then
                    debug("GENERIC compare_direct: different argument counts: " + self + " is different from " + other);
                    return Types.MATCH.DIFFERENT;
                fi
    
                let result = Types.MATCH.SAME;
    
                for i in 0..generic_symbol.arguments.count do
                    debug("GENERIC compare_direct: comparing argument at index " + i + " (" + generic_symbol.arguments[i] + " vs " + generic_other_symbol.arguments[i] + "): " + self + ", " + other);

                    let variance = generic_other.get_argument_type_variance(i);

                    debug("GENERIC compare_direct: variance is " + variance);
    
                    let argument_score: Types.MATCH;
    
                    if variance == TYPE_VARIANCE.COVARIANT then
                        debug("GENERIC compare_direct: covariant");

                        argument_score = generic_symbol.arguments[i].compare(generic_other_symbol.arguments[i]);

                        debug("GENERIC compare_direct: covariant score: " + argument_score);
                    elif variance == TYPE_VARIANCE.CONTRAVARIANT then
                        debug("GENERIC compare_direct: contravariant");

                        argument_score = generic_other_symbol.arguments[i].compare(generic_symbol.arguments[i]);

                        debug("GENERIC compare_direct: contravariant score: " + argument_score);
                    elif generic_symbol.arguments[i] =~ generic_other_symbol.arguments[i] then
                        debug("GENERIC compare_direct: same argument types at index " + i + " (" + generic_symbol.arguments[i] + " vs " + generic_other_symbol.arguments[i] + "): " + self + ", " + other);

                        argument_score = Types.MATCH.SAME;
                    else
                        debug("GENERIC compare_direct: different argument types at index " + i + " (" + generic_symbol.arguments[i] + " vs " + generic_other_symbol.arguments[i] + "): " + self + ", " + other);

                        return Types.MATCH.DIFFERENT;
                    fi

                    debug("GENERIC compare_direct: argument match: " + argument_score + " for " + generic_symbol.arguments[i] + " vs " + generic_other_symbol.arguments[i] + " in " + self + ", " + other);
    
                    if cast int(argument_score) > cast int(result) then
                        debug("GENERIC compare_direct: arg match is worst so far: " + argument_score + " for " + generic_symbol.arguments[i] + " vs " + generic_other_symbol.arguments[i] + " in " + self + ", " + other);
                        result = argument_score;
                    fi
                od
    
                debug("GENERIC compare_direct: " + self + " is " + result + " from " + other);
                return result;
    
            finally
                debug_unindent();                
            yrt
        si

        compare(other: Type) -> Types.MATCH is
            try
                debug_indent();

                debug("GENERIC compare: " + self + ", " + other);

                if other.is_null then
                    debug("GENERIC compare: self is null, so assignable: " + self + " vs " + other);
                    return Types.MATCH.ASSIGNABLE;                
                elif symbol == null \/ other == null then
                    debug("GENERIC compare: symbol or other is null, so different: " + self + " vs " + other);
                    return Types.MATCH.DIFFERENT;
                elif other.is_named then
                    debug("GENERIC compare: other is named: " + self + " vs " + other + ", will compare direct...");
                    
                    let direct_score = compare_direct(other);
    
                    if cast int(direct_score) <= cast int(Types.MATCH.ASSIGNABLE) then
                        debug("GENERIC compare: direct score is at least assignable: " + direct_score + " for " + self + " vs " + other);
    
                        return direct_score;
                    fi
    
                    debug("GENERIC compare: direct score is not assignable, search for ancestor: " + direct_score + " for " + self + " vs " + other);
    
                    for i in 0..other.symbol.ancestors.count do
                        let a = other.symbol.get_ancestor(i);
    
                        let match = self.compare(a);
    
                        if cast int(match) <= cast int(Types.MATCH.ASSIGNABLE) then
                            debug("GENERIC compare: ancestor is at least assignable: " + match + " for " + self + " vs " + a);
    
                            return Types.MATCH.ASSIGNABLE;
                        elif match == Types.MATCH.CONVERTABLE then
                            debug("GENERIC compare: ancestor is convertable: " + match + " for " + self + " vs " + a);
    
                            return Types.MATCH.CONVERTABLE;
                        fi
                    od
                fi
    
                debug("GENERIC compare: no common ancestors: " + self + " vs " + other);
    
                if is_wild \/ other.is_wild then
                    debug("GENERIC compare: at least one is wild: " + self + " vs " + other);
                    return Types.MATCH.WILD;
                fi
    
                debug("GENERIC compare: different: " + self + " vs " + other);
                return Types.MATCH.DIFFERENT;
    
            finally
                debug_unindent();
            yrt
        si
               
        bind_type_variables(other: Type, results: GENERIC_ARGUMENT_BIND_RESULTS) -> bool is
            if other.is_null then
                return true;
            fi

            if isa GENERIC(other) then
                let other_generic = cast GENERIC(other);

                let generic_symbol = cast Symbols.GENERIC(symbol);
                let generic_other_symbol = cast Symbols.GENERIC(other_generic.symbol);
    
                if generic_symbol.symbol == generic_other_symbol.symbol then
                    let result = true;

                    for i in 0..arguments.count do
                        result = arguments[i].bind_type_variables(other.arguments[i], results) /\ result;
                    od

                    return result;
                else
                    for i in 0..other_generic.ancestors.count do
                        let a = other_generic.symbol.get_ancestor(i);

                        if bind_type_variables(a, results) then
                            return true;
                        fi
                    od

                    return false;
                fi
            else
                for a in other.ancestors do
                    if bind_type_variables(a, results) then
                        return true;
                    fi
                od

                return false;
            fi
        si

        to_string() -> string => symbol.to_string();
    si
si
