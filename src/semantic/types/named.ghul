namespace Semantic.Types is
    use IO.Std;

    class NAMED: Type is
        _compare_count: int static;
        _same_count: int static;
        _named_count: int static;
        _hit_count: int static;
        _miss_count: int static;

        _cache: Collections.MutableMap[(int,int), Types.MATCH] static;

        name: string => symbol.name;
        scope: Scope => symbol;

        _symbol: Symbols.Symbol;

        symbol: Symbols.Symbol => _symbol;

        short_description: string is
            if symbol? then
                return symbol.name;
            else
                return "(undefined)";
            fi
        si

        is_type_variable: bool =>
            symbol.is_type_variable;

        is_named: bool => true;

        is_value_type: bool => symbol? /\ symbol.is_value_type;
        is_trait: bool => symbol? /\ symbol.is_trait;
        is_inheritable: bool => symbol? /\ symbol.is_inheritable;
        is_class: bool => symbol? /\ symbol.is_class;
        is_object: bool => symbol? /\ symbol.is_object;
        is_void: bool => symbol? /\ symbol.is_void;

        init(symbol: Symbols.Symbol) is
            super.init();
            
            _symbol = symbol;
        si
        
        =~(other: Type) -> bool is
            if other.is_any then
                return true;
            elif isa NAMED(other) then
                let other_symbol = cast NAMED(other);
                return symbol == other_symbol.symbol;
            fi
        si

        specialize(type_map: Collections.Map[string,Type]) -> Type is
            if type_map.contains_key(name) then
                return type_map[name];
            else
                return self;
            fi
        si

        _cache_result(other: Type, result: Types.MATCH) -> Types.MATCH is
            _cache[(self.symbol.get_hash_code(), other.symbol.get_hash_code())] = result;

            return result;
        si

        dump_stats() static is
            IO.Std.error.write_line("cache size: {_cache.count} named ratio: {cast double(_hit_count) / cast double(_named_count)}");

            IO.Std.error.write_line("total: {_compare_count} named: {_named_count} same: {_same_count} misses: {_miss_count} hits: {_hit_count}");                
        si

        clear_cache() static is
            if _cache == null then
                _cache = new Collections.MAP[(int,int), Types.MATCH]();
            fi

            _cache.clear();
        si

        compare(other: Type) -> Types.MATCH is
            _compare_count = _compare_count + 1;
            if other.is_any then
                return Types.MATCH.ASSIGNABLE;
            fi

            if other.is_null /\ !is_value_type then
                return Types.MATCH.ASSIGNABLE;
            fi

            if symbol == null then
                return Types.MATCH.DIFFERENT;
            elif other.is_named then
                _named_count = _named_count + 1;

                if symbol == other.symbol then
                    _same_count = _same_count + 1;
                    return Types.MATCH.SAME;
                fi
                
                let result: Types.MATCH;

                if _cache == null then
                    _cache = new Collections.MAP[(int,int),Types.MATCH]();
                fi

                if _cache.try_get_value((self.symbol.get_hash_code(), other.symbol.get_hash_code()), result ref) then
                    _hit_count = _hit_count + 1;
                    return result;
                fi

                _miss_count = _miss_count + 1;

                for a in other.symbol.ancestors do
                    let match = self.compare(a);

                    if cast int(match) <= cast int(Types.MATCH.ASSIGNABLE) then
                        return _cache_result(other, Types.MATCH.ASSIGNABLE);
                    elif match == Types.MATCH.CONVERTABLE then
                        return _cache_result(other, Types.MATCH.CONVERTABLE);
                    fi
                od

                if is_wild \/ other.is_wild then
                    return _cache_result(other, Types.MATCH.WILD);
                fi

                return _cache_result(other, Types.MATCH.DIFFERENT);
            fi

            // FIXME: should we be caching this result?
            return Types.MATCH.DIFFERENT;            
        si

        find_member(name: string) -> Symbols.Symbol is
            if symbol? then
                return symbol.find_member(name);
            fi
        si

        find_ancestor(type: Type) -> Type is
            if symbol? then
                return symbol.find_ancestor(type);
            fi            
        si

        gen_class_name(buffer: System.Text.StringBuilder) is
            symbol.gen_class_name(buffer);
        si

        gen_type(buffer: System.Text.StringBuilder) is
            symbol.gen_type(buffer);
        si

        to_string() -> string is
            if symbol? then
                return symbol.qualified_name;
            else
                return "(null symbol) {name}";
            fi
        si
    si
si