namespace Semantic.Types is
    use IO.Std;

    // class TYPE_PAIR is
    //     t0: Type;
    //     t1: Type;

    //     init(t0: Type, t1: Type) is
    //         self.t0 = t0;
    //         self.t1 = t1;
    //     si

    //     get_hash_code() -> int =>
    //         t0.get_hash_code() + t1.get_hash_code() * 1024;

    //     equals(other: object) -> bool is
    //         if !other? \/ !isa TYPE_PAIR(other) then
    //             return false;
    //         fi

    //         return self =~ cast TYPE_PAIR(other);
    //     si        

    //     =~(other: TYPE_PAIR) -> bool =>
    //         t0 =~ other.t0 /\
    //         t1 =~ other.t1;
    // si

    // struct TYPE_STATS is
    //     equality_calls: int;
    //     compare_calls: int;

    //     init(equality_calls: int, compare_calls: int) is
    //         self.equality_calls = equality_calls;
    //         self.compare_calls = compare_calls;
    //     si        
    // si

    class NAMED: Type is
        name: string => symbol.name;
        scope: Scope => symbol;

        _hash: int;

        _symbol: Symbols.Symbol;

        symbol: Symbols.Symbol => _symbol;

        short_description: string is
            if symbol? then
                return symbol.name;
            else
                return "(undefined)";
            fi
        si

        is_type_variable: bool =>
            isa Symbols.TYPE(symbol);

        is_named: bool => true;
        is_value_type: bool => symbol? /\ symbol.is_value_type;
        is_trait: bool => symbol? /\ symbol.is_trait;
        is_inheritable: bool => symbol? /\ symbol.is_inheritable;
        is_class: bool => symbol? /\ symbol.is_class;
        is_object: bool => symbol? /\ symbol.is_object;

        init(symbol: Symbols.Symbol) is
            super.init();
            
            _symbol = symbol;
        si
        
        =~(other: Type) -> bool is
            // _count_equality(other);

            if other.is_any then
                return true;
            else 
                return other.is_named /\ symbol == other.symbol;
            fi
        si

        specialize(type_map: Collections.Map[string,Type]) -> Type is
            if type_map.contains_key(name) then
                return type_map[name];
            else
                return self;
            fi
        si

        // _compare_count: Collections.MutableMap[TYPE_PAIR,TYPE_STATS] static;

        // _increment_stats(other: Type, equality_increment: int, compare_increment: int) is
        //     if !_compare_count? then
        //         _compare_count = new Collections.MAP[TYPE_PAIR,TYPE_STATS]();
        //     fi

        //     let stats: TYPE_STATS;

        //     let key = new TYPE_PAIR(self,other);

        //     _compare_count.try_get_value(key, stats ref);

        //     _compare_count[key] = 
        //         new TYPE_STATS(
        //             stats.equality_calls + equality_increment,
        //             stats.compare_calls + compare_increment
        //         );
        // si

        // _count_equality(other: Type) is
        //     _increment_stats(other, 1, 0);
        // si
        
        // _count_compare(other: Type) is
        //     _increment_stats(other, 1, 0);
        // si

        // dump_stats(writer: IO.TextWriter) static is
        //     if !_compare_count? then
        //         writer.write_line("XXXXXXXX: no stats recorded");
        //         return;
        //     fi
 
        //     writer.write_line("QQQQQQQQ: some stats recorded: " + _compare_count.count);
 
        //     for kv in _compare_count do
        //         writer.write_line(
        //             "{0} {1} ~ {2} {3} ({4} {5}): {6} {7} {8} {9}", [
        //                 kv.key.t0, 
        //                 kv.key.t0.get_hash_code(),
        //                 kv.key.t1,
        //                 kv.key.t1.get_hash_code(),
        //                 kv.key.get_hash_code(),
        //                 kv.key =~ kv.key,
        //                 kv.value.equality_calls, 
        //                 kv.value.compare_calls
        //             ]: object
        //         );
        //     od
        // si

        compare(other: Type) -> Types.MATCH is
            // _count_compare(other);

            if other.is_null then
                return Types.MATCH.ASSIGNABLE;
            fi

            if symbol == null \/ other == null then
                return Types.MATCH.DIFFERENT;
            elif other.is_named then
                if symbol == other.symbol then
                    return Types.MATCH.SAME;
                fi

                let i: int;
                let osa = other.symbol.ancestors;
                let count = osa.count;

                while i < count do
                    let a = osa[i];

                    let match = self.compare(a);

                    if cast int(match) <= cast int(Types.MATCH.ASSIGNABLE) then
                        return Types.MATCH.ASSIGNABLE;
                    elif match == Types.MATCH.CONVERTABLE then
                        return Types.MATCH.CONVERTABLE;
                    fi
                    
                    i = i + 1;
                od
            fi

            return Types.MATCH.DIFFERENT;
        si

        find_member(name: string) -> Symbols.Symbol is
            if symbol? then
                return symbol.find_member(name);
            fi
        si

        find_ancestor(type: Type) -> Type is
            if symbol? then
                return symbol.find_ancestor(type);
            fi            
        si

        gen_class_name(buffer: System.Text.StringBuilder) is
            symbol.gen_class_name(buffer);
        si

        gen_type(buffer: System.Text.StringBuilder) is
            symbol.gen_type(buffer);
        si

        get_hash_code() -> int is
            return symbol.get_hash_code();
        si
        
        to_string() -> string is
            if symbol? then
                return symbol.qualified_name;
            else
                return "(null symbol) " + name;
            fi
        si
    si
si