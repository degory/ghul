namespace Semantic.Types is
    use IO.Std;

    use Logging;

    class NAMED: Type is
        _compare_count: int static;
        _same_count: int static;
        _named_count: int static;
        _hit_count: int static;
        _miss_count: int static;

        _cache: Collections.MutableMap[(int,int), Types.MATCH] static;

        name: string => symbol.name;
        scope: Scope => symbol;

        _symbol: Symbols.Symbol;

        symbol: Symbols.Symbol => _symbol;

        short_description: string =>
            if symbol? then
                symbol.name;
            else
                "(undefined)";
            fi;

        is_type_variable: bool =>
            symbol.is_type_variable;

        is_named: bool => true;

        is_value_type: bool => symbol? /\ symbol.is_value_type;
        is_trait: bool => symbol? /\ symbol.is_trait;
        is_inheritable: bool => symbol? /\ symbol.is_inheritable;
        is_class: bool => symbol? /\ symbol.is_class;
        is_object: bool => symbol? /\ symbol.is_object;
        is_void: bool => symbol? /\ symbol.is_void;

        init(symbol: Symbols.Symbol) is
            super.init();
            
            _symbol = symbol;
        si
        
        =~(other: Type) -> bool is
            debug("comparing {symbol} to {other.symbol}...");

            return 
                if other.is_any then
                    true;
                elif isa NAMED(other) then
                    let other_named = cast NAMED(other);
                    debug("comparing {symbol} ({symbol.get_type()} {symbol.get_hash_code()}) to {other_named.symbol} ({other_named.symbol.get_type()} {other_named.symbol.get_hash_code()}) result {symbol == other_named.symbol}");

                    symbol == other_named.symbol;
                else
                    debug("comparing {symbol} to {other} result false");
                    false;
                fi;
        si

        specialize(type_map: Collections.Map[string,Type]) -> Type =>
            if type_map.contains_key(name) then
                type_map[name];
            else
                self;
            fi;

        _cache_result(other: Type, result: Types.MATCH) -> Types.MATCH is
            _cache[(self.symbol.get_hash_code(), other.symbol.get_hash_code())] = result;

            return result;
        si

        dump_stats() static is
            IO.Std.error.write_line("cache size: {_cache.count} named ratio: {cast double(_hit_count) / cast double(_named_count)}");

            IO.Std.error.write_line("total: {_compare_count} named: {_named_count} same: {_same_count} misses: {_miss_count} hits: {_hit_count}");                
        si

        clear_cache() static is
            if _cache == null then
                _cache = new Collections.MAP[(int,int), Types.MATCH]();
            fi

            _cache.clear();
        si

        compare(other: Type) -> Types.MATCH is
            debug("comparing {self} to {other}...");

            _compare_count = _compare_count + 1;
            if other.is_any then
                return Types.MATCH.ASSIGNABLE;
            fi

            if other.is_null /\ !is_value_type then
                return Types.MATCH.ASSIGNABLE;
            fi

            if symbol == null then
                debug("comparing {self} to {other} result DIFFERENT (null symbol)");

                return Types.MATCH.DIFFERENT;
            elif other.is_named then
                debug("other is NAMED");

                _named_count = _named_count + 1;

                if symbol == other.symbol then
                    _same_count = _same_count + 1;
                    return Types.MATCH.SAME;
                fi

                debug("comparing {self} to {other} symbols are different {symbol.qualified_name} ({symbol.get_hash_code()}) vs {other.symbol.qualified_name} ({other.symbol.get_hash_code()})");
                
                let result: Types.MATCH;

                if _cache == null then
                    _cache = new Collections.MAP[(int,int),Types.MATCH]();
                fi

                if _cache.try_get_value((self.symbol.get_hash_code(), other.symbol.get_hash_code()), result ref) then
                    debug("return cached result {result}");
                    _hit_count = _hit_count + 1;
                    return result;
                fi

                _miss_count = _miss_count + 1;

                for a in other.symbol.ancestors do
                    debug("compare {self} to ancestor {a}...");
                    debug_indent();

                    let match = self.compare(a);

                    if cast int(match) <= cast int(Types.MATCH.ASSIGNABLE) then
                        return _cache_result(other, Types.MATCH.ASSIGNABLE);
                    elif match == Types.MATCH.CONVERTABLE then
                        return _cache_result(other, Types.MATCH.CONVERTABLE);
                    fi

                    debug_unindent();
                od

                if is_wild \/ other.is_wild then
                    debug("comparing {self} to {other} result WILD");
                    return _cache_result(other, Types.MATCH.WILD);
                fi

                debug("comparing {self} to {other} result DIFFERENT (no ancestor match)");
                return _cache_result(other, Types.MATCH.DIFFERENT);
            fi

            debug("comparing {self} to {other} result DIFFERENT (other is not named)");

            // FIXME: should we be caching this result?
            return Types.MATCH.DIFFERENT;            
        si

        find_member(name: string) -> Symbols.Symbol is
            if symbol? then
                return symbol.find_member(name);
            fi
        si

        find_ancestor(type: Type) -> Type is
            if symbol? then
                return symbol.find_ancestor(type);
            fi            
        si

        gen_class_name(buffer: System.Text.StringBuilder) is
            symbol.gen_class_name(buffer);
        si

        gen_type(buffer: System.Text.StringBuilder) is
            symbol.gen_type(buffer);
        si

        to_string() -> string =>
            if symbol? then
                symbol.qualified_name;
            else
                "(null symbol) {name}";
            fi;
    si
si