namespace Semantic.Types is
    use IO.Std;

    class NAMED: Type is
        name: string => symbol.name;
        scope: Scope => symbol;

        _symbol: Symbols.Symbol;

        symbol: Symbols.Symbol => _symbol;

        short_description: string is
            if symbol? then
                return symbol.name;
            else
                return "(undefined)";
            fi
        si

        is_type_variable: bool =>
            symbol.is_type_variable;

        is_named: bool => true;

        is_value_type: bool => symbol? /\ symbol.is_value_type;
        is_trait: bool => symbol? /\ symbol.is_trait;
        is_inheritable: bool => symbol? /\ symbol.is_inheritable;
        is_class: bool => symbol? /\ symbol.is_class;
        is_object: bool => symbol? /\ symbol.is_object;
        is_void: bool => symbol? /\ symbol.is_void;

        init(symbol: Symbols.Symbol) is
            super.init();
            
            _symbol = symbol;
        si
        
        =~(other: Type) -> bool is
            if other.is_any then
                return true;
            elif isa NAMED(other) then
                let other_symbol = cast NAMED(other);
                return symbol == other_symbol.symbol;
            fi
        si

        specialize(type_map: Collections.Map[string,Type]) -> Type is
            if type_map.contains_key(name) then
                return type_map[name];
            else
                return self;
            fi
        si

        compare(other: Type) -> Types.MATCH is
            if other.is_null then
                return Types.MATCH.ASSIGNABLE;
            fi

            if symbol == null \/ other == null then
                return Types.MATCH.DIFFERENT;
            elif other.is_named then
                if symbol == other.symbol then
                    return Types.MATCH.SAME;
                fi

                for a in other.symbol.ancestors do
                    let match = self.compare(a);

                    if cast int(match) <= cast int(Types.MATCH.ASSIGNABLE) then
                        return Types.MATCH.ASSIGNABLE;
                    elif match == Types.MATCH.CONVERTABLE then
                        return Types.MATCH.CONVERTABLE;
                    fi
                od

                if is_wild \/ other.is_wild then
                    return Types.MATCH.WILD;
                fi                
            fi

            return Types.MATCH.DIFFERENT;
        si

        find_member(name: string) -> Symbols.Symbol is
            if symbol? then 
                return symbol.find_member(name);
            fi
        si

        find_ancestor(type: Type) -> Type is
            if symbol? then
                return symbol.find_ancestor(type);
            fi            
        si

        gen_class_name(buffer: System.Text.StringBuilder) is
            symbol.gen_class_name(buffer);
        si

        gen_type(buffer: System.Text.StringBuilder) is
            symbol.gen_type(buffer);
        si
 
        to_string() -> string is
            if symbol? then
                return symbol.qualified_name;
            else
                return "(null symbol) " + name;
            fi
        si
    si
si