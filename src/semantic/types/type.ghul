namespace Semantic.Types is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System.Text.StringBuilder;

    use Source;

    trait SettableTyped: Typed is
        set_type(value: Type);
    si

    trait Typed is
        type: Type;
    si

    enum MATCH is
        SAME = 0,
        ASSIGNABLE = 1,
        CONVERTABLE = 2,
        DIFFERENT = 100000
    si

    class Type: object, Typed is
        scope: Scope => null;

        symbol: Symbols.Symbol is
            if scope? && isa Symbols.Symbol(scope) then
                return cast Symbols.Symbol(scope);
            else
                return Symbols.NONE.instance;
            fi
        si

        unspecialized_symbol: Symbols.Symbol is
            let s = scope;

            if s? then
                return s.unspecialized_symbol;
            fi
        si        

        type: Type => self;

        arguments: Collections.LIST[Type] => new Collections.LIST[Type](0);

        short_description: string => to_string();

        // FIXME: better than isa XXXX, but still should not need these:
        is_null: bool => false;
        is_any: bool => false;
        is_type_variable: bool => false;
        is_value_type: bool => false;
        is_inheritable: bool => false;
        is_class: bool => false;
        is_trait: bool => false;

        init() is
        si

        =~(other: Type) -> bool => false;

        is_assignable_from(other: Type) -> bool
            => compare(other) <= MATCH.ASSIGNABLE;

        compare(other: Type) -> MATCH
            => MATCH.DIFFERENT;

        find_member(name: string) -> Symbols.Symbol
            => null;

        find_ancestor(type: Type) -> Type => null;        

        specialize(type_map: Collections.MAP[string,Type]) -> Type is
            throw new System.NotImplementedException("not implemented by " + self.get_type());
        si

        get_il_type() -> string is
            let result = new StringBuilder();

            gen_type(result);

            return result.to_string();
        si

        get_il_class_name() -> string is
            let result = new StringBuilder();

            gen_class_name(result);

            return result.to_string();
        si
        
        // output IL name for this type in a normal context:
        gen_type(buffer: StringBuilder) is
            throw new System.NotImplementedException("not implemented by " + self.get_type());
        si

        // output IL name for this type in a context that requires a 'class name' (i.e. a type without 'class' or 'valuetype' prefix)
        gen_class_name(buffer: StringBuilder) is
            throw new System.NotImplementedException("not implemented by " + self.get_type());
        si

        format(result: StringBuilder) is
            result.append(self);
        si
    si

    class NONE: Type is
        _instance: NONE static;

        instance: NONE static is
            if !_instance? then
                _instance = new NONE();
            fi

            return _instance;
        si
        
        init() is
            super.init();
        si

        =~(other: Type) -> bool
            => false;

        compare(other: Type) -> Types.MATCH
            => MATCH.DIFFERENT;

        to_string() -> string => "!!!";
    si

    class ANY: Type is
        is_null: bool => true;
        is_any: bool => true;

        init() is
            super.init();
        si

        specialize(type_map: Collections.MAP[string,Type]) -> Type => self;

        =~(other: Type) -> bool
            => true;

        compare(other: Type) -> Types.MATCH
            => MATCH.ASSIGNABLE;

        to_string() -> string => "***";
    si

    class NULL: Type is
        is_null: bool => true;
        is_any: bool => false;

        init() is
            super.init();
        si

        specialize(type_map: Collections.MAP[string,Type]) -> Type => self;

        =~(other: Type) -> bool
            => true;

        compare(other: Type) -> Types.MATCH
            => MATCH.ASSIGNABLE;

        to_string() -> string => "null";
    si

    class ACTION_0: NAMED is
        init(
            // location: LOCATION,
            symbol: Symbols.Classy
        ) is
            super.init(symbol);
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy
        ) -> ACTION_0 is
            return new ACTION_0(symbol);
        si

        to_string() -> string => "() -> void";
    si

    class FUNCTION: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(location, symbol, arguments);
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new FUNCTION(location, symbol, arguments);
        si

        to_string() -> string is
            let result = new System.Text.StringBuilder();

            if arguments.count == 2 then
                result
                    .append(arguments[0])
                    .append(" -> ")
                    .append(arguments[1]);
            elif arguments.count == 1 then
                result
                    .append("() -> ")
                    .append(arguments[0]);
            else
                result.append('(');

                for i in 0..arguments.count do
                    result.append(arguments[i]);

                    if i == arguments.count - 2 then
                        result.append(") -> ");
                    elif i != arguments.count - 1 then
                        result.append(',');
                    fi
                od
            fi

            return result.to_string();
        si
    si

    class TUPLE: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(location, symbol, arguments);
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new TUPLE(location, symbol, arguments);
        si

        to_string() -> string =>
            "(" + new Shim.JOIN[Type](arguments) + ")";
    si

    class ARRAY: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(new Symbols.ARRAY(location, symbol, arguments[0]));
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new Types.ARRAY(location, symbol, arguments);
        si

        gen_class_name(buffer: System.Text.StringBuilder) is
            gen_type(buffer);
        si

        gen_type(buffer: System.Text.StringBuilder) is
            arguments[0].gen_type(buffer);
            buffer.append("[] ");
        si

        to_string() -> string =>
            arguments[0].to_string() + "[]";
    si

    class POINTER: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(new Symbols.POINTER(location, symbol, arguments[0]));
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new Types.POINTER(location, symbol, arguments);
        si

        gen_class_name(buffer: System.Text.StringBuilder) is
            gen_type(buffer);
        si

        gen_type(buffer: System.Text.StringBuilder) is
            arguments[0].gen_type(buffer);
            buffer.append("* ");
        si

        to_string() -> string =>
            arguments[0].to_string() + " ptr";
    si

    class REFERENCE: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(new Symbols.REFERENCE(location, symbol, arguments[0]));
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new Types.REFERENCE(location, symbol, arguments);
        si

        gen_class_name(buffer: System.Text.StringBuilder) is
            gen_type(buffer);
        si

        gen_type(buffer: System.Text.StringBuilder) is
            arguments[0].gen_type(buffer);
            buffer.append("& ");
        si

        to_string() -> string =>
            arguments[0].to_string() + " ref";
    si

    class ENUM: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(location, symbol, arguments);
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new Types.ENUM(location, symbol, arguments);
        si

        to_string() -> string =>
            arguments[0].to_string();
    si

    class FUNCTION_GROUP: Type is
        name: string;

        function_group: Symbols.FUNCTION_GROUP;

        init(name: string, function_group: Symbols.FUNCTION_GROUP) is
            super.init();

            self.name = name;
            self.function_group = function_group;
        si

        =~(other: Type) -> bool is
            if isa FUNCTION_GROUP(other) then
                let other_function_group = cast FUNCTION_GROUP(other);
                return function_group == other_function_group.function_group;
            fi
        si

        to_string() -> string =>
            name + "(...)";
    si
si