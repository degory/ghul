namespace Semantic is
    use IO.Std;

    
    use Logging;

    use Types.Type;

    use IR.Values;

    class FUNCTION_CALLER is
        _symbol_table: SYMBOL_TABLE;
        _symbol_table_state: SYMBOL_TABLE_STATE;

        _value_boxer: IR.VALUE_BOXER;

        init(
            symbol_table: SYMBOL_TABLE,
            symbol_table_state: SYMBOL_TABLE_STATE,
            value_boxer: IR.VALUE_BOXER
        )
        is
            super.init();

            _value_boxer = value_boxer;
            _symbol_table_state = symbol_table_state;
            _symbol_table = symbol_table;
        si

        call_innate_function(
            function: Symbols.INNATE_FUNCTION, 
            arguments: Collections.LIST[Value],
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value =>
            new Call.INNATE(
                function,
                null,
                arguments,
                type
            );        

        call_innate_function(
            function: Symbols.INNATE_METHOD, 
            from: Value, 
            arguments: Collections.LIST[Value],
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value =>
            new Call.INNATE(
                function,
                from,
                arguments,
                type
            );        
    
        call_global_function(
            function: Symbols.Function, 
            arguments: Collections.LIST[Value], 
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value =>
            new Call.GLOBAL(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );        

        call_instance_method(
            location: Source.LOCATION,
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.LIST[Value], 
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value is

            if !from? then
                let context = _symbol_table_state.current_function;

                if !context? then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance member from non-function context");                    
                elif !context.is_instance then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance member from static context");
                fi
            fi
            
            if from == null then
                from = new Load.SELF(_symbol_table_state.current_instance_context);
            fi

            return 
                new Call.INSTANCE(
                    _value_boxer.box_if_value(from),
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_struct_method(
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.LIST[Value], 
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value is
            if from == null then
                from = new Load.SELF(_symbol_table_state.current_instance_context);
            else
                from = new ADDRESS(from);
            fi

            return 
                new Call.STRUCT(
                    from,
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_abstract_method(
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.LIST[Value], 
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value is
            if from == null then
                from = new Load.SELF(_symbol_table_state.current_instance_context);
            elif from.is_value_type then
                from = new ADDRESS(from);
            fi

            return 
                new Call.INSTANCE(
                    from,
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_static_method(
            function: Symbols.Function,
            arguments: Collections.LIST[Value],
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value =>
            new Call.STATIC(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );
    si
si