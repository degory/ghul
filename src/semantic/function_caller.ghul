namespace Semantic is
    use System;
    use Generic;

    use Logging;

    class VALUE_BOXER is
        init() is
            super.init();
        si

        box_if_value(value: Graph.Value.BASE) -> Graph.Value.BASE is
            if value.is_value_type then
                return new Graph.Value.BOX(value);
            else
                return value;
            fi
        si
        
        box_arguments(arguments: List[Graph.Value.BASE], argument_types: List[Type.BASE]) -> List[Graph.Value.BASE] is
            let any_need_boxing = false;

            let result = new Vector[Graph.Value.BASE](arguments.Length);

            for i in 0..arguments.Length do
                if !argument_types[i]? || !arguments[i]? || !arguments[i].has_type then
                    IO.Std.err.println("cannot box incomplete arguments: " + arguments + " / " + argument_types);

                    return arguments;
                fi

                if !argument_types[i].is_value_type && arguments[i].type.is_value_type then
                    any_need_boxing = true;
                    break;
                fi
            od

            if !any_need_boxing then
                return arguments;
            fi

            for i in 0..arguments.Length do
                if !argument_types[i].is_value_type && arguments[i].type.is_value_type then
                    result.add(new Graph.Value.BOX(arguments[i]));
                fi
            od
        si
    si    

    class FUNCTION_CALLER is
        _symbol_table: SYMBOL_TABLE;
        _value_boxer: VALUE_BOXER;

        init(symbol_table: SYMBOL_TABLE) is
            super.init();

            // FIXME: IoC

            _value_boxer = new VALUE_BOXER();
            _symbol_table = symbol_table;
        si

        call_innate_function(
            function: Symbol.INNATE_FUNCTION, 
            arguments: List[Graph.Value.BASE],
            argument_types: List[Type.BASE],
            type: Type.BASE
        ) -> Graph.Value.BASE =>
            new Graph.Value.Call.INNATE(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );        

        call_global_function(
            function: Symbol.Function, 
            arguments: List[Graph.Value.BASE], 
            argument_types: List[Type.BASE],
            type: Type.BASE
        ) -> Graph.Value.BASE =>
            new Graph.Value.Call.GLOBAL(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );        

        call_instance_method(
            from: Graph.Value.BASE, 
            function: Symbol.Function, 
            arguments: List[Graph.Value.BASE], 
            argument_types: List[Type.BASE],
            type: Type.BASE
        ) -> Graph.Value.BASE is
            if from == null then
                from = new Graph.Value.Load.SELF(_symbol_table.current_instance_context);
            fi

            return 
                new Graph.Value.Call.INSTANCE(
                    _value_boxer.box_if_value(from),
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_static_method(
            function: Symbol.Function,
            arguments: List[Graph.Value.BASE],
            argument_types: List[Type.BASE],
            type: Type.BASE
        ) -> Graph.Value.BASE =>
            new Graph.Value.Call.STATIC(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );
    si
si