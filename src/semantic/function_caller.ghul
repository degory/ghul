namespace Semantic is
    use IO.Std;

    
    use Logging;

    use Types.Type;

    use IR.Values;

    class FUNCTION_CALLER is
        _symbol_table: SYMBOL_TABLE;
        _value_boxer: IR.VALUE_BOXER;

        init(
            symbol_table: SYMBOL_TABLE,
            value_boxer: IR.VALUE_BOXER
        )
        is
            super.init();

            _value_boxer = value_boxer;
            _symbol_table = symbol_table;
        si

        call_innate_function(
            function: Symbols.INNATE_FUNCTION, 
            arguments: Collections.LIST[Value],
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value =>
            new Call.INNATE(
                function,
                null,
                arguments,
                type
            );        

        call_innate_function(
            function: Symbols.INNATE_METHOD, 
            from: Value, 
            arguments: Collections.LIST[Value],
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value =>
            new Call.INNATE(
                function,
                from,
                arguments,
                type
            );        
    
        call_global_function(
            function: Symbols.Function, 
            arguments: Collections.LIST[Value], 
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value =>
            new Call.GLOBAL(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );        

        call_instance_method(
            location: Source.LOCATION,
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.LIST[Value], 
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value is
            if from == null then
                // FIXME: IoC
                let loader = IoC.CONTAINER.instance.symbol_loader;

                from = loader.load_self(location);
            fi

            return 
                new Call.INSTANCE(
                    _value_boxer.box_if_value(from),
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_struct_method(
            location: Source.LOCATION,
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.LIST[Value], 
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value is
            if from == null then
                // FIXME: IoC
                let loader = IoC.CONTAINER.instance.symbol_loader;

                from = loader.load_self(location);
            else
                from = new ADDRESS(from);
            fi

            return 
                new Call.STRUCT(
                    from,
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_abstract_method(
            location: Source.LOCATION,
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.LIST[Value], 
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value is
            if from == null then
                // FIXME: IoC
                let loader = IoC.CONTAINER.instance.symbol_loader;

                from = loader.load_self(location);
            elif from.is_value_type then
                from = new ADDRESS(from);
            fi

            return 
                new Call.INSTANCE(
                    from,
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_static_method(
            function: Symbols.Function,
            arguments: Collections.LIST[Value],
            argument_types: Collections.LIST[Type],
            type: Type
        ) -> Value =>
            new Call.STATIC(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );
    si
si