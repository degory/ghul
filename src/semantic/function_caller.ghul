namespace Semantic is
    use IO.Std;

    use Logging;

    use Types.Type;

    use IR.Values;

    class FUNCTION_CALLER is
        _symbol_table: SYMBOL_TABLE;
        _value_boxer: IR.VALUE_BOXER;

        // public so container can initialize it to break a
        // circular dependency:
        loader: SYMBOL_LOADER public;

        init(
            symbol_table: SYMBOL_TABLE,
            value_boxer: IR.VALUE_BOXER
        )
        is
            super.init();

            _value_boxer = value_boxer;
            _symbol_table = symbol_table;
        si

        call_innate_function(
            function: Symbols.INNATE_FUNCTION, 
            arguments: Collections.List[Value],
            argument_types: Collections.List[Type],
            type: Type
        ) -> Value =>
            Call.INNATE(
                function,
                null,
                arguments,
                type
            );

        call_innate_function(
            function: Symbols.INNATE_METHOD, 
            from: Value, 
            arguments: Collections.List[Value],
            argument_types: Collections.List[Type],
            type: Type
        ) -> Value =>
            Call.INNATE(
                function,
                from,
                arguments,
                type
            );

        call_global_function(
            function: Symbols.Function, 
            arguments: Collections.List[Value], 
            argument_types: Collections.List[Type],
            type: Type
        ) -> Value =>
            Call.GLOBAL(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );        

        call_instance_method(
            location: Source.LOCATION,
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.List[Value], 
            argument_types: Collections.List[Type],
            type: Type
        ) -> Value is
            if from == null then
                from = loader.load_self(location);
            fi

            if from.type.is_type_variable then
                from = CONSTRAINED(from);
            fi

            return 
                Call.INSTANCE(
                    _value_boxer.box_if_value(from),
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_struct_method(
            location: Source.LOCATION,
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.List[Value], 
            argument_types: Collections.List[Type],
            type: Type
        ) -> Value is
            if from == null then
                from = loader.load_self(location);
            else
                from = ADDRESS(from);
            fi

            return 
                Call.STRUCT(
                    from,
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_abstract_method(
            location: Source.LOCATION,
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.List[Value], 
            argument_types: Collections.List[Type],
            type: Type
        ) -> Value is
            if from == null then
                from = loader.load_self(location);
            elif from.is_value_type then
                // Don't believe this is possible in practice except
                // for calls to IDisposable.Dispose() generated by the
                // compiler for `let use` statements.
                from = CONSTRAINED(from);
            fi

            return 
                Call.INSTANCE(
                    from,
                    function,
                    _value_boxer.box_arguments(arguments, function.arguments),
                    type
                );
        si

        call_static_method(
            function: Symbols.Function,
            arguments: Collections.List[Value],
            argument_types: Collections.List[Type],
            type: Type
        ) -> Value =>
            Call.STATIC(
                function,
                _value_boxer.box_arguments(arguments, function.arguments),
                type
            );

        call_extension_method(
            location: Source.LOCATION,
            from: Value, 
            function: Symbols.Function, 
            arguments: Collections.List[Value], 
            argument_types: Collections.List[Type],
            type: Type
        ) -> Value is
            if from == null then
                IoC.CONTAINER.instance.logger.error(location, "extension method call must have explicit self");
                from = loader.load_self(location);
            fi

            if from.type.is_type_variable then
                from = CONSTRAINED(from);
            fi

            let actual_arguments = Collections.LIST[Value](arguments.count + 1);

            actual_arguments.add(from);
            actual_arguments.add_range(arguments);

            return 
                Call.STATIC(
                    function,
                    _value_boxer.box_arguments(actual_arguments, function.arguments),
                    type
                );
        si
    
    si
si