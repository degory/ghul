namespace Semantic.Types is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System;
    
    use Source;

    trait SettableTyped: Typed is
        set_type(value: Type);
    si

    trait Typed is
        type: Type;
    si

    enum MATCH is
        SAME = 0,
        ASSIGNABLE = 1,
        CONVERTABLE = 2,
        DIFFERENT = 100000
    si

    class Type: object, Typed is
        scope: Scope => null;

        symbol: Symbols.Symbol is
            if scope? && isa Symbols.Symbol(scope) then
                return cast Symbols.Symbol(scope);
            else
                return Symbols.NONE.instance;
            fi
        si

        unspecialized_symbol: Symbols.Symbol is
            let s = scope;

            if s? then
                return s.unspecialized_symbol;
            fi
        si        

        type: Type => self;

        arguments: Collections.LIST[Type] => new Collections.LIST[Type](0);

        short_description: string => to_string();

        // FIXME: better than isa XXXX, but still should not need these:
        is_null: bool => false;
        is_any: bool => false;
        is_type_variable: bool => false;
        is_value_type: bool => false;
        is_inheritable: bool => false;
        is_class: bool => false;
        is_trait: bool => false;

        init() is
        si

        =~(other: Type) -> bool => false;

        is_assignable_from(other: Type) -> bool
            => compare(other) <= MATCH.ASSIGNABLE;

        compare(other: Type) -> MATCH
            => MATCH.DIFFERENT;

        find_member(name: string) -> Symbols.Symbol
            => null;

        find_ancestor(type: Type) -> Type => null;        

        specialize(type_map: Collections.MAP[string,Type]) -> Type is
            throw new System.NotImplementedException("specialize " + self.get_type());
        si

        il_type_name: string => "unknown";
        il_token_name: string => "unknown";
    si

    class NONE: Type is
        _instance: NONE static;

        instance: NONE static is
            if !_instance? then
                _instance = new NONE();
            fi

            return _instance;
        si
        
        init() is
            super.init();
        si

        =~(other: Type) -> bool
            => false;

        compare(other: Type) -> Types.MATCH
            => MATCH.DIFFERENT;

        il_type_name: string => "none";

        to_string() -> string => "!!!";
    si

    class ANY: Type is
        il_type_name: string => "any";

        is_null: bool => true;
        is_any: bool => true;

        init() is
            super.init();
        si

        specialize(type_map: Collections.MAP[string,Type]) -> Type => self;

        =~(other: Type) -> bool
            => true;

        compare(other: Type) -> Types.MATCH
            => MATCH.ASSIGNABLE;

        to_string() -> string => "***";
    si

    class NULL: Type is
        il_type_name: string => "null";

        is_null: bool => true;
        is_any: bool => false;

        init() is
            super.init();
        si

        specialize(type_map: Collections.MAP[string,Type]) -> Type => self;

        =~(other: Type) -> bool
            => true;

        compare(other: Type) -> Types.MATCH
            => MATCH.ASSIGNABLE;

        to_string() -> string => "null";
    si

    class NAMED: Type is
        name: string => symbol.name;

        scope: Scope => symbol;

        symbol: Symbols.Symbol;

        arguments: Collections.LIST[Type] => new Collections.LIST[Type](0);

        short_description: string is
            if symbol? then
                return symbol.name;
            else
                return "(undefined)";
            fi
        si

        is_type_variable: bool =>
            isa Symbols.TYPE(symbol);

        is_value_type: bool => symbol? && symbol.is_value_type;
        is_trait: bool => symbol? && symbol.is_trait;
        is_inheritable: bool => symbol? && symbol.is_inheritable;
        is_class: bool => symbol? && symbol.is_class;

        il_type_name: string => symbol.il_type_name;
        il_token_name: string => symbol.il_token_name;

        init(symbol: Symbols.Symbol) is
            super.init();
            
            self.symbol = symbol;
        si

        specialize(type_map: Collections.MAP[string,Type]) -> Type is
            if type_map.contains_key(name) then
                return type_map[name];
            else
                return self;
            fi
        si

        =~(other: Type) -> bool is
            if isa NAMED(other) then
                let other_symbol = cast NAMED(other);
                return symbol == other_symbol.symbol;
            fi
        si

        compare_tuple(other: GENERIC) -> Types.MATCH is

        si

        compare(other: Type) -> Types.MATCH is
            if other.is_null then
                return Types.MATCH.ASSIGNABLE;
            fi

            if symbol == null || other == null then
                return Types.MATCH.DIFFERENT;
            elif isa NAMED(other) then
                let other_named = cast NAMED(other);
              
                if symbol == other_named.symbol then
                    return Types.MATCH.SAME;
                fi

                for a in other_named.symbol.ancestors do
                    let match = self.compare(a);

                    if match <= Types.MATCH.ASSIGNABLE then
                        return Types.MATCH.ASSIGNABLE;
                    elif match == Types.MATCH.CONVERTABLE then
                        return Types.MATCH.CONVERTABLE;
                    fi
                od
            fi

            return Types.MATCH.DIFFERENT;
        si

        find_member(name: string) -> Symbols.Symbol is
            if symbol? then
                return symbol.find_member(name);
            fi
        si

        find_ancestor(type: Type) -> Type is
            if symbol? then
                return symbol.find_ancestor(type);
            fi            
        si

        to_string() -> string is
            if symbol? then
                return symbol.qualified_name;
            else
                return "(null symbol) " + name;
            fi
        si
    si

    class GENERIC: NAMED is
        arguments: Collections.LIST[Type] => cast Symbols.GENERIC(symbol).arguments;
        ancestors: Collections.LIST[Type] => cast Symbols.GENERIC(symbol).ancestors;

        short_description: string is
            assert self? else "self is null";
            assert symbol? else "symbol is null";
            assert symbol.name? else "symbol.name is null";
            assert arguments? else "arguments is null";

            let result = new System.Text.StringBuilder();

            result
                .append(symbol.name)
                .append('[');

            var seen_any = false;

            for a in arguments do
                assert a? else "argument is null";

                if seen_any then
                    result.append(',');
                fi

                if a? then
                    result.append(a.short_description);
                fi

                seen_any = true;
            od

            result.append(']');

            return result.to_string();
        si

        init(
            symbol: Symbols.GENERIC
        ) is
            super.init(symbol);
        si
        
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(new Symbols.GENERIC(location, symbol, arguments));
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC
        is
            let result = new GENERIC(location, symbol, arguments);
            
            return result;
        si

        specialize_generic(type_map: Collections.MAP[string,Type]) -> Types.GENERIC is
            let context = IoC.CONTAINER.instance.symbol_table.current_instance_context;

            let we_are_generic = context.arguments.count > 0;
            
            var seen_any_new = false;

            let generic_symbol = cast Symbols.GENERIC(symbol);

            let new_arguments = new Collections.LIST[Type](arguments.count);

            for i in 0..arguments.count do
                let argument_name
                    = generic_symbol.symbol.argument_names[i];

                let mapped_type: Type;

                // FIXME: this seems to fix #118 but don't think this is the correct place to put this check:
                if we_are_generic && type_map.contains_key(argument_name) then
                    mapped_type = type_map[argument_name];
                fi
                
                if mapped_type? then
                    new_arguments.add(mapped_type);

                    seen_any_new = true;
                else
                    let oa = generic_symbol.arguments[i];
                    let na = oa.specialize(type_map);
                    new_arguments.add(na);

                    if oa != na then
                        seen_any_new = true;
                    fi
                fi
            od

            if seen_any_new then
                let result = create(symbol.location, generic_symbol.symbol, new_arguments);

                return result;
            else
                return self;
            fi
        si

        specialize(type_map: Collections.MAP[string,Type]) -> Type =>
            specialize_generic(type_map);

        =~(other: Type) -> bool is
            if !isa GENERIC(other) then
                return false;
            fi

            let generic_other = cast GENERIC(other);

            if symbol == generic_other.symbol then
                return true;
            fi

            let generic_symbol = cast Symbols.GENERIC(symbol);
            let generic_other_symbol = cast Symbols.GENERIC(generic_other.symbol);

            if generic_symbol.symbol != generic_other_symbol.symbol then
                return false;
            fi

            if generic_symbol.arguments.count != generic_other_symbol.arguments.count then
                return false;
            fi

            for i in 0..generic_symbol.arguments.count do
                // TODO: implement type variance here:
                if generic_symbol.arguments[i] !~ generic_other_symbol.arguments[i] then
                    return false;
                fi
            od

            return true;
        si

        compare(other: Type) -> Types.MATCH is
            if other.is_null then
                return Types.MATCH.ASSIGNABLE;
            elif symbol == null || other == null then
                return Types.MATCH.DIFFERENT;
            /*
            elif isa GENERIC(other) then
                let other_generic = cast GENERIC(other);
            */
            elif isa NAMED(other) then
                let other_named = cast NAMED(other);

                if self =~ other then
                    return Types.MATCH.SAME;
                fi

                for i in 0..other_named.symbol.ancestors.count do
                    let a = other_named.symbol.get_ancestor(i);

                    let match = self.compare(a);

                    if match <= Types.MATCH.ASSIGNABLE then
                        return Types.MATCH.ASSIGNABLE;
                    elif match == Types.MATCH.CONVERTABLE then
                        return Types.MATCH.CONVERTABLE;
                    fi
                od

                /*
                if other_named.name =~ "TUPLE_1" then
                    Std.error.write_line("possible tuple match: " + self + " vs " + other);

                    let match = self.compare(other_named.arguments[0]);

                    Std.error.write_line("tuple match score: " + self + " vs " + other_named.arguments[0] + " = " + match);

                    if match <= Types.MATCH.ASSIGNABLE then
                        return Types.MATCH.ASSIGNABLE;
                    elif match == Types.MATCH.CONVERTABLE then
                        return Types.MATCH.CONVERTABLE;
                    fi
                fi
                */
            fi

            return Types.MATCH.DIFFERENT;
        si

        get_hash_code() -> int => symbol.get_hash_code();

        to_string() -> string => symbol.to_string();
    si

    class ACTION_0: NAMED is
        init(
            // location: LOCATION,
            symbol: Symbols.Classy
        ) is
            super.init(symbol);
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy
            // FIXME: this ACTION_0 should be in scope here:
        ) -> Semantic.Types.ACTION_0 is
            return new Semantic.Types.ACTION_0(symbol);
        si

        to_string() -> string => "() -> void";
    si

    class FUNCTION: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(location, symbol, arguments);
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new FUNCTION(location, symbol, arguments);
        si

        to_string() -> string is
            let result = new System.Text.StringBuilder();

            if arguments.count == 2 then
                result
                    .append(arguments[0])
                    .append(" -> ")
                    .append(arguments[1]);
            elif arguments.count == 1 then
                result
                    .append("() -> ")
                    .append(arguments[0]);
            else
                result.append('(');

                for i in 0..arguments.count do
                    result.append(arguments[i]);

                    if i == arguments.count - 2 then
                        result.append(") -> ");
                    elif i != arguments.count - 1 then
                        result.append(',');
                    fi
                od
            fi

            return result.to_string();
        si
    si

    class TUPLE: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(location, symbol, arguments);
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new TUPLE(location, symbol, arguments);
        si

        to_string() -> string =>
            "(" + new Shim.JOIN[Type](arguments) + ")";
    si

    class ARRAY: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(new Symbols.ARRAY(location, symbol, arguments[0]));
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new Types.ARRAY(location, symbol, arguments);
        si

        to_string() -> string =>
            arguments[0].to_string() + "[]";
    si

    class POINTER: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(new Symbols.POINTER(location, symbol, arguments[0]));
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new Types.POINTER(location, symbol, arguments);
        si

        to_string() -> string =>
            arguments[0].to_string() + " ptr";
    si

    class REFERENCE: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(new Symbols.REFERENCE(location, symbol, arguments[0]));
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new Types.REFERENCE(location, symbol, arguments);
        si

        to_string() -> string =>
            arguments[0].to_string() + " ref";
    si

    class ENUM: GENERIC is
        init(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) is
            super.init(location, symbol, arguments);
        si

        create(
            location: LOCATION,
            symbol: Symbols.Classy,
            arguments: Collections.LIST[Type]
        ) -> GENERIC is
            return new Types.ENUM(location, symbol, arguments);
        si

        to_string() -> string =>
            arguments[0].to_string();
    si

    class INTEGER: NAMED is
        signed: bool => true;

        bits: int is
            throw new System.NotImplementedException();
        si

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class FLOAT: NAMED is
        signed: bool => true;

        bits: int is
            throw new System.NotImplementedException();
        si

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class BOOL: NAMED is
        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class CHAR: INTEGER is
        bits: int => 8;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class BYTE: INTEGER is
        bits: int => 8;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class UBYTE: INTEGER is
        signed: bool => false;
        bits: int => 8;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class SHORT: INTEGER is
        bits: int => 16;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class USHORT: INTEGER is
        signed: bool => false;
        bits: int => 16;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class INT: INTEGER is
        bits: int => 32;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class UINT: INTEGER is
        signed: bool => false;
        bits: int => 32;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class LONG: INTEGER is
        bits: int => 64;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class ULONG: INTEGER is
        signed: bool => false;
        bits: int => 64;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class WORD: INTEGER is
        // FIXME: should be target dependent:
        bits: int => 64;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class UWORD: INTEGER is
        signed: bool => false;
        // FIXME: should be target dependent:
        bits: int => 64;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class SINGLE: FLOAT is
        bits: int => 32;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class DOUBLE: FLOAT is
        bits: int => 64;

        init(symbol: Semantic.Symbols.Symbol) is
            super.init(symbol);
        si
    si

    class FUNCTION_GROUP: Type is
        name: string;

        function_group: Symbols.FUNCTION_GROUP;

        init(name: string, function_group: Symbols.FUNCTION_GROUP) is
            super.init();

            self.name = name;
            self.function_group = function_group;
        si

        =~(other: Type) -> bool is
            if isa FUNCTION_GROUP(other) then
                let other_function_group = cast FUNCTION_GROUP(other);
                return function_group == other_function_group.function_group;
            fi
        si

        to_string() -> string =>
            name + "(...)";
    si
si