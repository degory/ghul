namespace Semantic is
    use IO.Std;

    use Collections.Iterable;
    use Collections.Iterator;

    use Collections.SET;

    use Pair = Collections.KeyValuePair`2;

    use Symbols.Symbol;
    use Symbols.Classy;
    use Symbols.Function;
    use Symbols.FUNCTION_GROUP;
    use Symbols.TYPE;

    use Types.Type;
    
    class SYMBOL_INHERITANCE_RESOLVER is
        into: Classy;

        init(into: Classy) is
            self.into = into;
        si
        
        pull_into() is
            if into.name =~ "NpgsqlDataSource" then
                IO.Std.error.write_line("pull_into: " + into.name);                
            fi

            let logger = IoC.CONTAINER.instance.logger;
            
            let overridees = new Collections.MAP[string,METHOD_OVERRIDE_MAP]();

            let members = into.get_all_direct_ancestor_members();

            for symbol in members do
                let overridees_with_this_name: METHOD_OVERRIDE_MAP;

                if overridees.contains_key(symbol.name) then
                    overridees_with_this_name = overridees[symbol.name];
                else
                    overridees_with_this_name = new METHOD_OVERRIDE_MAP(symbol.name);
                    overridees[symbol.name] = overridees_with_this_name;
                fi

                overridees_with_this_name.add(symbol);
            od

            for p in overridees do
                let overridee_name = p.key;
                let overridee_map = p.value;

                if overridee_name =~ "CreateCommand" then
                    IO.Std.error.write_line("overridee_name: " + overridee_name);
                fi

                let overriders = get_overriders_map_for(overridee_name);
                
                let overrider_other_symbol = overriders.symbols| .first().value;

                let overridee_other_symbols = overridee_map.symbols;
                
                if overridee_map.contains_any_methods then
                    for overridee_list in overridee_map do
                        let overrider_list = overriders[overridee_list.override_class];

                        if overridee_name =~ "CreateCommand" then
                            IO.Std.error.write_line("overrider_list: " + overrider_list);
                        fi
                        
                        try_inherit(
                            overridee_name,
                            overrider_list, 
                            overrider_other_symbol,
                            overridee_list, 
                            overridee_other_symbols,                        
                            logger
                        );
                    od
                elif overridee_map.contains_any_symbols /\ !overriders.contains_any_methods then
                    if overridee_name =~ "CreateCommand" then
                        IO.Std.error.write_line("symbols but no methods: " + overridee_name);
                    fi

                    try_inherit(
                        overridee_name,
                        overrider_other_symbol,
                        overridee_other_symbols,
                        logger
                    );

                elif overridee_name =~ "CreateCommand" then
                    IO.Std.error.write_line("no methods: " + overridee_name);
                fi
            od  
        si
        
        try_inherit(
            name: string,
            overriders: METHOD_OVERRIDE_SET, 
            other_overrider_symbol: Symbol,
            overridees: METHOD_OVERRIDE_SET, 
            other_overridee_symbols: Iterable[Symbol],
            logger: Logging.Logger
        )
        is
            let is_stub = into.is_stub;
            let other_overridee_symbols_count = other_overridee_symbols| .count();
            let overriding_method: Function;

            // IO.Std.error.write_line("try_inherit: " + name + " " + overriders + " " + other_overrider_symbol + " " + overridees + " " + other_overridee_symbols_count);

            if overriders? then
                overriding_method = overriders.get_overrider(into);
            fi

            if overriding_method? then
                for f in overridees.iterable do
                    // check if we can/do override, implement or hide it:
                    overriding_method.try_override(into, f, logger);
                od

                if !is_stub then
                    // for all non-method symbols in superclasses/traits:
                    for os in other_overridee_symbols do
                        logger.warn(overriding_method.location, "hides " + os + " (case A)");
                    od
                fi
            elif other_overrider_symbol? then
                if !is_stub then
                    for f in overridees.iterable do    
                        logger.warn(other_overrider_symbol.location, "hides " + f + " (case B)");
                    od
    
                    for os in other_overridee_symbols do
                        logger.warn(other_overrider_symbol.location, "hides " + os + " (case C)");
                    od                        
                fi
            elif other_overridee_symbols_count == 1 /\ overridees.count != 0 then
                into.add_member(other_overridee_symbols| .first().value);
            elif other_overridee_symbols_count > 0 then
                let all_symbols = new Collections.LIST[Symbol]();

                all_symbols.add_range(         
                    overridees.iterable |
                        .map(function -> Symbol => function)
                );

                all_symbols.add_range(other_overridee_symbols);

                logger.error(into.location, 
                    "cannot inherit multiple symbols with the same name: " + all_symbols| .sort()
                );
            else
                let concrete_method: Function;

                if overridees.count == 1 then
                    let first = overridees.iterable| .first().value;

                    first.try_pull_down_into(into, other_overridee_symbols, logger);
                elif overridees.count == 0 then
                    if other_overridee_symbols_count == 0 then
                        // nothing to do
                    elif other_overridee_symbols_count == 1 then
                        // exactly one method symbol with this name: pull it down:

                        let first = other_overridee_symbols| .first().value;

                        first.try_pull_down_into(into, other_overridee_symbols, logger);
                    else
                        for os in other_overridee_symbols do
                            os.try_pull_down_into(into, other_overridee_symbols, logger);                            
                        od
                        
                        logger.error(
                            into.location, 
                            "cannot inherit multiple symbols with the same name: " + 
                                overridees.iterable |
                                    .map(f => f.to_string())
                                    .sort()                                    
                        );
                    fi
                else
                    let concrete: Function;
                    let abstract: Function;

                    let seen_multiple_concrete = false;
                    let seen_multiple_abstract = false;

                    for f in overridees.iterable do
                        if f.is_abstract then
                            if abstract? then
                                seen_multiple_abstract = true;
                            else
                                abstract = f;
                            fi
                        elif f.is_instance then
                            if concrete? /\ f != concrete then
                                seen_multiple_concrete = true;
                            else
                                concrete = f;
                            fi
                        fi
                    od

                    if 
                        seen_multiple_concrete /\ 
                        overridees.iterable | 
                            .has(function => function.is_instance /\ !function.is_reflected)
                    then
                        let concretes = 
                            overridees.iterable |
                                .filter(function => function.is_instance);
                        
                        logger
                            .error(
                                into.location, 
                                "inherits multiple concrete methods: " + 
                                    concretes
                                        .map(f => f.to_string())
                                        .sort()
                            );

                    elif concrete? then
                        into.add_member(concrete);

                        for f in overridees.iterable do
                            if f != concrete then
                                concrete.try_override(into, f, logger);                                
                            fi
                        od
                        
                    elif seen_multiple_abstract /\ !into.location.is_internal then
                        let abstracts =
                            overridees.iterable |
                                .filter(function => function.is_abstract);

                        logger.error(
                            into.location,
                            "cannot inherit multiple abstract methods: " + 
                                abstracts |
                                    .map(f => f.to_string())
                                    .sort()
                        );

                    elif abstract? then
                        into.add_member(abstract);
                    fi
                fi
            fi
        si

        try_inherit(
            name: string,
            overrider_symbol: Symbol,
            overridee_symbols: Iterable[Symbol],
            logger: Logging.Logger
        )
        is
            if overrider_symbol? then
                if isa Symbols.Property(overrider_symbol) then
                    let property_symbol = cast Symbols.Property(overrider_symbol);

                    for overridee in overridee_symbols do
                        if isa Symbols.Property(overridee) then
                            if !overridee.type.is_assignable_from(overrider_symbol.type) then
                                if overridee.is_instance /\ overrider_symbol.is_instance then
                                    logger.warn(overrider_symbol.location, "" + overrider_symbol + " does not override " + overridee + " due to non-assignable type (" + overrider_symbol.type + " vs " + overridee.type + ")");
                                else                                    
                                    logger.warn(overrider_symbol.location, "" + overrider_symbol + " hides " + overridee);
                                fi
                            else
                                let overrides = true;

                                if overridee.is_assignable then
                                    if overridee.is_private then
                                        if !property_symbol.is_assignable then
                                            logger.warn(overrider_symbol.location, "does not override assign accessor for " + overridee);
                                        fi
                                    else
                                        if !property_symbol.is_assignable then
                                            logger.error(overrider_symbol.location, "does not override public assign accessor for " + overridee);
                                        elif property_symbol.is_private then
                                            logger.error(overrider_symbol.location, "hides public assign accessor for " + overridee);
                                        fi                                            
                                    fi
                                fi
                                
                                if property_symbol.il_name_override? then
                                    if overridee.il_name_override? /\ property_symbol.il_name_override !~ overridee.il_name_override then
                                        logger.warn(overrider_symbol.location, "" + overrider_symbol + " does not override " + overridee + " due to different IL name (" + overrider_symbol.il_name_override + " vs " + overridee.il_name_override + ")");
                                        overrides = false;
                                    fi
                                else
                                    property_symbol.il_name_override = overridee.il_name_override;
                                fi

                                if overrides then
                                    property_symbol.add_overridee(overridee);
                                    overridee.add_overrider(property_symbol);
                                fi
                            fi
                        elif !(isa Symbols.Variable(overridee)) then
                            logger.warn(overrider_symbol.location, "" + overrider_symbol + " hides non-property " + overridee_symbols|);                            
                        fi                        
                    od                    
                else
                    for overridee in overridee_symbols do
                        if !(isa Symbols.Variable(overridee)) then
                            logger.warn(overrider_symbol.location, "" + overrider_symbol + " hides (case 3): " + overridee_symbols|);                            
                        fi
                    od
                fi
                
                return;
            fi

            let count = overridee_symbols| .count();
            
            if count == 1 then
                let first = overridee_symbols| .first().value;

                into.add_member(first);
            elif count > 1 then
                // FIXME: can we do this in a more OOP way?

                let type: Type;

                let inconsistent_types = false;
                let any_non_properties = false;

                let property: Symbol;

                for s in overridee_symbols do
                    if isa Symbols.Property(s) then
                        property = s;

                        if type? then
                            if s.type !~ type then
                                inconsistent_types = true;
                                property = null;

                                break;
                            fi
                        else
                            type = s.type;
                        fi
                    else
                        property = null;
                        any_non_properties = true;
                        break;
                    fi                    
                od

                if any_non_properties then
                    logger.error(
                        into.location, 
                        "inherit multiple symbols with the same name " + 
                        overridee_symbols |
                            .map(s => s.to_string())
                            .sort()
                    );

                elif inconsistent_types then
                    // FIXME: unless overridee_symbols is enumerated here, the following | .map() .sort() produces no results:
                    for os in overridee_symbols do
                    od

                    logger.error(
                        into.location, 
                        "inherit multiple properties with the same name but different types " + 
                            overridee_symbols |
                                .map(s => s.to_string())
                                .sort()
                    );

                elif property? then    
                    into.add_member(property);
                else
                    logger
                        .error(
                            into.location, 
                            "did nothing with multiple parent symbols " + 
                                overridee_symbols |
                                    .map(s => s.to_string())
                                    .sort()
                        );
                fi
            fi
        si

        get_overriders_map_for(overridee_name: string) -> METHOD_OVERRIDE_MAP is
            let result = new METHOD_OVERRIDE_MAP(overridee_name);

            let symbol = into.find_direct(overridee_name);

            if !symbol? then
                // do nothing
            elif isa FUNCTION_GROUP(symbol) then
                for f in cast FUNCTION_GROUP(symbol).functions do
                    result.add(f);
                od
            elif !symbol.is_type_variable then
                result.add(symbol);
            fi

            return result;
        si
    si
si
