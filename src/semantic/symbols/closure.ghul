namespace Semantic.Symbols is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System.Text.StringBuilder;
    
    use IoC;
    use Logging;
    use Source;

    use IR.Values.Value;
    class Closure: Function, Types.Typed is
        description: string => "" + type + " // closure";
        short_description: string => description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        qualified_name: string => "[closure]" + name; // FIXME

        il_name: string => name; // FIXME
        owner_il_name: string => "[closure]"; // FIXME

        il_body: string public;
        
        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            throw new System.NotImplementedException("abstract");
        si

        to_string() -> string => "[closure " + name + "]";
    si

    class INSTANCE_CLOSURE: Closure is
        is_instance: bool => true;

        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.INSTANCE_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            return loader.load_instance_closure(self, type);
        si

        gen_calling_convention(buffer: StringBuilder) is
            buffer.append("instance ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer
                .append("hidebysig specialname ");
        si
    si

    class STATIC_CLOSURE: Closure is
        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.STATIC_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            return loader.load_static_closure(self, type);
        si

        gen_flags(buffer: StringBuilder) is
            buffer
                .append("hidebysig specialname static ");
        si
    si
si
