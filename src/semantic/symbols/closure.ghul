namespace Semantic.Symbols is
    use IO.Std;

    use System.Text.StringBuilder;
    
    use IoC;
    use Logging;
    use Source;

    use IR.Values.Value;

    class Closure: Function, Types.Typed is
        _is_loading_captures: bool;

        captures: Collections.SET[Symbol];
        is_self_captured: bool;

        frame: FRAME;

        description: string => "" + type + " // closure";
        short_description: string => description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        qualified_name: string => "[closure]" + name; // FIXME

        il_name: string => name; // FIXME
        owner_il_name: string => "[closure]"; // FIXME

        il_body: string public;
        
        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        find_or_add_capture(variable: Symbol) -> Field is
            if !frame? then
                captures = new Collections.SET[Symbol]();

                frame = new Semantic.Symbols.FRAME(cast Classy(owner), self);

                owner = frame;
            fi

            if variable? then
                if !captures.contains(variable) then
                    captures.add(variable);

                    return frame.declare_captured(variable.name, variable.type, IoC.CONTAINER.instance.symbol_definition_locations);
                else

                    return frame.get_captured(variable.name);
                fi
            else
                if !is_self_captured then
                    is_self_captured = true;

                    captures.add(null);

                    return frame.declare_captured("$self", owner.type, IoC.CONTAINER.instance.symbol_definition_locations);
                else                    
                    return frame.get_captured("$self");
                fi                
            fi
        si

        find_or_add_capture_self() -> Field => find_or_add_capture(null);

        set_void_return_type() is
            return_type = new Types.ANY();
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            throw new System.NotImplementedException("abstract");
        si

        load_closure(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            let actual_arguments = new Collections.LIST[Value]();

            _is_loading_captures = true;

            for c in captures do
                if c == null then
                    // FIXME: if in a nested closure, this needs to load the outer $self:
                    actual_arguments.add(new IR.Values.Load.SELF(cast Symbol(owner)));
                else
                    actual_arguments.add(
                        c.load(
                            location, 
                            null,
                            loader
                        )
                    );
                fi                
            od
 
            _is_loading_captures = false;

            let frame_instance = frame.get_create_instance(actual_arguments);

            let result = loader.load_closure(self, frame_instance, type);

            return result;
        si

        load_self(location: Source.LOCATION, loader: SYMBOL_LOADER) -> Value is
            if _is_loading_captures then
                // tell loader to load the variable normally: 
                return null;
            fi

            let field = find_or_add_capture_self();

            new IR.Values.Load.SELF(frame);

            return loader.load_instance_variable(location, new IR.Values.Load.SELF(frame), field);
        si
        
        load_captured_value(symbol: Variable, loader: SYMBOL_LOADER) -> Value is
            if _is_loading_captures then
                // tell loader to load the variable normally: 
                return null;
            fi

            symbol.is_captured = true;

            let field = find_or_add_capture(symbol);

            // FIXME: IoC
            // FIXME: nested closures
            let context = IoC.CONTAINER.instance.symbol_table.current_instance_context;

            return loader.load_instance_variable(LOCATION.internal, new IR.Values.Load.SELF(context), field);
        si

        gen_frame(context: IR.CONTEXT, symbol_loader: SYMBOL_LOADER) is
            if frame? then
                frame.gen_all(context, symbol_loader);                
            fi
        si        

        to_string() -> string => "[closure " + name + "]";
    si

    class INSTANCE_CLOSURE: Closure is
        is_instance: bool => true;

        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            var result = new Symbols.INSTANCE_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            if frame? then
                return super.load_closure(location, loader);
            fi
            
            return loader.load_instance_anonymous_function(self, type);
        si

        gen_calling_convention(buffer: StringBuilder) is
            buffer.append("instance ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer
                .append("hidebysig specialname ");
        si

        to_string() -> string => "[instance closure " + name + "]";
    si

    class STATIC_CLOSURE: Closure is
        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            var result = new Symbols.STATIC_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            if frame? then
                return super.load_closure(location, loader);
            fi
            
            return loader.load_static_anonymous_function(self, type);
        si

        gen_calling_convention(buffer: StringBuilder) is
            // if we captured values then we're an instance method on our frame, even if the closure is defined in a static method:
            if frame? then
                buffer.append("instance ");
            fi
        si

        gen_flags(buffer: StringBuilder) is
            if frame? then
                buffer
                    .append("hidebysig specialname ");
            else
                buffer
                    .append("hidebysig specialname static ");
            fi
        si

        to_string() -> string => "[static closure " + name + "]";
    si
si
