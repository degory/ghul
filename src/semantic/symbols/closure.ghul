namespace Semantic.Symbols is
    use IO.Std;

    use System.Text.StringBuilder;
    
    use IoC;
    use Logging;
    use Source;

    use IR.Values.Value;

    class Closure: Function, Types.Typed is
        _is_loading_captures: bool;

        captured_values: Collections.SET[Symbol];
        captured_type_arguments: Collections.MAP[Symbol, CAPTURED_TYPE_ARGUMENT];
        is_self_captured: bool;
        is_delegate: bool;
        is_anon_func_or_delegate: bool => is_delegate \/ !frame?;

        could_be_delegate: bool => is_self_captured /\ captured_values? /\ captured_values.count <= 1 /\ !is_recursive;

        frame: FRAME;

        description: string => "{type} // closure";
        short_description: string => description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        qualified_name: string => "[closure]{name}"; // FIXME

        il_name: string => name; // FIXME
        owner_il_name: string => "[closure]"; // FIXME

        il_body: string public;

        is_closure: bool => true;
        is_recursive: bool;

        next_type_argument_index: int;
        
        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope, is_recursive: bool) is
            super.init(location, location, owner, name, enclosing_scope);

            self.is_recursive = is_recursive;
        si

        convert_to_delegate() is
            assert could_be_delegate;

            is_self_captured = false;
            captured_values = null;
            frame = null;
            is_delegate = true;
        si
        
        find_or_add_capture(variable: Symbol) -> Field is
            if !frame? then
                captured_values = Collections.SET[Symbol]();

                frame = Semantic.Symbols.FRAME(owner, self);
            fi

            if variable? then
                if !captured_values.contains(variable) then
                    captured_values.add(variable);

                    return frame.declare_captured(variable.name, variable.type, IoC.CONTAINER.instance.symbol_definition_locations);
                else
                    return frame.get_captured(variable.name);
                fi
            else
                if !is_self_captured then
                    is_self_captured = true;

                    captured_values.add(null);

                    return frame.declare_captured("$self", owner.type, IoC.CONTAINER.instance.symbol_definition_locations);
                else                    
                    return frame.get_captured("$self");
                fi                
            fi
        si

        add_type_argument_reference(type: Symbol) is
            if !captured_type_arguments? then
                captured_type_arguments = new Collections.MAP[Symbol,CAPTURED_TYPE_ARGUMENT]();
            fi
            
            if !captured_type_arguments.contains_key(type) then
                debug_always("add type argument reference {type} at index {next_type_argument_index}");
                captured_type_arguments.add(type, CAPTURED_TYPE_ARGUMENT(next_type_argument_index));
            else
                let existing_name = captured_type_arguments[type].il_name;

                debug_always("existing type argument reference {type} maps to {existing_name}");
            fi
        si

        find_or_add_recurse() -> Field is
            if !frame? then
                captured_values = Collections.SET[Symbol]();

                frame = Semantic.Symbols.FRAME(owner, self);
            fi

            let recurse = frame.find_member("$recurse");

            if recurse? then
                return cast Field(recurse);
            else
                return frame.declare_recurse(IoC.CONTAINER.instance.symbol_definition_locations);
            fi
        si
        
        find_or_add_capture_self() -> Field => find_or_add_capture(null);

        type_updated(type: Semantic.Types.Type) is
            if is_recursive /\ frame? then
                frame.try_update_recurse_type(type)
            fi
        si

        set_type_arguments() is
            if !captured_type_arguments? then
                // not needed
                return;
            fi

            if frame? then
                frame.set_type_arguments(get_sorted_captured_type_argument_symbols());
                return;
            fi

            if generic_arguments? then
                // already done
                return;
            fi 

            let args = get_sorted_captured_type_argument_symbols();

            generic_arguments = args | .map(a => a.type) .collect();
            generic_argument_names = args | .map(a => a.name) .collect();
        si

        get_sorted_captured_type_argument_symbols() -> Collections.List[Symbol] =>
            if captured_type_arguments? then
                captured_type_arguments | .sort((a, b) => a.value.index - b.value.index) .map(p => p.key) .collect();
            else
                null
            fi;

        get_sorted_captured_type_argument_types() -> Collections.List[Types.Type] =>
            if captured_type_arguments? then
                captured_type_arguments | .sort((a, b) => a.value.index - b.value.index) .map(p => p.key.type) .collect()
            else
                null
            fi;

        get_type_arguments_as_specialize_map() -> Collections.Map[string,Types.Type] =>
            if captured_type_arguments? then
                Collections.MAP[string,Types.Type](
                    captured_type_arguments.keys | .map(key => new Collections.KeyValuePair`2[string,Types.Type](key.name, key.type.freeze()))
                )
            else
                null
            fi;
        
        // TODO save previous type argument overrides otherwise this won't
        // work for nested closures
        map_type_arguments() is
            if !captured_type_arguments? then
                return;
            fi

            for symbol_cta in captured_type_arguments do
                let symbol = symbol_cta.key;
                let cta = symbol_cta.value;

                debug_always("set type override {symbol.name} !{cta.index}");
                
                symbol.gen_type_override((s, buffer) is
                    debug_always("gen type override {symbol.name} !{cta.index}");

                    if frame? then
                        buffer.append("!{cta.index} ")
                    else
                        buffer.append("!!{cta.index} ")
                    fi

                    // gen_overridden_type_argument_name(cta.index, buffer);
                si);
            od
        si

        gen_overridden_type_argument_name(index: int, buffer: System.Text.StringBuilder);

        // TODO restore previous type argument overrides
        unmap_type_arguments() is
            if !captured_type_arguments? then
                return;
            fi

            for symbol_cta in captured_type_arguments do
                let symbol = symbol_cta.key;

                symbol.gen_type_override(null);
            od            
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            throw System.NotImplementedException("abstract");
        si

        load_closure(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            try
                return _load_closure(location, loader);
            catch e: System.Exception
                IoC.CONTAINER.instance.logger.exception(location, e, "exception loading closure");

                debug_always("exception load_closure {location} {e}");

                return IR.Values.DUMMY(Types.ERROR(), location)
            yrt
        si

        _get_actual_arguments(loader: SYMBOL_LOADER) -> Collections.LIST[Value] is
            let actual_arguments = Collections.LIST[Value]();

            let capture_type_argument = (t: Types.Type) is
                if t.is_type_variable then
                    add_type_argument_reference(t.symbol);
                fi
            si;

            for c in captured_values do
                if c == null then
                    let outer_self = loader.load_outer_self(location);

                    actual_arguments.add(outer_self);

                    outer_self.type.walk(capture_type_argument);
                else
                    let outer_captured_value =
                        c.load_outer(
                            location, 
                            null,
                            loader
                        );

                    actual_arguments.add(outer_captured_value);

                    outer_captured_value.type.walk(capture_type_argument);
                fi                
            od

            return actual_arguments;
        si

        _load_closure(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            if !type? then
                return IR.Values.DUMMY(Types.ERROR(), LOCATION.internal);
            fi

            if type.is_error then
                return IR.Values.DUMMY(type, LOCATION.internal);
            fi

            if is_delegate then
                return loader.load_instance_anonymous_function(self, type);
            fi

            let actual_arguments = _get_actual_arguments(loader);

            if captured_type_arguments? then
                return _load_closure_generic(actual_arguments, loader);
            else 
                return _load_closure_non_generic(actual_arguments, loader);
            fi
        si

        _load_closure_generic(actual_arguments: Collections.LIST[Value], loader: SYMBOL_LOADER) -> Value is
            let block = IR.Values.BLOCK(type);

            owner = frame;

            set_type_arguments();

            // we want these type arguments to remain in the current context
            let frozen_argument_types = get_sorted_captured_type_argument_types() | .map(t => t.freeze()) .collect();

            // but the formal arguments of the frame class constructor need to be in the frame's context
            map_type_arguments();

            let frame_instance = frame.get_create_instance(actual_arguments, frozen_argument_types);
            unmap_type_arguments();

            let frame_instance_copier = frame_instance.get_temp_copier(block, "frame-instance");

            owner = frame_instance.type.symbol;

            map_type_arguments();

            let function = new IR.Values.Load.INSTANCE_FUNCTION(self).freeze();

            unmap_type_arguments();

            let result = new IR.Values.Load.DELEGATE(self.type, function, frame_instance_copier()).freeze();

            let result_copier = result.get_temp_copier(block, "closure");

            let rec_member_symbol = frame.find_member("$recurse");

            if rec_member_symbol? /\ !frame_instance.type.is_error then
                block.add(rec_member_symbol.store(location, frame_instance_copier(), result_copier(), loader, true));
            fi

            block.add(result_copier());
            block.close();
            return block
        si

        _load_closure_non_generic(actual_arguments: Collections.LIST[Value], loader: SYMBOL_LOADER) -> Value is
            let block = IR.Values.BLOCK(type);

            owner = frame;

            let frame_instance = frame.get_create_instance(actual_arguments, null);

            let frame_instance_copier = frame_instance.get_temp_copier(block, "frame-instance");

            owner = frame_instance.type.symbol;

            let function = new IR.Values.Load.INSTANCE_FUNCTION(self).freeze();

            let result = new IR.Values.Load.DELEGATE(self.type, function, frame_instance_copier()).freeze();

            let result_copier = result.get_temp_copier(block, "closure");

            let rec_member_symbol = frame.find_member("$recurse");

            if rec_member_symbol? /\ !frame_instance.type.is_error then
                block.add(rec_member_symbol.store(location, frame_instance_copier(), result_copier(), loader, true));
            fi

            block.add(result_copier());
            block.close();
            return block
        si

        _load_lambda() -> Value is
            let use debug_dispose = debug_enter();
            debug("load lambda {self}");

            if !type? then
                debug("no type");
                return IR.Values.DUMMY(Types.ERROR(), LOCATION.internal);
            fi

            if type.is_error then
                debug("type is error");
                return IR.Values.DUMMY(type, LOCATION.internal);
            fi

            if captured_type_arguments? then
                debug("have captured type arguments");
                return _load_lambda_generic();
            else 
                debug("no captured type arguments");
                return _load_lambda_non_generic();
            fi
        si

        _load_lambda_generic() -> Value is
            let block = IR.Values.BLOCK(type);

            set_type_arguments();

            // we want these type arguments to remain in the current context
            // let frozen_argument_types = get_sorted_captured_type_argument_types() | .map(t => t.freeze()) .collect();

            let args_map = get_type_arguments_as_specialize_map();

            map_type_arguments();

            let specialized_lambda = specialize_function(args_map, null);

            let function_pointer = IR.Values.Load.INSTANCE_FUNCTION(specialized_lambda).freeze();

            // even without a frame we still need a delegate, bound to null:
            let delegate = new IR.Values.Load.DELEGATE(specialized_lambda.type, function_pointer, new IR.Values.NULL(new Types.NULL()));
            
            unmap_type_arguments();

            return delegate;
        si

        _load_lambda_non_generic() -> Value is
            let function_pointer = IR.Values.Load.INSTANCE_FUNCTION(self);
            let delegate = new IR.Values.Load.DELEGATE(type, function_pointer, new IR.Values.NULL(new Types.NULL()));

            return delegate;
        si

        load_outer_self(location: Source.LOCATION, loader: SYMBOL_LOADER) -> Value is
            let symbol_table = IoC.CONTAINER.instance.symbol_table;
            let context = symbol_table.current_instance_context;

            if is_delegate then
                return IR.Values.Load.REFERENCE_SELF(context, context.type);                
            fi
            
            let is_captured = false;

            let stack = symbol_table.stack;

            let index = stack.count - 1;
            let seen_self = false;

            while index >= 0 do
                let scope = stack[index];

                if scope.is_namespace then
                    break;
                fi

                if seen_self /\ scope.is_capture_context then
                    if scope.is_closure then
                        let c = cast Closure(scope);

                        // FIXME: may not be needed - load_self() should capture self:
                        c.find_or_add_capture_self();

                        return c.load_self(location, loader);
                    fi
                fi

                if scope == self then
                    seen_self = true;
                fi

                index = index - 1;
            od

            if !is_captured then
                // load self normally: 
                return IR.Values.Load.REFERENCE_SELF(context, context.type);
            fi
        si

        load_self(location: Source.LOCATION, loader: SYMBOL_LOADER) -> Value is
            if is_delegate then
                let context = IoC.CONTAINER.instance.symbol_table.current_instance_context;

                return IR.Values.Load.REFERENCE_SELF(context, context.type);                
            fi

            let `field = find_or_add_capture_self();

            return loader.load_instance_variable(location, IR.Values.Load.REFERENCE_SELF(frame, frame.type), `field);
        si

        load_outer_captured_value(location: LOCATION, symbol: Variable, loader: SYMBOL_LOADER) -> Value is
            let is_captured = false;

            let stack = IoC.CONTAINER.instance.symbol_table.stack;

            let index = stack.count - 1;
            let seen_self = false;

            while index >= 0 do
                let scope = stack[index];

                if seen_self /\ scope.is_capture_context then
                    if symbol.owner == scope then
                        // FIXME: use the symbol loader
                        if isa LOCAL_ARGUMENT(symbol) then
                            return IR.Values.Load.LOCAL_ARGUMENT(symbol);
                        else
                            return IR.Values.Load.LOCAL_VARIABLE(symbol);
                        fi                        
                    elif scope.is_closure then
                        let c = cast Closure(scope);

                        // FIXME: probably redundant
                        c.find_or_add_capture(symbol);

                        c.load_captured_value(location, symbol, loader);

                        let result = c.load_captured_value(location, symbol, loader);

                        return result;
                    fi     
                fi

                if scope == self then
                    seen_self = true;
                fi

                index = index - 1;
            od
        si

        load_recurse(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            let recurse = find_or_add_recurse();

            return recurse.load(location, IR.Values.Load.REFERENCE_SELF(frame, frame.type), loader);
        si
        
        load_captured_value(location: LOCATION, symbol: Variable, loader: SYMBOL_LOADER) -> Value is
            symbol.is_captured = true;

            let `field = find_or_add_capture(symbol);

            return loader.load_instance_variable(LOCATION.internal, IR.Values.Load.REFERENCE_SELF(frame, frame.type), `field);
        si

        gen_access(buffer: StringBuilder) is
            buffer.append("assembly ");
        si
        
        gen_frame(context: IR.CONTEXT, symbol_loader: SYMBOL_LOADER) is
            if frame? then
                frame.gen_all(context, symbol_loader);
            fi
        si        

        to_string() -> string => "[closure {name}]";
    si

    class INSTANCE_CLOSURE: Closure is
        is_instance: bool => true;

        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope, is_recursive: bool) is
            super.init(location, owner, name, enclosing_scope, is_recursive);
        si

        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, is_recursive: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.INSTANCE_CLOSURE(location, owner, name, enclosing, is_recursive);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            if !type? then
                return IR.Values.DUMMY(Types.ERROR(), LOCATION.internal);
            fi

            if type.is_error then
                return IR.Values.DUMMY(type, LOCATION.internal);
            fi

            if frame? then
                return super.load_closure(location, loader);
            fi
            
            return loader.load_instance_anonymous_function(self, type);
        si

        gen_overridden_type_argument_name(index: int, buffer: System.Text.StringBuilder) is
            buffer
                .append('!')
                .append(index);
        si

        gen_calling_convention(buffer: StringBuilder) is
            buffer.append("instance ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer
                .append("hidebysig specialname ");
        si

        to_string() -> string => "[instance closure {name}]";
    si

    class STATIC_CLOSURE: Closure is
        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope, is_recursive: bool) is
            super.init(location, owner, name, enclosing_scope, is_recursive);
        si

        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, is_recursive: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.STATIC_CLOSURE(location, owner, name, enclosing, is_recursive);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            if frame? then
                return super.load_closure(location, loader);
            fi

            return _load_lambda();
        si

        gen_overridden_type_argument_name(index: int, buffer: System.Text.StringBuilder) is
            buffer
                .append("!!")
                .append(index);
        si

        get_il_owner() -> Scope is
            if !frame? then
                debug_always("owner is {owner}");

                let temp_owner = owner;
    
                let classy_owner = cast Classy(owner);
    
                if classy_owner? /\ classy_owner.owner? then
                    return classy_owner.owner;
                fi    
            fi

            return owner;
        si

        gen_owner_reference(buffer: StringBuilder) is
            buffer.append("/*GOR*/");

            get_il_owner().gen_reference(buffer);
        si

        gen_owner_name(buffer: StringBuilder) is
            buffer.append("/*GON*/");

            if !frame? then
                get_il_owner().gen_dotted_name(buffer, self);
            fi
        si

        gen_dot(buffer: StringBuilder) is
            if !frame? then
                buffer.append(".");
            else
                buffer.append("::");
            fi
        si      
        
        gen_calling_convention(buffer: StringBuilder) is
            // if we captured values then we're an instance method on our frame, even if the closure is defined in a global method:
            if frame? then
                buffer.append("/*GCC*/ instance ");
            fi
        si

        gen_flags(buffer: StringBuilder) is
            if frame? then
                buffer
                    .append("hidebysig specialname ");
            else
                buffer
                    .append("hidebysig specialname static ");
            fi
        si

        to_string() -> string => "[static closure {name}]";
    si

    class GLOBAL_CLOSURE: Closure is
        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope, is_recursive: bool) is
            super.init(location, owner, name, enclosing_scope, is_recursive);
        si

        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, is_recursive: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.GLOBAL_CLOSURE(location, owner, name, enclosing, is_recursive);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Value is
            if !type? then
                return IR.Values.DUMMY(Types.ERROR(), LOCATION.internal);
            fi

            if type.is_error then
                return IR.Values.DUMMY(type, LOCATION.internal);
            fi

            if frame? then
                return super.load_closure(location, loader);
            fi

            set_type_arguments();

            return loader.load_global_anonymous_function(self, type);
        si

        gen_overridden_type_argument_name(index: int, buffer: System.Text.StringBuilder) is
            buffer
                .append("!!")
                .append(index);
        si

        gen_owner_name(buffer: StringBuilder) is
            if !frame? then
                owner.gen_dotted_name(buffer, self);
            fi
        si

        gen_dot(buffer: StringBuilder) is
            if !frame? then
                buffer.append(".");
            else
                buffer.append("::");
            fi
        si      
        
        gen_calling_convention(buffer: StringBuilder) is
            // if we captured values then we're an instance method on our frame, even if the closure is defined in a global method:
            if frame? then
                buffer.append("instance ");
            fi
        si

        gen_flags(buffer: StringBuilder) is
            if frame? then
                buffer
                    .append("hidebysig specialname ");
            else
                buffer
                    .append("hidebysig specialname static ");
            fi
        si

        to_string() -> string => "[global closure {name}]";
    si

    struct CAPTURED_TYPE_ARGUMENT is
        index: int;

        il_name: string => "!{index}";

        init(index: int) is
            self.index = index;
        si
    si
si
