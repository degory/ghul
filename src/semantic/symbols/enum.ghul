namespace Semantic.Symbols is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System.Text.StringBuilder;
    
    use IoC;
    use Logging;
    use Source;

    use IR.Values.Value;

    use Types.Type;

    class ENUM_: Scoped, Types.Typed is        
        _ancestor_: Types.NAMED;
        _ancestors: Collections.LIST[Type];

        _next_value: int;

        next_value: int is
            let result = _next_value;

            _next_value = _next_value + 1;

            return result;
        si        

        ancestors: Collections.LIST[Type] is
            if _ancestors == null then
                _ancestor_ = IoC.CONTAINER.instance.innate_symbol_lookup.get_enum_type(type);

                _ancestors = new Collections.LIST[Type]([cast Type(_ancestor_)]);
            fi

            return _ancestors;
        si

        get_ancestor(index: int) -> Type is
            assert index == 0;

            return _ancestor_;
        si

        type: Type;

        description: string => "enum " + qualified_name;
        short_description: string => "enum " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM_MEMBER;
        is_workspace_visible: bool => true;

        is_value_type: bool => true;

        // FIXME: should we just move ENUM_ under Classy to avoid duplicating this stuff?
        il_assembly_name: string;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);

            type = new Types.NAMED(self);
        si

        compare_type(other: Symbol) -> Types.MATCH is
            if self == other then
                return Types.MATCH.SAME;
            else
                return Types.MATCH.DIFFERENT;
            fi
        si

        specialize(type_map: Collections.MAP[string,Type], owner: GENERIC) -> Symbol
            => self;

        declare_enum_member(location: LOCATION, name: string, value: string, symbol_definition_listener: SymbolDefinitionListener) is
            if !value? then
                value = "" + next_value;
            fi

            var result = new Symbols.ENUM_MEMBER(location, self, name, value);

            declare(location, result, symbol_definition_listener);
        si

        find_member(name: string) -> Symbol is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = _ancestor_.find_member(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_member_matches(prefix: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            find_direct_matches(prefix, matches);
            find_ancestor_matches(prefix, matches);
        si

        find_ancestor_matches(prefix: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            _ancestor_.scope.find_member_matches(prefix, matches);
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            return loader.load_enum(self);
        si

        // FIXME: should we just move ENUM_ under Classy to avoid duplicating this stuff?

        gen_reference(buffer: StringBuilder) is
            gen_type(buffer);
        si

        gen_class_name(buffer: StringBuilder) is
            if il_is_built_in_type then
                buffer
                    .append(il_name_override)
                    .append(' ');

                return;
            fi
                        
            gen_assembly_reference(buffer);
            gen_dotted_name(buffer, false);
        si

        gen_type(buffer: StringBuilder) is
            if il_is_built_in_type then
                buffer
                    .append(il_name_override)
                    .append(' ');

                return;
            fi

            gen_type_prefix(buffer);
            gen_class_name(buffer);
        si

        gen_definition_header(buffer: StringBuilder) is
            buffer.append(".class ");

            gen_access(buffer);

            gen_flags(buffer);

            owner.gen_dotted_name(buffer, true);

            gen_name(buffer);

            buffer.append(" extends [mscorlib]System.Enum");
        si
        
        gen_access(buffer: StringBuilder) is
            buffer.append("public ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("auto ansi sealed ");
        si

        gen_assembly_reference(buffer: StringBuilder) is
            if il_assembly_name? then
                buffer
                    .append("['")
                    .append(il_assembly_name)
                    .append("']");
            elif il_name_override? then
                let parts = il_name_override.split(['[',']']);

                if parts.count == 3 then
                    buffer
                    .append('[')
                    .append(parts[1])
                    .append(']');                    
                fi
            fi
        si

        gen_dotted_name(buffer: StringBuilder, want_trailing_dot: bool) is
            let iln = il_name_override;

            if iln? then
                let parts = il_name_override.split(['[',']']);

                if parts.count == 3 then
                    buffer
                        .append(parts[2]);
                else
                    buffer.append(iln);
                fi
            else
            
                if owner? then
                    owner.gen_dotted_name(buffer, true);
                fi

                buffer
                    .append('\'')
                    .append(name)
                    .append('\'');
            fi

            if want_trailing_dot then
                buffer.append("::");
            else
                buffer.append(' ');
            fi            
        si

        gen_reference_name(buffer: StringBuilder) is
            gen_assembly_reference(buffer);
            gen_dotted_name(buffer, false);
        si

        gen_type_prefix(buffer: StringBuilder) is
            buffer
                .append("valuetype ");
        si
    si

    class ENUM_MEMBER: Symbol, Types.Typed is
        _enum: ENUM_ => cast ENUM_(owner);

        type: Type => _enum.type;

        value: string;

        description: string => "enum member " + qualified_name;
        short_description: string => name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM_MEMBER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;

        init(location: LOCATION, owner: ENUM_, name: string, value: string) is
            super.init(location, owner, name);

            self.value = value;
        si

        specialize(type_map: Collections.MAP[string,Symbols.Symbol], owner: GENERIC) -> Symbol
            => self;

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            var result = loader.load_enum_member(self);

            return result;
        si

        gen_definition_header(buffer: StringBuilder) is
            buffer
                .append(".field public static literal ");

            type.gen_type(buffer);

            gen_name(buffer);

            buffer
                .append(" = int32(")
                .append(value)
                .append(')');
        si        
    si
si

