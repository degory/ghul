namespace Semantic.Symbols is
    use IO.Std;

    use System.Text.StringBuilder;
    
    use IoC;
    use Logging;
    use Source;

    use Types.Type;

    use IR.Values.Value;
    use IR.Values.DUMMY;

    class Variable: Symbol, Types.SettableTyped is
        type: Type;
        set_type(value: Type) is type = value; si

        short_description: string => name + ": " + type.short_description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.VARIABLE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.VARIABLE;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);

            assert isa Types.SettableTyped(self) else "oops: should implement SettableTyped: " + self.get_type();
        si

        specialize(type_map: Collections.MAP[string,Type], owner: GENERIC) -> Symbol is
            let result = cast Variable(memberwise_clone());

            result.specialized_from = self;

            if type? then
                let specialized_type = type.specialize(type_map);

                result.type = specialized_type;                
            fi

            result.owner = owner;

            return result;
        si

        gen_reference(buffer: StringBuilder) is
            gen_name(buffer);
        si

        gen_definition_header(buffer: StringBuilder) is
            gen_directive(buffer);

            gen_access(buffer);

            gen_flags(buffer);

            gen_open_paren(buffer);

            type.gen_type(buffer);

            gen_name(buffer);

            gen_close_paren(buffer);
        si

        gen_directive(buffer: StringBuilder);

        gen_access(buffer: StringBuilder) is
        si

        gen_flags(buffer: StringBuilder) is
        si

        gen_open_paren(buffer: StringBuilder) is            
        si

        gen_close_paren(buffer: StringBuilder) is            
        si        

        to_string() -> string =>
            "" + get_type() + " " + name + " @ " + location + " type: " + type;
    si

    class LOCAL_VARIABLE: Variable, Types.SettableTyped is
        description: string => name + ": " + type + " // local variable";

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);

            il_name_override = IoC.CONTAINER.instance.local_id_generator.get_unique_il_name_for(name);
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            assert !from?;
            return loader.load_local_variable(self);
        si

        store(location: LOCATION, from: Value, value: Value, loader: SYMBOL_LOADER) -> Value is
            assert !from?;
            return loader.store_local_variable(self, value);
        si

        gen_directive(buffer: StringBuilder) is
            buffer.append(".locals ");
        si

        gen_access(buffer: StringBuilder) is
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("init ");
        si

        gen_open_paren(buffer: StringBuilder) is
            buffer.append("(");
        si
        
        gen_close_paren(buffer: StringBuilder) is
            buffer.append(")");
        si
    si

    class LOCAL_ARGUMENT: Variable, Types.SettableTyped is
        description: string => name + ": " + type + " // argument";

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            assert !from?;
            return loader.load_local_argument(self);
        si

        store(location: LOCATION, from: Value, value: Value, loader: SYMBOL_LOADER) -> Value is
            assert !from?;
            return loader.store_local_argument(self, value);
        si

        gen_definition_header(buffer: StringBuilder) is
        si
    si

    class GLOBAL_VARIABLE: Variable, Types.SettableTyped is
        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            assert !from? else "load global function from instance context";
            return loader.load_global_variable(self);
        si

        store(location: LOCATION, from: Value, value: Value, loader: SYMBOL_LOADER) -> Value is
            assert !from? else "load global function from instance context";
            return loader.store_global_variable(self, value);
        si

        gen_directive(buffer: StringBuilder) is
            buffer.append(".field ");
        si

        gen_access(buffer: StringBuilder) is
            buffer.append("public ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("static ");
        si
    si

    class Field: Variable, Types.SettableTyped is
        unspecialized_type: Type;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FIELD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FIELD;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        specialize(type_map: Collections.MAP[string,Type], owner: GENERIC) -> Symbol is
            let result = cast Field(super.specialize(type_map, owner));

            result.unspecialized_type = type;

            return result;
        si

        gen_reference(buffer: StringBuilder) is
            let t = unspecialized_type;

            if !t? then
                t = type;
            fi

            t.gen_type(buffer);
            owner.gen_reference(buffer);
            buffer.append("::");
            gen_name(buffer);
        si

        gen_access(buffer: StringBuilder) is
            buffer.append("public ");
        si
        

        gen_directive(buffer: StringBuilder) is
            buffer.append(".field ");
        si
    si

    class INSTANCE_FIELD: Field is
        description: string => qualified_name + ": " + type + " // field";

        is_instance: bool => true;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            if !from? then
                let context = IoC.CONTAINER.instance.symbol_table.current_function;

                if !context? then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance field from non-function context");
                elif !context.is_instance then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance field from static context");
                fi
            fi

            return loader.load_instance_variable(from, self);
        si

        store(location: LOCATION, from: Value, value: Value, loader: SYMBOL_LOADER) -> Value is
            return loader.store_instance_variable(from, self, value);
        si
    si

    class STATIC_FIELD: Field is
        description: string => qualified_name + ": " + type + " // class field";

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            return loader.load_static_field(self);
        si

        store(location: LOCATION, from: Value, value: Value, loader: SYMBOL_LOADER) -> Value is
            return loader.store_static_field(self, value);
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("static ");
        si
    si

    class CAPTURED_VALUE: Variable is
        description: string => name + ": " + type + " // captured value"; 

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            return loader.load_captured_value(self);
        si

        store(location: LOCATION, from: Value, value: Value, loader: SYMBOL_LOADER) -> Value is
            IoC.CONTAINER.logger.error(location, "captured values are read only");
            return new DUMMY(type, location);
        si
    si
si

