namespace Semantic.Symbols is
    use IO.Std;

    use System.Text.StringBuilder;
    
    use Collections.SET;

    use IoC;
    use Logging;
    use Source;

    use IR.Values.Value;

    use Types.Type;

    class Classy: ScopedWithEnclosingScope, ClosureContext is
        _ancestors: Collections.LIST[Type];
        _implementors: Collections.LIST[Symbol];
        _enclosing_symbols: Collections.MAP[string,Symbol];
        _closures: Collections.SET[Closure];

        _are_overrides_resolved: bool;

        type: Type;
        set_type(value: Type) is type = value; si

        span: LOCATION;

        _depth: int;
        depth: int is
            if _depth > 0 then
                return _depth;
            fi

            _depth = _calc_depth();
            return _depth;
        si

        argument_names: Collections.List[string];
        is_generic: bool => argument_names.count > 0;

        // FIXME: not safe to expose unspecialized ancestors
        ancestors: Collections.List[Type] => _ancestors;

        implementors: Collections.Iterable[Symbol] => _implementors;

        il_assembly_name: string public;

        is_workspace_visible: bool => true;
        is_capture_context: bool => true;
        is_type: bool => true;
        is_classy: bool => true;
        is_instance_context: bool => false;

        is_extension: bool;

        is_derived_from_iterable_trait: bool
            => find_ancestor(IoC.CONTAINER.instance.innate_symbol_lookup.get_unspecialized_iterable_type())?;

        is_derived_from_iterator_trait: bool
            => find_ancestor(IoC.CONTAINER.instance.innate_symbol_lookup.get_unspecialized_iterator_type())?;

        are_overrides_resolved: bool => _are_overrides_resolved;

        init(location: LOCATION, span: LOCATION, owner: Scope, name: string, argument_names: Collections.List[string], enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            assert argument_names?;
            assert span?;

            _ancestors = Collections.LIST[Type]();
            _enclosing_symbols = Collections.MAP[string,Symbol]();

            self.span = span;
            self.argument_names = argument_names;

            type = Types.NAMED(self);
        si

        get_ancestor(i: int) -> Type
            => ancestors[i].specialize(Collections.MAP[string,Type]());

        add_ancestor(ancestor: Type) is
            _ancestors.add(ancestor);
        si

        _calc_depth() -> int;

        add_implementor(symbol: Symbol) is
            if !_implementors? then
                _implementors = Collections.LIST[Symbol]();
            fi
 
            _implementors.add(symbol);
        si
        
        push_ancestor(ancestor: Type) is
            let na = Collections.LIST[Type]();

            na.add(ancestor);
            na.add_range(_ancestors);

            _ancestors = na;
        si
        
        add_closure(closure: Closure) is
            if !_closures? then
                _closures = Collections.SET[Closure]();
            fi

            if !_closures.contains(closure) then
                _closures.add(closure);                
            fi
        si

        get_closures() -> Collections.Iterable[Closure] => _closures;

        mark_is_extension() is
            is_extension = true;
        si

        find_member(name: string) -> Symbol => find_direct(name);

        find_enclosing(name: string) -> Symbol is
            if _enclosing_symbols.contains_key(name) then
                return _enclosing_symbols[name];
            fi            

            let result = find_direct(name);

            if result? then
                if !isa FUNCTION_GROUP(result) then
                    _enclosing_symbols[name] = result;

                    return result;
                fi

                let outer = find_enclosing_only(name);

                if !outer? \/ !isa FUNCTION_GROUP(outer) then
                    _enclosing_symbols[name] = result;

                    return result;
                fi

                let combined = FUNCTION_GROUP(result.location, result.owner, result.name);

                let seen = Collections.SET[METHOD_OVERRIDE_CLASS]();

                for f in cast FUNCTION_GROUP(result).functions do
                    seen.add(f.override_class);
                    combined.add(f);
                od

                for f in cast FUNCTION_GROUP(outer).functions do
                    if !seen.contains(f.override_class) then
                        combined.add(f);                        
                    fi                    
                od

                _enclosing_symbols[name] = combined;
                                
                return combined;
            fi

            return find_enclosing_only(name);
        si

        find_ancestor_matches(prefix: string, matches: Collections.MutableMap[string, Symbols.Symbol]) is
            assert _are_overrides_resolved;

            for a in ancestors do
                if a? /\ a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
        si

        find_member_matches(prefix: string, matches: Collections.MutableMap[string, Symbols.Symbol]) is
            assert _are_overrides_resolved;

            find_direct_matches(prefix, matches);
        si

        find_enclosing_matches(prefix: string, matches: Collections.MutableMap[string, Symbols.Symbol]) is
            assert _are_overrides_resolved;

            find_member_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si

        find_extension_methods_for(left_type: Types.Type) -> Collections.Iterable[Function] =>
            _symbols.values |
                .filter(
                    s => 
                        let extension_method = cast EXTENSION_METHOD(s) 
                        in extension_method? /\ extension_method.could_extend(left_type))
                .map(s => cast Function(s));

        assert_symbols_pulled_down() is
            if !_are_overrides_resolved then
                pull_down_super_symbols();
            fi
        si

        mark_overrides_resolved() is
            _are_overrides_resolved = true;
        si

        pull_down_super_symbols() is
            if _are_overrides_resolved then
                return;
            fi

            // let use debug_dispose = debug_enter();

            debug("CCCC pull down super symbols {self} from {System.Diagnostics.StackTrace().to_string().replace_line_endings(" ")}");

            _are_overrides_resolved = true;

            for i in 0..ancestors.count do
                let symbol = get_ancestor(i).symbol;

                if symbol? then
                    debug("CCCC {self} ancestor #{i} {symbol} pull down");

                    symbol.pull_down_super_symbols();
                    symbol.add_implementor(self);
                fi
            od

            let resolver = SYMBOL_INHERITANCE_RESOLVER(self);

            resolver.pull_down_super_symbols_into();
        si

        try_specialize(
            location: LOCATION,
            logger: Logger,
            actual_type_arguments: Collections.List[Type]
        ) -> Symbol is
            if !is_generic then
                logger.error(location, "cannot explicitly specialize non-generic type");
                return null;
            elif actual_type_arguments.count != argument_names.count then
                logger.error(location, "expected {argument_names.count} explicit generic type arguments");
                return null;                
            fi
            
            return GENERIC(location, self, actual_type_arguments);
        si
        
        gen_reference(buffer: StringBuilder) is
            gen_type(buffer);

            if is_generic then
                buffer.append('<');
                gen_actual_type_arguments(buffer);
                buffer.append("> ");
            fi
        si

        gen_class_name(buffer: StringBuilder) is
            if il_is_primitive_type then
                buffer
                    .append(il_name_override)
                    .append(' ');

                return;
            fi
                        
            gen_assembly_reference(buffer);
            gen_dotted_name(buffer, null);
        si

        gen_type(buffer: StringBuilder) is
            if il_is_primitive_type then
                buffer
                    .append(il_name_override)
                    .append(' ');

                return;
            fi

            gen_type_prefix(buffer);
            gen_class_name(buffer);
        si

        gen_definition_header(buffer: StringBuilder) is
            gen_directive(buffer);

            gen_access(buffer);

            gen_flags(buffer);

            owner.gen_dotted_name(buffer, self);

            gen_name(buffer);

            if is_generic then
                buffer.append('<');
                gen_formal_type_arguments(buffer);
                buffer.append("> ");
            fi
            
            gen_extends(buffer);

            gen_implements(buffer);
        si

        gen_directive(buffer: StringBuilder) is
            buffer.append(".class ");
        si

        gen_access(buffer: StringBuilder) is
            buffer.append("public ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("auto ansi beforefieldinit ");
        si

        gen_formal_type_arguments(buffer: StringBuilder) is
            let seen_any = false;

            for argument in argument_names do
                if seen_any then
                    buffer.append(',');
                fi

                buffer
                    .append('\'')
                    .append(argument)
                    .append('\'');

                seen_any = true;
            od
        si

        gen_actual_type_arguments(buffer: StringBuilder) is
            let seen_any = false;

            for index in 0..argument_names.count do
                if seen_any then
                    buffer.append(',');
                fi

                buffer
                    .append('!')
                    .append(index);

                seen_any = true;
            od
        si

        gen_extends(buffer: StringBuilder) is
            for ancestor in ancestors do
                assert isa Types.NAMED(ancestor);

                if ancestor.is_trait then
                    continue;
                fi

                buffer
                    .append(" extends ");

                ancestor
                    .gen_class_name(buffer);

                break;
            od
        si

        gen_implements(buffer: StringBuilder) is
            let seen_any = false;

            for ancestor in ancestors do
                assert isa Types.NAMED(ancestor);

                if !ancestor.is_trait then
                    continue;
                fi

                if seen_any then
                    buffer
                        .append(',');
                else
                    buffer
                        .append("implements ");                    
                fi
                
                ancestor
                    .gen_class_name(buffer);

                seen_any = true;
            od
        si

        gen_assembly_reference(buffer: StringBuilder) is
            if il_assembly_name? then
                buffer
                    .append("['")
                    .append(il_assembly_name)
                    .append("']");
            elif il_name_override? then
                let parts = il_name_override.split(['[',']']);

                if parts.count == 3 then
                    buffer
                    .append('[')
                    .append(parts[1])
                    .append(']');                    
                fi
            fi
        si

        gen_dot(buffer: System.Text.StringBuilder) is
            buffer.append(".");
        si
        
        gen_dotted_name(buffer: System.Text.StringBuilder, qualifying: Scope) is
            let iln = il_name_override;
            
            if iln? then
                let parts = il_name_override.split(['[',']']);

                if parts.count == 3 then
                    buffer
                        .append(parts[2]);
                else
                    if owner? /\ !iln.contains('.') then
                        owner.gen_dotted_name(buffer, self);
                    fi    

                    buffer.append(iln);
                fi
            else
                if owner? then
                    owner.gen_dotted_name(buffer, self);
                fi
            
                buffer
                    .append('\'')
                    .append(name)
                    .append('\'');
            fi

            if !qualifying? then
                buffer.append(' ');
            else
                qualifying.gen_dot(buffer);
            fi            
        si

        gen_type_prefix(buffer: StringBuilder) is
            throw System.NotImplementedException("not implemented by {get_type()}");            
        si
    si

    class CLASS: Classy, Types.Typed is
        description: string => "class {qualified_name}";
        short_description: string => "class {name}";

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.CLASS;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        is_stub: bool;

        is_inheritable: bool => true;
        is_class: bool => true;
        is_object: bool;
        is_root_value_type: bool;

        il_name_prefix: string => "class ";

        is_instance_context: bool => true;

        init(location: LOCATION, span: LOCATION, owner: Scope, name: string, arguments: Collections.List[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, span, owner, name, arguments, enclosing_scope);

            self.span = span;
            self.is_stub = is_stub;
        si

        mark_is_object() is
            is_object = true;
        si

        mark_is_root_value_type() is
            is_root_value_type = true;
        si

        _calc_depth() -> int =>
            if is_object then
                0
            else
                ancestors[0].depth + 1
            fi;
        
        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            return loader.load_class(self);
        si

        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.CLASSY_GENERIC_ARGUMENT(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Function;

            if is_static then
                result = Symbols.STATIC_METHOD(location, span, self, name, enclosing);
            else
                result = Symbols.INSTANCE_METHOD(location, span, self, name, enclosing);
            fi
            
            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Variable;
            
            if is_static then
                result = Symbols.STATIC_FIELD(location, self, name);
            else
                result = Symbols.INSTANCE_FIELD(location, self, name);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Property;

            if is_static then
                result = Symbols.STATIC_PROPERTY(location, span, self, name, is_assignable, is_private);
            else
                result = Symbols.INSTANCE_PROPERTY(location, span, self, name, is_assignable, is_private);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si

        gen_type_prefix(buffer: StringBuilder) is
            buffer.append("class ");
        si
    si

    class TRAIT: Classy, Types.Typed is
        description: string => "trait {qualified_name}";
        short_description: string => "trait {name}";

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.INTERFACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.INTERFACE;

        is_stub: bool;

        is_inheritable: bool => true;
        is_trait: bool => true;

        il_name_prefix: string => "class ";

        is_instance_context: bool => true;

        init(location: LOCATION, span: LOCATION, owner: Scope, name: string, arguments: Collections.List[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, span, owner, name, arguments, enclosing_scope);
            self.is_stub = is_stub;
        si

        _calc_depth() -> int =>
            ancestors | .map(a => a.depth) .reduce(0, (max, n) => if n > max then n else max fi) + 1;

        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.CLASSY_GENERIC_ARGUMENT(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value is
            return loader.load_trait(self);
        si

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Function;
            
            if is_static then
                IoC.CONTAINER.instance.logger.error(location, "cannot declare static method in trait");
                result = Symbols.STATIC_METHOD(location, span, self, name, enclosing);
            else
                result = Symbols.ABSTRACT_METHOD(location, span, self, name, enclosing);
            fi

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Property;

            if is_static then
                IoC.CONTAINER.instance.logger.error(location, "cannot declare static property in trait");
                result = Symbols.STATIC_PROPERTY(location, span, self, name, is_assignable, is_private);
            else
                result = Symbols.INSTANCE_PROPERTY(location, span, self, name, is_assignable, is_private);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("interface auto ansi beforefieldinit ");
        si

        gen_type_prefix(buffer: StringBuilder) is
            buffer.append("class ");
        si

        gen_extends(buffer: StringBuilder) is
            // do nothing
        si
    si

    class STRUCT: Classy, Types.Typed is
        description: string => "struct {qualified_name}";
        short_description: string => "struct {name}";

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.STRUCT;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.STRUCT;

        is_stub: bool;

        is_value_type: bool => true;

        il_name_prefix: string => "valuetype ";

        is_instance_context: bool => true;

        init(location: LOCATION, span: LOCATION, owner: Scope, name: string, arguments: Collections.List[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, span, owner, name, arguments, enclosing_scope);
            self.is_stub = is_stub;
        si

        _calc_depth() -> int => 2; // object -> value type -> struct

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value is
            return loader.load_struct(self);
        si

        // FIXME: most of these can be folded into Classy:

        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.CLASSY_GENERIC_ARGUMENT(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Function;

            if is_static then
                result = Symbols.STATIC_METHOD(location, span, self, name, enclosing);
            else
                result = Symbols.STRUCT_METHOD(location, span, self, name, enclosing);
            fi

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Variable;
            
            if is_static then
                result = Symbols.STATIC_FIELD(location, self, name);
            else
                result = Symbols.STRUCT_FIELD(location, self, name);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Property;

            if is_static then
                result = Symbols.STATIC_PROPERTY(location, span, self, name, is_assignable, is_private);
            else
                result = Symbols.INSTANCE_PROPERTY(location, span, self, name, is_assignable, is_private);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si

        gen_type_prefix(buffer: StringBuilder) is
            buffer.append("valuetype ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("sealed auto ansi beforefieldinit ");
        si
    si

    class UNION: Classy, Types.Typed is
        description: string => "union {qualified_name}";
        short_description: string => "union {name}";

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.CLASS;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        is_stub: bool;

        il_name_prefix: string => "class ";

        is_union: bool => true;
        is_instance_context: bool => true;

        init(location: LOCATION, span: LOCATION, owner: Scope, name: string, arguments: Collections.List[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, span, owner, name, arguments, enclosing_scope);
            self.is_stub = is_stub;
        si

        _calc_depth() -> int => 1; // object -> union

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value =>
            loader.load_union(self);

        // FIXME: most of these can be folded into Classy:
        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.CLASSY_GENERIC_ARGUMENT(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Function;

            if is_static then
                result = Symbols.STATIC_METHOD(location, span, self, name, enclosing);
            else
                result = Symbols.INSTANCE_METHOD(location, span, self, name, enclosing);
            fi
            
            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Property;

            if is_static then
                result = Symbols.STATIC_PROPERTY(location, span, self, name, is_assignable, is_private);
            else
                result = Symbols.INSTANCE_PROPERTY(location, span, self, name, is_assignable, is_private);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_variant(location: LOCATION, span: LOCATION, name: string, is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.VARIANT(location, span, self, name, argument_names, is_stub, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        gen_type_prefix(buffer: StringBuilder) is
            buffer.append("class ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("auto ansi beforefieldinit ");
        si
    si

    class VARIANT: Classy, Types.Typed is
        _field_names: Collections.LIST[string];

        description: string => "variant {qualified_name}{field_descriptions}";
        short_description: string => "variant {name}";

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.CLASS;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        is_stub: bool;

        il_name_prefix: string => "class ";

        is_variant: bool => true;
        is_instance_context: bool => true;        
        can_accept_actual_type_arguments: bool => true;

        field_descriptions: string =>
            if _field_names.count == 0 then
                "";
            else
                "({_field_names | .map(name => let member = find_member(name) in "{member.name}: {member.type}") .join(", ")})";
            fi; 
        
        init(location: LOCATION, span: LOCATION, owner: Scope, name: string, arguments: Collections.List[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, span, owner, name, arguments, enclosing_scope);
            self.is_stub = is_stub;

            _field_names = Collections.LIST[string]();
        si

        _calc_depth() -> int => 2; // object -> union -> variant

        find_member(name: string) -> Symbol => 
            let direct_result = find_direct(name) in

            // we don't want the union's properties to conflict with
            // the variant's fields, or to be visible to the user:
            if direct_result? /\ !direct_result.owner.is_union then
                direct_result
            else
                null
            fi;

        get_destructure_member_name(index: int) -> string =>
            if index < _field_names.count then
                _field_names[index];
            else
                null
            fi;            

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value =>
            loader.load_variant(self);

        // FIXME: most of these can be folded into Classy:
        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.CLASSY_GENERIC_ARGUMENT(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Function;

            if is_static then
                result = Symbols.STATIC_METHOD(location, span, self, name, enclosing);
            else
                result = Symbols.INSTANCE_METHOD(location, span, self, name, enclosing);
            fi
            
            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result = Symbols.VARIANT_FIELD(location, self, name);

            _field_names.add(name);
            
            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Symbol is
            let result: Property;

            if is_static then
                result = Symbols.STATIC_PROPERTY(location, span, self, name, is_assignable, is_private);
            else
                result = Symbols.INSTANCE_PROPERTY(location, span, self, name, is_assignable, is_private);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si

        specialize(arguments: Collections.List[Type]) -> Symbol is
            return GENERIC(location, self, arguments);
        si

        gen_dot(buffer: System.Text.StringBuilder) is
            buffer.append(".");
        si

        gen_type_prefix(buffer: StringBuilder) is
            buffer.append("class ");
        si

        gen_flags(buffer: StringBuilder) is
            buffer.append("sealed auto ansi beforefieldinit ");
        si
    si
    
    class ENUM_STRUCT: STRUCT is
        _next_value: int;

        next_value: int is
            let result = _next_value;

            _next_value = _next_value + 1;

            return result;
        si

        description: string => "enum {qualified_name}";
        short_description: string => "enum {name}";

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;

        init(location: LOCATION, span: LOCATION, owner: Scope, name: string, is_stub: bool, enclosing_scope: Scope) is
            super.init(location, span, owner, name, Collections.LIST[string](), is_stub, enclosing_scope);
        si

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value is
            return loader.load_struct(self);
        si

        declare_enum_member(location: LOCATION, name: string, value: string, symbol_definition_listener: SymbolDefinitionListener) is
            if !value? then
                value = "{next_value}";
            fi

            let result = Symbols.ENUM_STRUCT_MEMBER(location, self, name, value);

            declare(location, result, symbol_definition_listener);
        si
    si
    
    class VOID_STRUCT: STRUCT is
        is_void: bool => true;
        
        init(location: LOCATION, span: LOCATION, owner: Scope, name: string, arguments: Collections.List[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, span, owner, name, arguments, is_stub, enclosing_scope);
            self.is_stub = is_stub;
        si

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value is
            IoC.CONTAINER.instance.logger.error(location, "cannot use void value here");

            return loader.load_struct(self);
        si
    si    

    class FRAME: Classy is
        _next_id: int static;

        _closure: Closure;
        _constructor: Method;
        _captures: Collections.LIST[Field];

        next_id: int static is
            let result = _next_id;

            _next_id = _next_id + 1;

            return result;
        si        

        init(owner: Scope, closure: Closure) is
            let owner_owner: Scope;

            if isa Symbol(owner) then
                let owner_symbol = cast Symbol(owner);

                owner_owner = owner_symbol.owner;
            else
                owner_owner = owner;
            fi

            super.init(LOCATION.internal, LOCATION.internal, owner_owner, "$frame_{next_id}", System.Array.empty[string](), owner);

            assert closure?;
            assert closure.captured_values?;

            _closure = closure;
            _captures = Collections.LIST[Field](closure.captured_values.count);

            set_type(Types.NAMED(self));
        si
        
        declare() is
            if _constructor? then
                return;
            fi

            let symbol_definition_listener = IoC.CONTAINER.instance.symbol_definition_locations;

            declare_constructor(symbol_definition_listener);

            type = Types.NAMED(self);
        si
        
        declare_constructor(symbol_definition_listener: SymbolDefinitionListener) is            
            let constructor = Symbols.INSTANCE_METHOD(LOCATION.internal, LOCATION.internal, self, "init", self);

            let argument_names = Collections.LIST[string]();
            let arguments = Collections.LIST[Type]();

            for `field in symbols | .filter(s => s.is_variable /\ s.name !~ "$recurse").map(s => cast Variable(s)) do
                argument_names.add(`field.name);
                arguments.add(`field.type);
            od
            
            constructor.set_arguments(argument_names, arguments);

            constructor.set_void_return_type();

            declare(LOCATION.internal, constructor, symbol_definition_listener);

            _constructor = constructor;
        si

        get_captured(name: string) -> Field is
            for c in _captures do
                if c.name =~ name then
                    return c;
                fi
            od            
        si
                            
        declare_captured(name: string, type: Type, symbol_definition_listener: SymbolDefinitionListener) -> Field is           
            let `field = Symbols.INSTANCE_FIELD(LOCATION.internal, self, name);

            declare(location, `field, symbol_definition_listener);

            `field.set_type(type);

            _captures.add(`field);

            return `field;
        si

        declare_recurse(symbol_definition_listener: SymbolDefinitionListener) -> Field is
            let `field = Symbols.INSTANCE_FIELD(LOCATION.internal, self, "$recurse");

            declare(location, `field, symbol_definition_listener);

            `field.set_type(_closure.type);

            _captures.add(`field);

            return `field;
        si

        try_update_recurse_type(type: Type) is
            let `field = get_captured("$recurse");

            if `field? then
                `field.set_type(type);
            fi
        si

        set_type_arguments(arguments: Collections.Iterable[Symbol]) is
            // self.arguments = arguments | .map(a => a.type) .collect();
            self.argument_names = arguments | .map(a => a.name) .collect();
        si

        gen_all(context: IR.CONTEXT, symbol_loader: SYMBOL_LOADER) is
            gen_definition_header(context);

            context.write_line("{{");

            context.indent();

            for c in _captures do
                c.gen_definition_header(context);
            od

            gen_constructor(context, symbol_loader);

            gen_closure(context);

            context.outdent();

            context.write_line("}}");
        si

        gen_constructor(context: IR.CONTEXT, symbol_loader: SYMBOL_LOADER) is
            let internal = LOCATION.internal;
           
            _constructor.gen_definition_header(context);

            context.write_line("{{");

            context.indent();

            try
                for c in _captures | .filter(c => c.name !~ "$recurse") do
                    let argument = LOCAL_ARGUMENT(internal, _constructor, c.name);
                    argument.set_type(c.type);

                    c.store(
                        internal, 
                        IR.Values.Load.REFERENCE_SELF(self), 
                        argument.load(LOCATION.internal, null, symbol_loader),
                        symbol_loader,
                        true
                    ).gen(context);
                od
            catch ex: System.Exception
                IoC.CONTAINER.instance.logger.exception(location, ex, "error generating closure frame constructor");
            yrt            
            
            context.write_line("ret");

            context.outdent();
            context.write_line("}}");
        si

        gen_closure(context: IR.CONTEXT) is
            _closure.gen_definition_header(context);

            context.write_line("{{");

            context.indent();

            context.write_line(_closure.il_body);
            
            context.outdent();
            context.write_line("}}");            
        si
        
        get_create_instance(
            actual_arguments: Collections.List[Value],
            type_arguments: Collections.List[Type]
        ) -> IR.Values.Value is
            declare();

            try
                return
                    if type_arguments? then
                        let specialized_self = GENERIC(location, self, type_arguments);
                        let ctor = cast Function(specialized_self.find_member("init"));
            
                        IR.Values.NEW(specialized_self.type, ctor, actual_arguments)
                    else
                        IR.Values.NEW(type, _constructor, actual_arguments)
                    fi
                        .freeze();
            catch ex: System.Exception
                CONTAINER.instance.logger.exception(self.location, ex, "trying to generate frame instance");
            yrt
        si

        gen_access(buffer: StringBuilder) is
            buffer.append("private ");
        si

        gen_type_prefix(buffer: StringBuilder) is
            buffer.append("class ");
        si
    si

    class ENUM_STRUCT_MEMBER: Symbol, Types.Typed is
        _enum: ENUM_STRUCT => cast ENUM_STRUCT(owner);

        type: Type => _enum.type;

        value: string;

        description: string => "{qualified_name} = {value} // enum member";
        short_description: string => name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM_MEMBER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;

        init(location: LOCATION, owner: ENUM_STRUCT, name: string, value: string) is
            super.init(location, owner, name);

            self.value = value;
        si

        specialize(type_map: Collections.Map[string,Symbols.Symbol], owner: GENERIC) -> Symbol
            => self;

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            let result = loader.load_enum_struct_member(self);

            return result;
        si

        gen_definition_header(buffer: StringBuilder) is
            buffer
                .append(".field public static literal ");

            type.gen_type(buffer);

            gen_name(buffer);

            buffer
                .append(" = int32(")
                .append(value)
                .append(')');
        si        
    si
si