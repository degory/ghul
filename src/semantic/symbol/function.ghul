namespace Semantic.Symbol is
    use System;
    
    use IoC;
    use Logging;
    use Source;

    class Function: ScopedWithEnclosingScope, Type.Typed is
        _declaring_arguments: bool;
        _override_class: METHOD_OVERRIDE_CLASS;

        override_class: METHOD_OVERRIDE_CLASS is
            if !_override_class? then
                _override_class = new METHOD_OVERRIDE_CLASS(arguments);
            fi

            return _override_class;
        si

        type: Type.BASE public;
        return_type: Type.BASE public;
        arguments: Collections.LIST[Type.BASE] public;

        unspecialized_arguments: Collections.LIST[Type.BASE] public;
        unspecialized_return_type: Type.BASE public;

        argument_names: Collections.LIST[String] public;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        is_workspace_visible: bool => true;
        is_abstract: bool => false;

        short_description: String => name + "(" + short_argument_descriptions + ") -> " + return_type.short_description;

        il_property_def: String => get_il_def("// not a property ");

        il_qualified_name: String is
            assert
                owner? && isa BASE(owner)
            else
                "null or invalid owner";

            return cast BASE(owner).il_type_name + "::" + il_name;
        si

        il_type_name: String is
            let result = new System.Text.StringBuilder();

            assert self? else "function il_type_name self is null";

            assert 
                unspecialized_arguments? || !specialized_from?
            else
                "function specialized from generic has no copy of original unspecialised arguments";

            assert
                unspecialized_return_type? || !specialized_from?
            else
                "function specialized from generic has no copy of original unspecialised arguments";

            let rt = unspecialized_return_type;

            if !rt? then
                rt = return_type;
            fi

            if !rt? then
                System.Console.error.write_line("function has no return type");
                System.Console.error.write_line("function has no return type: " + name);
                System.Console.error.write_line("function has no return type: " + owner + "." + name);

                result.append("void ");
            else
                result
                .append(rt.il_type_name)
                .append(' ');
            fi
            
            result
                .append(il_qualified_name)
                .append('(');

            let seen_any = false;

            let args = unspecialized_arguments;

            if !args? then
                args = arguments;
            fi
            
            for argument in args do
                if seen_any then
                    result.append(',');
                fi

                if argument? then
                    result.append(argument.il_type_name);
                else
                    System.Console.error.write_line("broken unspecialized_arguments: " + unspecialized_arguments);
                fi

                seen_any = true;
            od

            result.append(')');

            return result.to_string();
        si

        argument_descriptions: String is
            let result = new System.Text.StringBuilder();

            for i in 0..arguments.count do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_argument_description(i));
            od

            return result.to_string();
        si

        short_argument_descriptions: String is
            let result = new System.Text.StringBuilder();

            for i in 0..arguments.count do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_short_argument_description(i));
            od

            return result.to_string();
        si

        override: Function public
            => null,
            = value
                is throw new NotImplementedException("" + self + " cannot override " + value); si

        =~(other: Function) -> bool => self == other;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            if name =~ "init" then
                il_name_override = "'.ctor'";
            fi
            
            type = new Type.NAMED(self);
        si

        get_il_def(preamble: String) -> String is
            let result = new System.Text.StringBuilder();
            
            result
                .append(preamble)
                .append(' ')
                .append(return_type.il_type_name)
                .append(' ')
                .append(il_name)
                .append('(');

            let seen_any = false;
            
            for i in 0..argument_names.count do
                if seen_any then
                    result.append(',');
                fi
                
                result
                    .append(arguments[i].il_type_name)
                    .append(" '")
                    .append(argument_names[i])
                    .append("'");

                seen_any = true;
            od

            result.append(") cil managed");

            return result.to_string();    
        si
        
        start_declaring_arguments() is
            _declaring_arguments = true;
        si

        end_declaring_arguments() is
            _declaring_arguments = false;
        si

        specialize_function(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> Function is
            assert owner? else "cannot specialize with null owner";

            let result = cast Function(memberwise_clone());
            
            result.specialized_from = self;
            result._override_class = null;

            // System.Console.error.write_line("set specialized from: " + qualified_name);

            if !return_type? then
                IoC.CONTAINER.instance.logger.info(self.location, "specialized with null return type");
            else
                result.return_type = return_type.specialize(type_map);
            fi
            
            if unspecialized_arguments? then
                result.unspecialized_arguments = unspecialized_arguments;
            else
                result.unspecialized_arguments = arguments;
            fi

            if unspecialized_return_type? then
                result.unspecialized_return_type = unspecialized_return_type;
            else
                result.unspecialized_return_type = return_type;
            fi
            
            let ra = new Collections.LIST[Type.BASE](arguments);

            result.arguments = ra;

            for i in 0..arguments.count do
                let a = arguments[i];

                if a? then
                    ra[i] = arguments[i].specialize(type_map);
                fi
            od

            if result.owner == owner.unspecialized_symbol then
                result.owner = owner;
            elif result.owner != owner then
                result.owner = result.owner.type.specialize(owner.type_map).symbol;
            else
                System.Console.error.write_line("" + result + " is already owned by " + owner);
            fi

            return result;
        si

        specialize(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> BASE =>
            specialize_function(type_map, owner);

        get_full_type(ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) -> Type.NAMED is
            let types = new Collections.LIST[Type.BASE](arguments.count + 1);

            types.add_range(arguments);
            types.add(return_type);

            return ghul_symbol_lookup.get_function_type(types);
        si

        is_exact_match(arguments: Collections.LIST[Type.BASE], type: Type.BASE) -> bool is
            if arguments.count != self.arguments.count then
                return false;
            fi

            for i in 0..arguments.count do
                if arguments[i] != self.arguments[i] then
                    return false;
                fi
            od

            if return_type != self.return_type then
                return false;
            fi

            return true;
        si

        try_override(into: Classy, function: Function, logger: Logger) is
            @IF.debug() Console.error.write_line("try override A: " + self + " " + function);
            logger.error(location, "cannot override " + function);
        si

        try_override(into: Classy, symbol: BASE, logger: Logger) is
            @IF.debug() Console.error.write_line("try override B: " + self + " " + symbol);
            logger.error(location, "hides " + symbol + " (case F)");
        si

        try_instance_override_me(into: Classy, function: Function, logger: Logger) is
            logger.error(function.location, "cannot be overridden by " + function);
        si

        try_struct_override_me(into: Classy, function: Function, logger: Logger) is
            logger.error(function.location, "cannot be overridden by " + function);
        si

        try_abstract_override_me(into: Classy, function: Function, logger: Logger) is
            logger.error(function.location, "cannot be overridden by " + function);
        si

        inheritance_warn(logger: Logger, into: Classy, message: String) is
            if owner == into then
                logger.warn(location, message);                    
            else
                logger.warn(into.location, "" + self + " " + message);                    
            fi
        si

        inheritance_error(logger: Logger, into: Classy, message: String) is
            if owner == into then
                logger.error(location, message);
            else
                logger.error(into.location, "" + self + " " + message);
            fi
        si
                
        ensure_return_type_matches(into: Classy, overridee: Function, want_override: bool, logger: Logger) -> bool is
            if !into.is_stub then
                if return_type !~ overridee.return_type then
                    if want_override then
                        inheritance_warn(logger, into, "does not override " + overridee + " due to different return type " + return_type);
                    else
                        inheritance_error(logger, into, "does not implement " + overridee + " due to different return type " + return_type);                            
                    fi
                    return false;
                fi
            fi

            return true;
        si

        ensure_il_name_matches(into: Classy, overridee: Function, override_type: String, logger: Logger) -> bool is
            if il_name !~ overridee.il_name then
                if il_name_override? then
                    logger.warn(location, "does not " + override_type + " " + overridee + " due to inconsistent IL names (" + il_name + " vs " + overridee.il_name + ")");
                    return false;
                else
                    il_name_override = overridee.il_name;                    
                fi
            fi

            return true;
        si
                
        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            if _declaring_arguments then
                var result = new Symbol.LOCAL_ARGUMENT(location, self, name);

                declare(location, result, symbol_definition_listener);

                return result;
            else
                var result = new Symbol.LOCAL_VARIABLE(location, self, name);

                declare(location, result, symbol_definition_listener);                            

                return result;
            fi
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        get_argument_description(index: int) -> String is
            let result = new System.Text.StringBuilder();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index]);

            return result.to_string();
        si

        get_short_argument_description(index: int) -> String is
            let result = new System.Text.StringBuilder();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index].short_description);

            return result.to_string();
        si

        to_string() -> String is
            let result = new System.Text.StringBuilder();

            try
                result.append(qualified_name);
                result.append("(");
                result.append(short_argument_descriptions);
                result.append(") -> ");
                result.append(return_type);

                // return qualified_name + " (" + short_argument_descriptions + ") -> " + return_type;
                return result.to_string();
            catch ex: Exception
                // System.Console.error.write_line("failed to convert function to string: " + name + ", got as far as: " + result);
                // System.Console.error.write_line(ex);

                return "[garbled function: " + result + "]";
            yrt
        si
    si
si