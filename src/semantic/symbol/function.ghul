namespace Semantic.Symbols is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System;

    use Collections.Iterable;
    
    use IoC;
    use Logging;
    use Source;

    use IR.Values.Value;

    use Types.Type;

    class Function: ScopedWithEnclosingScope, Types.Typed is
        _declaring_arguments: bool;
        _override_class: METHOD_OVERRIDE_CLASS;

        override_class: METHOD_OVERRIDE_CLASS is
            if !_override_class? then
                _override_class = new METHOD_OVERRIDE_CLASS(arguments);
            fi

            return _override_class;
        si

        _overridees: Collections.MutableList[Symbol];

        type: Type public;
        return_type: Type public;
        arguments: Collections.LIST[Type] public;

        unspecialized_arguments: Collections.LIST[Type] public;
        unspecialized_return_type: Type public;

        argument_names: Collections.LIST[string] public;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        is_workspace_visible: bool => true;
        is_abstract: bool => false;

        short_description: string => name + "(" + short_argument_descriptions + ") -> " + return_type.short_description;

        il_qualified_name: string is
            assert
                owner? && isa Symbol(owner)
            else
                "null or invalid owner";

            return cast Symbol(owner).il_type_name + "::" + il_name;
        si

        il_type_name: string is
            let result = new System.Text.StringBuilder();

            assert self? else "function il_type_name self is null";

            assert 
                unspecialized_arguments? || !specialized_from?
            else
                "function specialized from generic has no copy of original unspecialised arguments";

            assert
                unspecialized_return_type? || !specialized_from?
            else
                "function specialized from generic has no copy of original unspecialised arguments";

            let rt = unspecialized_return_type;

            if !rt? then
                rt = return_type;
            fi

            if !rt? then
                Std.error.write_line("function has no return type");
                Std.error.write_line("function has no return type: " + name);
                Std.error.write_line("function has no return type: " + owner + "." + name);

                result.append("void ");
            else
                result
                .append(rt.il_type_name)
                .append(' ');
            fi
            
            result
                .append(il_qualified_name)
                .append('(');

            let seen_any = false;

            let args = unspecialized_arguments;

            if !args? then
                args = arguments;
            fi
            
            for argument in args do
                if seen_any then
                    result.append(',');
                fi

                if argument? then
                    result.append(argument.il_type_name);
                else
                    Std.error.write_line("broken unspecialized_arguments: " + unspecialized_arguments);
                fi

                seen_any = true;
            od

            result.append(')');

            return result.to_string();
        si
        
        argument_descriptions: string is
            let result = new System.Text.StringBuilder();

            for i in 0..arguments.count do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_argument_description(i));
            od

            return result.to_string();
        si

        short_argument_descriptions: string is
            let result = new System.Text.StringBuilder();

            for i in 0..arguments.count do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_short_argument_description(i));
            od

            return result.to_string();
        si
        
        overridees: Collections.Iterable[Symbol] => _overridees;

        =~(other: Function) -> bool => self == other;

        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            if name =~ "init" then
                il_name_override = "'.ctor'";
            fi
            
            type = new Types.NAMED(self);
        si

        get_il_def(preamble: string) -> string is
            let result = new System.Text.StringBuilder();
            
            result
                .append(preamble)
                .append(' ')
                .append(return_type.il_type_name)
                .append(' ')
                .append(il_name)
                .append('(');

            let seen_any = false;
            
            for i in 0..argument_names.count do
                if seen_any then
                    result.append(',');
                fi
                
                result
                    .append(arguments[i].il_type_name)
                    .append(" '")
                    .append(argument_names[i])
                    .append("'");

                seen_any = true;
            od

            result.append(") cil managed");

            return result.to_string();    
        si

        il_property_def: string is throw new NotImplementedException(); si

        // FIXME: this is needed to avoid emitting 'class' or 'valuetype' in a position that confuses ILAsm. There must be some
        // underlying regularity to when 'class' and 'valuetype' prefixes are needed and when they're not that could be exploited
        // to simplify all this stuff:
        get_il_property_def(kind: string) -> string is 
            let result = new System.Text.StringBuilder();

            assert arguments.count <= 1;
            assert self? else "function il_type_name self is null";

            assert 
                unspecialized_arguments? || !specialized_from?
            else
                "function specialized from generic has no copy of original unspecialised arguments";

            assert
                unspecialized_return_type? || !specialized_from?
            else
                "function specialized from generic has no copy of original unspecialised arguments";

            assert isa Symbol(owner);
            
            if arguments.count == 0 then
                result
                    .append(".get ");                
            elif arguments.count == 1 then
                result
                    .append(".set ");
            fi

            result
                .append(kind)
                .append(' ');

            let rt = unspecialized_return_type;

            if !rt? then
                rt = return_type;
            fi

            result
                .append(rt.il_type_name)
                .append(' ')
                .append(cast Symbol(owner).il_token_name)
                .append("::")
                .append(il_name)
                .append("(");

            let seen_any = false;

            let args = unspecialized_arguments;

            if !args? then
                args = arguments;
            fi
            
            for argument in args do
                if seen_any then
                    result.append(',');
                fi

                assert argument?;

                result.append(argument.il_type_name);

                seen_any = true;
            od

            result.append(')');

            return result.to_string();

        si
        
        add_overridee(overridee: Function) is
            if !_overridees? then
                _overridees = new Collections.LIST[Symbol]();
            fi 

            _overridees.add(overridee);
        si

        start_declaring_arguments() is
            _declaring_arguments = true;
        si

        end_declaring_arguments() is
            _declaring_arguments = false;
        si

        specialize_function(type_map: Collections.MAP[string,Type], owner: GENERIC) -> Function is
            assert owner? else "cannot specialize with null owner";

            let result = cast Function(memberwise_clone());
            
            result.specialized_from = self;
            result._override_class = null;

            // Std.error.write_line("set specialized from: " + qualified_name);

            if !return_type? then
                IoC.CONTAINER.instance.logger.poison(self.location, "specialized with null return type");
            else
                result.return_type = return_type.specialize(type_map);
            fi
            
            if unspecialized_arguments? then
                result.unspecialized_arguments = unspecialized_arguments;
            else
                result.unspecialized_arguments = arguments;
            fi

            if unspecialized_return_type? then
                result.unspecialized_return_type = unspecialized_return_type;
            else
                result.unspecialized_return_type = return_type;
            fi
            
            let ra = new Collections.LIST[Type](arguments);

            result.arguments = ra;

            for i in 0..arguments.count do
                let a = arguments[i];

                if a? then
                    ra[i] = arguments[i].specialize(type_map);
                fi
            od

            if result.owner == owner.unspecialized_symbol then
                result.owner = owner;
            elif result.owner != owner then
                result.owner = result.owner.type.specialize(owner.type_map).symbol;
            else
                Std.error.write_line("" + result + " is already owned by " + owner);
            fi

            return result;
        si

        specialize(type_map: Collections.MAP[string,Type], owner: GENERIC) -> Symbol =>
            specialize_function(type_map, owner);

        get_full_type(innate_symbol_lookup: Lookups.InnateSymbolLookup) -> Types.NAMED is
            let types = new Collections.LIST[Type](arguments.count + 1);

            types.add_range(arguments);
            types.add(return_type);

            return innate_symbol_lookup.get_function_type(types);
        si

        is_exact_match(arguments: Collections.LIST[Type], type: Type) -> bool is
            if arguments.count != self.arguments.count then
                return false;
            fi

            for i in 0..arguments.count do
                if arguments[i] != self.arguments[i] then
                    return false;
                fi
            od

            if return_type != self.return_type then
                return false;
            fi

            return true;
        si

        try_override(into: Classy, function: Function, logger: Logger) is
            @IF.debug() Std.error.write_line("try override A: " + self + " " + function);
            logger.error(location, "cannot override " + function);
        si

        try_instance_override_me(into: Classy, function: Function, logger: Logger) is
            logger.error(function.location, "cannot be overridden by " + function);
        si

        try_struct_override_me(into: Classy, function: Function, logger: Logger) is
            logger.error(function.location, "cannot be overridden by " + function);
        si

        try_abstract_override_me(into: Classy, function: Function, logger: Logger) is
            logger.error(function.location, "cannot be overridden by " + function);
        si

        inheritance_warn(logger: Logger, into: Classy, message: string) is
            if owner == into then
                logger.warn(location, message);                    
            else
                logger.warn(into.location, "" + self + " " + message);                    
            fi
        si

        inheritance_error(logger: Logger, into: Classy, message: string) is
            if owner == into then
                logger.error(location, message);
            else
                logger.error(into.location, "" + self + " " + message);
            fi
        si
                
        ensure_return_type_matches(into: Classy, overridee: Function, want_override: bool, logger: Logger) -> bool is
            if !into.is_stub then
                if return_type !~ overridee.return_type then
                    if want_override then
                        inheritance_warn(logger, into, "does not override " + overridee + " due to different return type " + return_type);
                    else
                        inheritance_error(logger, into, "does not implement " + overridee + " due to different return type " + return_type);                            
                    fi
                    return false;
                fi
            fi

            return true;
        si

        ensure_il_name_matches(into: Classy, overridee: Function, override_type: string, logger: Logger) -> bool is
            if il_name !~ overridee.il_name then
                if il_name_override? then
                    logger.warn(location, "does not " + override_type + " " + overridee + " due to inconsistent IL names (" + il_name + " vs " + overridee.il_name + ")");
                    return false;
                else
                    il_name_override = overridee.il_name;                    
                fi
            fi

            return true;
        si
                
        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            if _declaring_arguments then
                var result = new Symbols.LOCAL_ARGUMENT(location, self, name);

                declare(location, result, symbol_definition_listener);

                return result;
            else
                var result = new Symbols.LOCAL_VARIABLE(location, self, name);

                declare(location, result, symbol_definition_listener);                            

                return result;
            fi
        si

        declare_function(location: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        get_argument_description(index: int) -> string is
            let result = new System.Text.StringBuilder();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index]);

            return result.to_string();
        si

        get_short_argument_description(index: int) -> string is
            let result = new System.Text.StringBuilder();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index].short_description);

            return result.to_string();
        si

        to_string() -> string is
            let result = new System.Text.StringBuilder();

            try
                if name.starts_with("__read_") then
                    result
                        .append(owner.qualified_name)
                        .append(".")
                        .append(name.substring(7))
                        .append(": ")
                        .append(return_type);
                elif name.starts_with("__assign_") then
                    result
                        .append(owner.qualified_name)
                        .append(".")
                        .append(name.substring(9))
                        .append(": ")
                        .append(return_type)
                        .append(" = ")
                        .append(argument_names[0]);
                elif name =~ "get_Item" then
                    result
                        .append(owner.qualified_name)
                        .append("[")
                        .append(argument_names[0])
                        .append(": ")
                        .append(arguments[0])
                        .append("]: ")

                        .append(return_type);
                elif name =~ "set_Item" then
                    result
                        .append(owner.qualified_name)
                        .append("[")
                        .append(argument_names[0])
                        .append(": ")
                        .append(arguments[0])
                        .append("]: ")

                        .append(return_type)
                        .append(" = ")
                        .append(argument_names[1]);
                else
                    result
                        .append(qualified_name)
                        .append("(")
                        .append(short_argument_descriptions)
                        .append(") -> ")
                        .append(return_type);
                fi

                // return qualified_name + " (" + short_argument_descriptions + ") -> " + return_type;
                return result.to_string();
            catch ex: Exception
                // Std.error.write_line("failed to convert function to string: " + name + ", got as far as: " + result);
                // Std.error.write_line(ex);

                return "[garbled function: " + result + "]";
            yrt
        si
    si

    class GLOBAL_FUNCTION: Function is
        description: string => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // global function";

        il_def: string => get_il_def("// global ");

        init(location: LOCATION, owner: Scope, name: string, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value is
            @IF.not.release()
            if from? then
                IoC.CONTAINER.instance.logger.poison(location, "global function load shouldn't have a left expression");
            fi
            
            return loader.load_global_function(self);
        si

        call(location: Source.LOCATION, from: IR.Values.Value, arguments: Collections.LIST[IR.Values.Value], type: Type, caller: FUNCTION_CALLER) -> IR.Values.Value is
            @IF.not.release()
            if from? then
                IoC.CONTAINER.instance.logger.poison(location, "global function call shouldn't have a left expression");
            fi

            return caller.call_global_function(self, arguments, self.arguments, type);
        si
    si
si