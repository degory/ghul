namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    class Function: ScopedWithEnclosingScope, Type.Typed is
        _declaring_arguments: bool;
        _override_class: METHOD_OVERRIDE_CLASS;

        override_class: METHOD_OVERRIDE_CLASS is
            if !_override_class? then
                _override_class = new METHOD_OVERRIDE_CLASS(arguments);
            fi
            
            return _override_class;
        si

        type: Type.BASE public;
        return_type: Type.BASE public;
        arguments: Collections.LIST[Type.BASE] public;

        unspecialized_arguments: Collections.LIST[Type.BASE] public;
        unspecialized_return_type: Type.BASE public;

        argument_names: Collections.LIST[String] public;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        is_workspace_visible: bool => true;
        is_abstract: bool => false;

        short_description: String => name + "(" + short_argument_descriptions + ") -> " + return_type.short_description;

        il_property_def: String => get_il_def("// not a property ");

        il_qualified_name: String is
            assert
                owner? && isa BASE(owner)
            else
                "null or invalid owner";

            return cast BASE(owner).il_type_name + "::" + il_name;
        si

        il_type_name: String is
            let result = new System.Text.StringBuilder();

            assert self? else "function il_type_name self is null";

            assert 
                unspecialized_arguments? || !specialized_from?
            else
                "function specialized from generic has no copy of original unspecialised arguments";

            assert
                unspecialized_return_type? || !specialized_from?
            else
                "function specialized from generic has no copy of original unspecialised arguments";

            let rt = unspecialized_return_type;

            if !rt? then
                rt = return_type;
            fi

            if !rt? then
                System.Console.error.write_line("function has no return type");
                System.Console.error.write_line("function has no return type: " + name);
                System.Console.error.write_line("function has no return type: " + owner + "." + name);

                result.append("void ");
            else
                result
                .append(rt.il_type_name)
                .append(' ');
            fi
            
            result
                .append(il_qualified_name)
                .append('(');

            let seen_any = false;


            let args = unspecialized_arguments;

            if !args? then
                args = arguments;
            fi
            
            for argument in args do
                if seen_any then
                    result.append(',');
                fi

                if argument? then
                    result.append(argument.il_type_name);
                else
                    System.Console.error.write_line("broken unspecialized_arguments: " + unspecialized_arguments);
                fi

                seen_any = true;
            od

            result.append(')');

            return result.to_string();
        si

        argument_descriptions: String is
            let result = new System.Text.StringBuilder();

            for i in 0..arguments.count do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_argument_description(i));
            od

            return result.to_string();
        si

        short_argument_descriptions: String is
            let result = new System.Text.StringBuilder();

            for i in 0..arguments.count do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_short_argument_description(i));
            od

            return result.to_string();
        si

        override: Function public
            => null,
            = value
                is throw new NotImplementedException("" + self + " cannot override " + value); si

        =~(other: Function) -> bool => self == other;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            if name =~ "init" then
                il_name_override = "'.ctor'";
            fi
            
            type = new Type.NAMED(self);
        si

        get_il_def(preamble: String) -> String is
            let result = new System.Text.StringBuilder();
            
            result
                .append(preamble)
                .append(' ')
                .append(return_type.il_type_name)
                .append(' ')
                .append(il_name)
                .append('(');

            let seen_any = false;
            
            for i in 0..argument_names.count do
                if seen_any then
                    result.append(',');
                fi
                
                result
                    .append(arguments[i].il_type_name)
                    .append(" '")
                    .append(argument_names[i])
                    .append("'");

                seen_any = true;
            od

            result.append(") cil managed");

            return result.to_string();    
        si
        
        start_declaring_arguments() is
            _declaring_arguments = true;
        si

        end_declaring_arguments() is
            _declaring_arguments = false;
        si

        specialize(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> Function is
            assert owner? else "cannot specialize with null owner";

            @IF.legacy()
            let result = cast Function(clone());

            @IF.dotnet()
            let result = cast Function(memberwise_clone());
            
            result.specialized_from = self;
            result._override_class = null;

            // System.Console.error.write_line("set specialized from: " + qualified_name);

            if !return_type? then
                IoC.CONTAINER.instance.logger.info(self.location, "specialized with null return type");
            else
                result.return_type = return_type.specialize(type_map);
            fi
            
            if unspecialized_arguments? then
                result.unspecialized_arguments = unspecialized_arguments;
            else
                result.unspecialized_arguments = arguments;
            fi

            if unspecialized_return_type? then
                result.unspecialized_return_type = unspecialized_return_type;
            else
                result.unspecialized_return_type = return_type;
            fi
            
            let ra = new Collections.LIST[Type.BASE](arguments);

            result.arguments = ra;

            for i in 0..arguments.count do
                let a = arguments[i];

                if a? then
                    ra[i] = arguments[i].specialize(type_map);
                fi
            od

            Logging.DEBUG.write_line("OOOOOO: source owner is: " + owner.unspecialized_symbol + " vs " + self.owner);

            if result.owner == owner.unspecialized_symbol then
                result.owner = owner;

                Logging.DEBUG.write_line("OOOOOO: source owner is: " + owner.unspecialized_symbol);
                Logging.DEBUG.write_line("OOOOOO: result owner is: " + result.owner);
            elif result.owner != owner then
                Logging.DEBUG.write_line("WWWWWW: owner type: " + result.owner.type);

                result.owner = result.owner.type.specialize(owner.type_map).symbol;
                Logging.DEBUG.write_line("WWWWWW: specialised owner type: " + result.owner.type.specialize(owner.type_map));

                // let new_owner: Type.BASE;

                // Logging.DEBUG.write_line("YYYYYY: have " + owner.ancestors.count + " ancestors");

                // for i in 0..owner.ancestors.count do
                //     let ancestor = owner.get_ancestor(i);

                //     Logging.DEBUG.write_line("YYYYYY: compare: " + self.owner + " vs " + ancestor);

                //     if ancestor.type =~ result.owner.type then
                //         new_owner = ancestor;
                //         Logging.DEBUG.write_line("XXXXXX: yup: " + self.owner.unspecialized_symbol + " vs " + ancestor.unspecialized_symbol);
                //     else
                //         Logging.DEBUG.write_line("XXXXXX: nope: " + self.owner.unspecialized_symbol + " vs " + ancestor.unspecialized_symbol);
                //     fi
                // od
                
                // Logging.DEBUG.write_line("WWWWWW: new owner: " + new_owner);

                // if new_owner? then
                //     result.owner = new_owner.scope;
                // else
                //     System.Console.error.write_line("\nspecialize broken owner " + result.owner + " with " + owner);
                //     System.Console.error.write_line("specializing: " + self + " with " + type_map);

                //     owner.dump_ancestors(1);

                //     result.owner = owner;                    
                // fi
            else
                System.Console.error.write_line("" + result + " is already owned by " + owner);
            fi

            return result;
        si

        get_full_type(ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) -> Type.NAMED is
            let types = new Collections.LIST[Type.BASE](arguments.count + 1);

            types.add_range(arguments);
            types.add(return_type);

            return ghul_symbol_lookup.get_function_type(types);
        si

        is_exact_match(arguments: Collections.LIST[Type.BASE], type: Type.BASE) -> bool is
            if arguments.count != self.arguments.count then
                return false;
            fi

            for i in 0..arguments.count do
                if arguments[i] != self.arguments[i] then
                    return false;
                fi
            od

            if return_type != self.return_type then
                return false;
            fi

            return true;
        si

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            if _declaring_arguments then
                var result = new Symbol.LOCAL_ARGUMENT(location, self, name);

                declare(location, result, symbol_definition_listener);
            else
                var result = new Symbol.LOCAL_VARIABLE(location, self, name);

                declare(location, result, symbol_definition_listener);                            
            fi
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        get_argument_description(index: int) -> String is
            let result = new System.Text.StringBuilder();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index]);

            return result.to_string();
        si

        get_short_argument_description(index: int) -> String is
            let result = new System.Text.StringBuilder();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index].short_description);

            return result.to_string();
        si

        @IF.legacy()
        toString() -> String is
            let result = new System.Text.StringBuilder();

            try
                result.append(qualified_name);
                result.append("(");
                result.append(short_argument_descriptions);
                result.append(") -> ");
                result.append(return_type);

                // return qualified_name + " (" + short_argument_descriptions + ") -> " + return_type;
                return result.to_string();
            catch ex: Exception
                // System.Console.error.write_line("failed to convert function to string: " + name + ", got as far as: " + result);
                // System.Console.error.write_line(ex);

                return "[garbled function: " + result + "]";
            yrt
        si

        @IF.dotnet()
        @IL.name("ToString")
        to_string() -> String is
            let result = new System.Text.StringBuilder();

            try
                result.append(qualified_name);
                result.append("(");
                result.append(short_argument_descriptions);
                result.append(") -> ");
                result.append(return_type);

                // return qualified_name + " (" + short_argument_descriptions + ") -> " + return_type;
                return result.to_string();
            catch ex: Exception
                // System.Console.error.write_line("failed to convert function to string: " + name + ", got as far as: " + result);
                // System.Console.error.write_line(ex);

                return "[garbled function: " + result + "]";
            yrt
        si

    si
si