namespace Semantic.Symbols is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System;
    
    use IoC;
    use Logging;
    use Source;

    use IR.Values.Value;

    use Types.Type;

    class ENUM_: Scoped, Types.Typed is        
        _ancestor_: Types.NAMED;
        _ancestors: Collections.LIST[Type];

        _next_value: int;

        next_value: int is
            let result = _next_value;

            _next_value = _next_value + 1;

            return result;
        si        

        ancestors: Collections.LIST[Type] is
            if _ancestors == null then
                _ancestor_ = IoC.CONTAINER.instance.innate_symbol_lookup.get_enum_type(type);

                _ancestors = new Collections.LIST[Type]([cast Type(_ancestor_)]);
            fi

            return _ancestors;
        si

        get_ancestor(index: int) -> Type is
            assert index == 0;

            return _ancestor_;
        si

        type: Type;

        description: string => "enum " + qualified_name;
        short_description: string => "enum " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM_MEMBER;
        is_workspace_visible: bool => true;

        is_value_type: bool => true;

        il_type_name: string is
            if il_name_override? then
                return il_qualified_name;
            else
                return "valuetype " + il_qualified_name;
            fi
        si

        il_def: string =>
            ".class public auto ansi sealed " + il_name + " extends [mscorlib]System.Enum";

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);

            type = new Types.NAMED(self);
        si

        compare_type(other: Symbol) -> Types.MATCH is
            if self == other then
                return Types.MATCH.SAME;
            else
                return Types.MATCH.DIFFERENT;
            fi
        si

        specialize(type_map: Collections.MAP[string,Type], owner: GENERIC) -> Symbol
            => self;

        declare_enum_member(location: LOCATION, name: string, value: string, symbol_definition_listener: SymbolDefinitionListener) is
            if !value? then
                value = "" + next_value;
            fi

            var result = new Symbols.ENUM_MEMBER(location, self, name, value);

            declare(location, result, symbol_definition_listener);
        si

        find_member(name: string) -> Symbol is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = _ancestor_.find_member(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_member_matches(prefix: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            find_direct_matches(prefix, matches);
            find_ancestor_matches(prefix, matches);
        si

        find_ancestor_matches(prefix: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            _ancestor_.scope.find_member_matches(prefix, matches);
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            return loader.load_enum(self);
        si
    si

    class ENUM_MEMBER: Symbol, Types.Typed is
        _enum: ENUM_ => cast ENUM_(owner);

        type: Type => _enum.type;

        value: string;

        description: string => "enum member " + qualified_name;
        short_description: string => name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM_MEMBER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;

        il_def: string =>
            ".field public static literal " + _enum.il_type_name + " " + il_name + " = int32(" + value + ")";

        init(location: LOCATION, owner: ENUM_, name: string, value: string) is
            super.init(location, owner, name);

            self.value = value;
        si

        specialize(type_map: Collections.MAP[string,Symbols.Symbol], owner: GENERIC) -> Symbol
            => self;

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            var result = loader.load_enum_member(self);

            return result;
        si
    si
si

