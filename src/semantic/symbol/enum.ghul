namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    class ENUM_: Scoped, Type.Typed is
        _ancestor_: Type.NAMED;
        _ancestors: Collections.LIST[Type.BASE];

        _next_value: int;

        next_value: int is
            let result = _next_value;

            _next_value = _next_value + 1;

            return result;
        si        

        ancestors: Collections.LIST[Type.BASE] is
            if _ancestors == null then
                _ancestor_ = IoC.CONTAINER.instance.ghul_symbol_lookup.get_enum_type(type);

                _ancestors = new Collections.LIST[Type.BASE]([cast Type.BASE(_ancestor_)]);
            fi

            return _ancestors;
        si

        get_ancestor(index: int) -> Type.BASE is
            assert(index == 0, "Enum ancestor index out of range");

            return _ancestor_;
        si

        type: Type.BASE;

        description: String => "enum " + qualified_name;
        short_description: String => "enum " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;
        is_workspace_visible: bool => true;

        is_value_type: bool => true;

        il_type_name: String is
            if il_name_override? then
                return il_qualified_name;
            else
                return "valuetype " + il_qualified_name;
            fi
        si

        il_def: String =>
            ".class public auto ansi sealed " + il_name + " extends [mscorlib]System.Enum";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            type = new Type.NAMED(self);
        si

        compare_type(other: BASE) -> Type.MATCH is
            if self == other then
                return Type.MATCH.SAME;
            else
                return Type.MATCH.DIFFERENT;
            fi
        si

        specialize(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> BASE
            => self;

        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.ENUM_MEMBER(location, self, name, next_value);

            declare(location, result, symbol_definition_listener);
        si

        find_member(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = _ancestor_.find_member(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_member_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            find_ancestor_matches(prefix, matches);
        si

        find_ancestor_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            _ancestor_.scope.find_member_matches(prefix, matches);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_enum(self);
        si
    si

    class ENUM_MEMBER: BASE, Type.Typed is
        _enum: ENUM_ => cast ENUM_(owner);

        type: Type.BASE => _enum.type;

        value: int;

        description: String => "enum member " + qualified_name;
        short_description: String => name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM_MEMBER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;

        il_def: String =>
            ".field public static literal " + _enum.il_type_name + " " + il_name + " = int32(" + value + ")";

        init(location: LOCATION, owner: ENUM_, name: String, value: int) is
            super.init(location, owner, name);

            self.value = value;
        si

        specialize(type_map: Collections.MAP[String,Symbol.BASE], owner: GENERIC) -> BASE
            => self;

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            var result = loader.load_enum_member(self);

            return result;
        si
    si
si

