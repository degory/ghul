namespace Semantic.Symbol is
    use object = System.Object;
    use string = System.String;
    use STD = System.Console;

    use System;
    
    use IoC;
    use Logging;
    use Source;

    // FIXME: doesn't really have a type, not sure how to represent this:
    class NAMESPACE: ScopedWithEnclosingScope, NamespaceContext, Type.Typed is
        _dotnet_symbol_table: DotNet.SYMBOL_TABLE;

        qualified_name: string;

        type: Type.BASE;

        description: string => "namespace " + qualified_name;
        short_description: string => "namespace " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.NAMESPACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.MODULE;

        is_workspace_visible: bool => true;

        il_qualified_name: string is
            let parts = qualified_name.substring(1).split(['.']);

            let result = new System.Text.StringBuilder(qualified_name.length + parts.count * 3);

            let seen_any = false;

            for part in parts do
                if seen_any then
                    result.append('.');
                fi                

                result
                    .append("'")
                    .append(part)
                    .append("'");

                seen_any = true;
            od

            return result.to_string();
        si

        // FIXME: the IL generation pass is not using the namespace symbol so does not see this:
        il_def: string => ".namespace " + il_qualified_name;

        init(location: LOCATION, name: string, enclosing_scope: Scope, qualified_name: string) is
            super.init(location, self, name, enclosing_scope);

            self.qualified_name = qualified_name;

            type = new Type.NAMED(self);
        si

        qualify(name: string) -> string is
            let q = qualified_name;

            if q.length > 1 then
                return qualified_name.substring(1) + "." + name;                
            fi
            
            return name;
        si

        find_direct(name: string) -> BASE is
            assert name? else "searched name is null";

            let result = super.find_direct(name);

            if result then
                return result;
            fi

            if !_dotnet_symbol_table? then
                _dotnet_symbol_table = IoC.CONTAINER.instance.dotnet_symbol_table.value;
            fi
            
            if _dotnet_symbol_table? then
                let qn = qualified_name;

                if qn =~ "." || qn.length == 0 then
                    return null;
                fi
                
                if qn.starts_with(".") then
                    qn = qn.substring(1);
                fi

                return _dotnet_symbol_table.get_symbol(qn + "." + name);                
            fi
        si
        
        find_member(name: string) -> BASE
            => find_direct(name);

        find_member_matches(prefix: string, matches: Collections.MAP[string, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
        si

        declare_namespace(location: LOCATION, name: string, namespace_: Symbol.NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            assert name?;
            assert namespace_?;
            assert namespace_.name?;

            declare(location, namespace_, symbol_definition_listener);
        si

        declare_class(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.CLASS(location, self, name, arguments, is_stub, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_trait(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TRAIT(location, self, name, arguments, is_stub, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_struct(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.STRUCT(location, self, name, arguments, is_stub, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: string, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_function(location: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_VARIABLE(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_PROPERTY(location, self, name, is_assignable);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_namespace(self);
        si
    si
si
