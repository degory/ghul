namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    // FIXME: doesn't really have a type, not sure how to represent this:
    class NAMESPACE: ScopedWithEnclosingScope, NamespaceContext, Type.Typed is
        qualified_name: String;

        type: Type.BASE;

        description: String => "namespace " + qualified_name;
        short_description: String => "namespace " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.NAMESPACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.MODULE;

        is_workspace_visible: bool => true;

        il_qualified_name: String is
            let parts = Shim.STR.split(qualified_name.substring(1), '.');

            let result = new System.Text.StringBuilder(Shim.STR.length(qualified_name) + parts.count * 3);

            let seen_any = false;

            for part in parts do
                if seen_any then
                    result.append('.');
                fi                

                result
                    .append("'")
                    .append(part)
                    .append("'");

                seen_any = true;
            od

            return result.to_string();
        si

        // FIXME: the IL generation pass is not using the namespace symbol so does not see this:
        il_def: String => ".namespace " + il_qualified_name;

        init(location: LOCATION, name: String, enclosing_scope: Scope, qualified_name: String) is
            super.init(location, self, name, enclosing_scope);

            self.qualified_name = qualified_name;

            type = new Type.NAMED(self);
        si

        qualify(name: String) -> String is
            let q = qualified_name;

            if Shim.STR.length(q) > 1 then
                return qualified_name.substring(1) + "." + name;                
            fi
            
            return name;
        si

        find_member(name: String) -> BASE
            => find_direct(name);

        find_member_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
        si

        declare_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare(location, namespace_, symbol_definition_listener);
        si

        declare_class(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.CLASS(location, self, name, arguments, is_stub, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_trait(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TRAIT(location, self, name, arguments, is_stub, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_struct(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.STRUCT(location, self, name, arguments, is_stub, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.GLOBAL_VARIABLE(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_PROPERTY(location, self, name, is_assignable);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_namespace(self);
        si
    si
si
