namespace Semantic.Symbol is
    use System;
    
    use IoC;
    use Logging;
    use Source;

    class FUNCTION_GROUP: BASE, Type.Typed is
        // _overrides_resolved: bool;

        description: String => qualified_name + "(...) // function group";
        short_description: String => name + "(...)";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        type: Type.BASE;

        set_type(value: Type.BASE) is type = value; si

        functions: Collections.MutableList[Function];

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            type = new Type.FUNCTION_GROUP(name, self);
            functions = new Collections.LIST[Function]();
        si

        specialize_function_group(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> FUNCTION_GROUP is
            let result = cast FUNCTION_GROUP(memberwise_clone());

            result.specialized_from = self;

            result.type = new Type.FUNCTION_GROUP(
                name,
                result
            );

            result.functions = new Collections.LIST[Function](functions);

            for i in 0..functions.count do
                result.functions[i] = functions[i].specialize_function(type_map, owner);
            od

            return result;
        si

        specialize(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> BASE =>
            specialize_function_group(type_map, owner);

        add(function: Function) is
            assert function.name =~ self.name;
                        
            functions.add(function);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_function_group(from, self);
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException("cannot call unresolved function overload group: " + self);
        si

        collapse_group_if_single_member() -> Symbol.BASE is
            if functions.count == 1 then
                return functions[0];
            else
                return self;
            fi
        si

        collapse_group_or_null() -> Symbol.Function is
            if functions.count == 1 then
                return functions[0];
            else
                return null;
            fi
        si

        to_string() -> String =>
            description + " [" + new Shim.JOIN[Symbol.Function](functions) + "]";
    si
si