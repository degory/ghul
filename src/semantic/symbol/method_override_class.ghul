namespace Semantic is
    use System.String;
    use System.Console;
    use System.Text.StringBuilder;

    use Collections.Iterable;
    use Collections.Iterator;
    use Collections.LIST;
    use Collections.MAP;
    use Collections.SET;

    class METHOD_OVERRIDE_CLASS is
        arguments: LIST[Type.BASE];

        init(arguments: LIST[Type.BASE]) is
            self.arguments = arguments;
        si

        =~(other: METHOD_OVERRIDE_CLASS) -> bool is            
            if other.arguments.count != arguments.count then
                return false;
            fi
            
            for i in 0..arguments.count do
                if arguments[i] !~ other.arguments[i] then                    
                    return false;
                fi                
            od    
            
            return true;
        si

        @IL.name("Equals")
        =~(other: System.Object) -> bool is
            if !other? then
                return false;
            fi

            if !isa METHOD_OVERRIDE_CLASS(other) then
                return false;
            fi

            return self =~ cast METHOD_OVERRIDE_CLASS(other);
        si
        
        @IF.legacy()
        hash() -> int is
            let result = 0;

            for a in arguments do
                result = result + a.hash();
            od

            return result;
        si

        @IF.dotnet()
        get_hash_code() -> int is
            let result = 0;

            for a in arguments do
                result = result + a.get_hash_code();
            od

            return result;
        si

        @IF.legacy()
        toString() -> String => "(" + arguments.get_inner() + ")";

        @IF.dotnet()
        @IL.name("ToString")
        to_string() -> String => "(" + new Shim.JOIN[Type.BASE](arguments) + ")";
    si
    
    class FUNCTION_WRAPPER is
        _hash: int;
        _root_function: Symbol.BASE;

        function: Symbol.Function;

        =~(other: System.Object) -> bool is
            if !other? then
                return false;
            elif !isa FUNCTION_WRAPPER(other) then
                return false;
            fi

            return self =~ cast FUNCTION_WRAPPER(other);
        si

        =~(other: FUNCTION_WRAPPER) -> bool =>
            _root_function == other._root_function;
        
        init(function: Symbol.Function) is
            _root_function = function.root_specialized_from;

            @IF.legacy()
            _hash = _root_function.hash();

            @IF.dotnet()
            _hash = _root_function.get_hash_code();

            self.function = function;
        si
        
        hash() -> int => _hash;

        toString() -> String => "" + function + " (from " + _root_function + ", hash: " + _hash + ")";
    si

    class METHOD_OVERRIDE_SET: System.Object, Iterable[Symbol.Function] is
        _set: SET[FUNCTION_WRAPPER];

        _iterable: Iterable[Symbol.Function];

        override_class: METHOD_OVERRIDE_CLASS;

        iterator: Iterator[Symbol.Function] => _iterable.iterator;

        init(override_class: METHOD_OVERRIDE_CLASS) is
            _set = new SET[FUNCTION_WRAPPER]();

            _iterable = 
                new Shim.MAPPER[FUNCTION_WRAPPER,Symbol.Function](
                    _set,
                    (from: FUNCTION_WRAPPER) -> Symbol.Function => from.function
                );

            self.override_class = override_class;
        si

        add(method: Symbol.Function) is
            assert method.override_class =~ override_class;
            _set.add(new FUNCTION_WRAPPER(method));
        si

        pull_into(into: Symbol.BASE, name: String, overriders: METHOD_OVERRIDE_SET, other_overridee_symbols: Collections.SET[Symbol.BASE]) -> Symbol.BASE is
            let logger = IoC.CONTAINER.instance.instance.logger;

            let abstract_count = 0;
            let concrete_count = 0;
            let static_count = 0;

            let abstract_method: Symbol.Function;
            let concrete_method: Symbol.Function;
            let static_method: Symbol.Function;
            let overriding_method: Symbol.Function;

            let overrider_symbol: Symbol.BASE;

            if overriders? then
                overriding_method = overriders.get_overrider(into);
            else
                overrider_symbol = into.find_direct(name);
            fi
            
            for fw in _set do
                let f = fw.function;

                if f.is_abstract then
                    abstract_count = abstract_count + 1;

                    if !abstract_method? then
                        abstract_method = f;
                    fi
                elif f.is_instance then
                    concrete_count = concrete_count + 1;

                    if !concrete_method? then
                        concrete_method = f;
                    fi
                else
                    static_count = static_count + 1;

                    if !static_method? then
                        static_method = f;                        
                    fi                    
                fi
            od
            
            // if !into.is_stub && (concrete_count > 1 || abstract_count > 1) then
            //     report_error(into, "ambiguous inheritance", concrete_count > 1);
            // fi            

            if overriding_method? then
                for symbol in other_overridee_symbols do
                    logger.warn(overriding_method.location, "hides " + symbol);
                od

                if concrete_method? && overriding_method.il_name !~ concrete_method.il_name then
                    if overriding_method.il_name_override? then
                        logger.error(overriding_method.location, "cannot override " + concrete_method + " with different IL name (" + overriding_method.il_name + " vs " + concrete_method.il_name + ")");
                    else
                        overriding_method.il_name_override = concrete_method.il_name;
                    fi
                fi
                
                if abstract_method? && overriding_method.il_name !~ abstract_method.il_name then
                    if overriding_method.il_name_override? then
                        logger.error(overriding_method.location, "cannot implement " + abstract_method + " with different IL name (" + overriding_method.il_name + " vs " + abstract_method.il_name + ")");
                    else
                        overriding_method.il_name_override = abstract_method.il_name;
                    fi
                fi
            elif concrete_method? then
                if abstract_method? && concrete_method.il_name !~ abstract_method.il_name then
                    logger.warn(into.location, "inherited method " + concrete_method + " does not implement " + abstract_method + " because IL names differ (" + concrete_method.il_name + " vs " + abstract_method.il_name + ")");
                fi

                into.add_member(concrete_method);
            elif abstract_method? then
                // 

                if !into.is_stub && !into.is_trait then
                    

                    logger.error(into.location, "must implement " + abstract_method);
                fi
                
                into.add_member(abstract_method);
            elif static_method? then
                into.add_member(static_method);
            elif other_overridee_symbols.count > 0 then
                throw new System.Exception("dont think this is possible");
            fi
        si
                        
        @IF.legacy()
        toString() -> String => "" + override_class + ": " + new Shim.JOIN[FUNCTION_WRAPPER](_set);

        @IF.dotnet()
        @IL.name("ToString")
        to_string() -> String => "" + override_class + ": " + new Shim.JOIN[FUNCTION_WRAPPER](_set);

        report_error(into: Symbol.BASE, prefix: String, is_error: bool) is
            let buffer = new StringBuilder();

            buffer.append(prefix).append(" ");

            let seen_any = false;

            for fw in _set do
                let f = fw.function;

                if seen_any then
                    buffer.append(",");
                fi
                
                buffer.append(f.owner.qualified_name).append(".").append(f.short_description);

                seen_any = true;
            od            

            if is_error then
                IoC.CONTAINER.instance.logger.info(into.location, Shim.STR.format(buffer));
            else
                IoC.CONTAINER.instance.logger.info(into.location, Shim.STR.format(buffer));
            fi
        si

        get_overrider(into: Symbol.BASE) -> Symbol.Function is
            if !into.is_stub && _set.count > 1 then
                for fw in _set do
                    let f = fw.function;
                    IoC.CONTAINER.instance.logger.info(f.location, "duplicate method " + f.owner.qualified_name + "." + f.short_description);
                od
            fi
                        
            if _set.count == 0 then
                return null;
            fi

            let i = _set.iterator;

            i.move_next();

            return i.current.function;
        si
    si

    class METHOD_OVERRIDE_MAP: System.Object, Iterable[METHOD_OVERRIDE_SET] is
        _method_sets: MAP[METHOD_OVERRIDE_CLASS,METHOD_OVERRIDE_SET];
        _symbols: SET[Symbol.BASE];

        contains_any_methods: bool => _method_sets.count > 0;

        name: String;

        other_symbols: SET[Symbol.BASE] => _symbols;

        iterator: Iterator[METHOD_OVERRIDE_SET] => _method_sets.values.iterator;

        [method_class: METHOD_OVERRIDE_CLASS]: METHOD_OVERRIDE_SET is
            if _method_sets.contains_key(method_class) then
                return _method_sets[method_class];
            fi

            return null;            
        si

        init(name: String) is
            _method_sets = new MAP[METHOD_OVERRIDE_CLASS,METHOD_OVERRIDE_SET]();
            _symbols = new SET[Symbol.BASE]();

            self.name = name;
        si

        contains(override_class: METHOD_OVERRIDE_CLASS) -> bool => _method_sets.contains_key(override_class);        

        add(symbol: Symbol.BASE) is
            if isa Symbol.Function(symbol) then
                add(cast Symbol.Function(symbol));

                return;
            fi

            if !_symbols.contains(symbol) then
                _symbols.add(symbol);
            fi            
        si

        add(group: Symbol.FUNCTION_GROUP) is
            for f in group.functions do
                add(f);
            od            
        si

        add(method: Symbol.Function) is
            let c = method.override_class;

            let method_set: METHOD_OVERRIDE_SET;

            if _method_sets.contains_key(c) then
                method_set = _method_sets[c];
            else
                method_set = new METHOD_OVERRIDE_SET(c);
                _method_sets[c] = method_set;
            fi

            method_set.add(method);


            
            for s in _method_sets do
                

                for f in s.value do
                    
                od
                
            od

            

            // 
        si

        @IF.legacy()
        toString() -> String is
            let result = new StringBuilder();

            for s in _method_sets do
                result.append(name + ": " + s.key + ": " + s.value + "\n");
            od          
            
            return Shim.STR.format(result);
        si
    si
si