namespace Semantic is
    use System.String;
    use System.Console;
    use System.Text.StringBuilder;

    use Collections.Iterable;
    use Collections.Iterator;
    use Collections.LIST;
    use Collections.MAP;
    use Collections.SET;

    class METHOD_OVERRIDE_CLASS is
        arguments: LIST[Type.BASE];

        init(arguments: LIST[Type.BASE]) is
            self.arguments = arguments;
        si

        =~(other: METHOD_OVERRIDE_CLASS) -> bool is            
            if other.arguments.count != arguments.count then
                return false;
            fi
            
            for i in 0..arguments.count do
                if arguments[i] !~ other.arguments[i] then                    
                    return false;
                fi                
            od    
            
            return true;
        si

        @IL.name("Equals")
        =~(other: System.Object) -> bool is
            if !other? then
                return false;
            fi

            if !isa METHOD_OVERRIDE_CLASS(other) then
                return false;
            fi

            return self =~ cast METHOD_OVERRIDE_CLASS(other);
        si
        
        // @IL.name("get_hash_code")
        hash() -> int is
            let result = 0;

            for a in arguments do
                // Logging.DEBUG.write_line("TTTTTT: type: " + a);
                // Logging.DEBUG.write_line("TTTTTT: hash: " + a.hash());
                // Logging.DEBUG.write_line("TTTTTT: symbol: " + a.symbol);
                // Logging.DEBUG.write_line("TTTTTT: symbol hash: " + a.symbol.hash());
                // Logging.DEBUG.write_line("");
            
                result = result + a.hash();
            od

            return result;
        si

        @IF.legacy()
        toString() -> String => "(" + arguments.get_inner() + ")";

        @IF.dotnet()
        @IL.name("ToString")
        to_string() -> String => "(" + new Shim.JOIN[Type.BASE](arguments) + ")";
    si
    
    class FUNCTION_WRAPPER is
        _hash: int;
        _root_function: Symbol.BASE;

        function: Symbol.Function;

        =~(other: System.Object) -> bool is
            if !other? then
                return false;
            elif !isa FUNCTION_WRAPPER(other) then
                return false;
            fi

            return self =~ cast FUNCTION_WRAPPER(other);
        si

        =~(other: FUNCTION_WRAPPER) -> bool =>
            _root_function == other._root_function;
        
        init(function: Symbol.Function) is
            _root_function = function.root_specialized_from;

            _hash = _root_function.hash();

            self.function = function;
        si
        
        hash() -> int => _hash;

        toString() -> String => "" + function + " (from " + _root_function + ", hash: " + _hash + ")";
    si

    class METHOD_OVERRIDE_SET: System.Object, Iterable[Symbol.Function] is
        _set: SET[FUNCTION_WRAPPER];

        _iterable: Iterable[Symbol.Function];

        override_class: METHOD_OVERRIDE_CLASS;

        iterator: Iterator[Symbol.Function] => _iterable.iterator;

        init(override_class: METHOD_OVERRIDE_CLASS) is
            _set = new SET[FUNCTION_WRAPPER]();

            _iterable = 
                new Shim.MAPPER[FUNCTION_WRAPPER,Symbol.Function](
                    _set,
                    (from: FUNCTION_WRAPPER) -> Symbol.Function => from.function
                );

            self.override_class = override_class;
        si

        add(method: Symbol.Function) is
            assert method.override_class =~ override_class;
            _set.add(new FUNCTION_WRAPPER(method));

            Logging.DEBUG.write_line("added function " + method + " to " + override_class + " result is:");

            for f in _set do                
                Logging.DEBUG.write_line("FFFFFF: " + f);
            od
        si

        pull_into(into: Symbol.BASE, name: String, overriders: METHOD_OVERRIDE_SET, other_overridee_symbols: Collections.SET[Symbol.BASE]) -> Symbol.BASE is
            Logging.DEBUG.write_line("pull into: " + into.qualified_name);

            let logger = IoC.CONTAINER.instance.instance.logger;

            let abstract_count = 0;
            let concrete_count = 0;

            let abstract_method: Symbol.Function;
            let concrete_method: Symbol.Function;
            let overriding_method: Symbol.Function;

            let overrider_symbol: Symbol.BASE;

            if overriders? then
                overriding_method = overriders.get_overrider(into);
            else
                overrider_symbol = into.find_direct(name);
            fi
            
            for fw in _set do
                let f = fw.function;

                if f.is_abstract then
                    abstract_count = abstract_count + 1;

                    if !abstract_method? then
                        abstract_method = f;
                    fi
                elif f.is_instance then
                    concrete_count = concrete_count + 1;

                    if !concrete_method? then
                        concrete_method = f;
                    fi
                fi
            od
            
            if !into.is_stub && (concrete_count > 1 || abstract_count > 1) then
                report_error(into, "ambiguous inheritance", concrete_count > 1);
            fi            

            if overriding_method? then                
                Logging.DEBUG.write_line("have overriding method: " + overriding_method);
                Logging.DEBUG.write_line("overriding method IL name override: " + overriding_method.il_name_override);
                Logging.DEBUG.write_line("overriding method IL name effective: " + overriding_method.il_name);
            fi

            if concrete_method? then
                Logging.DEBUG.write_line("have concrete method: " + concrete_method);
                Logging.DEBUG.write_line("concrete method IL name override: " + concrete_method.il_name_override);
                Logging.DEBUG.write_line("concrete method IL name effective: " + concrete_method.il_name);    
            fi
            
            if abstract_method? then
                Logging.DEBUG.write_line("have abstract method: " + abstract_method);
                Logging.DEBUG.write_line("abstract method IL name override: " + abstract_method.il_name_override);
                Logging.DEBUG.write_line("abstract method IL name effective: " + abstract_method.il_name);    
            fi

            if overriding_method? then
                for symbol in other_overridee_symbols do
                    logger.warn(overriding_method.location, "hides " + symbol);
                od

                if concrete_method? && overriding_method.il_name !~ concrete_method.il_name then
                    if overriding_method.il_name_override? then
                        logger.error(overriding_method.location, "cannot override " + concrete_method + " with different IL name (" + overriding_method.il_name + " vs " + concrete_method.il_name + ")");
                    else
                        overriding_method.il_name_override = concrete_method.il_name;
                    fi
                fi
                
                if abstract_method? && overriding_method.il_name !~ abstract_method.il_name then
                    if overriding_method.il_name_override? then
                        logger.error(overriding_method.location, "cannot implement " + abstract_method + " with different IL name (" + overriding_method.il_name + " vs " + abstract_method.il_name + ")");
                    else
                        overriding_method.il_name_override = abstract_method.il_name;
                    fi
                fi
            elif concrete_method? then
                if abstract_method? && concrete_method.il_name !~ abstract_method.il_name then
                    logger.warn(into.location, "inherited method " + concrete_method + " does not implement " + abstract_method + " because IL names differ (" + concrete_method.il_name + " vs " + abstract_method.il_name + ")");
                fi

                into.add_member(concrete_method);
            elif abstract_method? then
                // Logging.DEBUG.write_line("will pull down abstract method: " + abstract_method);

                if !into.is_stub && !into.is_trait then
                    Logging.DEBUG.write_line("IIIIII: non trait " + into + " must implement " + abstract_method);

                    logger.error(into.location, "must implement " + abstract_method);
                fi
                
                into.add_member(abstract_method);
            elif other_overridee_symbols.count > 0 then
                throw new System.Exception("dont think this is possible");

                // if overrider_symbol then
                //     let overrider_is_property = isa Symbol.Property(overrider_symbol);

                //     if isa Symbol.Property(overrider_symbol) then
                //         for overridee_symbol in other_overridee_symbols do
                //             if !overrider_is_property && !isa Symbol.Property(overridee_symbol) then
                //                 logger.warn(overrider_symbol.location, "" + overrider_symbol + " hides " + overridee_symbol);                                                                        
                //             fi
                //         od
                //     fi

                // else
                //     if other_overridee_symbols.count > 1 then
                //         for overridee_symbol in other_overridee_symbols do
                //             logger.warn(into.location, "ambiguous " + overrider_symbol + " hides " + overridee_symbol);                                                                        
                //         od
                //     fi

                //     let existing_symbol = into.find_direct(overridee_symbol.name);

                //     let i = other_overridee_symbols.iterator;
                //     i.move_next();
                //     let overridee_symbol = i.current;
                    
    
                //     if !existing_symbol? then
                //         into.add_member(overridee_symbol);
                //     elif isa Symbol.Property(existing_symbol) && isa Symbol.Property(overridee_symbol) then
                //         logger.warn(existing_symbol.location, "cannot inherit non-function " + member + " over the top of non-function member " + existing);                                        
                //     fi
    
                // fi               

            fi
        si
                        
        @IF.legacy()
        toString() -> String => "" + override_class + ": " + new Shim.JOIN[FUNCTION_WRAPPER](_set);

        @IF.dotnet()
        @IL.name("ToString")
        to_string() -> String => "" + override_class + ": " + new Shim.JOIN[FUNCTION_WRAPPER](_set);

        report_error(into: Symbol.BASE, prefix: String, is_error: bool) is
            let buffer = new StringBuilder();

            buffer.append(prefix).append(" ");

            let seen_any = false;

            for fw in _set do
                let f = fw.function;

                if seen_any then
                    buffer.append(",");
                fi
                
                buffer.append(f.owner.qualified_name).append(".").append(f.short_description);

                seen_any = true;
            od            

            if is_error then
                IoC.CONTAINER.instance.logger.info(into.location, Shim.STR.format(buffer));
            else
                IoC.CONTAINER.instance.logger.info(into.location, Shim.STR.format(buffer));
            fi
        si

        get_overrider(into: Symbol.BASE) -> Symbol.Function is
            if !into.is_stub && _set.count > 1 then
                for fw in _set do
                    let f = fw.function;
                    IoC.CONTAINER.instance.logger.info(f.location, "duplicate method " + f.owner.qualified_name + "." + f.short_description);
                od
            fi
                        
            if _set.count == 0 then
                // Logging.DEBUG.write_line("no concrete implementation");

                return null;
            fi

            let i = _set.iterator;

            i.move_next();

            // Logging.DEBUG.write_line("exactly one concrete implementation:" + i.current.description);

            return i.current.function;
        si
    si

    class METHOD_OVERRIDE_MAP: System.Object, Iterable[METHOD_OVERRIDE_SET] is
        _method_sets: MAP[METHOD_OVERRIDE_CLASS,METHOD_OVERRIDE_SET];
        _symbols: SET[Symbol.BASE];

        name: String;

        other_symbols: SET[Symbol.BASE] => _symbols;

        iterator: Iterator[METHOD_OVERRIDE_SET] => _method_sets.values.iterator;

        [method_class: METHOD_OVERRIDE_CLASS]: METHOD_OVERRIDE_SET is
            if _method_sets.contains_key(method_class) then
                return _method_sets[method_class];
            fi

            return null;            
        si

        init(name: String) is
            _method_sets = new MAP[METHOD_OVERRIDE_CLASS,METHOD_OVERRIDE_SET]();
            _symbols = new SET[Symbol.BASE]();

            self.name = name;
        si

        add(symbol: Symbol.BASE) is
            if isa Symbol.Function(symbol) then
                add(cast Symbol.Function(symbol));

                return;
            fi

            if !_symbols.contains(symbol) then
                _symbols.add(symbol);
            fi            
        si

        add(method: Symbol.Function) is
            let c = method.override_class;

            let method_set: METHOD_OVERRIDE_SET;

            if _method_sets.contains_key(c) then
                method_set = _method_sets[c];
                // Logging.DEBUG.write_line("found existing set: " + method_set);
            else
                method_set = new METHOD_OVERRIDE_SET(c);
                _method_sets[c] = method_set;
                // Logging.DEBUG.write_line("created empty set: " + method_set);
            fi

            method_set.add(method);


            Logging.DEBUG.write_line("all sets named " + name);
            for s in _method_sets do
                Logging.DEBUG.write_line("  set " + name + " " + s.key);

                for f in s.value do
                    Logging.DEBUG.write_line("    " + f);
                od
                
            od

            Logging.DEBUG.write_line("end " + name);

            // Logging.DEBUG.write_line(self);
        si

        @IF.legacy()
        toString() -> String is
            let result = new StringBuilder();

            for s in _method_sets do
                result.append(name + ": " + s.key + ": " + s.value + "\n");
            od          
            
            return Shim.STR.format(result);
        si
    si
si