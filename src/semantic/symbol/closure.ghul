namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    class Closure: Function, Type.Typed is
        description: String => "" + type + " // closure";
        short_description: String => description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        qualified_name: String => "[closure]" + name; // FIXME

        il_name: String => name; // FIXME
        owner_il_name: String => "[closure]"; // FIXME

        il_body: String public;
        
        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new System.NotImplementedException("abstract");
        si

        to_string() -> String => "[closure " + name + "]";

        @IF.legacy()
        toString() -> String => to_string();
    si

    class INSTANCE_CLOSURE: Closure is
        il_def: String => get_il_def(".method public virtual hidebysig instance default ");

        is_instance: bool => true;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_closure(self, type);
        si
    si

    class STATIC_CLOSURE: Closure is
        il_def: String => get_il_def(".method public static hidebysig default ");

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.STATIC_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_closure(self, type);
        si
    si
si
