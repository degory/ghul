namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    class INSTANCE_METHOD: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        is_instance: bool => true;

        override: Function public;

        il_def: String is 
            if il_name !~ ".ctor" then
                return get_il_def(".method public virtual hidebysig instance default ");
            else
                return get_il_def(".method public hidebysig instance default ");
            fi        
        si 

        il_property_def: String => "instance default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_method(from, self);
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            if !from? then
                let context = IoC.CONTAINER.instance.symbol_table.current_function;

                if !context? then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance member from non-function context");                    
                elif !context.is_instance then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance member from static context");
                fi
            fi
            
            return caller.call_instance_method(from, self, arguments, self.arguments, type);
        si
    si

    class STRUCT_METHOD: INSTANCE_METHOD is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        override: Function public;

        il_def: String => get_il_def(".method public final virtual hidebysig newslot instance default ");
        il_property_def: String => "instance default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_struct_method(from, self);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_struct_method(from, self, arguments, self.arguments, type);
        si
    si

    class ABSTRACT_METHOD: INSTANCE_METHOD is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // abstract method";

        il_def: String => get_il_def(".method public virtual hidebysig abstract instance default ");
        il_property_def: String => "instance default " + il_type_name;

        is_abstract: bool => true;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            assert(owner?, "abstract method created without owner");
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_abstract_method(from, self, arguments, self.arguments, type);
        si
    si

    class STATIC_METHOD: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // class method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        override: Function public;

        il_def: String => get_il_def(".method public hidebysig static default ");
        il_property_def: String => "default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.STATIC_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_method(self);
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_static_method(self, arguments, self.arguments, type);
        si
    si
si
