namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    class INSTANCE_METHOD: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        is_instance: bool => true;

        override: Function public;

        il_def: String is 
            if name !~ "init" then
                return get_il_def(".method public virtual hidebysig instance default ");
            else
                return get_il_def(".method public hidebysig instance default ");
            fi        
        si 

        il_property_def: String => "instance default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_method(from, self);
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            if !from? then
                let context = IoC.CONTAINER.instance.symbol_table.current_function;

                if !context? then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance member from non-function context");                    
                elif !context.is_instance then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance member from static context");
                fi
            fi
            
            return caller.call_instance_method(from, self, arguments, self.arguments, type);
        si

        try_override(into: Classy, overridee: Function, logger: Logging.Logger) is
            @IF.debug()  System.Console.write_line("instance try override: " + into + " " + self + " <- " + overridee);

            overridee.try_instance_override_me(into, self, logger);
        si

        try_instance_override_me(into: Classy, overrider: Function, logger: Logger) is
            @IF.debug()  System.Console.write_line("instance try override me: " + into + " " + overrider + " <- " + self);

            let return_type_matches = overrider.ensure_return_type_matches(into, self, true, logger);

            let il_name_matches = overrider.ensure_il_name_matches(into, self, "override", logger);

            @IF.debug()
            if !into.is_stub && return_type_matches && il_name_matches then
                logger.info(overrider.location, "overrides " + self);                
            fi            
        si

        try_struct_override_me(into: Classy, overrider: Function, logger: Logger) is
            let return_type_matches = overrider.ensure_return_type_matches(into, self, true, logger);

            let il_name_matches = overrider.ensure_il_name_matches(into, self, "override", logger);

            @IF.debug() 
            if !into.is_stub && return_type_matches && il_name_matches then
                logger.info(overrider.location, "overrides " + self);                
            fi            
        si

        try_abstract_override_me(into: Classy, overrider: Function, logger: Logger) is
            logger.error(overrider.location, "cannot override abstract method " + self);
        si
    si

    class STRUCT_METHOD: INSTANCE_METHOD is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        override: Function public;

        il_def: String is 
            if il_name !~ ".ctor" && il_name !~ "'.ctor'" then
                return get_il_def(".method public final virtual hidebysig instance default ");
            else
                return get_il_def(".method public final hidebysig instance default ");
            fi        
        si 

        il_property_def: String => "instance default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_struct_method(from, self);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_struct_method(from, self, arguments, self.arguments, type);
        si

        try_override(into: Classy, overridee: Function, logger: Logging.Logger) is
            @IF.debug() Console.write_line("try override C: " + self + " " + overridee);
            overridee.try_struct_override_me(into, self, logger);
        si

        try_struct_override_me(into: Classy, overrider: Function, logger: Logger) is
            logger.error(overrider.location, "cannot override struct method " + self);
        si

        try_instance_override_me(into: Classy, overrider: Function, logger: Logger) is
            logger.error(overrider.location, "cannot override struct method " + self);
        si

        try_abstract_override_me(into: Classy, overrider: Function, logger: Logger) is
            logger.error(overrider.location, "cannot override struct method " + self);
        si
    si

    class ABSTRACT_METHOD: INSTANCE_METHOD is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // abstract method";

        il_def: String => get_il_def(".method public virtual hidebysig abstract instance default ");
        il_property_def: String => "instance default " + il_type_name;

        is_abstract: bool => true;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            assert owner? else "abstract method created without owner";
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_abstract_method(from, self, arguments, self.arguments, type);
        si

        try_pull_down_into(
            into: Classy,
            other_overridee_symbols: Collections.Iterable[BASE],
            logger: Logging.Logger
        ) is
            if !into.is_trait && !into.is_stub then
                logger.error(into.location, "must implement " + self);
            fi
            
            into.add_member(self);
        si

        try_override(into: Classy, overridee: Function, logger: Logging.Logger) is
            @IF.debug()  Console.write_line("try override D: " + self + " " + overridee);
            overridee.try_abstract_override_me(into, self, logger);
        si

        try_instance_override_me(into: Classy, overrider: Function, logger: Logger) is
            let return_type_matches = overrider.ensure_return_type_matches(into, self, false, logger);

            let il_name_matches = overrider.ensure_il_name_matches(into, self, "implement", logger);
            
            @IF.debug() 
            if !into.is_stub && return_type_matches && il_name_matches then
                logger.info(overrider.location, "implements " + self);                
            fi            
        si

        try_struct_override_me(into: Classy, overrider: Function, logger: Logger) is
            let return_type_matches = overrider.ensure_return_type_matches(into, self, false, logger);

            let il_name_matches = overrider.ensure_il_name_matches(into, self, "implement", logger);

            @IF.debug() 
            if !into.is_stub && return_type_matches && il_name_matches then
                logger.info(overrider.location, "implements " + self);
            fi
        si

        try_abstract_override_me(into: Classy, overrider: Function, logger: Logger) is
            logger.info(overrider.location, "hides " + self + " (case D)");
        si
    si

    class STATIC_METHOD: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // class method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        override: Function public;

        il_def: String => get_il_def(".method public hidebysig static default ");
        il_property_def: String => "default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.STATIC_CLOSURE(location, owner, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_method(self);
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_static_method(self, arguments, self.arguments, type);
        si

        try_override(into: Classy, overridee: Function, logger: Logging.Logger) is
            @IF.debug() Console.write_line("try override E: " + self + " " + overridee);
            logger.warn(self.location, "static method hides " + overridee);
        si

        try_instance_override_me(into: Classy, overrider: Function, logger: Logger) is
            logger.info(overrider.location, "hides static method " + self);
        si

        try_struct_override_me(into: Classy, overrider: Function, logger: Logger) is
            logger.info(overrider.location, "hides static method " + self);
        si

        try_abstract_override_me(into: Classy, overrider: Function, logger: Logger) is
            logger.info(overrider.location, "hides static method " + self);
        si
    si
si
