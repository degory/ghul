namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    enum ACCESS is
        PRIVATE, PUBLIC, PROTECTED 
    si

    // Language Server Protocol symbol kinds.
    // Not all are applicatble to ghÅ«l:

    /*
	export const File = 1;
	export const Module = 2;
	export const Namespace = 3;
	export const Package = 4;
	export const Class = 5;
	export const Method = 6;
	export const Property = 7;
	export const Field = 8;
	export const Constructor = 9;
	export const Enum = 10;
	export const Interface = 11;
	export const Function = 12;
	export const Variable = 13;
	export const Constant = 14;
	export const String = 15;
	export const Number = 16;
	export const Boolean = 17;
	export const Array = 18;
	export const Object = 19;
	export const Key = 20;
	export const Null = 21;
	export const EnumMember = 22;
	export const Struct = 23;
	export const Event = 24;
	export const Operator = 25;
	export const TypeParameter = 26;
    */

    // FIXME: think the language server needs to declare it can
    // use the newer list below for completions as well as symbol info:
    enum COMPLETION_KIND is
        UNDEFINED = 0,
        METHOD = 2,
        FUNCTION = 3,
        CONSTRUCTOR = 4,
        FIELD = 5,
        VARIABLE = 6,
        CLASS = 7,
        INTERFACE = 8,
        MODULE = 9,
        PROPERTY = 10,
        ENUM = 13
    si

    enum SYMBOL_KIND is
        UNDEFINED = 0,
        FILE = 1,
        MODULE = 2,
        NAMESPACE = 3,
        PACKAGE = 4,
        CLASS = 5,
        METHOD = 6,
        PROPERTY = 7,
        FIELD = 8,
        CONSTRUCTOR = 9,
        ENUM = 10,
        INTERFACE = 11,
        FUNCTION = 12,
        VARIABLE = 13,
        CONSTANT = 14,
        STRING = 15,
        NUMBER = 16,
        BOOLEAN = 17,
        ARRAY = 18,
        OBJECT = 19,
        KEY = 20,
        NULL = 21,
        ENUM_MEMBER = 22,
        STRUCT = 23,
        EVENT = 24,
        OPERATOR = 25,
        TYPE_PARAMETER = 26
    si

    class BASE: Object, Scope is
        _owner: Scope;

        type: Type.BASE => Type.NONE.instance;

        owner: Scope public => _owner, = value is
            if _owner? && !value? then
                IO.Std.err.println("clear owner " + self + " from " + new System.Backtrace());                
            fi
            
            _owner = value;
        si
        
        location: LOCATION;
        _name: String;

        name: String => _name;

        qualified_name: String is
            assert(owner?, ClassName + " " + name + " has no qualified name because owner is null");

            return owner.qualify(name);
        si
        
        il_name: String is
            if il_name_override? then
                return il_name_override;
            else
                return "'" + name + "'";
            fi
        si

        il_qualified_name: String is
            if il_name_override? && (il_is_built_in_type || il_name_override.indexOf('.') >= 0 || il_name_override.indexOf("::") >= 0) then
                return il_name_override;
            fi            

            if owner? then
                return owner_il_name + "." + il_name;
            else
                return il_name;
            fi
        si        

        il_name_override: String public;

        // FIXME: can these go somewhere more specific?
        il_is_built_in_type: bool public;

        owner_il_name: String is
            if self.owner == self then
                throw new Exception("symbol is own owner");
            fi

            assert(owner? && isa BASE(owner), "owner is null or not a symbol: " + self + " owner: " + owner);

            return cast BASE(owner).il_qualified_name;
        si        

        argument_names: List[String] => new String[](0);        
        arguments: List[Type.BASE] => new Type.BASE[](0);
        ancestors: List[Type.BASE] => new Type.BASE[](0);

        specialized_from: Symbol.BASE public;
        // specializations: Iterable[List[Type.BASE]] => new List[Type.BASE][](0);

        access: ACCESS => ACCESS.PUBLIC;

        description: String => qualified_name;
        short_description: String => name;

        is_workspace_visible:
             bool => false;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.UNDEFINED;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.UNDEFINED;

        is_value_type: bool => false;
        is_instance: bool => false;
        is_innate: bool => false;
        is_inheritable: bool => false;
        is_class: bool => false;
        is_trait: bool => false;

        il_type_name: String => il_qualified_name;

        il_def: String => name;

        init(location: LOCATION, owner: Scope, name: String) is
            self.location = location;
            self.owner = owner;
            _name = name;
        si

        get_ancestor(i: int) -> Type.BASE is
            throw new NotImplementedException(ClassName + " has no ancestor " + i);
        si

        find_ancestor(ancestor: Symbol.BASE, name: String) -> BASE is
            let debug = name =~ "__read_iterator";

            if ancestor.type =~ self.type return
                return self;
            fi
            
            for a in ancestors do
                let result = a.find_ancestor(ancestor, name);

                if result? then
                    return result;
                fi
            od
        si

        qualify(name: String) -> String => qualified_name + "." + name;

        compare_type(other: Symbol.BASE) -> Type.MATCH
            => Type.MATCH.DIFFERENT;

        specialize(type_map: Dict[String,Type.BASE], owner: BASE) -> BASE is
            throw new NotImplementedException(ClassName + " cannot be specialized: " + self);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be loaded: " + self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be stored: " + self);
        si

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException(ClassName + " cannot be called: " + self);
        si

        find_direct(name: String) -> BASE => null;

        find_member(name: String) -> BASE => null;

        find_enclosing(name: String) -> BASE => null;

        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        find_ancestor_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        collapse_group_if_single_member() -> Symbol.BASE is
            return self;
        si

        toString() -> String =>
            ClassName + " " + name + " @ " + location;
    si

    class NONE: BASE, Scope is
        _instance: NONE static;

        instance: NONE static is
            if !_instance? then
                _instance = new NONE();
            fi

            return _instance;
        si

        init() is
            super.init();
        si
    si
    

    // A GENERIC represents a particular specialization of a generic class, trait or struct - i.e. a version of that symbol
    // with actual type arguments specified for its formal type parameters, and all its member symbols' signatures rewritten 
    // with all instances of each formal type parameter replaced with the corresponding actual type argument  
    class GENERIC: BASE, Scope is
        type_map: Dict[String,Type.BASE];
        arguments: List[Type.BASE];
        ancestors: List[Type.BASE] => symbol.ancestors;
        symbol: ScopedWithInheritance;

        owner: Scope => symbol.owner;
        location: LOCATION => symbol.location;
        name: String => symbol.name;

        access: ACCESS => symbol.access;

        is_value_type: bool => symbol.is_value_type;
        is_inheritable: bool => symbol.is_inheritable;
        is_class: bool => symbol.is_class;
        is_trait: bool => symbol.is_trait;

        description: String => qualified_name + "[" + arguments + "]";

        short_description: String is
            let result = new StringBuffer();

            result
                .append(name)
                .append('[');

            var seen_any = false;

            for a in arguments do
                if seen_any then
                    result.append(',');
                fi

                result.append(a.short_description);

                seen_any = true;
            od

            result.append(']');
        si

        symbol_kind: SYMBOL_KIND => symbol.symbol_kind;
        completion_kind: COMPLETION_KIND => symbol.completion_kind;
        // is_workspace_visible: bool => true;

        il_type_name: String is
            let result = new StringBuffer();

            let qn = symbol.il_name_override;

            if !qn? then

                let kind = "class ";

                if symbol.is_value_type then
                    kind = "valuetype ";
                fi            
    
                result
                    .append(kind)
                    .append(owner_il_name)
                    .append('.')
                    // FIXME: trying to quote name causes an ILAsm syntax error here:
                    .append(name)
                    .append('`')
                    .append(arguments.Length);
            else
                result
                    .append(qn);
            fi

            result
                .append('<');

            var seen_any = false;

            for a in arguments do
                if seen_any then
                    result.append(',');
                fi

                result.append(a.il_type_name);

                seen_any = true;
            od

            result.append('>');

            return result;
        si

        il_def: String => "generic has no il_def: " + self;

        type: Type.NAMED is
            return new Type.GENERIC(self.location, self.symbol, self.arguments);
        si
        
        init(location: LOCATION, symbol: ScopedWithInheritance, arguments: List[Type.BASE]) is
            super.init(
                symbol.location,
                symbol,
                symbol.name);

            self.symbol = symbol;

            let length = arguments.Length;

            if arguments.Length != symbol.argument_names.Length then
                if length > symbol.argument_names.Length then
                    length = symbol.argument_names.Length;
                fi

                IoC.CONTAINER.instance.logger.error(location, "expected % type arguments" % [symbol.argument_names.Length]: Object);
            fi

            self.arguments = arguments;
            type_map = new Map[String,Type.BASE]();

            for i in 0..length do
                type_map[symbol.argument_names[i]] = arguments[i];
            od
        si

        get_ancestor(i: int) -> Type.BASE
            => ancestors[i].specialize(type_map);
        
        =~(other: BASE) -> bool is
            if !isa GENERIC(other) then
                return false;
            fi

            let other_generic = cast GENERIC(other);

            if other_generic.symbol != symbol then
                return false;
            fi

            assert(
                other_generic.arguments.Length == arguments.Length,
                "generics with the same symbol should have same number of arguments (% vs %)"
                    % [other_generic.arguments, arguments]: Object);

            for i in 0..arguments.Length do
                if arguments[i] != other_generic.arguments[i] then
                    return false;
                fi
            od

            return true;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return symbol.load(location, from, loader);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return symbol.store(location, from, value, loader);
        si

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return symbol.call(from, arguments, type, caller);
        si

        // given a member of the class, trait or struct that this generic wraps, we want to get a copy of it
        // with all references to formal type parameters replaced with the corresponding actual type arguments
        _specialize(member: Symbol.BASE) -> Symbol.BASE is
            if member? /* && result.owner == symbol */ then
                // result is owned by the class/trait that we wrap and so
                // needs to be specialized according to our type map

                let generic_cache = IoC.CONTAINER.instance.generic_cache;

                let key = new GENERIC_KEY(symbol, member, arguments);

                // do we already have a specialization for this symbol with
                // our actual type arguments?
                let specialized = generic_cache[key];

                if specialized == null then
                    // no pre-existing specialization found, create one:
                    specialized = member.specialize(type_map, self);

                    // and cache it:
                    generic_cache[key] = specialized;
                fi

                return specialized;
            else
                return null;
            fi
        si

        find_direct(name: String) -> BASE is
            return _specialize(symbol.find_direct(name));
        si

        find_member(name: String) -> BASE is
            if name =~ "__read_iterator" then
                let result = symbol.find_member(name);

                IO.Std.err.println("unspecialized: " + result);

                result = _specialize(result);

                IO.Std.err.println("specialized: " + result);

                return result;
            fi            

            return _specialize(symbol.find_member(name));
        si

        find_enclosing(name: String) -> BASE is
            let unspecialized = symbol.find_enclosing(name);

            if unspecialized? && unspecialized.owner == symbol then
                return _specialize(unspecialized);
            else
                return unspecialized;
            fi
        si

        // used by the language server to offer code completion suggestions - as code completion is
        // only possible from within the class/trait/struct, we do not need to specialize - the user
        // needs to see unspecialized member symbols and formal type parameters 
        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            let m = new Map[String, Symbol.BASE]();

            symbol.find_direct_matches(prefix, m);

            for p in m.Pairs do
                if !matches.contains(p.key) then
                    matches[p.key] = _specialize(p.value).collapse_group_if_single_member();
                fi
            od
        si

        // used by the language server to offer code completion suggestions - as code completion is
        // only possible from within the class/trait/struct, we do not need to specialize - the user
        // needs to see unspecialized member symbols and formal type parameters 
        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            symbol.find_ancestor_matches(prefix, matches);
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
        si

        hash() -> int is
            var result = symbol.hash();

            for a in arguments do
                result = result + a.hash();
            od

            return result;
        si

        toString() -> String => qualified_name + "[" + arguments + "]";
    si

    class Scoped: BASE, Scope, DeclarationContext is
        _symbols: SYMBOL_MAP;

        symbols: Iterable[BASE] => _symbols;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
            _symbols = new SYMBOL_MAP();
        si

        resolve_overrides() is
            throw new NotImplementedException();
        si

        find_direct(name: String) -> BASE is
            return _symbols[name];
        si

        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            _symbols.find_matches(prefix, matches);
        si

        declare(location: LOCATION, symbol: BASE, symbol_definition_listener: SymbolDefinitionListener) is
            var existing = find_direct(symbol.name);

            if existing? then
                CONTAINER.instance.logger.error(location, "redefining symbol " + symbol.name + " originally defined at " + existing.location);
                CONTAINER.instance.logger.error(existing.location, "symbol " + symbol.name + " is redefined at " + location);

                return;
            fi

            if symbol_definition_listener? then
                symbol_definition_listener.add_symbol_definition(location, symbol);
            fi

            _symbols[symbol.name] = symbol;
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, self, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_struct(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "struct", name);

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "closure", name);

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "innate", name);

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "property", name);

        declare_label(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "label", name);
        si

        declare_function_group(location: LOCATION, function: Function, symbol_definition_listener: SymbolDefinitionListener) is
            var existing = find_direct(function.name);
            var function_group: Symbol.FUNCTION_GROUP;

            if existing? then
                if !isa Symbol.FUNCTION_GROUP(existing) then
                    CONTAINER.instance.logger.error(location, "redefining symbol " + function.name + " originally defined at " + existing.location);
                    CONTAINER.instance.logger.error(existing.location, "symbol " + function.name + " is redefined at " + location);

                    return;
                fi

                function_group = cast Symbol.FUNCTION_GROUP(existing);
            else
                function_group = new Symbol.FUNCTION_GROUP(LOCATION.dummy, self, function.name);
                _symbols[function.name] = function_group;
            fi

            symbol_definition_listener.add_symbol_definition(location, function);

            function_group.add(function);
        si
    si

    class UNDEFINED: BASE, Scope, DeclarationContext, Type.Typed is
        type: Type.BASE => new Type.ANY();

        description: String => "undefined";

        il_def: String => "undefined has no il_def: " + self;       

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, self, name);
        si

        add_namespace(location: LOCATION, name: String, namespace_: NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_struct(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "struct", name);

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "closure", name);

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "innate", name);

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "variable", name);
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "undefine", name);        

        declare_label(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "label", name);
        si
    si

    class ScopedWithEnclosingScope: Scoped is
        _enclosing_scope: Scope;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name);

            _enclosing_scope = enclosing_scope;
        si

        find_enclosing_only(name: String) -> BASE is
            if _enclosing_scope? then
                var result = _enclosing_scope.find_enclosing(name);

                return result;
            fi

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            else
                return find_enclosing_only(name);
            fi
        si

        find_enclosing_only_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            if _enclosing_scope? then
                _enclosing_scope.find_enclosing_matches(prefix, matches);
            fi
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si
    si

    class ScopedWithInheritance: ScopedWithEnclosingScope is
        _ancestors: Vector[Type.BASE];

        type: Type.BASE public;

        argument_names: List[String];
        ancestors: List[Type.BASE] => _ancestors;

        closures: List[CLOSURE];

        is_workspace_visible: bool => true;

        il_name_prefix: String => "";        

        il_type_name: String is
            if il_name_override? then
                return il_qualified_name;
            else
                return il_name_prefix + il_qualified_name;
            fi
        si

        get_il_def(preamble: String) -> String is
            let result = new StringBuffer();

            result
                .append(preamble)
                .append(' ');

            if il_name_override? then
                result
                    .append(il_name_override);

            elif argument_names.Length > 0 then
                result
                    .append(name)
                    .append('`')
                    .append(argument_names.Length)
                    .append('<');

                // FIXME: contraints here

                let seen_any = false;

                for argument in argument_names do
                    if seen_any then
                        result.append(',');
                    fi
                    
                    result
                        .append(argument);

                    seen_any = true;
                od

                result.append('>');
            else
                result.append(il_name);        
            fi
            
            let index = 0;
            let done_implements = false;

            for a in ancestors do
                if !isa Type.NAMED(a) then
                    continue;  
                fi

                let ancestor = cast Type.NAMED(a).symbol;

                if index == 0 && !ancestor.is_trait then
                    result
                        .append(" extends ")
                        .append(ancestor.il_type_name);

                elif ancestor.is_trait then
                    if !done_implements then
                        result.append(" implements ");

                        done_implements = true;
                    else
                        result.append(", ");
                    fi

                    result
                        .append(a.il_type_name);
                fi

                index = index + 1;
            od

            return result;
        si

        init(location: LOCATION, owner: Scope, name: String, argument_names: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            _ancestors = new Vector[Type.BASE]();
            self.argument_names = argument_names;

            type = new Type.NAMED(self);
        si

        get_ancestor(i: int) -> Type.BASE
            => ancestors[i].specialize(new Map[String,Type.BASE]());

        add_ancestor(ancestor: Type.BASE) is
            ancestors.add(ancestor);
        si

        push_ancestor(ancestor: Type.BASE) is
            let na = new Vector[Type.BASE]();

            na.add(ancestor);
            na.add(_ancestors);

            _ancestors = na;
        si

        add_closure(closure: CLOSURE) is
            if !closures? then
                closures = new Vector[CLOSURE]();
            fi

            closures.add(closure);
        si
        
        resolve_overrides(overriding_fg: FUNCTION_GROUP, generic_cache: GENERIC_CACHE) is
            try
                // all function groups in ancestors with same name:
                for overridden_fg in find_member_all(overriding_fg.name) do
                    if isa FUNCTION_GROUP(overridden_fg) then

                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    else
                        for f in overriding_fg.functions do
                            CONTAINER.instance.logger.error(f.location, "overriding non-function declared at " + overridden_fg.location);
                        od
                    fi
                od

                // FIXME: although these functions do need to be treated similarly, they are not overridden, merely hidden, by methods in this scope:

                // function group in enclosing scope with same name, if any:
                let overridden_fg = find_enclosing_only(overriding_fg.name);

                if overridden_fg? then
                    if isa FUNCTION_GROUP(overridden_fg) then
                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    else
                        for f in overriding_fg.functions do
                            CONTAINER.instance.logger.error(f.location, "overriding non-function declared at " + overridden_fg.location);
                        od
                    fi

                    overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                fi
            catch e: Exception
                IO.Std.err.println("caught exception trying to resolve overrides for " + overriding_fg + "\n" + e);
            yrt
        si

        find_member(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = find_member_only(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = find_member_only(name);

            if result? then
                return result;
            fi

            result = find_enclosing_only(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_member_only(name: String) -> BASE is
            assert(ancestors?, "ancestors is null");

            for a in ancestors do
                if a? && a.scope? then
                    var result = a.scope.find_member(name);

                    if result? then
                        return result;
                    fi
                elif a? then
                    IO.Std.err.println("ancestor of " + qualified_name + " has null scope");
                    IO.Std.err.println("ancestor of " + qualified_name + " has null scope " + a);
                else
                    IO.Std.err.println("ancestor or " + qualified_name + " is null");
                fi
            od

            return null;
        si

        find_member_all(name: String) -> Iterable[BASE] is
            let result = new Vector[BASE]();

            for a in ancestors do
                if a? && a.scope? then
                    let s = a.scope.find_member(name);

                    if s? then
                        result.add(s);
                    fi
                else
                    IO.Std.err.println("something wrong with ancestors for " + qualified_name);
                fi
            od

            return result;
        si

        find_ancestor_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);

            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
        si

        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_member_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si
    si

    class CLASS: ScopedWithInheritance, Type.Typed is
        description: String => "class " + qualified_name;
        short_description: String => "class " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.CLASS;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        is_inheritable: bool => true;
        is_class: bool => true;

        il_def: String => get_il_def(".class public auto ansi beforefieldinit");

        il_name_prefix: String => "class ";

        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_class(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Function;

            if is_static then
                result = new Symbol.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbol.INSTANCE_METHOD(location, self, name, enclosing);
            fi
            
            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            let result: Variable;
            
            if is_static then
                result = new Symbol.STATIC_FIELD(location, self, name);
            else
                result = new Symbol.INSTANCE_FIELD(location, self, name);
            fi

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Property;

            if is_static then
                result = new Symbol.STATIC_PROPERTY(location, self, name, is_assignable);
            else
                result = new Symbol.INSTANCE_PROPERTY(location, self, name, is_assignable);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si

    class TRAIT: ScopedWithInheritance, Type.Typed is
        description: String => "trait " + qualified_name;
        short_description: String => "trait " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.INTERFACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.INTERFACE;

        is_inheritable: bool => true;
        is_trait: bool => true;

        il_name_prefix: String => "class ";

        il_def: String => get_il_def(".class public interface auto ansi beforefieldinit");

        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_trait(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result: Function;
            
            if is_static then
                IoC.CONTAINER.instance.logger.error(location, "cannot declare static method in trait");
                result = new Symbol.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbol.ABSTRACT_METHOD(location, self, name, enclosing);
            fi

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result: Property;

            if is_static then
                IoC.CONTAINER.instance.logger.error(location, "cannot declare static property in trait");
                result = new Symbol.STATIC_PROPERTY(location, self, name, is_assignable);
            else
                result = new Symbol.INSTANCE_PROPERTY(location, self, name, is_assignable);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si

    // FIXME: misleading name and class heirarchy - STRUCT doesn't support inheritance
    class STRUCT: ScopedWithInheritance, Type.Typed is
        description: String => "struct " + qualified_name;
        short_description: String => "struct " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.STRUCT;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        is_value_type: bool => true;

        il_name_prefix: String => "valuetype ";

        il_def: String => get_il_def(".class public auto ansi beforefieldinit");

        init(location: LOCATION, owner: Scope, name: String, arguments: List[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_struct(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Function;

            if is_static then
                result = new Symbol.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbol.STRUCT_METHOD(location, self, name, enclosing);
            fi

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            // FIXME: probably also needs to load address of self:
            var result = new Symbol.INSTANCE_FIELD(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_PROPERTY(location, self, name, is_assignable);

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si

    // FIXME: doesn't really have a type, not sure how to represent this:
    class NAMESPACE: ScopedWithEnclosingScope, NamespaceContext, Type.Typed is
        qualified_name: String;

        type: Type.BASE;

        description: String => "namespace " + qualified_name;
        short_description: String => "namespace " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.NAMESPACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.MODULE;

        is_workspace_visible: bool => true;

        il_qualified_name: String is
            let parts = qualified_name.substring(1).split('.');

            let result = new StringBuffer(qualified_name.Length + parts.Length * 3);

            let seen_any = false;

            for part in parts do
                if seen_any then
                    result.append('.');
                fi                

                result
                    .append("'")
                    .append(part)
                    .append("'");

                seen_any = true;
            od

            return result;
        si

        // FIXME: the IL generation pass is not using the namespace symbol so does not see this:
        il_def: String => ".namespace " + il_qualified_name;

        init(location: LOCATION, name: String, enclosing_scope: Scope, qualified_name: String) is
            super.init(location, self, name, enclosing_scope);

            self.qualified_name = qualified_name;

            type = new Type.NAMED(self);
        si

        qualify(name: String) -> String => qualified_name.substring(1) + "." + name;

        find_member(name: String) -> BASE
            => find_direct(name);

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
        si

        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare(location, namespace_, symbol_definition_listener);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.CLASS(location, self, name, arguments, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TRAIT(location, self, name, arguments, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_struct(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.STRUCT(location, self, name, arguments, enclosing);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.GLOBAL_VARIABLE(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_PROPERTY(location, self, name, is_assignable);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_namespace(self);
        si
    si

    class ENUM_: Scoped, Type.Typed is
        _ancestor_: Type.NAMED;
        _ancestors: Type.BASE[];

        _next_value: int;

        next_value: int is
            let result = _next_value;

            _next_value = _next_value + 1;

            return result;
        si        

        ancestors: List[Type.BASE] is
            if _ancestors == null then
                _ancestor_ = IoC.CONTAINER.instance.ghul_symbol_lookup.get_enum_type(type);

                _ancestors = [cast Type.BASE(_ancestor_)];
            fi

            return _ancestors;
        si

        get_ancestor(index: int) -> Type.BASE is
            assert(index == 0, ClassName + " has only a single ancestor");

            return _ancestor_;
        si

        type: Type.BASE;

        description: String => "enum " + qualified_name;
        short_description: String => "enum " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;
        is_workspace_visible: bool => true;

        is_value_type: bool => true;

        il_type_name: String is
            if il_name_override? then
                return il_qualified_name;
            else
                return "valuetype " + il_qualified_name;
            fi
        si

        il_def: String =>
            ".class public auto ansi sealed " + il_name + " extends [mscorlib]System.Enum";

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            type = new Type.NAMED(self);
        si

        compare_type(other: BASE) -> Type.MATCH is
            if self == other then
                return Type.MATCH.SAME;
            else
                return Type.MATCH.DIFFERENT;
            fi
        si

        specialize(type_map: Dict[String,Type.BASE], owner: BASE) -> BASE
            => self;

        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var result = new Symbol.ENUM_MEMBER(location, self, name, next_value);

            declare(location, result, symbol_definition_listener);
        si

        find_member(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = _ancestor_.find_member(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            find_ancestor_matches(prefix, matches);
        si

        find_ancestor_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            _ancestor_.scope.find_member_matches(prefix, matches);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_enum(self);
        si
    si

    class ENUM_MEMBER: BASE, Type.Typed is
        _enum: ENUM_ => cast ENUM_(owner);

        type: Type.BASE => _enum.type;

        value: int;

        description: String => "enum member " + qualified_name;
        short_description: String => name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.ENUM_MEMBER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.ENUM;

        il_def: String =>
            ".field public static literal " + _enum.il_type_name + " " + il_name + " = int32(" + value + ")";

        init(location: LOCATION, owner: ENUM_, name: String, value: int) is
            super.init(location, owner, name);

            self.value = value;
        si

        specialize(type_map: Dict[String,Symbol.BASE], owner: BASE) -> BASE
            => self;

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            var result = loader.load_enum_member(self);

            return result;
        si
    si

    class LABEL: BASE is
        description: String => "label " + name;
        short_description: String => description;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        specialize(type_map: Dict[String,Symbol.BASE], owner: GENERIC) -> BASE
            => self;
    si

    class TYPE: Scoped, Type.SettableTyped is
        type: Type.BASE public;
        
        ancestor: Semantic.Scope public;

        index: int;

        il_def: String => "type has no il_def: " + self;

        il_type_name: String => "!" + index;

        // FIXME: should ancestor be a type not a symbol? We could then just use BASE.ancestors.
        // We'll need multiple ancestors to support multiple constraints anyway
        ancestors: List[Type.BASE] is
            if ancestor == null then
                return new Type.BASE[](0);
            fi

            let result = new Type.BASE[](1);
            result[0] = new Type.NAMED(cast Symbol.BASE(ancestor));

            return result;
        si
        
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.TYPE_PARAMETER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.VARIABLE;

        description: String => name + ": " + type + " // type variable";
        short_description: String => description;

        init(location: LOCATION, owner: Scope, name: String, index: int) is
            init(location, owner, name, new Type.NAMED(self));

            self.index = index; 
        si

        init(location: LOCATION, owner: Scope, name: String, type: Type.BASE) is
            super.init(location, owner, name);

            self.type = type;
        si

        find_member(name: String) -> BASE is
            if ancestor? then
                let result = ancestor.find_member(name);

                return result;
            fi
        si

        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]) is
            if ancestor? then
                ancestor.find_member_matches(prefix, matches);
            fi
        si

        compare_type(other: BASE) -> Type.MATCH is
            if self == other then
                return Type.MATCH.SAME;
            fi

            return Type.MATCH.DIFFERENT;
        si

        specialize(type_map: Dict[String,Type.BASE], owner: BASE) -> BASE is
            let result_type = type_map[self.name];

            if result_type? then
                return new TYPE(
                    location,
                    self,
                    name,
                    result_type
                );
            fi

            return self;
        si
    si

    class Function: ScopedWithEnclosingScope, Type.Typed is
        _declaring_arguments: bool;

        type: Type.BASE public;
        return_type: Type.BASE public;
        arguments: List[Type.BASE] public;

        unspecialized_arguments: List[Type.BASE] public;
        unspecialized_return_type: Type.BASE public;

        argument_names: List[String] public;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        is_workspace_visible: bool => true;
        is_abstract: bool => false;

        short_description: String => name + "(" + short_argument_descriptions + ") -> " + return_type.short_description;

        il_property_def: String => get_il_def("// not a property ");

        il_qualified_name: String is
            assert(
                owner? && isa BASE(owner),
                "null or invalid owner"
            );

            return cast BASE(owner).il_type_name + "::" + il_name;
        si

        il_type_name: String is
            let result = new StringBuffer();

            assert(self?, "function il_type_name self is null");

            assert(unspecialized_arguments? || !specialized_from?, "function specialized from generic has no copy of original unspecialised arguments: " + self);
            assert(unspecialized_return_type? || !specialized_from?, "function specialized from generic has no copy of original unspecialised arguments: " + self);

            let rt = unspecialized_return_type;

            if !rt? then
                rt = return_type;
            fi

            if !rt? then
                IO.Std.err.println("function has no return type");
                IO.Std.err.println("function has no return type: " + name);
                IO.Std.err.println("function has no return type: " + owner + "." + name);

                result.append("void ");
            else
                result
                .append(rt.il_type_name)
                .append(' ');
            fi
            
            result
                .append(il_qualified_name)
                .append('(');

            let seen_any = false;


            let args = unspecialized_arguments;

            if !args? then
                args = arguments;
            fi
            
            for argument in args do
                if seen_any then
                    result.append(',');
                fi

                if argument? then
                    result.append(argument.il_type_name);
                else
                    IO.Std.err.println("broken unspecialized_arguments: " + unspecialized_arguments);
                fi

                seen_any = true;
            od

            result.append(')');

            return result;
        si

        argument_descriptions: String is
            let result = new StringBuffer();

            for i in 0..arguments.Length do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_argument_description(i));
            od

            return result;
        si

        short_argument_descriptions: String is
            let result = new StringBuffer();

            for i in 0..arguments.Length do
                if i > 0 then
                    result.append(", ");
                fi
                result.append(get_short_argument_description(i));
            od

            return result;
        si

        override: Function public
            => null,
            = value
                is throw new NotImplementedException("" + self + " cannot override " + value); si

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            type = new Type.NAMED(self);
        si

        get_il_def(preamble: String) -> String is
            let result = new StringBuffer();

            result
                .append(preamble)
                .append(' ')
                .append(return_type.il_type_name)
                .append(' ')
                .append(il_name)
                .append('(');

            let seen_any = false;
            
            for i in 0..argument_names.Length do
                if seen_any then
                    result.append(',');
                fi
                
                result
                    .append(arguments[i].il_type_name)
                    .append(" '")
                    .append(argument_names[i])
                    .append("'");

                seen_any = true;
            od

            result.append(") cil managed");

            return result;    
        si
        
        start_declaring_arguments() is
            _declaring_arguments = true;
        si

        end_declaring_arguments() is
            _declaring_arguments = false;
        si

        specialize(type_map: Dict[String,Type.BASE], owner: BASE) -> Function is
            assert(owner?, "cannot specialize " + self + " with null owner");

            if return_type == null then
                IO.Std.err.println("oops: attempting to specialize function with null return type");
                return self;
            fi

            let result = cast Function(clone());
            
            result.specialized_from = self;

            // IO.Std.err.println("set specialized from: " + qualified_name);

            result.return_type = return_type.specialize(type_map);

            result.owner = owner;

            result.unspecialized_arguments = arguments;
            result.unspecialized_return_type = return_type;

            result.arguments = new Vector[Type.BASE](arguments);

            for i in 0..arguments.Length do
                let a = arguments[i];

                if a? then
                    result.arguments[i] = arguments[i].specialize(type_map);
                fi
            od

            return result;
        si

        get_full_type(ghul_symbol_lookup: GHUL_SYMBOL_LOOKUP) -> Type.NAMED is
            let types = new Vector[Type.BASE](arguments.Length + 1);

            types.add(arguments);
            types.add(return_type);

            return ghul_symbol_lookup.get_function_type(types);
        si

        is_exact_match(arguments: List[Type.BASE], type: Type.BASE) -> bool is
            if arguments.Length != self.arguments.Length then
                return false;
            fi

            for i in 0..arguments.Length do
                if arguments[i] != self.arguments[i] then
                    return false;
                fi
            od

            if return_type != self.return_type then
                return false;
            fi

            return true;
        si

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            if _declaring_arguments then
                var result = new Symbol.LOCAL_ARGUMENT(location, self, name);

                declare(location, result, symbol_definition_listener);
            else
                var result = new Symbol.LOCAL_VARIABLE(location, self, name);

                declare(location, result, symbol_definition_listener);                            
            fi
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.CLOSURE(location, self, name, enclosing);

            declare(location, result, null);

            return result;
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.GLOBAL_FUNCTION(location, self, name, enclosing);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        get_argument_description(index: int) -> String is
            let result = new StringBuffer();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index]);

            return result;
        si

        get_short_argument_description(index: int) -> String is
            let result = new StringBuffer();

            result
                .append(argument_names[index])
                .append(": ")
                .append(arguments[index].short_description);

            return result;
        si

        toString() -> String => qualified_name + " (" + arguments + ") -> " + return_type;
    si

    // FIXME: need separate representations for closures within instance methods, static methods,
    // global methods and other closures: might make sense for each of these to inherit from the
    // corresponding Function subclass
    class CLOSURE: Function, Type.Typed is
        description: String => "" + type + " // closure";
        short_description: String => description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        il_name: String => name; // FIXME
        owner_il_name: String => "[closure]"; // FIXME
        il_def: String => get_il_def(".method public virtual hidebysig instance default ");

        il_body: String public;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        declare_closure(location: LOCATION, name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.CLOSURE(location, self, name, enclosing);

            declare(location, result, null);

            return result;
        si

        load(location: LOCATION, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_closure(self, type);
        si
    si

    class InnateFunction: Function is
        innate_name: String;
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // innate function " + innate_name;
        
        is_innate: bool => true;

        il_def: String => get_il_def("// innate ");

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope, innate_name: String) is            
            super.init(location, owner, name, qualifier_scope);

            self.innate_name = innate_name;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_global_function(self);
        si

    si

    class INNATE_FUNCTION: InnateFunction is
        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope, innate_name: String) is            
            super.init(location, owner, name, qualifier_scope, innate_name);
        si        

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            assert(from == null, "instance call of innate function: " + self + "\nfrom: " + from + "\nargs: " + arguments + "\n");

            return caller.call_innate_function(self, arguments, self.arguments, type);
        si
    si

    class INNATE_METHOD: InnateFunction is
        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope, innate_name: String) is            
            super.init(location, owner, name, qualifier_scope, innate_name);
        si        

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_innate_function(self, from, arguments, self.arguments, type);
        si        
    si
    
    

    class GLOBAL_FUNCTION: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // global function";

        il_def: String => get_il_def("// global ");

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_global_function(self);
        si

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            assert(from == null);
            return caller.call_global_function(self, arguments, self.arguments, type);
        si
    si

    class INSTANCE_METHOD: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        is_instance: bool => true;

        override: Function public;

        il_def: String => get_il_def(".method public virtual hidebysig instance default ");
        il_property_def: String => "instance default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_method(from, self);
        si

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_instance_method(from, self, arguments, self.arguments, type);
        si
    si

    class STRUCT_METHOD: INSTANCE_METHOD is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        override: Function public;

        il_def: String => get_il_def(".method public hidebysig instance default ");
        il_property_def: String => "instance default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_struct_method(from, self);
        si

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_struct_method(from, self, arguments, self.arguments, type);
        si
    si

    class ABSTRACT_METHOD: INSTANCE_METHOD is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // abstract method";

        il_def: String => get_il_def(".method public virtual hidebysig abstract instance default ");
        il_property_def: String => "instance default " + il_type_name;

        is_abstract: bool => true;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);

            assert(owner?, "abstract method " + name + " created without owner " + qualifier_scope);
        si

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_abstract_method(from, self, arguments, self.arguments, type);
        si
    si

    class STATIC_METHOD: Function is
        description: String => qualified_name + "(" + argument_descriptions + ") -> " + return_type + " // class method";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.METHOD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.METHOD;

        override: Function public;

        il_def: String => get_il_def(".method public hidebysig static default ");
        il_property_def: String => "default " + il_type_name;

        init(location: LOCATION, owner: Scope, name: String, qualifier_scope: Scope) is
            super.init(location, owner, name, qualifier_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_method(self);
        si

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return caller.call_static_method(self, arguments, self.arguments, type);
        si
    si

    class FUNCTION_GROUP: BASE, Type.Typed is
        _overrides_resolved: bool;

        description: String => qualified_name + "(...) // function group";
        short_description: String => name + "(...)";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FUNCTION;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FUNCTION;

        type: Type.BASE public;

        functions: Vector[Function];

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            type = new Type.FUNCTION_GROUP(name, self);
            functions = new Vector[Function]();
        si

        specialize(type_map: Dict[String,Type.BASE], owner: BASE) -> FUNCTION_GROUP is
            let result = cast FUNCTION_GROUP(clone());

            result.specialized_from = self;

            result.type = new Type.FUNCTION_GROUP(
                name,
                result
            );

            var any_changes = false;

            result.functions = new Vector[Function](functions);

            for i in 0..functions.Length do
                let actual_owner = owner.find_ancestor(functions[i].owner, name);

                if !actual_owner? then
                    IO.Std.err.println("no actual owner found for " + functions[i]);
                    IO.Std.err.println("from " + new System.Backtrace());
                    IO.Std.err.println("self " + type_map);
                    IO.Std.err.println("map " + type_map);
                    actual_owner = self;
                fi

                result.functions[i] = functions[i].specialize(type_map, actual_owner);
            od

            return result;
        si

        resolve_overrides() is
            if _overrides_resolved then
                return;
            fi

            if isa ScopedWithInheritance(owner) then
                _overrides_resolved = true;

                cast ScopedWithInheritance(owner).resolve_overrides(
                    self,
                    IoC.CONTAINER.instance.generic_cache
                );
            fi
        si

        add(function: Function) is
            functions.add(function);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_function_group(from, self);
        si

        call(from: Graph.Value.BASE, arguments: List[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException("cannot call unresolved function overload group: " + self);
        si

        find_exact_match(arguments: List[Type.BASE], result: Type.BASE) -> Function is
            for f in functions do
                if f.is_exact_match(arguments, result) then
                    return f;
                fi
            od
        si

        find_override(function: Function) -> Function is
            var result: Function;

            for f in functions do
                if f != function && f.arguments.Length == function.arguments.Length then
                    result = f;

                    for i in 0..f.arguments.Length do
                        if f.arguments[i] !~ function.arguments[i] then

                            result = null;
                            break;
                        fi
                    od

                    if result? then
                        return result;
                    fi
                fi
            od

            return null;
        si

        merge(group: FUNCTION_GROUP) is            
            group.resolve_overrides();
            
            for overridee in group.functions do
                if overridee.name =~ "__read_iterator" then
                    IO.Std.err.println("may pull " + overridee + " into " + self);
                    IO.Std.err.println("overridee owner is: " + overridee.owner + " with IL name " + overridee.owner_il_name);
                    IO.Std.err.println("overridee IL name is: " + overridee.il_name);
                fi

                var overrider = find_override(overridee);

                if overrider? then
                    if isa INSTANCE_METHOD(overrider) then
                        if isa INSTANCE_METHOD(overridee) then
                            overrider.override = overridee;

                            if overridee.name =~ "__read_iterator" then
                                IO.Std.err.println("ignore inherited method in favor of overrider " + overrider);
                            fi            

                            if cast BASE(overrider.owner).is_trait then
                                if cast BASE(overridee.owner).is_trait then
                                    // trait method cannot override trait method (does the CLI allow this? if so, then can allow it here)
                                    CONTAINER.instance.logger.warn(
                                        overrider.location,
                                        "hides method " + overridee + " (defined at " + overridee.location + ")");
                                else
                                    CONTAINER.instance.logger.error(
                                        overrider.location,
                                        "hides method " + overridee + " (defined at " + overridee.location + ", oops: trait inherits from class)");

                                    // add(overridee);
                                fi                                
                            else
                                let proposed_il_override_name = overrider.il_name_override;

                                if proposed_il_override_name? then
                                    if overrider.name =~ "init" && proposed_il_override_name !~ ".ctor" then
                                        CONTAINER.instance.logger.error(
                                            overrider.location,
                                            "constructor IL name must be .ctor"
                                        );                                        
                                    elif overridee.il_name_override? && proposed_il_override_name !~ overridee.il_name_override then
                                        CONTAINER.instance.logger.error(
                                            overrider.location,
                                            "cannot override " + overridee + " with different IL name (" + overridee.il_name_override + ", defined at " + overridee.location + ")" 
                                        );                 
                                    fi                                    
                                elif overridee.il_name_override? then
                                    overrider.il_name_override = overridee.il_name_override;                                    
                                elif overrider.name =~ "init" then
                                    overrider.il_name_override = ".ctor";
                                fi
                            fi
                        else
                            CONTAINER.instance.logger
                                .warn(
                                    overrider.location,
                                    "hides " + overridee + " (defined at " + overridee.location + ")"
                                );
                        fi
                    else
                        CONTAINER.instance.logger
                            .error(
                                overrider.location,
                                "non-virtual method cannot override " + overridee + " (defined at " + overridee.location + ")"
                            );
                    fi
                elif overridee.name !~ "init" then

                    if overridee.name =~ "__read_iterator" then
                        IO.Std.err.println("pull inherited method " + overridee + " into " + self);
                        IO.Std.err.println("overridee owner is: " + overridee.owner + " with IL name " + overridee.owner_il_name);
                        IO.Std.err.println("overridee IL name is: " + overridee.il_name);
                    fi

                    add(overridee);
                fi
            od
        si

        collapse_group_if_single_member() -> Symbol.BASE is
            if functions.Length == 1 then
                return functions[0];
            else
                return self;
            fi
        si

        toString() -> String =>
            ClassName + " " + name + " @ " + location + " (" + functions + ")";
    si

    class Variable: BASE, Type.SettableTyped is
        type: Type.BASE public;
        short_description: String => name + ": " + type.short_description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.VARIABLE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.VARIABLE;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        specialize(type_map: Dict[String,Type.BASE], owner: BASE) -> BASE is
            let result = cast Variable(clone());

            result.specialized_from = self;

            if type? then
                let specialized_type = type.specialize(type_map);

                result.type = specialized_type;                
            fi

            result.owner = owner;

            return result;
        si

        toString() -> String =>
            ClassName + " " + name + " @ " + location + " type: " + type;
    si

    class LOCAL_VARIABLE: Variable is
        description: String => name + ": " + type + " // local variable";

        il_def: String is
            assert(type?, "local has null type: " + description + " in " + owner);

            return ".locals init (" + type.il_type_name + " " + il_name + ")";
        si    

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            il_name_override = IoC.CONTAINER.instance.local_id_generator.get_unique_il_name_for(name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_local_variable(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_local_variable(self, value);
        si
    si

    class LOCAL_ARGUMENT: Variable is
        description: String => name + ": " + type + " // argument";

        il_def: String => null;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_local_argument(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_local_argument(self, value);
        si
    si

    class GLOBAL_VARIABLE: Variable is
        description: String => qualified_name + ": " + type + " // global variable";
        is_workspace_visible: bool => true;

        il_def: String => "// global variable " + type.il_type_name + " " + name;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.load_global_variable(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert(from == null);
            return loader.store_global_variable(self, value);
        si
    si

    class INSTANCE_FIELD: Variable is
        description: String => qualified_name + ": " + type + " // field";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FIELD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FIELD;

        is_workspace_visible: bool => true;

        is_instance: bool => true;

        il_def: String => ".field public " + type.il_type_name + " " + il_name;

        il_qualified_name: String => owner_il_name + "::" + il_name;

        il_type_name: String => type.il_type_name + " " + owner_il_name + "::" + il_name;        

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_variable(from, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_variable(from, self, value);
        si
    si

    class STATIC_FIELD: Variable is
        description: String => qualified_name + ": " + type + " // class field";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FIELD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FIELD;

        is_workspace_visible: bool => true;

        il_def: String => ".field public static " + type.il_type_name + " " + il_name;

        il_qualified_name: String => owner_il_name + "::" + il_name;

        il_type_name: String => type.il_type_name + " " + owner_il_name + "::" + il_name;        

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_field(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_static_field(self, value);
        si
    si

    class Property: BASE, Type.SettableTyped is
        type: Type.BASE public;
        short_description: String => name + ": " + type.short_description;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.PROPERTY;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.PROPERTY;
        is_assignable: bool;

        is_workspace_visible: bool => true;

        read_function: Function public;
        read_function_il_name_override: String public;

        assign_function: Function public;
        assign_function_il_name_override: String public;

        il_def: String => "// .property public " + type.il_type_name + " " + name;

        init(location: LOCATION, owner: Scope, name: String, is_assignable: bool) is
            super.init(location, owner, name);

            self.is_assignable = is_assignable;
        si

        specialize(type_map: Dict[String,Type.BASE], owner: BASE) -> BASE is
            let result = cast Property(self.clone());

            result.specialized_from = self;

            if type? then
                result.type = type.specialize(type_map);
            fi

            if read_function? then
                result.read_function = read_function.specialize(type_map, owner);
            fi

            if assign_function? then
                result.assign_function = assign_function.specialize(type_map, owner);
            fi

            return result;
        si
    si

    class INSTANCE_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // instance property";

        is_instance: bool => true;

        il_def: String => ".property " + type.il_type_name + " " + il_name + "()";

        il_qualified_name: String is
            return owner_il_name + "::" + il_name;
        si
        
        init(location: LOCATION, owner: Scope, name: String, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_instance_property(location, from, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_property(location, from, self, value);
        si
    si

    class STATIC_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // class property";

        il_def: String => ".property " + type.il_type_name + " " + il_name + "()";

        il_qualified_name: String is
            return owner_il_name + "::" + il_name;
        si
        
        init(location: LOCATION, owner: Scope, name: String, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_property(location, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_static_property(location, self, value);
        si
    si

    class GLOBAL_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // global property";

        init(location: LOCATION, owner: Scope, name: String, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                IO.Std.err.println("expected from to be null but got " + from);
            fi
            */

            return loader.load_global_property(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                IO.Std.err.println("expected from to be null but got " + from);
            fi
            */

            return loader.store_global_property(self, value);
        si
    si
si
