namespace Semantic.Symbol is
    use System;
    
    use IoC;
    use Logging;
    use Source;

    enum ACCESS is
        PRIVATE, PUBLIC, PROTECTED 
    si

    // FIXME: think the language server needs to declare it can
    // use the newer list below for completions as well as symbol info:
    enum COMPLETION_KIND is
        UNDEFINED = 0,
        METHOD = 2,
        FUNCTION = 3,
        CONSTRUCTOR = 4,
        FIELD = 5,
        VARIABLE = 6,
        CLASS = 7,
        INTERFACE = 8,
        MODULE = 9,
        PROPERTY = 10,
        ENUM = 13
    si

    enum SYMBOL_KIND is
        UNDEFINED = 0,
        FILE = 1,
        MODULE = 2,
        NAMESPACE = 3,
        PACKAGE = 4,
        CLASS = 5,
        METHOD = 6,
        PROPERTY = 7,
        FIELD = 8,
        CONSTRUCTOR = 9,
        ENUM = 10,
        INTERFACE = 11,
        FUNCTION = 12,
        VARIABLE = 13,
        CONSTANT = 14,
        STRING = 15,
        NUMBER = 16,
        BOOLEAN = 17,
        ARRAY = 18,
        OBJECT = 19,
        KEY = 20,
        NULL = 21,
        ENUM_MEMBER = 22,
        STRUCT = 23,
        EVENT = 24,
        OPERATOR = 25,
        TYPE_PARAMETER = 26
    si

    class BASE: Object, Scope is
        _owner: Scope;

        type: Type.BASE => Type.NONE.instance;

        symbols: Collections.Iterable[BASE] => new Collections.LIST[Symbol.BASE]();

        overridees: Collections.Iterable[BASE] => null;

        unspecialized_symbol: Symbol.BASE => self;

        root_unspecialized_symbol: Symbol.BASE => self;

        owner: Scope public => _owner, = value is
            if _owner? && !value? then
                System.Console.error.write_line("clear owner " + self);                
            fi
            
            _owner = value;
        si
        
        location: LOCATION;
        _name: String;

        name: String => _name;

        is_internal: bool => _name.starts_with("__");

        qualified_name: String is
            // assert owner? else "" + get_type() + " " + name + " has no qualified name because owner is null";

            if owner then
                return owner.qualify(name);
            else
                return name;
            fi
        si
        
        il_name: String is
            if il_name_override? then
                return il_name_override;
            else
                return "'" + name + "'";
            fi
        si

        il_qualified_name: String is
            if
                il_name_override? && (
                    il_is_built_in_type || 
                    il_name_override.index_of('.') >= 0 || 
                    il_name_override.index_of("::") >= 0
                )
            then
                return il_name_override;
            fi            

            if owner? && !isa EMPTY_SCOPE(owner) then
                return owner_il_name + "." + il_name;
            else
                return il_name;
            fi
        si        

        il_name_override: String public;

        // FIXME: can these go somewhere more specific?
        il_is_built_in_type: bool public;

        owner_il_name: String is
            if self.owner == self then
                throw new Exception("symbol is own owner");
            fi

            assert owner? && isa BASE(owner) else "owner is null or not a symbol: " + owner;

            return cast BASE(owner).il_qualified_name;
        si

        owner_il_type_name: String is
            if self.owner == self then
                throw new Exception("symbol is own owner");
            fi

            assert owner? && isa BASE(owner) else "owner is null or not a symbol: " + owner;

            return cast BASE(owner).il_type_name;
        si

        argument_names: Collections.LIST[String] => new Collections.LIST[String](0);        
        arguments: Collections.LIST[Type.BASE] => new Collections.LIST[Type.BASE](0);
        ancestors: Collections.LIST[Type.BASE] => new Collections.LIST[Type.BASE](0);

        specialized_from: Symbol.BASE public;

        root_specialized_from: Symbol.BASE is
            let sf = specialized_from;

            if sf? then
                return sf.root_specialized_from;
            else
                return self;
            fi
        si
        // specializations: Collections.Iterable[Collections.LIST[Type.BASE]] => new Collections.LIST[Type.BASE][](0);

        access: ACCESS => ACCESS.PUBLIC;

        description: String => qualified_name;
        short_description: String => name;

        is_workspace_visible:
             bool => false;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.UNDEFINED;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.UNDEFINED;

        is_stub: bool => false;
        is_value_type: bool => false;
        is_instance: bool => false;
        is_innate: bool => false;
        is_inheritable: bool => false;
        is_class: bool => false;
        is_trait: bool => false;

        il_type_name: String => il_qualified_name;
        il_token_name: String => il_type_name;

        il_def: String => name;

        =~(other: Object) -> bool is
            if !other? && !isa BASE(other) then
                return false;
            fi

            return self == other;
        si

        =~(other: BASE) -> bool => self == other;
        
        init(location: LOCATION, owner: Scope, name: String) is
            self.location = location;
            self.owner = owner;
            _name = name;
        si

        add_member(function: BASE) -> bool is
            throw new System.NotImplementedException("cannot add member to " + self);
        si

        get_ancestor(i: int) -> Type.BASE is
            if ancestors.count > 0 then
                System.Console.error.write_line("oops: " + self.get_type() + " " + self + " has ancestors but expected none");

                for a in ancestors do
                    System.Console.error.write_line("ancestor: " + a);                    
                od
            fi

            throw new NotImplementedException("" + get_type() + " has no ancestor " + i);
        si

        qualify(name: String) -> String => qualified_name + "." + name;

        compare_type(other: Symbol.BASE) -> Type.MATCH
            => Type.MATCH.DIFFERENT;

        specialize(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> BASE is
            throw new NotImplementedException("" + get_type() + " cannot be specialized: " + self);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException("" + get_type() + " cannot be loaded: " + self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            throw new NotImplementedException("" + get_type() + " cannot be stored: " + self);
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            throw new NotImplementedException("" + get_type() + " cannot be called: " + self);
        si

        try_pull_down_into(
            into: Classy,
            other_overridee_symbols: Collections.Iterable[BASE],
            logger: Logging.Logger
        ) is
            into.add_member(self);
        si

        assert_symbols_pulled_down() is
            throw new System.NotImplementedException("implement me");
        si

        pull_down_super_symbols() is
            throw new System.NotImplementedException("implement me");
        si
        
        find_direct(name: String) -> BASE => null;

        find_member(name: String) -> BASE => null;

        find_enclosing(name: String) -> BASE => null;

        // FIXME: the way we handle inheritance and specialization of generics makes it tricky to get the correctly specialized owner of methods that
        // are interited from a super class or trait. The following works, but the fact that it's needed suggests we ought to be tracking this some other way
        find_owning_ancestor(o: Scope) -> Scope is
            let search_symbol = o.unspecialized_symbol;

            if !search_symbol? then
                return null;
            fi

            if self.unspecialized_symbol == search_symbol then
                return self;
            fi
            
            if ancestors.count == 0 then
                return o;
            fi
            
            for i in 0..ancestors.count do
                let aa = get_ancestor(i);

                if aa.unspecialized_symbol == o.unspecialized_symbol then
                    return get_ancestor(i).symbol;
                fi

                let result = aa.symbol.find_owning_ancestor(o);

                if result? then
                    return result;
                fi
            od        
        si

        find_ancestor(search_type: Type.BASE) -> Type.BASE is
            if unspecialized_symbol == search_type.unspecialized_symbol then
                return self.type;
            fi
            
            for a in ancestors do
                let result = a.find_ancestor(search_type);
                
                if result? then
                    return result;
                fi                
            od
        si

        get_all_direct_ancestor_members() -> Collections.Iterable[BASE] is
            let result = new Collections.LIST[BASE]();

            for i in 0..ancestors.count do
                let a = get_ancestor(i);

                

                if a? && a.scope? then
                    if a.is_trait then
                        
                    else
                        
                    fi
                    
                    for member in a.scope.symbols do
                        if isa FUNCTION_GROUP(member) then
                            for function in cast FUNCTION_GROUP(member).functions do
                                if function.is_abstract then
                                    
                                elif function.name =~ "init" then
                                    
                                    continue;
                                elif !a.is_trait then
                                    
                                else
                                    
                                    continue;                                  
                                fi
            
                                result.add(function);
                            od
                        elif isa Function(member) then
                            

                            let function = cast Function(member);

                            if function.is_abstract then
                                
                            elif function.name =~ "init" then
                                
                                continue;
                            elif !a.is_trait then
                                
                            else
                                
                                continue;                                  
                            fi
        
                            result.add(function);
                        elif !isa Semantic.Symbol.TYPE(member) then
                            result.add(member);
                        fi
                    od
                fi
            od

            return result;
        si
        
        find_direct_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
        si

        find_ancestor_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
        si

        find_member_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
        si

        find_enclosing_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
        si

        collapse_group_if_single_member() -> Symbol.BASE is
            return self;
        si

        to_string() -> String =>
            "" + get_type() + " '" + name + "' @ " + location;
    si

    class Scoped: BASE, Scope, DeclarationContext is
        _symbols: SYMBOL_MAP;

        symbols: Collections.Iterable[BASE] => _symbols.values;
        is_empty: bool => _symbols.count == 0;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
            _symbols = new SYMBOL_MAP();
        si

        clear() is
            _symbols.clear();
        si

        find_direct(name: String) -> BASE => _symbols[name];

        find_direct_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            _symbols.find_matches(prefix, matches);
        si

        declare(location: LOCATION, symbol: BASE, symbol_definition_listener: SymbolDefinitionListener) is
            assert symbol? else "declared symbol is null";
                
            var existing = find_direct(symbol.name);

            if existing? then
                CONTAINER.instance.logger.error(location, "redefining symbol " + symbol.name + " originally defined at " + existing.location);
                CONTAINER.instance.logger.error(existing.location, "symbol " + symbol.name + " is redefined at " + location);

                return;
            fi

            if symbol_definition_listener? then
                symbol_definition_listener.add_symbol_definition(location, symbol);
            fi

            _symbols[symbol.name] = symbol;
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, self, name);
        si

        declare_namespace(location: LOCATION, name: String, namespace_: NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_struct(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "struct", name);

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, value: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "closure", name);

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "innate", name);

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "variable", name);

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "property", name);

        declare_label(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "label", name);
        si

        declare_function_group(location: LOCATION, function: Function, symbol_definition_listener: SymbolDefinitionListener) is
            var existing = find_direct(function.name);
            var function_group: Symbol.FUNCTION_GROUP;

            if existing? then
                if !isa Symbol.FUNCTION_GROUP(existing) then
                    CONTAINER.instance.logger.error(location, "redefining symbol " + function.name + " originally defined at " + existing.location);
                    CONTAINER.instance.logger.error(existing.location, "symbol " + function.name + " is redefined at " + location);

                    return;
                fi

                function_group = cast Symbol.FUNCTION_GROUP(existing);
            else
                function_group = new Symbol.FUNCTION_GROUP(LOCATION.dummy, self, function.name);
                _symbols[function.name] = function_group;
            fi

            symbol_definition_listener.add_symbol_definition(location, function);

            function_group.add(function);
        si

        add_member(member: BASE) -> bool is
            if _symbols.contains_key(member.name) then

                let existing = _symbols[member.name];

                if existing == member then
                    // 
                    return true;
                fi

                if !isa Function(member) then
                    
                fi
                
                if isa FUNCTION_GROUP(existing) then
                    assert isa Function(member) else " cannot inherit function " + member + " over the top of non function member " + existing;

                    // 
                    cast FUNCTION_GROUP(existing).add(cast Function(member));
                    return true;
                elif isa Function(existing) then
                    // 
                    assert isa Function(member) else " cannot inherit function " + member + " over the top of non function member " + existing;

                    let fg = new FUNCTION_GROUP(location, self, member.name);

                    fg.add(cast Function(existing));
                    fg.add(cast Function(member));

                    _symbols[member.name] = fg;
                    return true;
                else
                    throw new System.Exception("cannot inherit non-function " + member + " over the top of non-function member " + existing);
                fi

                // 
                // FIXME: specific error?

                return false;                
            fi

            if isa Function(member) then
                let fg = new FUNCTION_GROUP(location, self, member.name);

                fg.add(cast Function(member));
    
                _symbols[member.name] = fg;
            else
                _symbols[member.name] = member;                                    
            fi            

            // 

            return true;
        si
    si

    class NONE: BASE, Scope is
        _instance: NONE static;

        instance: NONE static is
            if !_instance? then
                _instance = new NONE();
            fi

            return _instance;
        si

        init() is
            super.init(LOCATION.dummy, null, "!!!");
        si
    si
    
    class UNDEFINED: BASE, Scope, DeclarationContext, Type.Typed is
        type: Type.BASE => new Type.ANY();

        description: String => "undefined";

        il_def: String => "undefined has no il_def: " + self;       

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> UNDEFINED is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new UNDEFINED(location, self, name);
        si

        declare_namespace(location: LOCATION, name: String, namespace_: NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_class(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_struct(location: LOCATION, name: String, arguments: Collections.LIST[String], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "struct", name);

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, value: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "closure", name);

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "innate", name);

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "function", name);

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "variable", name);

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "undefine", name);        

        declare_label(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "label", name);
        si
    si

    class ScopedWithEnclosingScope: Scoped is
        enclosing_scope: Scope;

        init(location: LOCATION, owner: Scope, name: String, enclosing_scope: Scope) is
            super.init(location, owner, name);

            self.enclosing_scope = enclosing_scope;
        si

        find_enclosing_only(name: String) -> BASE is
            if enclosing_scope? then
                return enclosing_scope.find_enclosing(name);
            fi

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            else
                return find_enclosing_only(name);
            fi
        si

        find_enclosing_only_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            if enclosing_scope? then
                enclosing_scope.find_enclosing_matches(prefix, matches);
            fi
        si

        find_enclosing_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si
    si
si
