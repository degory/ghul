namespace Semantic.Symbol is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use STD = System.Console;

    use System;
    
    use IoC;
    use Logging;
    use Source;

    class Property: BASE, Type.SettableTyped is
        _overridees: Collections.MutableList[BASE];

        type: Type.BASE;

        set_type(value: Type.BASE) is type = value; si

        short_description: string => name + ": " + type.short_description;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.PROPERTY;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.PROPERTY;
        is_assignable: bool;

        is_workspace_visible: bool => true;

        read_function: Function public;
        read_function_il_name_override: string public;

        assign_function: Function public;
        assign_function_il_name_override: string public;

        il_def: string => "// .property public " + type.il_type_name + " " + name;

        overridees: Collections.Iterable[BASE] => _overridees;

        init(location: LOCATION, owner: Scope, name: string, is_assignable: bool) is
            super.init(location, owner, name);

            assert isa Type.SettableTyped(self) else "oops: should implement SettableTyped: " + self.get_type();

            self.is_assignable = is_assignable;
        si
        
        add_overridee(overridee: BASE) is
            if !_overridees? then
                _overridees = new Collections.LIST[BASE]();
            fi 

            _overridees.add(overridee);
        si

        specialize(type_map: Collections.MAP[string,Type.BASE], owner: GENERIC) -> BASE is
            let result = cast Property(self.memberwise_clone());

            result.specialized_from = self;

            if type? then
                result.type = type.specialize(type_map);
            fi

            if read_function? then
                result.read_function = read_function.specialize_function(type_map, owner);
            fi

            if assign_function? then
                result.assign_function = assign_function.specialize_function(type_map, owner);
            fi

            return result;
        si

        to_string() -> string is
            let result = new System.Text.StringBuilder();

            try
                result.append(qualified_name);
                result.append(": ");
                result.append(type);
    
                // return qualified_name + " (" + short_argument_descriptions + ") -> " + return_type;
                return result.to_string();
            catch ex: Exception
                // STD.error.write_line("failed to convert function to string: " + name + ", got as far as: " + result);
                // STD.error.write_line(ex);

                return "[garbled property: " + result + "]";
            yrt
        si
    si

    class INSTANCE_PROPERTY: Property is
        description: string => qualified_name + ": " + type + " // instance property";

        is_instance: bool => true;

        il_def: string => ".property " + type.il_type_name + " " + il_name + "()";

        il_qualified_name: string is
            return owner_il_name + "::" + il_name;
        si
        
        init(location: LOCATION, owner: Scope, name: string, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            if !from? then
                let context = IoC.CONTAINER.instance.symbol_table.current_function;

                if !context? then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance property from non-function context");                    
                elif !context.is_instance then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance property from static context");                    
                fi
            fi

            return loader.load_instance_property(location, from, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_property(location, from, self, value);
        si
    si

    class STATIC_PROPERTY: Property is
        description: string => qualified_name + ": " + type + " // class property";

        il_def: string => ".property " + type.il_type_name + " " + il_name + "()";

        il_qualified_name: string is
            return owner_il_name + "::" + il_name;
        si
        
        init(location: LOCATION, owner: Scope, name: string, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_property(location, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_static_property(location, self, value);
        si
    si

    class GLOBAL_PROPERTY: Property is
        description: string => qualified_name + ": " + type + " // global property";

        init(location: LOCATION, owner: Scope, name: string, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                STD.error.write_line("expected from to be null but got " + from);
            fi
            */

            return loader.load_global_property(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                STD.error.write_line("expected from to be null but got " + from);
            fi
            */

            return loader.store_global_property(self, value);
        si
    si
si


