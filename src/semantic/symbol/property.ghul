namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    class Property: BASE, Type.SettableTyped is
        type: Type.BASE public;
        short_description: String => name + ": " + type.short_description;
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.PROPERTY;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.PROPERTY;
        is_assignable: bool;

        is_workspace_visible: bool => true;

        read_function: Function public;
        read_function_il_name_override: String public;

        assign_function: Function public;
        assign_function_il_name_override: String public;

        il_def: String => "// .property public " + type.il_type_name + " " + name;

        init(location: LOCATION, owner: Scope, name: String, is_assignable: bool) is
            super.init(location, owner, name);

            self.is_assignable = is_assignable;
        si

        specialize(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> BASE is
            let result = cast Property(self.clone());

            result.specialized_from = self;

            if type? then
                result.type = type.specialize(type_map);
            fi

            if read_function? then
                result.read_function = read_function.specialize(type_map, owner);
            fi

            if assign_function? then
                result.assign_function = assign_function.specialize(type_map, owner);
            fi

            return result;
        si
    si

    class INSTANCE_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // instance property";

        is_instance: bool => true;

        il_def: String => ".property " + type.il_type_name + " " + il_name + "()";

        il_qualified_name: String is
            return owner_il_name + "::" + il_name;
        si
        
        init(location: LOCATION, owner: Scope, name: String, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            if !from? then
                let context = IoC.CONTAINER.instance.symbol_table.current_function;

                if !context? then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance property from non-function context");                    
                elif !context.is_instance then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance property from static context");                    
                fi
            fi

            return loader.load_instance_property(location, from, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_property(location, from, self, value);
        si
    si

    class STATIC_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // class property";

        il_def: String => ".property " + type.il_type_name + " " + il_name + "()";

        il_qualified_name: String is
            return owner_il_name + "::" + il_name;
        si
        
        init(location: LOCATION, owner: Scope, name: String, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_property(location, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_static_property(location, self, value);
        si
    si

    class GLOBAL_PROPERTY: Property is
        description: String => qualified_name + ": " + type + " // global property";

        init(location: LOCATION, owner: Scope, name: String, is_assignable: bool) is
            super.init(location, owner, name, is_assignable);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                System.Console.error.write_line("expected from to be null but got " + from);
            fi
            */

            return loader.load_global_property(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            /*
            if from? then
                System.Console.error.write_line("expected from to be null but got " + from);
            fi
            */

            return loader.store_global_property(self, value);
        si
    si
si


