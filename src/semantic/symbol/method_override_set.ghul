namespace Semantic is
    use System.String;
    use System.Text.StringBuilder;
    use System.Console;
    
    use Collections.Iterable;
    use Collections.Iterator;

    use Collections.SET;

    use Symbol.Function;

    class DUMMY: System.Object, Iterable[Function] is
        _set: SET[FUNCTION_WRAPPER];

        _iterable: Iterable[Function];

        override_class: METHOD_OVERRIDE_CLASS;

        iterator: Iterator[Function] => _iterable.iterator;
 
        iterable: Iterable[Function] => _iterable;

        count: int => _set.count;

        init(override_class: METHOD_OVERRIDE_CLASS) is
            _set = new SET[FUNCTION_WRAPPER]();

            _iterable = 
                new Shim.MAPPER[FUNCTION_WRAPPER,Function](
                    _set,
                    (from: FUNCTION_WRAPPER) -> Function => from.function
                );

            self.override_class = override_class;
        si

        add(method: Function) is
            assert method.override_class =~ override_class;
            _set.add(new FUNCTION_WRAPPER(method));
        si
                  
        to_string() -> String => "" + override_class + ": " + new Shim.JOIN[FUNCTION_WRAPPER](_set);

        @IF.legacy()
        toString() -> String => to_string();

        get_overrider(into: Symbol.BASE) -> Function is
            @IF.debug()  Console.write_line("get overrider from: " + into);

            if !into.is_stub && _set.count > 1 then
                for fw in _set do
                    let f = fw.function;
                    IoC.CONTAINER.instance.logger.error(f.location, "duplicate method");
                od
            fi

            return new Shim.FIRST[Function](self.iterable).result;
        si
    si

    class METHOD_OVERRIDE_SET: System.Object /*, Iterable[Function]*/ is
        _set: SET[FUNCTION_WRAPPER];

        _iterable: Iterable[Function];

        override_class: METHOD_OVERRIDE_CLASS;

        iterator: Iterator[Function] => _iterable.iterator;
 
        iterable: Iterable[Function] => _iterable;

        count: int => _set.count;

        init(override_class: METHOD_OVERRIDE_CLASS) is
            _set = new SET[FUNCTION_WRAPPER]();

            _iterable = 
                new Shim.MAPPER[FUNCTION_WRAPPER,Function](
                    _set,
                    (from: FUNCTION_WRAPPER) -> Function => from.function
                );

            self.override_class = override_class;
        si

        add(method: Function) is
            assert method.override_class =~ override_class;
            _set.add(new FUNCTION_WRAPPER(method));
        si
                  
        to_string() -> String => "" + override_class + ": " + new Shim.JOIN[FUNCTION_WRAPPER](_set);

        @IF.legacy()
        toString() -> String => to_string();

        get_overrider(into: Symbol.BASE) -> Function is
            @IF.debug()  Console.write_line("get overrider from: " + into);

            if !into.is_stub && _set.count > 1 then
                for fw in _set do
                    let f = fw.function;
                    IoC.CONTAINER.instance.logger.error(f.location, "duplicate method");
                od
            fi

            return new Shim.FIRST[Function](self.iterable).result;
        si
    si
si