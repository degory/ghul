namespace Semantic.Symbol is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use STD = System.Console;

    use System;
    
    use IoC;
    use Logging;
    use Source;

    class Variable: BASE, Type.SettableTyped is
        type: Type.BASE;
        set_type(value: Type.BASE) is type = value; si

        short_description: string => name + ": " + type.short_description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.VARIABLE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.VARIABLE;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);

            assert isa Type.SettableTyped(self) else "oops: should implement SettableTyped: " + self.get_type();
        si

        specialize(type_map: Collections.MAP[string,Type.BASE], owner: GENERIC) -> BASE is
            let result = cast Variable(memberwise_clone());

            result.specialized_from = self;

            if type? then
                let specialized_type = type.specialize(type_map);

                result.type = specialized_type;                
            fi

            result.owner = owner;

            return result;
        si

        to_string() -> string =>
            "" + get_type() + " " + name + " @ " + location + " type: " + type;
    si

    class LOCAL_VARIABLE: Variable, Type.SettableTyped is
        description: string => name + ": " + type + " // local variable";

        il_def: string is
            assert type? else "local has null type: " + name + " " + location;
            
            return ".locals init (" + type.il_type_name + " " + il_name + ")";
        si    

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);

            il_name_override = IoC.CONTAINER.instance.local_id_generator.get_unique_il_name_for(name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from?;
            return loader.load_local_variable(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from?;
            return loader.store_local_variable(self, value);
        si
    si

    class LOCAL_ARGUMENT: Variable, Type.SettableTyped is
        description: string => name + ": " + type + " // argument";

        il_def: string => null;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from?;
            return loader.load_local_argument(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from?;
            return loader.store_local_argument(self, value);
        si
    si

    class GLOBAL_VARIABLE: Variable, Type.SettableTyped is
        is_workspace_visible: bool => true;

        il_def: string => "// global variable " + type.il_type_name + " " + name;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from? else "load global function from instance context";
            return loader.load_global_variable(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from? else "load global function from instance context";
            return loader.store_global_variable(self, value);
        si
    si

    class Field: Variable, Type.SettableTyped is
        unspecialized_type: Type.BASE;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FIELD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FIELD;

        is_workspace_visible: bool => true;
        il_qualified_name: string => owner_il_name + "::" + il_name;
        il_type_name: string is
            let t = unspecialized_type;

            if !t? then
                t = type;
            fi

            return t.il_type_name + " " + owner_il_type_name + "::" + il_name;
        si

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        specialize(type_map: Collections.MAP[string,Type.BASE], owner: GENERIC) -> BASE is
            let result = cast Field(super.specialize(type_map, owner));

            result.unspecialized_type = type;

            return result;
        si
    si

    class INSTANCE_FIELD: Field is
        description: string => qualified_name + ": " + type + " // field";

        is_instance: bool => true;

        il_def: string => ".field public " + type.il_type_name + " " + il_name;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            if !from? then
                let context = IoC.CONTAINER.instance.symbol_table.current_function;

                if !context? then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance field from non-function context");
                elif !context.is_instance then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance field from static context");
                fi
            fi

            return loader.load_instance_variable(from, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_variable(from, self, value);
        si
    si

    class STATIC_FIELD: Field is
        description: string => qualified_name + ": " + type + " // class field";

        il_def: string => ".field public static " + type.il_type_name + " " + il_name;

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_field(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_static_field(self, value);
        si
    si

    class CAPTURED_VALUE: Variable is
        description: string => name + ": " + type + " // captured value"; 

        init(location: LOCATION, owner: Scope, name: string) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_captured_value(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            IoC.CONTAINER.logger.error(location, "captured values are read only");
            return new Graph.Value.DUMMY(type, location);
        si
    si
si

