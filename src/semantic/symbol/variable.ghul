namespace Semantic.Symbol is
    use System;
    
    use IoC;
    use Logging;
    use Source;

    class Variable: BASE, Type.SettableTyped is
        type: Type.BASE;
        set_type(value: Type.BASE) is type = value; si

        short_description: String => name + ": " + type.short_description;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.VARIABLE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.VARIABLE;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            assert isa Type.SettableTyped(self) else "oops: should implement SettableTyped: " + Shim.OBJ.type_name(self);
        si

        specialize(type_map: Collections.MAP[String,Type.BASE], owner: GENERIC) -> BASE is
            let result = cast Variable(memberwise_clone());

            result.specialized_from = self;

            if type? then
                let specialized_type = type.specialize(type_map);

                result.type = specialized_type;                
            fi

            result.owner = owner;

            return result;
        si

        to_string() -> String =>
            Shim.OBJ.type_name(self) + " " + name + " @ " + location + " type: " + type;
    si

    class LOCAL_VARIABLE: Variable, Type.SettableTyped is
        description: String => name + ": " + type + " // local variable";

        il_def: String is
            assert type? else "local has null type: " + name + " " + location;
            
            return ".locals init (" + type.il_type_name + " " + il_name + ")";
        si    

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);

            il_name_override = IoC.CONTAINER.instance.local_id_generator.get_unique_il_name_for(name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from?;
            return loader.load_local_variable(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from?;
            return loader.store_local_variable(self, value);
        si
    si

    class LOCAL_ARGUMENT: Variable, Type.SettableTyped is
        description: String => name + ": " + type + " // argument";

        il_def: String => null;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from?;
            return loader.load_local_argument(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from?;
            return loader.store_local_argument(self, value);
        si
    si

    class GLOBAL_VARIABLE: Variable, Type.SettableTyped is
        description: String => qualified_name + ": " + type + " // global variable";
        is_workspace_visible: bool => true;

        il_def: String => "// global variable " + type.il_type_name + " " + name;

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from? else "load global function from instance context";
            return loader.load_global_variable(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            assert !from? else "load global function from instance context";
            return loader.store_global_variable(self, value);
        si
    si

    class INSTANCE_FIELD: Variable, Type.SettableTyped is
        description: String => qualified_name + ": " + type + " // field";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FIELD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FIELD;

        is_workspace_visible: bool => true;

        is_instance: bool => true;

        il_def: String => ".field public " + type.il_type_name + " " + il_name;

        il_qualified_name: String => owner_il_name + "::" + il_name;

        il_type_name: String => type.il_type_name + " " + owner_il_type_name + "::" + il_name;        

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            if !from? then
                let context = IoC.CONTAINER.instance.symbol_table.current_function;

                if !context? then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance field from non-function context");
                elif !context.is_instance then
                    IoC.CONTAINER.instance.logger.error(location, "cannot access instance field from static context");
                fi
            fi

            return loader.load_instance_variable(from, self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_instance_variable(from, self, value);
        si
    si

    class STATIC_FIELD: Variable, Type.SettableTyped is
        description: String => qualified_name + ": " + type + " // class field";
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.FIELD;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.FIELD;

        is_workspace_visible: bool => true;

        il_def: String => ".field public static " + type.il_type_name + " " + il_name;

        il_qualified_name: String => owner_il_name + "::" + il_name;

        il_type_name: String => type.il_type_name + " " + owner_il_type_name + "::" + il_name;        

        init(location: LOCATION, owner: Scope, name: String) is
            super.init(location, owner, name);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_static_field(self);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.store_static_field(self, value);
        si
    si
si

