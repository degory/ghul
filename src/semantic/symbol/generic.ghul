namespace Semantic.Symbol is
    use System;
    
    use IoC;
    use Logging;
    use Source;

    // A GENERIC represents a particular specialization of a generic class, trait or struct - i.e. a version of that symbol
    // with actual type arguments specified for its formal type parameters, and all its member symbols' signatures rewritten 
    // with all instances of each formal type parameter replaced with the corresponding actual type argument  
    class GENERIC: BASE, Scope is
        type_map: Collections.MAP[String,Type.BASE];
        arguments: Collections.LIST[Type.BASE];
        ancestors: Collections.LIST[Type.BASE] => symbol.ancestors;
        symbol: Classy;

        symbols: Collections.Iterable[BASE] is
            let result = new Collections.LIST[BASE]();
            
            for s in symbol.symbols do
                result.add(_specialize(s));
            od
            
            return result;
        si

        owner: Scope => symbol.owner;

        unspecialized_symbol: Symbol.BASE => symbol;
        root_unspecialized_symbol: Symbol.BASE => symbol.root_unspecialized_symbol;

        location: LOCATION => symbol.location;
        name: String => symbol.name;

        access: ACCESS => symbol.access;

        is_value_type: bool => symbol.is_value_type;
        is_inheritable: bool => symbol.is_inheritable;
        is_class: bool => symbol.is_class;
        is_trait: bool => symbol.is_trait;

        qualified_name: String => symbol.qualified_name + "[" + arguments_string + "]";

        arguments_string: String is
            let result = new System.Text.StringBuilder();

            let seen_any = false;

            for a in arguments do
                if seen_any then
                    result.append(',');
                fi

                result.append(a);

                seen_any = true;
            od

            return result.to_string();
        si
        
        description: String => qualified_name;

        short_description: String is
            let result = new System.Text.StringBuilder();

            result
                .append(name)
                .append('[');

            var seen_any = false;

            for a in arguments do
                if seen_any then
                    result.append(',');
                fi

                result.append(a.short_description);

                seen_any = true;
            od

            result
                .append(']');

            return result.to_string();
        si

        symbol_kind: SYMBOL_KIND => symbol.symbol_kind;
        completion_kind: COMPLETION_KIND => symbol.completion_kind;
        // is_workspace_visible: bool => true;

        il_type_name: String is
            let result = new System.Text.StringBuilder();

            let qn = symbol.il_name_override;

            if !qn? then

                let kind = "class ";

                if symbol.is_value_type then
                    kind = "valuetype ";
                fi            
    
                result
                    .append(kind);

                if !isa EMPTY_SCOPE(owner) then
                    result
                        .append(owner_il_name)
                        .append('.');
                fi
                
                result
                    // FIXME: trying to quote name causes an ILAsm syntax error here:
                    .append(name)
                    .append('`')
                    .append(arguments.count);
            else
                result
                    .append(qn);
            fi

            result
                .append('<');

            var seen_any = false;

            for a in arguments do
                if seen_any then
                    result.append(',');
                fi

                result.append(a.il_type_name);

                seen_any = true;
            od

            result.append('>');

            return result.to_string();
        si

        il_def: String => "generic has no il_def: " + self;

        type: Type.BASE is
            return new Type.GENERIC(self.location, self.symbol, self.arguments);
        si
        
        init(location: LOCATION, symbol: Classy, arguments: Collections.LIST[Type.BASE]) is
            assert symbol? else "generic symbol is null";
            assert symbol.name? else "generic symbol name is null";

            super.init(
                symbol.location,
                symbol,
                symbol.name);

            self.symbol = symbol;

            assert arguments? else "generic arguments is null";
            assert arguments.count > 0 else "generic has 0 arguments";
            assert symbol.argument_names? else "symbol argument names is null"; 

            let length = arguments.count;

            if arguments.count != symbol.argument_names.count then
                if length > symbol.argument_names.count then
                    length = symbol.argument_names.count;
                fi

                IoC.CONTAINER.instance.logger.error(location, "expected " + symbol.argument_names.count + " type arguments");
            fi

            self.arguments = arguments;
            type_map = new Collections.MAP[String,Type.BASE]();

            for i in 0..length do
                type_map[symbol.argument_names[i]] = arguments[i];
            od
        si

        add_member(symbol: BASE) -> bool is            
            IoC.CONTAINER.instance.logger.warn(location, "cannot inherit " + symbol + " into to specialized generic " + self);
            return true;
        si

        assert_symbols_pulled_down() is
            symbol.assert_symbols_pulled_down();
        si
    
        pull_down_super_symbols() is
            symbol.pull_down_super_symbols();
        si        

        get_ancestor(i: int) -> Type.BASE
            => ancestors[i].specialize(type_map);
        
        =~(other: BASE) -> bool is
            if !isa GENERIC(other) then
                return false;
            fi

            let other_generic = cast GENERIC(other);

            if other_generic.symbol != symbol then
                return false;
            fi

            assert
                other_generic.arguments.count == arguments.count
            else
                "generics with the same symbol should have same number of arguments";

            for i in 0..arguments.count do
                if arguments[i] !~ other_generic.arguments[i] then
                    return false;
                fi
            od

            return true;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return symbol.load(location, from, loader);
        si

        store(location: LOCATION, from: Graph.Value.BASE, value: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return symbol.store(location, from, value, loader);
        si

        call(location: Source.LOCATION, from: Graph.Value.BASE, arguments: Collections.LIST[Graph.Value.BASE], type: Semantic.Type.BASE, caller: FUNCTION_CALLER) -> Graph.Value.BASE is
            return symbol.call(location, from, arguments, type, caller);
        si

        dump_ancestors(depth: int) is
            for i in 0..self.ancestors.count do
                for j in 0..depth do
                    System.Console.error.write("  ");
                od
                
                let a = get_ancestor(i);
                System.Console.error.write_line("" + self + " has ancestor: " + a);
            
                if isa Type.GENERIC(a) then
                    let s = cast Type.GENERIC(a).symbol;

                    if isa Symbol.GENERIC(s) then
                        let gs = cast Symbol.GENERIC(s);

                        gs.dump_ancestors(depth + 1);
                    fi                    
                fi
            od
        si

        // given a member of the class, trait or struct that this generic wraps, we want to get a copy of it
        // with all references to formal type parameters replaced with the corresponding actual type arguments
        _specialize(member: Symbol.BASE) -> Symbol.BASE is
            if member? /* && result.owner == symbol */ then
                // result is owned by the class/trait that we wrap and so
                // needs to be specialized according to our type map

                return member.specialize(type_map, self);

                /*
                let generic_cache = IoC.CONTAINER.instance.generic_cache;

                let key = new GENERIC_KEY(symbol, member, arguments);

                // do we already have a specialization for this symbol with
                // our actual type arguments?
                let specialized = generic_cache[key];

                if specialized == null then
                    // no pre-existing specialization found, create one:
                    specialized = member.specialize(type_map, self);

                    // and cache it:
                    generic_cache[key] = specialized;
                fi

                return specialized;
                */
            else
                return null;
            fi
        si

        find_direct(name: String) -> BASE is
            assert_symbols_pulled_down();

            return _specialize(symbol.find_direct(name));
        si

        find_member(name: String) -> BASE is            
            return _specialize(symbol.find_member(name));
        si

        find_enclosing(name: String) -> BASE is
            let unspecialized = symbol.find_enclosing(name);

            if unspecialized? && unspecialized.owner == symbol then
                return _specialize(unspecialized);
            else
                return unspecialized;
            fi
        si

        find_direct_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            let m = new Collections.MAP[String, Symbol.BASE]();

            symbol.find_direct_matches(prefix, m);

            for p in m.iterator do
                if !matches.contains_key(p.key) then
                    matches[p.key] = _specialize(p.value).collapse_group_if_single_member();
                fi
            od
        si

        find_member_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);
            symbol.find_ancestor_matches(prefix, matches);
        si

        find_enclosing_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
        si

        get_hash_code() -> int is
            var result = symbol.get_hash_code();

            for a in arguments do
                result = result + a.get_hash_code();
            od

            return result;
        si

        to_string() -> String => qualified_name;
    si
si
