namespace Semantic.Symbol is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    class Classy: ScopedWithEnclosingScope is
        _ancestors: Collections.LIST[Type.BASE];

        type: Type.BASE public;

        argument_names: Collections.LIST[String];
        ancestors: Collections.LIST[Type.BASE] => _ancestors;

        closures: Collections.LIST[Closure];

        is_workspace_visible: bool => true;

        il_name_prefix: String => "";

        il_name: String is
            let result = new System.Text.StringBuilder(Shim.STR.length(name) + 5);

            result.append("'").append(name);

            if argument_names.count > 0 then
                result
                    .append("`")
                    .append(argument_names.count);
            fi

            result.append("'");

            return result.to_string();
        si

        il_type_name: String is
            let result = new System.Text.StringBuilder();

            if il_name_override? then
                result.append(il_qualified_name);
            else
                result.append(il_name_prefix + il_qualified_name);
            fi

            if argument_names.count > 0 then
                result.append('<');

                let seen_any = false;

                for i in 0..argument_names.count do
                    if seen_any then
                        result.append(',');
                    fi
                    
                    result.append('!');
                    result.append(i);

                    seen_any = true;
                od
                
                result.append('>');
            fi
            
            return result.to_string();
        si

        is_derived_from_iterable_trait: bool
            => find_ancestor(IoC.CONTAINER.instance.collections_symbol_lookup.get_unspecialized_iterable_type())?;

        is_derived_from_iterator_trait: bool
            => find_ancestor(IoC.CONTAINER.instance.collections_symbol_lookup.get_unspecialized_iterator_type())?;

        get_il_def(preamble: String) -> String is
            let result = new System.Text.StringBuilder();

            result
                .append(preamble)
                .append(' ');

            if il_name_override? then
                result
                    .append(il_name_override);

            elif argument_names.count > 0 then
                result
                    .append(name)
                    .append('`')
                    .append(argument_names.count)
                    .append('<');

                // FIXME: contraints here

                let seen_any = false;

                for argument in argument_names do
                    if seen_any then
                        result.append(',');
                    fi
                    
                    result
                        .append(argument);

                    seen_any = true;
                od

                result.append('>');
            else
                result.append(il_name);        
            fi
            
            let index = 0;
            let done_implements = false;

            for a in ancestors do
                if !isa Type.NAMED(a) then
                    continue;  
                fi

                let ancestor = cast Type.NAMED(a).symbol;

                if is_trait && !ancestor.is_trait then
                    continue;
                fi

                if index == 0 && !ancestor.is_trait then
                    result
                        .append(" extends ")
                        .append(ancestor.il_type_name);

                elif ancestor.is_trait then
                    if !done_implements then
                        result.append(" implements ");

                        done_implements = true;
                    else
                        result.append(", ");
                    fi

                    result
                        .append(a.il_type_name);
                fi

                index = index + 1;
            od

            return result.to_string();
        si

        init(location: LOCATION, owner: Scope, name: String, argument_names: Collections.LIST[String], enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            _ancestors = new Collections.LIST[Type.BASE]();
            self.argument_names = argument_names;

            type = new Type.NAMED(self);
        si

        get_ancestor(i: int) -> Type.BASE
            => ancestors[i].specialize(new Collections.MAP[String,Type.BASE]());

        add_ancestor(ancestor: Type.BASE) is
            _ancestors.add(ancestor);
        si

        push_ancestor(ancestor: Type.BASE) is
            let na = new Collections.LIST[Type.BASE]();

            na.add(ancestor);
            na.add_range(_ancestors);

            _ancestors = na;
        si

        add_closure(closure: Closure) is
            if !closures? then
                closures = new Collections.LIST[Closure]();
            fi

            closures.add(closure);
        si

        check_overrides(logger: Logging.Logger, location: Source.LOCATION) is
            if is_trait then
                return;
            fi

            let members = new Collections.MAP[String,BASE]();

            find_member_matches("", members);
            
            for member in members.values do
                if isa Function(member) then
                    check_override(logger, location, cast Function(member));
                elif isa FUNCTION_GROUP(member) then
                    for function in cast FUNCTION_GROUP(member).functions do
                        check_override(logger, location, function);
                    od
                fi
            od
        si

        check_override(logger: Logging.Logger, location: Source.LOCATION, function: Function) is
            if function.is_abstract then
                logger.error(location, qualified_name + " must implement " + function);
            fi                    
        si        
        
        resolve_overrides(overriding_fg: FUNCTION_GROUP, generic_cache: GENERIC_CACHE) is
            try
                // all function groups in direct ancestors with same name:
                for overridden_fg in find_member_all(overriding_fg.name) do
                    if isa FUNCTION_GROUP(overridden_fg) then

                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    else
                        for f in overriding_fg.functions do
                            CONTAINER.instance.logger.error(f.location, "overriding non-function declared at " + overridden_fg.location);
                        od
                    fi
                od

                // FIXME: although these functions do need to be treated similarly, they are not overridden, merely hidden, by methods in this scope:

                // function group in enclosing scope with same name, if any:
                let overridden_fg = find_enclosing_only(overriding_fg.name);

                if overridden_fg? then
                    if isa FUNCTION_GROUP(overridden_fg) then
                        overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                    else
                        for f in overriding_fg.functions do
                            CONTAINER.instance.logger.error(f.location, "overriding non-function declared at " + overridden_fg.location);
                        od
                    fi

                    overriding_fg.merge(cast FUNCTION_GROUP(overridden_fg));
                fi
            catch e: Exception
                System.Console.error.write_line("caught exception trying to resolve overrides for " + overriding_fg + "\n" + e);
            yrt
        si

        find_member(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = find_member_only(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_enclosing(name: String) -> BASE is
            var result = find_direct(name);

            if result? then
                return result;
            fi

            result = find_member_only(name);

            if result? then
                return result;
            fi

            result = find_enclosing_only(name);

            if result? then
                return result;
            fi

            return null;
        si

        find_member_only(name: String) -> BASE is
            _assert ancestors? else "ancestors is null";

            for a in ancestors do
                if a? && a.scope? then
                    var result = a.scope.find_member(name);

                    if result? then
                        return result;
                    fi
                elif a? then
                    System.Console.error.write_line("ancestor of " + qualified_name + " has null scope");
                    System.Console.error.write_line("ancestor of " + qualified_name + " has null scope " + a);
                else
                    System.Console.error.write_line("ancestor or " + qualified_name + " is null");
                fi
            od

            return null;
        si

        find_member_all(name: String) -> Collections.Iterable[BASE] is
            let result = new Collections.LIST[BASE]();

            for a in ancestors do
                if a? && a.scope? then
                    let s = a.scope.find_member(name);

                    if s? then
                        result.add(s);
                    fi
                else
                    System.Console.error.write_line("something wrong with ancestors for " + qualified_name);
                fi
            od

            return result;
        si

        find_ancestor_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
        si

        find_member_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            find_direct_matches(prefix, matches);

            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
        si

        find_enclosing_matches(prefix: String, matches: Collections.MAP[String, Symbol.BASE]) is
            find_member_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si
    si

    class CLASS: Classy, Type.Typed is
        description: String => "class " + qualified_name;
        short_description: String => "class " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.CLASS;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        is_inheritable: bool => true;
        is_class: bool => true;

        il_def: String => get_il_def(".class public auto ansi beforefieldinit");

        il_name_prefix: String => "class ";

        init(location: LOCATION, owner: Scope, name: String, arguments: Collections.LIST[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_class(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Function;

            if is_static then
                result = new Symbol.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbol.INSTANCE_METHOD(location, self, name, enclosing);
            fi
            
            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            let result: Variable;
            
            if is_static then
                result = new Symbol.STATIC_FIELD(location, self, name);
            else
                result = new Symbol.INSTANCE_FIELD(location, self, name);
            fi

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Property;

            if is_static then
                result = new Symbol.STATIC_PROPERTY(location, self, name, is_assignable);
            else
                result = new Symbol.INSTANCE_PROPERTY(location, self, name, is_assignable);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si

    class TRAIT: Classy, Type.Typed is
        description: String => "trait " + qualified_name;
        short_description: String => "trait " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.INTERFACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.INTERFACE;

        is_inheritable: bool => true;
        is_trait: bool => true;

        il_name_prefix: String => "class ";

        il_def: String => get_il_def(".class public interface auto ansi beforefieldinit");

        init(location: LOCATION, owner: Scope, name: String, arguments: Collections.LIST[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_trait(self);
        si

        // FIXME: most of these can be folded into Classy:

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result: Function;
            
            if is_static then
                IoC.CONTAINER.instance.logger.error(location, "cannot declare static method in trait");
                result = new Symbol.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbol.ABSTRACT_METHOD(location, self, name, enclosing);
            fi

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result: Property;

            if is_static then
                IoC.CONTAINER.instance.logger.error(location, "cannot declare static property in trait");
                result = new Symbol.STATIC_PROPERTY(location, self, name, is_assignable);
            else
                result = new Symbol.INSTANCE_PROPERTY(location, self, name, is_assignable);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si

    class STRUCT: Classy, Type.Typed is
        description: String => "struct " + qualified_name;
        short_description: String => "struct " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.STRUCT;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        is_value_type: bool => true;

        il_name_prefix: String => "valuetype ";

        il_def: String => get_il_def(".class public auto ansi beforefieldinit");

        init(location: LOCATION, owner: Scope, name: String, arguments: Collections.LIST[String], enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
        si

        load(location: LOCATION, from: Graph.Value.BASE, loader: SYMBOL_LOADER) -> Graph.Value.BASE is
            return loader.load_struct(self);
        si

        // FIXME: most of these can be folded into Classy:

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Function;

            if is_static then
                result = new Symbol.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbol.STRUCT_METHOD(location, self, name, enclosing);
            fi

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            // FIXME: probably also needs to load address of self:
            var result = new Symbol.INSTANCE_FIELD(location, self, name);

            declare(location, result, symbol_definition_listener);
        si

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbol.INSTANCE_PROPERTY(location, self, name, is_assignable);

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si
    
si
