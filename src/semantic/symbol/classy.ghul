namespace Semantic.Symbols is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System;
    
    use IoC;
    use Logging;
    use Source;

    use IR.Values.Value;

    use Types.Type;

    class Classy: ScopedWithEnclosingScope is
        _ancestors: Collections.LIST[Type];
        _enclosing_symbols: Collections.MAP[string,Symbol];

        _are_overrides_resolved: bool;

        inheritance_dependency_order: int;
        _next_inheritance_dependency_order: int static;

        type: Type;

        set_type(value: Type) is type = value; si

        argument_names: Collections.LIST[string];
        ancestors: Collections.LIST[Type] => _ancestors;

        closures: Collections.LIST[Closure];

        is_workspace_visible: bool => true;

        il_name_prefix: string => "";

        il_name: string is
            if il_name_override? then
                return il_name_override;
            fi

            let result = new System.Text.StringBuilder(name.length + 5);

            result.append("'").append(name);

            if argument_names.count > 0 then
                result
                    .append("`")
                    .append(argument_names.count);
            fi

            result.append("'");

            return result.to_string();
        si

        il_token_name: string is
            let ilqn = il_qualified_name;

            if il_name_override? then
                let result = ilqn;

                if result.starts_with("class ") then
                    return result.substring(6);
                elif result.starts_with("valuetype ") then
                    return result.substring(10);
                fi
                
                return result;
            fi

            let result = new System.Text.StringBuilder();

            result
                .append(ilqn);

            if argument_names.count > 0 && !ilqn.contains('`') then
                result.append("`").append(argument_names.count);
            fi

            return result.to_string();
        si

        il_type_name: string is
            let result = new System.Text.StringBuilder();

            if il_name_override? then
                result.append(il_qualified_name);
            else
                result
                    .append(il_name_prefix)
                    .append(il_qualified_name);
            fi

            if argument_names.count > 0 then
                result.append('<');

                let seen_any = false;

                for i in 0..argument_names.count do
                    if seen_any then
                        result.append(',');
                    fi
                    
                    result.append('!');
                    result.append(i);

                    seen_any = true;
                od
                
                result.append('>');
            fi
            
            return result.to_string();
        si

        is_derived_from_iterable_trait: bool
            => find_ancestor(IoC.CONTAINER.instance.innate_symbol_lookup.get_unspecialized_iterable_type())?;

        is_derived_from_iterator_trait: bool
            => find_ancestor(IoC.CONTAINER.instance.innate_symbol_lookup.get_unspecialized_iterator_type())?;

        is_derived_from_enum: bool =>
            find_ancestor(IoC.CONTAINER.instance.innate_symbol_lookup.get_unspecialized_enum_type())?;

        get_il_def(preamble: string) -> string is
            let result = new System.Text.StringBuilder();

            result
                .append(preamble)
                .append(' ');

            if il_name_override? then
                result
                    .append(il_name_override);

            elif argument_names.count > 0 then
                result
                    .append(name)
                    .append('`')
                    .append(argument_names.count)
                    .append('<');

                // FIXME: contraints here

                let seen_any = false;

                for argument in argument_names do
                    if seen_any then
                        result.append(',');
                    fi
                    
                    result
                        .append(argument);

                    seen_any = true;
                od

                result.append('>');
            else
                result.append(il_name);        
            fi
            
            let index = 0;
            let done_implements = false;

            for a in ancestors do
                if !isa Types.NAMED(a) then
                    continue;  
                fi

                let ancestor = cast Types.NAMED(a).symbol;

                if is_trait && !ancestor.is_trait then
                    continue;
                fi

                let atn = ancestor.il_type_name;

                // FIXME: not doing this causes .NET to throw a TypeLoadException. Not clear why this syntax is acceptable (indeed required)
                // in some contexts, and assembles when used in an 'extends' or 'implements' clause without an error, but then fails on load. 
                if atn.starts_with("class ") && !atn.contains('<') then
                    atn = atn.substring(6);
                fi

                if index == 0 && !ancestor.is_trait then

                    result
                        .append(" extends ")
                        .append(atn);

                elif ancestor.is_trait then
                    if !done_implements then
                        result.append(" implements ");

                        done_implements = true;
                    else
                        result.append(", ");
                    fi

                    result
                        .append(atn);
                fi

                index = index + 1;
            od

            return result.to_string();
        si

        init(location: LOCATION, owner: Scope, name: string, argument_names: Collections.LIST[string], enclosing_scope: Scope) is
            super.init(location, owner, name, enclosing_scope);

            _ancestors = new Collections.LIST[Type]();
            _enclosing_symbols = new Collections.MAP[string,Symbol]();
            self.argument_names = argument_names;

            type = new Types.NAMED(self);
        si

        get_ancestor(i: int) -> Type
            => ancestors[i].specialize(new Collections.MAP[string,Type]());

        add_ancestor(ancestor: Type) is
            _ancestors.add(ancestor);
        si

        push_ancestor(ancestor: Type) is
            let na = new Collections.LIST[Type]();

            na.add(ancestor);
            na.add_range(_ancestors);

            _ancestors = na;
        si

        add_closure(closure: Closure) is
            if !closures? then
                closures = new Collections.LIST[Closure]();
            fi

            closures.add(closure);
        si

        find_member(name: string) -> Symbol => find_direct(name);

        find_enclosing(name: string) -> Symbol is
            if _enclosing_symbols.contains_key(name) then
                return _enclosing_symbols[name];
            fi            

            let result = find_direct(name);

            if result? then
                if !isa FUNCTION_GROUP(result) then
                    _enclosing_symbols[name] = result;

                    return result;
                fi

                let outer = find_enclosing_only(name);

                if !outer? || !isa FUNCTION_GROUP(outer) then
                    _enclosing_symbols[name] = result;

                    return result;
                fi

                let combined = new FUNCTION_GROUP(result.location, result.owner, result.name);

                let seen = new Collections.SET[METHOD_OVERRIDE_CLASS]();

                for f in cast FUNCTION_GROUP(result).functions do
                    seen.add(f.override_class);
                    combined.add(f);
                od

                for f in cast FUNCTION_GROUP(outer).functions do
                    if !seen.contains(f.override_class) then
                        combined.add(f);                        
                    fi                    
                od

                _enclosing_symbols[name] = combined;
                                
                return combined;
            fi

            return find_enclosing_only(name);
        si

        find_ancestor_matches(prefix: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            assert _are_overrides_resolved;

            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
        si

        find_member_matches(prefix: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            assert _are_overrides_resolved;

            find_direct_matches(prefix, matches);

            /*
            for a in ancestors do
                if a? && a.scope? then
                    a.scope.find_member_matches(prefix, matches);
                fi
            od
            */
        si

        find_enclosing_matches(prefix: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            assert _are_overrides_resolved;

            find_member_matches(prefix, matches);
            find_enclosing_only_matches(prefix, matches);
        si

        assert_symbols_pulled_down() is
            if !_are_overrides_resolved then
                pull_down_super_symbols();
            fi
            // assert _are_overrides_resolved else "super type symbols for " + self + " should already have been pulled down";
        si

        pull_down_super_symbols() is
            if _are_overrides_resolved then
                return;
            fi

            @IF.debug() Std.error.write_line("before resolve overrides: " + self);
        
            _are_overrides_resolved = true;

            for i in 0..ancestors.count do
                @IF.debug() Std.error.write_line("pull down " + self + ": get ancestor: " + i);

                let a = get_ancestor(i);

                @IF.debug() Std.error.write_line("pull down " + self + ": have ancestor: " + a);

                let symbol = a.symbol;

                if symbol? then
                    @IF.debug() Std.error.write_line("pull down " + self + ": pull down ancestor: " + symbol);
                    symbol.pull_down_super_symbols();
                fi
            od

            inheritance_dependency_order = _next_inheritance_dependency_order;

            _next_inheritance_dependency_order = _next_inheritance_dependency_order + 1;

            let resolver = new SYMBOL_INHERITANCE_RESOLVER(self);
            @IF.debug() Std.error.write_line("pull down " + self + ": call inheritance resolver");

            resolver.pull_into();
        si
    si

    class CLASS: Classy, Types.Typed is
        description: string => "class " + qualified_name;
        short_description: string => "class " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.CLASS;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.CLASS;

        is_stub: bool;

        is_inheritable: bool => true;
        is_class: bool => true;

        il_def: string => get_il_def(".class public auto ansi beforefieldinit");

        il_name_prefix: string => "class ";

        init(location: LOCATION, owner: Scope, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);

            self.is_stub = is_stub;
        si

        load(location: LOCATION, from: Value, loader: SYMBOL_LOADER) -> Value is
            return loader.load_class(self);
        si

        // FIXME: most of these can be folded into ClassAndTraitBase:

        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: string, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Function;

            if is_static then
                result = new Symbols.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbols.INSTANCE_METHOD(location, self, name, enclosing);
            fi
            
            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si        

        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Variable;
            
            if is_static then
                result = new Symbols.STATIC_FIELD(location, self, name);
            else
                result = new Symbols.INSTANCE_FIELD(location, self, name);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Property;

            if is_static then
                result = new Symbols.STATIC_PROPERTY(location, self, name, is_assignable);
            else
                result = new Symbols.INSTANCE_PROPERTY(location, self, name, is_assignable);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si

    class TRAIT: Classy, Types.Typed is
        description: string => "trait " + qualified_name;
        short_description: string => "trait " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.INTERFACE;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.INTERFACE;

        is_stub: bool;

        is_inheritable: bool => true;
        is_trait: bool => true;

        il_name_prefix: string => "class ";

        il_def: string => get_il_def(".class public interface auto ansi beforefieldinit");

        init(location: LOCATION, owner: Scope, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
            self.is_stub = is_stub;
        si

        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value is
            return loader.load_trait(self);
        si

        // FIXME: most of these can be folded into Classy:

        declare_enum(location: LOCATION, name: string, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.INNATE_FUNCTION(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result: Function;
            
            if is_static then
                IoC.CONTAINER.instance.logger.error(location, "cannot declare static method in trait");
                result = new Symbols.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbols.ABSTRACT_METHOD(location, self, name, enclosing);
            fi

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result: Property;

            if is_static then
                IoC.CONTAINER.instance.logger.error(location, "cannot declare static property in trait");
                result = new Symbols.STATIC_PROPERTY(location, self, name, is_assignable);
            else
                result = new Symbols.INSTANCE_PROPERTY(location, self, name, is_assignable);
            fi

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si

    class STRUCT: Classy, Types.Typed is
        description: string => "struct " + qualified_name;
        short_description: string => "struct " + name;

        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.STRUCT;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.STRUCT;

        is_stub: bool;

        is_value_type: bool => true;

        il_name_prefix: string => "valuetype ";

        il_def: string => get_il_def(".class public sealed auto ansi beforefieldinit");

        init(location: LOCATION, owner: Scope, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing_scope: Scope) is
            super.init(location, owner, name, arguments, enclosing_scope);
            self.is_stub = true;
        si

        load(location: LOCATION, from: IR.Values.Value, loader: SYMBOL_LOADER) -> IR.Values.Value is
            return loader.load_struct(self);
        si

        // FIXME: most of these can be folded into Classy:

        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.TYPE(location, self, name, index);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_enum(location: LOCATION, name: string, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.ENUM_(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.INNATE_METHOD(location, self, name, enclosing, innate_name);

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_function(location: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            let result: Function;

            if is_static then
                result = new Symbols.STATIC_METHOD(location, self, name, enclosing);
            else
                result = new Symbols.STRUCT_METHOD(location, self, name, enclosing);
            fi

            declare_function_group(location, result, symbol_definition_listener);

            return result;
        si

        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            // FIXME: probably also needs to load address of self:
            var result = new Symbols.INSTANCE_FIELD(location, self, name);

            declare(location, result, symbol_definition_listener);

            return result;
        si

        declare_property(location: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var result = new Symbols.INSTANCE_PROPERTY(location, self, name, is_assignable);

            declare(location, result, symbol_definition_listener);

            return result;
        si
    si
    
si
