namespace Semantic.Symbol is
    use object = System.Object;
    use string = System.String;
    use STD = System.Console;

    use System;
    
    use IoC;
    use Logging;
    use Source;

    class TYPE: Scoped, Type.SettableTyped is
        type: Type.BASE;
        set_type(value: Type.BASE) is type = value; si
        
        is_value_type: bool => true;
        ancestor: Semantic.Scope public;

        index: int;

        il_def: string => "type has no il_def: " + self;

        il_type_name: string => "!" + index;

        // FIXME: should ancestor be a type not a symbol? We could then just use BASE.ancestors.
        // We'll need multiple ancestors to support multiple constraints anyway
        ancestors: Collections.LIST[Type.BASE] is
            if ancestor == null then
                return new Collections.LIST[Type.BASE](0);
            fi

            let result = new Collections.LIST[Type.BASE](1);
            result.add(new Type.NAMED(cast Symbol.BASE(ancestor)));

            return result;
        si
        
        symbol_kind: SYMBOL_KIND => SYMBOL_KIND.TYPE_PARAMETER;
        completion_kind: COMPLETION_KIND => COMPLETION_KIND.VARIABLE;

        description: string => name + ": " + type + " // type variable";
        short_description: string => description;

        init(location: LOCATION, owner: Scope, name: string, index: int) is
            init(location, owner, name, new Type.NAMED(self));

            self.index = index; 
        si

        init(location: LOCATION, owner: Scope, name: string, type: Type.BASE) is
            super.init(location, owner, name);

            assert isa Type.SettableTyped(self) else "oops: should implement SettableTyped: " + self.get_type();

            self.type = type;
        si

        get_ancestor(i: int) -> Type.BASE is
            return ancestors[i];
        si

        find_member(name: string) -> BASE is
            if ancestor? then
                let result = ancestor.find_member(name);

                return result;
            fi
        si

        find_member_matches(prefix: string, matches: Collections.MAP[string, Symbol.BASE]) is
            if ancestor? then
                ancestor.find_member_matches(prefix, matches);
            fi
        si

        compare_type(other: BASE) -> Type.MATCH is
            if self == other then
                return Type.MATCH.SAME;
            fi

            return Type.MATCH.DIFFERENT;
        si

        specialize(type_map: Collections.MAP[string,Type.BASE], owner: GENERIC) -> BASE is
            if type_map.contains_key(name) then
                return new TYPE(
                    location,
                    self,
                    name,
                    type_map[name]
                );                
            fi

            return self;
        si
    si

si
