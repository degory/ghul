namespace Semantic is
    use System.String;
    use System.Reflection;
    use System.Type2;

    use System.Console;
    
    use Collections.Iterable;
    use Collections.MutableMap;
    use Collections.SET;
    use Collections.LIST;
    use Collections.MAP;

    struct TYPE_NAME is
        qualified_name: String;

        namespace_name: String is
            let last_dot_index = qualified_name.last_index_of('.');

            if last_dot_index >= 0 then
                return qualified_name.substring(0, last_dot_index);
            fi
        si

        name: String is
            let last_dot_index = qualified_name.last_index_of('.');

            if last_dot_index >= 0 then
                return qualified_name.substring(last_dot_index + 1);
            fi
        si

        init(qualified_name: String) is
            self.qualified_name = qualified_name;
        si

        init(namespace_name: String, name: String) is
            self.qualified_name = namespace_name + "." + name;
        si
        
    si
    
    class TYPE_NAME_MAP is
        dotnet_type_name_map: MAP[String,TYPE_NAME];
        ghul_type_name_map: MAP[String,TYPE_NAME];

        init() is
            dotnet_type_name_map = new MAP[String,TYPE_NAME]();
            ghul_type_name_map = new MAP[String,TYPE_NAME]();
        si

        get_type_name(
            map: MutableMap[String,TYPE_NAME],
            qualified_name: String
        ) -> TYPE_NAME
        is
            let result: TYPE_NAME;

            if map.try_get_value(qualified_name, result ref) then
                return result;
            fi

            return new TYPE_NAME(qualified_name);
        si

        get_ghul_type_name(type: Type2) -> TYPE_NAME =>
            get_dotnet_type_name(type.full_name);
        
        get_dotnet_type_name(qualified_name: String) -> TYPE_NAME =>
            get_type_name(dotnet_type_name_map, qualified_name);

        get_ghul_type_name(qualified_name: String) -> TYPE_NAME =>
            get_type_name(ghul_type_name_map, qualified_name);
    si

    class ASSEMBLY_NAMESPACE: Scope is
        qualified_name: String;

        name: String => qualified_name;

        type: Type.BASE is
            throw new System.NotImplementedException();
        si

        unspecialized_symbol: Symbol.BASE is
            throw new System.NotImplementedException();
        si

        symbols: Iterable[Symbol.BASE] is
            throw new System.NotImplementedException();
        si

        is_trait: bool => false;

        init(qualified_name: String) is
            self.qualified_name = qualified_name;
        si

        qualify(name: String) -> String is
            throw new System.NotImplementedException();
        si
        
        find_direct(name: String) -> Symbol.BASE is
            throw new System.NotImplementedException();
        si

        find_member(name: String) -> Symbol.BASE is
            throw new System.NotImplementedException();
        si

        find_enclosing(name: String) -> Symbol.BASE is
            throw new System.NotImplementedException();
        si

        find_direct_matches(prefix: System.String, matches: Collections.MAP[String,Symbol.BASE]) is
            throw new System.NotImplementedException();
        si

        find_member_matches(prefix: System.String, matches: Collections.MAP[String,Symbol.BASE]) is
            throw new System.NotImplementedException();
        si

        find_enclosing_matches(prefix: System.String, matches: Collections.MAP[String,Symbol.BASE]) is
            throw new System.NotImplementedException();
        si
    si
    
    class ASSEMBLY is
        _type_name_map: TYPE_NAME_MAP;

        assembly: Assembly;
        namespaces: Iterable[String];

        symbols: MAP[String,Symbol.BASE];

        init(type_name_map: TYPE_NAME_MAP, name: String) is
            _type_name_map = type_name_map;

            assembly = Assembly.load_from(name);

            let ns = new SET[String]();

            for type in assembly.get_exported_types() do
                ns.add(type.namespace_);                
            od
            
            namespaces = ns;
        si

        find(qualified_name: String) -> Symbol.BASE is
            let result: Symbol.BASE;

            if symbols.try_get_value(qualified_name, result ref) then
                return result;
            fi

            let dotnet_name = _type_name_map.get_dotnet_type_name(qualified_name);

            let dotnet_type = assembly.get_type(dotnet_name.qualified_name);
            
            if !dotnet_type? then
                // FIXME: cache negative result on lookup failure here
                return null;
            fi

            Console.error.write_line("have .NET type: " + dotnet_type);
        si
    si

    class TYPE_MAPPER is
        _type_name_map: TYPE_NAME_MAP;

        init(type_name_map: TYPE_NAME_MAP) is
            _type_name_map = type_name_map;    
        si

        get_symbol(type: Type2) -> Symbol.BASE is
            if type.is_class then
                return 
                    get_class(type);
            fi
        si

        get_type(type: Type2) -> Type.BASE is
            let symbol = get_symbol(type);

            if symbol? then
                // FIXME: what if it's a generic?
                return new Type.NAMED(symbol);                
            fi
        si

        get_class(type: Type2) -> Symbol.Classy is
            let type_name = _type_name_map.get_ghul_type_name(type);

            let dummy_namespace = new ASSEMBLY_NAMESPACE(type_name.namespace_name);

            let arguments = new LIST[String]();

            if type.is_generic_type_definition then
                for argument in type.generic_type_arguments do
                    // arguments.add(get_type(argument));
                    arguments.add(argument.name);
                od
            fi
            
            return new Symbol.CLASS(Source.LOCATION.dummy, dummy_namespace, type_name.name, arguments, true, dummy_namespace);
        si
    si
si
