namespace Semantic is
    use System;
    use Generic;

    use IoC;
    use Logging;
    use Source;

    trait Scope is
        type: Type.BASE;

        unspecialized_symbol: Symbol.BASE;

        qualify(name: String) -> String;
        find_direct(name: String) -> Symbol.BASE;
        find_member(name: String) -> Symbol.BASE;
        find_enclosing(name: String) -> Symbol.BASE;

        find_direct_matches(prefix: String, matches: Dict[String, Symbol.BASE]);
        find_member_matches(prefix: String, matches: Dict[String, Symbol.BASE]);
        find_enclosing_matches(prefix: String, matches: Dict[String, Symbol.BASE]);
    si

    trait DeclarationContext is
        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_struct(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener);
        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener);
        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_label(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener);
    si

    trait NamespaceContext is
        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE, symbol_definition_listener: SymbolDefinitionListener);
    si

    class USE_SCOPE : Object, Scope  is
        _enclosing: Scope;
        _used_symbols: SYMBOL_MAP;
        _used_scopes: Vector[Scope];

        type: Type.BASE => Type.NONE.instance;

        unspecialized_symbol: Symbol.BASE => null;

        init(enclosing: Scope) is
            _enclosing = enclosing;
            _used_symbols = new SYMBOL_MAP();
            _used_scopes = new Vector[Scope]();
        si

        qualify(name: String) -> String => _enclosing.qualify(name);

        _find_direct(name: String) -> Symbol.BASE is
            var result = _used_symbols[name];

            if result? then
                return result;
            fi

            for scope in _used_scopes do
                result = scope.find_direct(name);
                if result? then
                    return result;
                fi
            od

            return null;
        si

        find_direct(name: String) -> Symbol.BASE is
            var result = _find_direct(name);

            if result == null && _enclosing? then
                result = _enclosing.find_direct(name);
            fi

            return result;
        si

        find_direct_matches(prefix: String, matches: Dict[String,Symbol.BASE]) is
            _used_symbols.find_matches(prefix, matches);
        
            for scope in _used_scopes do
                scope.find_direct_matches(prefix, matches);
            od
        si        

        find_member(name: String) -> Symbol.BASE is
            throw new NotImplementedException("cannot search for member " + name + " in use scope");
        si

        find_member_matches(prefix: String, results: Dict[String,Symbol.BASE]) is
            throw new NotImplementedException("cannot search for members matching " + prefix + " in use scope");
        si        

        find_enclosing(name: String) -> Symbol.BASE is
            var result = _find_direct(name);

            if result == null && _enclosing? then
                result = _enclosing.find_enclosing(name);
            fi

            return result;
        si

        find_enclosing_matches(prefix: String, matches: Dict[String,Symbol.BASE]) is
            _used_symbols.find_matches(prefix, matches);

            for scope in _used_scopes do
                scope.find_enclosing_matches(prefix, matches);
            od
        si        

        add_scope(scope: Scope) is
            _used_scopes.add(scope);
        si

        add_symbol(symbol: Symbol.BASE) is
            _used_symbols[symbol.name] = symbol;
        si

        toString() -> String is
            return 
                ClassName + "\n" + _used_symbols + "\n" + _used_scopes;
        si
    si

    class BLOCK_SCOPE: Object, Scope, DeclarationContext  is
        _enclosing: Scope;
        _symbols: Semantic.SYMBOL_MAP;

        type: Type.BASE => Type.NONE.instance;

        unspecialized_symbol: Symbol.BASE => null;

        init() is
            init(null);
        si

        init(enclosing: Scope) is
            self._enclosing = enclosing;
            _symbols = new Semantic.SYMBOL_MAP();
        si

        qualify(name: String) -> String => _enclosing.qualify(name);

        // qualify(name: String) -> String => "(" + ClassName + ") " + name;

        find_direct(name: String) -> Symbol.BASE =>
            _symbols[name];

        find_direct_matches(prefix: String, matches: Dict[String,Symbol.BASE]) is
            _symbols.find_matches(prefix, matches);
        si            

        find_member(name: String) -> Symbol.BASE is
            throw new NotImplementedException("cannot search for member " + name + " in block scope");
        si

        find_member_matches(prefix: String, matches: Dict[String,Symbol.BASE]) is
            throw new NotImplementedException("cannot search for member matches " + prefix + " in block scope");
        si        

        find_enclosing(name: String) -> Symbol.BASE is
            var result = find_direct(name);

            if result? then
                return result;
            elif _enclosing? then
                return _enclosing.find_enclosing(name);
            else
                return null;
            fi
        si

        find_enclosing_matches(prefix: String, matches: Dict[String,Symbol.BASE]) is
            find_direct_matches(prefix, matches);

            _enclosing.find_enclosing_matches(prefix, matches);
        si

        declare_undefined(location: LOCATION, kind: String, name: String) -> Scope is
            CONTAINER.instance.logger.error(location, "cannot declare " + kind + " here");

            return new Symbol.UNDEFINED(location, self, name);
        si

        declare_class(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "class", name);

        declare_trait(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "trait", name);

        declare_struct(location: LOCATION, name: String, arguments: List[String], enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "struct", name);    

        declare_type(location: LOCATION, name: String, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "type", name);

        declare_enum(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "enum", name);

        declare_enum_member(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "enum member", name);
        si

        declare_innate(location: LOCATION, name: String, innate_name: String, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "innate", name);

        declare_function(location: LOCATION, name: String, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "function", name);

        add_namespace(location: LOCATION, name: String, namespace_: Symbol.NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            declare_undefined(location, "namespace", name);
        si

        declare_label(location: LOCATION, name: String, symbol_definition_listener: SymbolDefinitionListener) is
            var label = new Symbol.LABEL(location, self, name);
            declare(location, label, symbol_definition_listener);
        si

        declare_variable(location: LOCATION, name: String, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) is
            var variable = new Symbol.LOCAL_VARIABLE(location, self, name);
            declare(location, variable, symbol_definition_listener);
        si

        declare_closure(location: LOCATION, name: String, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope is
            var closure = new Symbol.CLOSURE(location, owner, name, enclosing);

            declare(location, closure, null);

            return closure;
        si        

        declare_property(location: LOCATION, name: String, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            declare_undefined(location, "property", name);

        declare(location: LOCATION, symbol: Symbol.BASE, symbol_definition_listener: SymbolDefinitionListener) is
            var name = symbol.name;
            var existing = find_direct(symbol.name);
            
            if existing? then
                CONTAINER.instance.logger.error(location, "redefining symbol " + symbol.name + " originally defined at " + existing.location);
                CONTAINER.instance.logger.error(existing.location, "symbol " + symbol.name + " is redefined at " + location);
            fi

            if symbol_definition_listener? then
                symbol_definition_listener.add_symbol_definition(location, symbol);
            fi
            
            _symbols[name] = symbol;
        si

        toString() -> String =>
            self.ClassName + " " + _symbols;
    si
si
