namespace Semantic is
    use System;

    @IF.legacy()
    class SYMBOL_MAP: Collection.SortedMap[String,Symbol.BASE] is
        init() is
            super.init();
        si

        find_matches(
            prefix: String,
            matches: Collections.MAP[String,Semantic.Symbol.BASE])
        is        
            var n = find_first_match(prefix);

            if !n? then return; fi

            add_match(n.key, n.value, matches);

            for i in new Collection.SortedMapIterator[String,Semantic.Symbol.BASE](n) do
                if Shim.STR.starts_with(i.key, prefix) then
                    add_match(i.key, i.value, matches);
                else
                    return;
                fi
            od
        si

        add_match(
            name: String,
            match: Semantic.Symbol.BASE,
            matches: Collections.MAP[String,Semantic.Symbol.BASE]
        ) static is
            if !Shim.STR.starts_with(name, "__") && !matches.contains_key(name) then
                matches[name] = match.collapse_group_if_single_member();
            fi
        si

        find_first_match(
            prefix: String
        ) -> Collection.TreeNode[String,Semantic.Symbol.BASE] is
            var n = root;

            while n? do
                if n.key.startsWith(prefix) then
                    return n;
                fi

                let compResult = prefix.opCompare(n.key);

                if compResult == 0 then
                    System.Console.error.write_line("symbol map, weird: found exact match: " + n.key);

                    return n;
                elif compResult < 0 then
                    n = n.left;
                else
                    n = n.right;
                fi
            od

            return n;
        si        
    si

    @IF.dotnet()
    class SYMBOL_MAP /* : Collections.MutableMap[String,Symbol.BASE] */ is
        _map: Collections.MAP[String,Symbol.BASE];

        values: Collections.VALUE_COLLECTION[String,Symbol.BASE] => _map.values;

        init() is
            _map = new Collections.MAP[String,Symbol.BASE]();
        si

        [name: String]: Symbol.BASE is
            if _map.contains_key(name) then
                return _map[name];
            fi            
        si,
        = v is
            _map[name] = v;
        si

        add(pair: Collections.Pair[String,Symbol.BASE]) is _map.add(pair); si
        add(name: String, value: Symbol.BASE) is _map.add(name, value); si

        contains(pair: Collections.Pair[String,Symbol.BASE]) -> bool => _map.contains(pair);
        contains_key(name: String) -> bool => _map.contains_key(name);

        remove(pair: Collections.Pair[String,Symbol.BASE]) -> bool => _map.remove(pair);

        remove(name: String) is _map.remove(name); si

        // try_get_value(name: String, result: Symbol.BASE ref) -> bool => _map.try_get_value(name, result);

        // copy_to(result: Collections.Pair[String,Symbol.BASE][], index: int) is
        //     _map.copy_to(result, index);
        // si
                
        clear() is _map.clear(); si

        find_matches(
            prefix: String,
            matches: Collections.MAP[String,Semantic.Symbol.BASE])
        is
        si

        add_match(
            name: String,
            match: Semantic.Symbol.BASE,
            matches: Collections.MAP[String,Semantic.Symbol.BASE]
        ) static is
            if !Shim.STR.starts_with(name, "__") && !matches.contains_key(name) then
                matches[name] = match.collapse_group_if_single_member();
            fi
        si

        // find_first_match(
        //     prefix: String
        // ) -> Collection.TreeNode[String,Semantic.Symbol.BASE] is
        // si        
    si
si