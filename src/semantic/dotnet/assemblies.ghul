namespace Semantic.DotNet is
    use System.Type2;
    use System.String;
    use System.Console;

    use System.Reflection.Assembly;

    use Collections.MAP;
    use Collections.SET;
    use Collections.LIST;
    use Collections.Iterable;

    use Logging.TIMERS;

    class ASSEMBLIES is
        _is_enabled: bool;
        _timers: TIMERS;
        _ghul_symbol_table: Semantic.SYMBOL_TABLE;
        _namespaces: NAMESPACES;
        _type_name_map: TYPE_NAME_MAP;

        _is_started: bool;

        assemblies_by_name: MAP[String,Assembly];
        assemblies_by_dotnet_namespace: MAP[String,SET[Assembly]];
        assemblies_by_ghul_namespace: MAP[String,SET[Assembly]];

        init(
            timers: TIMERS,
            ghul_symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: NAMESPACES,
            type_name_map: TYPE_NAME_MAP
        ) is
            _timers = timers;
            _ghul_symbol_table = ghul_symbol_table;
            _namespaces = namespaces;
            _type_name_map = type_name_map;

            _is_enabled = true;

            assemblies_by_name = new MAP[String,Assembly]();
            assemblies_by_dotnet_namespace = new MAP[String,SET[Assembly]]();
            assemblies_by_ghul_namespace = new MAP[String,SET[Assembly]]();
        si

        disable() is
            _is_enabled = false;
        si

        start() is
            if !_is_enabled then
                return;
            fi

            let default_imports = ["System.Console", "System.Runtime", "System.IO.FileSystem", "System.Collections"];

            for a in default_imports do
                import(System.IO2.Path.combine("/usr/share/dotnet/shared/Microsoft.NETCore.App/5.0.0/", a + ".dll"));                
            od

            Console.error.write_line(_timers);
        si
        
        reset() is
            if !_is_enabled then
                return;
            fi

            if !_is_started then
                start();
                _is_started = true;
            fi

            create_namespaces();
        si

        create_namespaces() is
            let current = new LIST[String]();

            let namespaces = new LIST[String]();

            // for ns in assemblies_by_ghul_namespace do
            //     Console.error.write_line("namespace: " + ns.key + " assemblies: " + new Shim.JOIN[Assembly](ns.value));
            // od

            for ns in assemblies_by_ghul_namespace.keys do
                namespaces.add(ns);
            od

            namespaces.sort();

            for a in namespaces do
                let to_create = new LIST[String](a.split(['.']));

                // Console.error.write_line("initially in " + new Shim.JOIN[String](current, "/"));

                while current.count > to_create.count do
                    // Console.error.write_line("drop excess " + current[current.count - 1]);
                    _namespaces.leave_namespace(null, null);
                    _ghul_symbol_table.leave_scope();
                    current.remove_at(current.count - 1);
                od

                // Console.error.write_line("dropped excess down to " + new Shim.JOIN[String](current, "/"));

                let index = 0;

                while index < current.count && current[index] =~ to_create[index] do
                    index = index + 1;
                od
                
                while current.count > index do
                    // Console.error.write_line("drop non matching " + current[current.count - 1]);
                    _namespaces.leave_namespace(null, null);
                    _ghul_symbol_table.leave_scope();
                    current.remove_at(current.count - 1);
                od

                // Console.error.write_line("dropped non matching down to " + new Shim.JOIN[String](current, "/"));

                for i in index..to_create.count do
                    let ns = _namespaces.declare_and_enter_namespace(Source.LOCATION.dummy, to_create[i], null);
                    _ghul_symbol_table.enter_scope(ns);
                od
                
                current = to_create;
            od

            while current.count > 0 do
                // Console.error.write_line("drop out of " + current[current.count - 1]);
                _namespaces.leave_namespace(null, null);
                _ghul_symbol_table.leave_scope();
                current.remove_at(current.count - 1);                
            od            
        si        

        import(assembly_names: Iterable[String]) is
            for assembly_name in assembly_names do
                import(assembly_name);
            od            
        si

        import(path: String) is
            _timers.start("import assembly");

            try
                let assembly_name = System.IO2.Path.get_file_name_without_extension(path);

                if assemblies_by_name.contains_key(assembly_name) then
                    return;
                fi

                let assembly = Assembly.load_from(path);

                assemblies_by_name.add(assembly_name, assembly);

                import(assembly_name, assembly);

                Console.error.write_line("imported " + assembly);
            catch ex: System.Exception
                Console.error.write_line("failed to import: " + path);
            finally
                _timers.finish("import assembly");
            yrt            
        si

        import(name: String, assembly: Assembly) is
            let distinct_namespaces = new SET[String]();

            try
                for type in assembly.get_exported_types() do
                    let namespace_name = _type_name_map.get_ghul_namespace(type);

                    // Console.error.write_line("have type: " + type + " " + type.assembly_qualified_name);

                    distinct_namespaces.add(namespace_name);
                od
            catch ex: System.Exception
                Console.error.write_line("couldn't enumerate exported types in: " + assembly);
            yrt

            try
                for type in assembly.get_forwarded_types() do
                    let namespace_name = _type_name_map.get_ghul_namespace(type);

                    distinct_namespaces.add(namespace_name);
                od
            catch ex: System.Exception
                Console.error.write_line("couldn't enumerate forwarded types in: " + assembly);
            yrt
                    
            for namespace_name in distinct_namespaces do
                let set: SET[Assembly];
                // Console.error.write_line("assembly " + assembly + " contains types in " + namespace_name + " namespace");

                if !assemblies_by_ghul_namespace.try_get_value(namespace_name, set ref) then
                    set = new SET[Assembly]();
                    assemblies_by_ghul_namespace[namespace_name] = set;
                fi
                
                set.add(assembly);
            od
        si
        
        find(assembly_name: String, namespace_name: String, type_name: String) -> Type2 is
            let assembly: Assembly;            
        
            if !assemblies_by_name.try_get_value(assembly_name, assembly ref) then
                Console.error.write_line("assembly " + assembly_name + " not found looking for " + namespace_name + " " + type_name);

                return null;
            fi

            let qualified_name = namespace_name + "." + type_name;

            // Console.error.write_line("search " + assembly +  " for " + qualified_name);
            let result = assembly.get_type(qualified_name);
                
            if result? then
                // Console.error.write_line("found type: " + result);
                return result;
            fi                
        si
        
        find(namespace_name: String, name: String) -> Type2 is
            let set: SET[Assembly];

            // Console.error.write_line("search for type: " + name + " in namespace: " + namespace_name);
            
            if !assemblies_by_ghul_namespace.try_get_value(namespace_name, set ref) then
                // Console.error.write_line("namespace " + namespace_name +  " not found in any assembly");
                // Console.error.write_line("searched from " + new System.Diagnostics.StackTrace());

                // Console.write_line("not found in: " + new Shim.JOIN[Collections.Pair[System.String,SET[Assembly]]](assemblies_containing_namespace));

                return null;
            fi

            let qualified_name = namespace_name + "." + name;

            for assembly in set do
                // Console.error.write_line("search " + assembly +  " for " + qualified_name);
                let result = assembly.get_type(qualified_name);
                
                if result? then
                    // Console.error.write_line("found type: " + result + " in assembly " + assembly);
                    return result;
                fi                
            od
        si       
    si
si