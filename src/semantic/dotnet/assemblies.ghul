namespace Semantic.DotNet is
    use TYPE = System.Type2;

    use System.Reflection.Assembly;

    use IO.Std;

    use Collections.MAP;
    use Collections.SET;
    use Collections.LIST;
    use Collections.Iterable;

    use Logging.TIMERS;

    class ASSEMBLIES is
        _timers: TIMERS;

        _flags: Driver.BUILD_FLAGS;
        _paths: Driver.PATH_CONFIG;
        _type_details_lookup: TYPE_DETAILS_LOOKUP;
        _ghul_symbol_table: Semantic.SYMBOL_TABLE;
        _namespaces: NAMESPACES;
        _type_name_map: TYPE_NAME_MAP;

        _is_enabled: bool;
        _is_started: bool;
        _default_imports_are_needed: bool;

        // FIXME: does this need to vary with System.Environment.version? What's the Mono equivalent? Can we get it via config?
        sdk_path: string => "/usr/share/dotnet/packs/Microsoft.NETCore.App.Ref/5.0.0/ref/net5.0/"; 

        blocked_assemblies: SET[string];

        all_assemblies: Iterable[Assembly] => assemblies_by_name.values;
        assemblies_by_name: MAP[string,Assembly];
        assemblies_by_ghul_namespace: MAP[string,SET[Assembly]];

        all_types: SET[TYPE];
        
        init(
            timers: TIMERS,
            flags: Driver.BUILD_FLAGS,
            paths: Driver.PATH_CONFIG,
            ghul_symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: NAMESPACES,            
            type_name_map: TYPE_NAME_MAP,
            type_details_lookup: TYPE_DETAILS_LOOKUP
        ) is
            _timers = timers;
            _flags = flags;
            _paths = paths;
            _ghul_symbol_table = ghul_symbol_table;
            _namespaces = namespaces;
            _type_name_map = type_name_map;

            _is_enabled = true;
            _default_imports_are_needed = true;

            _type_details_lookup = type_details_lookup;

            blocked_assemblies = new SET[string]();

            block_all_unsupported_assemblies();

            assemblies_by_name = new MAP[string,Assembly]();
            assemblies_by_ghul_namespace = new MAP[string,SET[Assembly]]();

            all_types = new SET[TYPE]();
        si

        disable() is
            _is_enabled = false;
        si

        start() is
            if !_is_enabled \/ _is_started then
                return;
            fi

            _is_started = true;

            _type_name_map.start();

            @IF.not.release() Std.error.write_line("assemblies starting up...");
            
            let default_imports = ["System.Console", "System.Runtime", "System.IO.FileSystem", "System.Collections", "System.Threading"];

            if _default_imports_are_needed then
                for a in default_imports do
                    import(sdk_path + a + ".dll");
                od
                
                if !_flags.exclude_runtime_symbols then
                    import(_paths.install_folder + "ghul-runtime.dll");                    
                fi
            fi
        si
        
        import(assembly_names: Iterable[string]) is
            for assembly_name in assembly_names do
                import(assembly_name);
            od            
        si

        import(path: string) is
            _default_imports_are_needed = false;

            start();

            _timers.start("import assembly");

            try
                let assembly_name = IO.Path.get_file_name_without_extension(path);

                if assemblies_by_name.contains_key(assembly_name) \/ blocked_assemblies.contains(assembly_name) then
                    return;
                fi

                let assembly: Assembly;

                // FIXME: less brittle check:
                if path.starts_with(sdk_path) then
                    assembly = Assembly.load_from(path);
                else
                    try
                        assembly = Assembly.load_file(path);
                    catch whatever: System.Exception
                        assembly = Assembly.load_from(path);
                    yrt
                fi

                assemblies_by_name.add(assembly_name, assembly);

                let assembly_version = assembly.get_name().version.to_string().replace('.', ':');

                import(assembly, assembly_name, assembly_version);
            catch ex: System.Exception
                Std.error.write_line("failed to import assembly: " + path + " exception: " + ex.to_string().replace('\n', ' '));
            finally
                _timers.finish("import assembly");
            yrt
        si

        import(assembly: Assembly, assembly_name: string, assembly_version: string) is
            assert assembly_name? /\ assembly_name.length > 0;

            @IF.debug() Std.error.write_line("start type map...");

            _type_name_map.start();

            let types_file = _paths.get_library_location("dotnet/refs") + assembly_name + ".types";
        
            let any_succeeded = false;
            let exported_ex: System.Exception;
            let forwarded_ex: System.Exception;

            try
                for type in assembly.get_types() do                        
                    import_type(type, assembly_name, assembly_version);

                    any_succeeded = true;
                od
            catch ex: System.Exception
                exported_ex = exported_ex;
            yrt        

            try
                for type in assembly.get_forwarded_types() do
                    import_type(type, assembly_name, assembly_version);

                    any_succeeded = true;
                od
            catch ex: System.Exception
                forwarded_ex = ex;
            yrt

            if !any_succeeded then
                Std.error.write_line("warning: couldn't enumerate any types in " + assembly);
            fi                
        si

        import_type(type: TYPE, assembly_name: string, assembly_version: string) is
            assert assembly_name? else "attempting to import type " + type + " with no assembly name supplied";

            try
                let type_details = _type_name_map.get_type_details(type);

                if type_details? then
                    type_details.merge_assembly_reference(type, assembly_name, assembly_version);

                    return;
                elif !type.`namespace? then
                    return;
                else
                    let namespace_details = _type_name_map.get_namespace_details(type);
                    let namespace_name: string;
    
                    if namespace_details? then
                        namespace_name = namespace_details.ghul_name;
                    else
                        namespace_name = type.`namespace;
                    fi

                    let type_name = type.name;

                    if type.is_nested then
                        let parts = type.full_name.split(['.']);
                        
                        type_name = parts[parts.count-1].replace('+', '_');
                    fi
                    
                    type_details = new TYPE_DETAILS(type, namespace_name, type_name, null, assembly_name, assembly_version);
                fi
    
                assert type_details.assembly_name? /\ type_details.assembly_name.length > 0 else "invalid assmbly name before add type " + type_details;

                _type_details_lookup.add_type(type_details);
            catch ex: System.Exception
                Std.error.write_line("failed to import: " + type + " exception: " + ex.to_string().replace('\n', ' '));
            yrt
        si
 
        block_all_unsupported_assemblies() is
            blocked_assemblies.add("netstandard");
            blocked_assemblies.add("mscorlib");
            blocked_assemblies.add("WindowsBase");            
            blocked_assemblies.add("System.Configuration");
            blocked_assemblies.add("System.Core");
            blocked_assemblies.add("System.Data");
            blocked_assemblies.add("System");
            blocked_assemblies.add("System.Drawing");
            blocked_assemblies.add("System.Net");
            blocked_assemblies.add("System.Private.CoreLib");
            blocked_assemblies.add("System.Security");
            blocked_assemblies.add("System.ServiceModel.Web");
            blocked_assemblies.add("System.ServiceProcess");
            blocked_assemblies.add("System.Transactions");
        si
    si
si