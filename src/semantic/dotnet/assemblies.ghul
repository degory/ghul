namespace Semantic.DotNet is
    use TYPE = System.Type2;

    use System.Reflection.PathAssemblyResolver;
    use System.Reflection.MetadataLoadContext;
    use System.Reflection.MetadataAssemblyResolver;
    use System.Reflection.Assembly;

    use IO.Std;

    use Collections.MAP;
    use Collections.SET;
    use Collections.LIST;
    use Collections.Iterable;

    use Logging.TIMERS;

    class ASSEMBLIES is
        _timers: TIMERS;

        _flags: Driver.BUILD_FLAGS;
        _paths: Driver.PATH_CONFIG;
        _type_details_lookup: TYPE_DETAILS_LOOKUP;
        _ghul_symbol_table: Semantic.SYMBOL_TABLE;
        _namespaces: NAMESPACES;
        _type_name_map: TYPE_NAME_MAP;

        _assemblies_by_name: MAP[string,Assembly];
        _assemblies_by_ghul_namespace: MAP[string,SET[Assembly]];

        _is_started: bool;
        
        init(
            timers: TIMERS,
            flags: Driver.BUILD_FLAGS,
            paths: Driver.PATH_CONFIG,
            ghul_symbol_table: Semantic.SYMBOL_TABLE,
            namespaces: NAMESPACES,
            type_name_map: TYPE_NAME_MAP,
            type_details_lookup: TYPE_DETAILS_LOOKUP
        ) is
            _timers = timers;
            _ghul_symbol_table = ghul_symbol_table;
            _namespaces = namespaces;
            _type_name_map = type_name_map;

            _type_details_lookup = type_details_lookup;

            _assemblies_by_name = new MAP[string,Assembly]();
            _assemblies_by_ghul_namespace = new MAP[string,SET[Assembly]]();
        si

        import(assembly: Assembly, assembly_name: string, assembly_version: string) is
            assert assembly_name? /\ assembly_name.length > 0;

            @IF.debug() Std.error.write_line("start type map...");

            let types_file = _paths.get_library_location("dotnet/refs") + assembly_name + ".types";
        
            let any_succeeded = false;
            let exported_ex: System.Exception;
            let forwarded_ex: System.Exception;

            try
                for type in assembly.get_types() do                        
                    import_type(type, assembly_name, assembly_version);

                    any_succeeded = true;
                od
            catch ex: System.Exception
                exported_ex = exported_ex;
            yrt        

            try
                for type in assembly.get_forwarded_types() do
                    import_type(type, assembly_name, assembly_version);

                    any_succeeded = true;
                od
            catch ex: System.Exception
                forwarded_ex = ex;
            yrt

            if !any_succeeded then
                Std.error.write_line("warning: couldn't enumerate any types in " + assembly);
            fi                
        si

        import_type(type: TYPE, assembly_name: string, assembly_version: string) is
            assert assembly_name? else "attempting to import type " + type + " with no assembly name supplied";

            try
                let type_details = _type_name_map.get_type_details(type);

                if type_details? then
                    type_details.merge_assembly_reference(type, assembly_name, assembly_version);

                    return;
                elif !type.`namespace? \/ !type.full_name? then
                    return;
                else
                    let namespace_details = _type_name_map.get_namespace_details(type);
                    let namespace_name: string;
    
                    if namespace_details? then
                        namespace_name = namespace_details.ghul_name;
                    else
                        namespace_name = type.`namespace;
                    fi

                    let type_name = type.name;

                    if type.is_nested then
                        let parts = type.full_name.split(['.']);
                        
                        type_name = parts[parts.count-1].replace('+', '_');
                    fi
                    
                    type_details = new TYPE_DETAILS(type, namespace_name, type_name, null, assembly_name, assembly_version);
                fi
    
                assert type_details.assembly_name? /\ type_details.assembly_name.length > 0 else "invalid assmbly name before add type " + type_details;

                _type_details_lookup.add_type(type_details);
            catch ex: System.Exception
                Std.error.write_line("failed to import: " + type + " exception: " + ex.to_string().replace('\n', ' '));
            yrt
        si
     si
si