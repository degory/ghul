namespace Semantic.DotNet is
    use IO.Std;

    use TYPE = System.Type2;
    use System.Reflection;

    use Collections.LIST;
    use Collections.MAP;

    use Types.Type;
    use Types.NAMED;
    use Types.ANY;
    use FUNCTION_GENERIC_ARGUMENT_SYMBOL = Symbols.FUNCTION_GENERIC_ARGUMENT;
    use FUNCTION_GENERIC_ARGUMENT_TYPE = Types.FUNCTION_GENERIC_ARGUMENT;

    class TypeCreator is
        _mapper: TYPE_MAPPER;

        init(mapper: TYPE_MAPPER) is
            _mapper = mapper;
        si

        create(symbol_table: SYMBOL_TABLE, type: TYPE) -> Type;
    si

    class GENERIC_TYPE_CREATOR: TypeCreator is
        init(mapper: TYPE_MAPPER) is
            super.init(mapper);
        si

        create(symbol_table: SYMBOL_TABLE, type: TYPE) -> Type is
            let result: Type;

            if type.is_generic_type_definition then
                result = new GENERIC_TYPE_WRAPPER(symbol_table, _mapper, type);

                return result;
            elif type.is_generic_type then
                result = new GENERIC_TYPE_WRAPPER(symbol_table, _mapper, type);

                return result;
            fi

            throw new System.InvalidOperationException("don't know how to create type: " + type);
        si
    si    

    class ACTION_0_TYPE_CREATOR: TypeCreator is
        init(mapper: TYPE_MAPPER) is
            super.init(mapper);
        si

        create(symbol_table: SYMBOL_TABLE, type: TYPE) -> Type => 
            new ACTION_0_TYPE_WRAPPER(symbol_table, type);
    si

    class ACTION_TYPE_CREATOR: TypeCreator is
        init(mapper: TYPE_MAPPER) is
            super.init(mapper);
        si

        create(symbol_table: SYMBOL_TABLE, type: TYPE) -> Type =>
             new ACTION_TYPE_WRAPPER(symbol_table, _mapper, type);
    si

    class FUNCTION_TYPE_CREATOR: TypeCreator is
        init(mapper: TYPE_MAPPER) is
            super.init(mapper);
        si

        create(symbol_table: SYMBOL_TABLE, type: TYPE) -> Type => 
            new FUNCTION_TYPE_WRAPPER(symbol_table, _mapper, type);
    si

    class TUPLE_TYPE_CREATOR: TypeCreator is
        init(mapper: TYPE_MAPPER) is
            super.init(mapper);
        si

        create(symbol_table: SYMBOL_TABLE, type: TYPE) -> Type =>
            new TUPLE_TYPE_WRAPPER(symbol_table, _mapper, type, null);
    si
    
    class TYPE_MAPPER is
        _symbol_table: System.Lazy`1[SYMBOL_TABLE];
        _innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;
        _type_name_map: TYPE_NAME_MAP;

        _generic_type_creator: TypeCreator;
        _type_creators: MAP[TYPE,TypeCreator];

        // we don't need to intern types for correctness, but expecting to encounter a lot of references
        // to identical types, so interning them will result in lower memory usage and fewer calls into the 
        // symbol table/symbol cache to materialize the associated ghul symbols
        _type_cache: MAP[TYPE,Type];

        init(
            symbol_table: System.Lazy`1[SYMBOL_TABLE],
            innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup,
            type_name_map: TYPE_NAME_MAP
        ) is
            _symbol_table = symbol_table;
            _innate_symbol_lookup = innate_symbol_lookup;
            _type_name_map = type_name_map;

            _generic_type_creator = new GENERIC_TYPE_CREATOR(self);
            _type_creators = new MAP[TYPE,TypeCreator]();

            let action_0_type_creator = new ACTION_0_TYPE_CREATOR(self);
            let action_type_creator = new ACTION_TYPE_CREATOR(self);
            let function_type_creator = new FUNCTION_TYPE_CREATOR(self);
            let tuple_type_creator = new TUPLE_TYPE_CREATOR(self);

            _type_creators.add(typeof Ghul.ACTION_0, action_0_type_creator);
            _type_creators.add(typeof Ghul.ACTION_1, action_type_creator);
            _type_creators.add(typeof Ghul.ACTION_2, action_type_creator);
            _type_creators.add(typeof Ghul.ACTION_3, action_type_creator);
            _type_creators.add(typeof Ghul.ACTION_4, action_type_creator);
            _type_creators.add(typeof Ghul.ACTION_6, action_type_creator);
            _type_creators.add(typeof Ghul.ACTION_7, action_type_creator);
            _type_creators.add(typeof Ghul.ACTION_8, action_type_creator);

            _type_creators.add(typeof Ghul.FUNCTION_0, function_type_creator);
            _type_creators.add(typeof Ghul.FUNCTION_1, function_type_creator);
            _type_creators.add(typeof Ghul.FUNCTION_2, function_type_creator);
            _type_creators.add(typeof Ghul.FUNCTION_3, function_type_creator);
            _type_creators.add(typeof Ghul.FUNCTION_4, function_type_creator);
            _type_creators.add(typeof Ghul.FUNCTION_6, function_type_creator);
            _type_creators.add(typeof Ghul.FUNCTION_7, function_type_creator);
            _type_creators.add(typeof Ghul.FUNCTION_8, function_type_creator);

            _type_creators.add(typeof Ghul.TUPLE_1, tuple_type_creator);
            _type_creators.add(typeof Ghul.TUPLE_2, tuple_type_creator);
            _type_creators.add(typeof Ghul.TUPLE_3, tuple_type_creator);
            _type_creators.add(typeof Ghul.TUPLE_4, tuple_type_creator);
            _type_creators.add(typeof Ghul.TUPLE_6, tuple_type_creator);
            _type_creators.add(typeof Ghul.TUPLE_7, tuple_type_creator);
            _type_creators.add(typeof Ghul.TUPLE_8, tuple_type_creator);


            _type_cache = new MAP[TYPE,Type]();
        si

        get_type(type: TYPE) -> Type is
            let result: Type;

            if !type? then
                Std.error.write_line("warning: materializing null type");
                return Types.NONE.instance;
            fi
            
            if _type_cache.try_get_value(type, result ref) then
                return result;
            fi

            if type.is_generic_method_parameter then
                let symbol = new FUNCTION_GENERIC_ARGUMENT_SYMBOL(Source.LOCATION.internal, null, type.name, type.generic_parameter_position);

                result = symbol.type;
                _type_cache.add(type, result);

                return result;
            elif type.is_generic_type_parameter then
                let symbol = new Symbols.TYPE(Source.LOCATION.internal, null, type.name, type.generic_parameter_position);
                
                result = symbol.type;
                _type_cache.add(type, result);

                return result;
            fi

            if type.is_generic_type_definition \/ type.is_generic_type then
                let b = type.get_generic_type_definition();

                let creator: TypeCreator;

                if !_type_creators.try_get_value(b, creator ref) then
                    creator = _generic_type_creator;
                fi

                result = creator.create(_symbol_table.value, type);

                _type_cache.add(type, result);

                return result;
            fi
            
            if type.is_array then
                let element_type = get_element_type(type);
                
                return _innate_symbol_lookup.get_array_type(element_type);
            elif type.is_by_ref then
                let element_type = get_element_type(type);

                return _innate_symbol_lookup.get_reference_type(element_type);
            elif type.is_pointer then
                let element_type = get_element_type(type);

                return _innate_symbol_lookup.get_pointer_type(element_type);                
            elif type.is_by_ref_like then
                @IF.not.release()
                Std.error.write_line("warning: cannot materialize by-ref-like type: " + type);
                
                return Types.NONE.instance;
            fi
            
            let creator: TypeCreator;

            if _type_creators.try_get_value(type, creator ref) then
                return creator.create(_symbol_table.value, type);
            fi


            result = new TYPE_WRAPPER(_symbol_table.value, type);

            _type_cache.add(type, result);

            return result;
        si

        get_element_type(type: TYPE) -> Type is
            let element_type = type.get_element_type();

            if !element_type? then
                Std.error.write_line("warning: structured .NET type " + type + " has null element type: treating as Types.NONE");

                return Types.NONE.instance;
            fi

            return get_type(element_type);
        si
    si
si