namespace Semantic.DotNet is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    @IF.not.v3() use TYPE = System.Type2;

    class SYMBOL_TABLE is
        _hits: int;
        _misses: int;

        _type_details_lookup: TYPE_DETAILS_LOOKUP;
        _symbol_factory: SYMBOL_FACTORY;

        _symbol_cache: SYMBOL_CACHE;

        init(
            type_details_lookup: TYPE_DETAILS_LOOKUP,
            symbol_factory: SYMBOL_FACTORY
        ) is
            _type_details_lookup = type_details_lookup;
            _symbol_factory = symbol_factory;

            _symbol_cache = new SYMBOL_CACHE();
        si

        find_root_matches(matches: Collections.MAP[string, Symbols.Symbol]) is
            let distinct_namespaces = new Collections.SET[string]();

            let owner = new EMPTY_SCOPE("");

            for ns in _type_details_lookup.find_all_root_namespaces() do
                if !matches.contains_key(ns) then
                    matches.add(ns, new STUB_SYMBOL(owner, ns,  Symbols.SYMBOL_KIND.NAMESPACE, Symbols.COMPLETION_KIND.MODULE));                    
                fi
            od            
        si

        find_member_matches(namespace_name: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            let owner = new EMPTY_SCOPE(namespace_name);

            let distinct_namespaces = new Collections.SET[string]();

            let type_details = _type_details_lookup.get_all_type_details_in_ghul_namespace(namespace_name);

            for td in type_details do
                let dotnet_type = td.dotnet_type;
                let ghul_name = td.ghul_type_name;
                let ghul_namespace = td.ghul_namespace;

                if ghul_namespace =~ namespace_name then
                    if !matches.contains_key(ghul_name) then
                        let symbol_kind = Symbols.SYMBOL_KIND.UNDEFINED;
                        let completion_kind = Symbols.COMPLETION_KIND.UNDEFINED;

                        if dotnet_type.is_value_type then
                            symbol_kind = Symbols.SYMBOL_KIND.STRUCT;
                            completion_kind = Symbols.COMPLETION_KIND.STRUCT;
                        elif dotnet_type.is_interface then
                            symbol_kind = Symbols.SYMBOL_KIND.INTERFACE;
                            completion_kind = Symbols.COMPLETION_KIND.INTERFACE;
                        elif dotnet_type.is_class then
                            symbol_kind = Symbols.SYMBOL_KIND.CLASS;
                            completion_kind = Symbols.COMPLETION_KIND.CLASS;
                        fi

                        matches.add(ghul_name, new STUB_SYMBOL(owner, ghul_name, symbol_kind, completion_kind));
                    fi
                elif ghul_namespace.starts_with(namespace_name + ".") then
                    let suffix = ghul_namespace.substring(namespace_name.length + 1);

                    let parts = suffix.split(['.']);

                    if parts.count >= 2 then
                        distinct_namespaces.add(parts[0]);
                    fi
                fi
            od

            for ns in distinct_namespaces do
                if !matches.contains_key(ns) then
                    matches.add(ns, new STUB_SYMBOL(owner, ns, Symbols.SYMBOL_KIND.NAMESPACE, Symbols.COMPLETION_KIND.MODULE));                        
                fi                    
            od
        si

        get_symbol(ghul_name: string) -> Symbols.Scoped is
            // if !_assemblies._is_enabled then
            //     return null;
            // fi

            @IF.debug() Std.error.write_line("SSS: get symbol by name: " + ghul_name);
            
            let result: Symbols.Scoped;
            
            if _symbol_cache.try_get_symbol(ghul_name, result ref) then
                _hits = _hits + 1;

                if result? then
                    @IF.debug() Std.error.write_line("SSS: cache hit found: " + ghul_name + " hits:" + _hits + " avoidable misses: " + (_misses - _symbol_cache.symbols_by_ghul_name.count));
                else
                    @IF.debug() Std.error.write_line("SSS: cache hit not found: " + ghul_name + " hits:" + _hits + " avoidable misses: " + (_misses - _symbol_cache.symbols_by_ghul_name.count));
                fi

                return result;
            fi

            _misses = _misses + 1;

            let type_name = new TYPE_NAME(ghul_name);

            let type_details = _type_details_lookup.get_type_details_by_ghul_namespace_and_symbol_name(type_name.namespace_name, type_name.name);

            if type_details? then
                assert type_details.assembly_name? && type_details.assembly_name.length > 0 else " invalid assembly name: " + type_details;
                
                @IF.debug() Std.error.write_line("SSS: create symbol from type details: " + type_details);
                return create_symbol(type_details);
            fi
            
            _symbol_cache.cache_no_result(ghul_name);

            @IF.debug() Std.error.write_line("SSS: no symbol found for ghul name: " + ghul_name);
        si
        
        get_symbol(type: TYPE) -> Symbols.Scoped is
            let result = _symbol_cache.get_symbol(type);

            if result? then
                return result;
            fi

            let type_details = _type_details_lookup.get_type_details_by_dotnet_type(type);

            if !type_details? then
                @IF.not.release()
                Std.error.write_line("oops: no type details for type " + type + " in assembly " + type.assembly.get_name());

                // FIXME: nested type name bodge?
                type_details = new TYPE_DETAILS(type, type.namespace_, type.name, null, type.assembly.get_name().name);
            fi

            assert type_details.assembly_name? && type_details.assembly_name.length > 0 else " invalid assembly name: " + type_details;

            return create_symbol(type_details);
        si

        create_symbol(type_details: TYPE_DETAILS) -> Symbols.Scoped is
            @IF.debug() Std.error.write_line("create symbol for " + type_details);

            let result = _symbol_factory.create_symbol(type_details);

            if !result? then
                @IF.debug() Std.error.write_line("not something we can handle yet: ignoring: " + type);
                
                return null;
            fi

            let dotnet_type = type_details.dotnet_type;
            
            _symbol_cache.add_symbol(dotnet_type, type_details.ghul_namespace + "." + type_details.ghul_type_name, result);

            @IF.debug() Std.error.write_line("add ancestors for " + type + " with ghul name " + ghul_name);

            _symbol_factory.add_ancestors(result, dotnet_type);

            _symbol_factory.add_members(result, dotnet_type);

            return result;
        si
    si
si