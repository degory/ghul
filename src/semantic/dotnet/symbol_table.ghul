namespace Semantic.DotNet is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    @IF.not.v3() use TYPE = System.Type2;

    class SYMBOL_TABLE is
        _hits: int;
        _misses: int;

        _assemblies: ASSEMBLIES;
        _type_name_map: TYPE_NAME_MAP;
        _symbol_factory: SYMBOL_FACTORY;

        _symbol_cache: SYMBOL_CACHE;

        init(
            assemblies: ASSEMBLIES,
            type_name_map: TYPE_NAME_MAP,
            symbol_factory: SYMBOL_FACTORY
        ) is
            _assemblies = assemblies;
            _type_name_map = type_name_map;
            _symbol_factory = symbol_factory;

            _symbol_cache = new SYMBOL_CACHE();
        si

        find_root_matches(matches: Collections.MAP[string, Symbols.Symbol]) is
            Std.error.write_line("search via reflection for all root namespaces...");

            let distinct_namespaces = new Collections.SET[string]();

            let owner = new EMPTY_SCOPE("");

            for a in _assemblies.assemblies_by_ghul_namespace.keys do
                let parts = a.split(['.']);

                Std.error.write_line("assembly namespace: " + a + " root namespace: " + parts[0]);

                distinct_namespaces.add(parts[0]);
            od

            for ns in distinct_namespaces do
                Std.error.write_line("add stub symbol for namespace: " + ns);

                matches.add(ns, new STUB_SYMBOL(owner, ns,  Symbols.SYMBOL_KIND.NAMESPACE, Symbols.COMPLETION_KIND.MODULE));
            od            
        si

        find_member_matches(namespace_name: string, matches: Collections.MAP[string, Symbols.Symbol]) is
            Std.error.write_line("search via reflection for all types in namespace: " + namespace_name);

            let types = _assemblies.find_all(namespace_name);

            let distinct_namespaces = new Collections.SET[string]();

            if types? then
                let owner = new EMPTY_SCOPE(namespace_name);

                for type in types do
                    let type_details = _type_name_map.get_type_details(type);

                    let type_name: string = null;
                    let type_namespace_name: string = null;

                    if type_details? then
                        let tn = new TYPE_NAME(type_details.ghul_name);
                        type_name = tn.name;
                        type_namespace_name = tn.namespace_name;
                    else
                        type_name = type.name;
                    fi
                    
                    if !type_namespace_name? then
                        let namespace_details = _type_name_map.get_namespace_details(type);

                        if namespace_details? then
                            type_namespace_name = namespace_details.ghul_name;
                        fi
                    fi

                    if !type_namespace_name? then
                        type_namespace_name = type.namespace_;
                    fi

                    if type_namespace_name =~ namespace_name then
                        if !matches.contains_key(type_name) then
                            let symbol_kind = Symbols.SYMBOL_KIND.UNDEFINED;
                            let completion_kind = Symbols.COMPLETION_KIND.UNDEFINED;

                            if type.is_value_type then
                                symbol_kind = Symbols.SYMBOL_KIND.STRUCT;
                                completion_kind = Symbols.COMPLETION_KIND.STRUCT;
                            elif type.is_interface then
                                symbol_kind = Symbols.SYMBOL_KIND.INTERFACE;
                                completion_kind = Symbols.COMPLETION_KIND.INTERFACE;
                            elif type.is_class then
                                symbol_kind = Symbols.SYMBOL_KIND.CLASS;
                                completion_kind = Symbols.COMPLETION_KIND.CLASS;
                            fi

                            matches.add(type_name, new STUB_SYMBOL(owner, type_name, symbol_kind, completion_kind));
                        fi                        
                    elif type_namespace_name.starts_with(namespace_name + ".") then
                        let suffix = type_namespace_name.substring(namespace_name.length + 1);

                        let parts = suffix.split(['.']);

                        if parts.count >= 2 then
                            distinct_namespaces.add(parts[0]);
                        fi
                    fi
                od

                for ns in distinct_namespaces do
                    if !matches.contains_key(ns) then
                        matches.add(ns, new STUB_SYMBOL(owner, ns, Symbols.SYMBOL_KIND.NAMESPACE, Symbols.COMPLETION_KIND.MODULE));                        
                    fi                    
                od                
            else
                Std.error.write_line("no types to search");
            fi
        si

        get_symbol(ghul_name: string) -> Symbols.Scoped is
            if !_assemblies._is_enabled then
                return null;
            fi

            @IF.debug() Std.error.write_line("SSS: get symbol by name: " + ghul_name);
            
            let result: Symbols.Scoped;
            
            if _symbol_cache.try_get_symbol(ghul_name, result ref) then
                _hits = _hits + 1;

                if result? then
                    @IF.debug() Std.error.write_line("SSS: cache hit found: " + ghul_name + " hits:" + _hits + " avoidable misses: " + (_misses - _symbol_cache.symbols_by_ghul_name.count));
                else
                    @IF.debug() Std.error.write_line("SSS: cache hit not found: " + ghul_name + " hits:" + _hits + " avoidable misses: " + (_misses - _symbol_cache.symbols_by_ghul_name.count));
                fi

                return result;
            fi

            _misses = _misses + 1;

            let type_details = _type_name_map.get_type_details(ghul_name);

            if type_details? then
                @IF.debug() Std.error.write_line("SSS: create symbol from type details: " + type_details);
                let result = create_symbol(type_details.dotnet_type, ghul_name, type_details.il_name);

                return result;
            fi

            let type: TYPE;
            let assembly_name: string;
            let dotnet_namespace_name: string;
            let namespace_name: string;

            @IF.debug() Std.error.write_line("SSS: attempt to create symbol from ghul name: " + ghul_name);

            let type_name = new TYPE_NAME(ghul_name);
            let namespace_details = _type_name_map.get_namespace_details(type_name.namespace_name);

            if namespace_details? then
                assembly_name = namespace_details.assembly_name;
                namespace_name = namespace_details.ghul_name;
                dotnet_namespace_name = namespace_details.dotnet_name;

                @IF.debug() Std.error.write_line("SSS: namespace mapped: assembly: " + assembly_name + " ghul namespace name: " + namespace_name + " " + dotnet_namespace_name);
            else
                namespace_name = type_name.namespace_name;
                dotnet_namespace_name = namespace_name;

                @IF.debug() Std.error.write_line("SSS: no mapping: namespace name: " + namespace_name);
            fi

            if assembly_name? then
                type = _assemblies.find(assembly_name, namespace_name, dotnet_namespace_name, type_name.name);
            else
                type = _assemblies.find(namespace_name, dotnet_namespace_name, type_name.name);                    
            fi

            if type? then
                @IF.debug() Std.error.write_line("SSS: create symbol from type: " + type);

                return create_symbol(type, ghul_name, null);
            fi

            _symbol_cache.cache_no_result(ghul_name);

            @IF.debug() Std.error.write_line("SSS: no symbol found for ghul name: " + ghul_name);
        si
        
        get_symbol(type: TYPE) -> Symbols.Scoped is
            if !_assemblies._is_enabled then
                return null;
            fi
            
            // Std.error.write_line("get symbol by .NET type " + type);

            let result = _symbol_cache.get_symbol(type);

            // Std.error.write_line("cache search result: " + result);

            if result? then
                // Std.error.write_line("return symbol from cache for name " + type);
                return result;
            fi

            let type_details = _type_name_map.get_type_details(type);

            let ghul_name: string;

            if type_details? then
                ghul_name = type_details.ghul_name;
            fi
            
            if !ghul_name? then
                let namespace_details = _type_name_map.get_namespace_details(type);

                if namespace_details? && namespace_details.ghul_name? then
                    ghul_name = namespace_details.ghul_name + "." + type.name;

                    @IF.debug() Std.error.write_line("MMM: ghul name from namespace details: " + type + " -> " + ghul_name);
                fi
                
                if !ghul_name? then
                    ghul_name = type.full_name;

                    @IF.debug() Std.error.write_line("MMM: ghul name from .NET type: " + type + " -> " + ghul_name);
                fi
            else
                @IF.debug() Std.error.write_line("MMM: ghul name from type details: " + type + " -> " + ghul_name);
            fi

            return create_symbol(type, ghul_name, null);
        si

        create_symbol(type: TYPE, ghul_name: string, il_name: string) -> Symbols.Scoped is
            @IF.debug() Std.error.write_line("create symbol for " + type + " with ghul name " + ghul_name);

            let result = _symbol_factory.create_symbol(type, ghul_name, il_name);

            if !result? then
                @IF.debug() Std.error.write_line("not something we can handle yet: ignoring: " + type);
                
                return null;
            fi
            
            _symbol_cache.add_symbol(type, ghul_name, result);

            @IF.debug() Std.error.write_line("add ancestors for " + type + " with ghul name " + ghul_name);
            _symbol_factory.add_ancestors(result, type);

            _symbol_factory.add_members(result, type);

            return result;
        si
    si
si