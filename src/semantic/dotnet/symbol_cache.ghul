namespace Semantic.DotNet is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use STD = System.Console;

    @IF.not.v3() use TYPE = System.Type2;
    
    use Collections.MAP;

    // FIXME: rename this - it's not a cache - it's essential that symbols are interned for
    // correct functioning of the type system:
    class SYMBOL_CACHE is
        symbols_by_dotnet_type: MAP[TYPE,Symbol.Scoped];
        symbols_by_ghul_name: MAP[string,Symbol.Scoped];

        init() is
            symbols_by_dotnet_type = new MAP[TYPE,Symbol.Scoped]();
            symbols_by_ghul_name = new MAP[string,Symbol.Scoped]();
        si

        get_symbol(dotnet_type: TYPE) -> Symbol.Scoped is
            let result: Symbol.Scoped;

            symbols_by_dotnet_type.try_get_value(dotnet_type, result ref);

            return result;
        si

        get_symbol(ghul_name: string) -> Symbol.Scoped is
            let result: Symbol.Scoped;

            symbols_by_ghul_name.try_get_value(ghul_name, result ref);

            return result;
        si

        add_symbol(type: TYPE, ghul_name: string, symbol: Symbol.Scoped) is
            assert type? else "type is null";
            assert ghul_name? else "ghull name is null";
            assert symbol? else "symbol is null";
                                    
            assert !symbols_by_ghul_name.contains_key(ghul_name);
            // assert !symbols_by_dotnet_type.contains_key(type);

            if symbols_by_dotnet_type.contains_key(type) then
                STD.error.write_line("add symbol: symbol already exists for type: " + type + " " + symbols_by_dotnet_type[type]);
            fi            

            symbols_by_dotnet_type.add(type, symbol);
            symbols_by_ghul_name.add(ghul_name, symbol);
        si        
    si
si