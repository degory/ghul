namespace Semantic.DotNet is
    use Collections;
    use System.Type2;
    use System.Reflection.MethodInfo;

    use Logging;

    class EXTENSION_METHOD_TYPE_MAP is
        _extension_methods_for_types: MutableMap[Type2, MutableList[MethodInfo]];
        _extension_attribute_type: Type2;

        init() is
            _extension_methods_for_types = MAP[Type2, MutableList[MethodInfo]]();
        si

        set_extension_attribute_type(type: Type2) is
            assert type? else "supplied extension attribute type is null";

            _extension_attribute_type = type;

            debug_always("extension attribute type is {_extension_attribute_type}");
        si

        get_extensions_for_type(type: Type2) -> Iterable[MethodInfo] =>
            let result: MutableList[MethodInfo] in
            if _extension_methods_for_types.try_get_value(type, result ref) then
                result
            else
                null
            fi;

        add_extensions_from_type(type: Type2) is
            assert _extension_attribute_type? else "extension attribute type has not been set";

            for method in type.get_methods() do
                if is_extension_method(method) then
                    let extended_type = method.get_parameters()[0].parameter_type;

                    debug_always("AAAA extension method {type} {method} extends {extended_type} is gp {extended_type.is_generic_parameter} is gtp {extended_type.is_generic_type_parameter}");

                    if extended_type.is_generic_method_parameter then
                        let constraints = extended_type.get_generic_parameter_constraints();

                        if constraints? /\ constraints.count > 0 then
                            for constraint in constraints do
                                add_extension_to_type(method, constraint);
                            od
                        else
                            debug_always("AAAA oops generic parameter but no constraints: extension {type} {method} extends {extended_type} probably not handled correctly");
                            add_extension_to_type(method, extended_type);
                        fi
                    else
                        add_extension_to_type(method, extended_type);
                    fi
                fi
            od
        si

        add_extension_to_type(method: MethodInfo, extended_type: Type2) is
            debug_always("AAAA store method {method} against {extended_type}");
  
            let extension_methods_for_extended_type: MutableList[MethodInfo];

            if !_extension_methods_for_types.try_get_value(extended_type, extension_methods_for_extended_type ref) then
                extension_methods_for_extended_type = LIST[MethodInfo]();
                _extension_methods_for_types[extended_type] = extension_methods_for_extended_type;
            fi

            extension_methods_for_extended_type.add(method);
        si

        is_extension_method(method: MethodInfo) -> bool =>
            method.get_custom_attributes_data() |
                .any(attr => attr.attribute_type == _extension_attribute_type);
    si
si