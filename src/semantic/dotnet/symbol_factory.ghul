namespace Semantic.DotNet is
    use TYPE = System.Type2;

    use System.Reflection.Assembly;
    use System.Reflection.ConstructorInfo;
    use System.Reflection.MethodInfo;
    use System.Reflection.FieldInfo;
    use System.Reflection.PropertyInfo;
    use System.Reflection.MemberInfo;
    use System.Reflection.ParameterInfo;

    use Collections.List;
    use Collections.MutableList;
    use Collections.LIST;
    use Collections.MAP;

    use Types.Type;
    
    class SYMBOL_FACTORY is
        _namespaces: NAMESPACES;
        _innate_types: INNATE_TYPES;
        _type_name_map: TYPE_NAME_MAP;
        _type_mapper: TYPE_MAPPER;
        _assembly_names: MAP[Assembly,string];

        _symbol_table: SYMBOL_TABLE;

        _referenced_assemblies: REFERENCED_ASSEMBLIES;

        _non_generic_get_enumerator: MethodInfo;

        _tuple_types: List[TYPE];

        init(
            namespaces: NAMESPACES,
            innate_types: INNATE_TYPES,
            type_name_map: TYPE_NAME_MAP,
            type_mapper: TYPE_MAPPER,
            referenced_assemblies: REFERENCED_ASSEMBLIES
        ) is
            _namespaces = namespaces;
            _innate_types = innate_types;
            _type_name_map = type_name_map;
            _type_mapper = type_mapper;
            _assembly_names = new MAP[Assembly,string]();
            _referenced_assemblies = referenced_assemblies;

            let mnt = typeof Collections.MoveNext;
            _non_generic_get_enumerator = mnt.get_method("GetEnumerator");

            _tuple_types = [
                typeof TUPLE_1,
                typeof TUPLE_2,
                typeof TUPLE_3,
                typeof TUPLE_4,
                typeof TUPLE_5,
                typeof TUPLE_6,
                typeof TUPLE_7,
                typeof TUPLE_8
            ];
        si

        set_symbol_table(symbol_table: SYMBOL_TABLE) is
            _symbol_table = symbol_table;
        si

        create_symbol(type_details: TYPE_DETAILS) -> Symbols.Scoped is
            let dotnet_type = type_details.dotnet_type;

            if dotnet_type.is_class \/ dotnet_type.is_value_type \/ dotnet_type.is_interface \/ dotnet_type.is_enum then
                return create_class(type_details);
            fi
        si

        create_class(type_details: TYPE_DETAILS) -> Symbols.Scoped is
            let dotnet_type = type_details.dotnet_type;
            let ghul_type_name = type_details.ghul_type_name;
            let assembly_name = type_details.assembly_name;
            let il_name = type_details.il_name;

            let owner = new EMPTY_SCOPE(type_details.ghul_namespace);
            //  _namespaces.find_or_add_namespace(namespace_name.name, "." + namespace_name.qualified_name);

            let arguments = new LIST[string]();

            let result: Symbols.Classy;

            if dotnet_type.is_class then
                result = new Symbols.CLASS(Source.LOCATION.reflected, owner, ghul_type_name, arguments, true, owner);
                result._are_overrides_resolved = true;
            elif dotnet_type.is_value_type then
                result = new Symbols.STRUCT(Source.LOCATION.reflected, owner, ghul_type_name, arguments, true, owner);
                result.il_is_primitive_type = dotnet_type.is_primitive \/ dotnet_type == typeof void;
                
                result._are_overrides_resolved = true;
            elif dotnet_type.is_interface then
                result = new Symbols.TRAIT(Source.LOCATION.reflected, owner, ghul_type_name, arguments, true, owner);
            fi

            _referenced_assemblies.add(type_details.assembly_name, type_details.version_number);

            result.il_assembly_name = assembly_name;

            if !il_name? then
                il_name = get_il_name(dotnet_type);
            fi

            result.il_name_override = il_name;
            
            if dotnet_type.is_generic_type /\ dotnet_type.contains_generic_parameters then
                let argument_types = dotnet_type.get_generic_arguments();

                for a in argument_types do
                    if a.is_generic_type_parameter then
                        arguments.add(a.name);
                    fi
                od
            fi
                        
            return result;
        si

        create_enum(type: TYPE, ghul_name: TYPE_NAME) -> Symbols.ENUM_ is
            let namespace_name = new TYPE_NAME(ghul_name.namespace_name);

            // @IF.debug() Std.error.write_line("get class: " + namespace_name + " " + ghul_name.name + " (" + ghul_name.qualified_name + ")");

            let owner = _namespaces.find_or_add_namespace(namespace_name.name, "." + namespace_name.qualified_name);

            let result = new Symbols.ENUM_(Source.LOCATION.reflected, owner, ghul_name.name);

            // FIXME:
            let assembly_name = get_assembly_name(type);

            result.il_name_override = "class ['" + assembly_name + "']" + type.full_name;
        si 

        add_ancestors(symbol: Symbols.Scoped, type: TYPE) is
            if !isa Symbols.Classy(symbol) then
                @IF.debug() Std.error.write_line("not a classy: " + type);
                return;
            fi

            let result = cast Symbols.Classy(symbol);

            if type.base_type? then
                result.add_ancestor(_type_mapper.get_type(type.base_type));
            elif type.is_interface then
                // FIXME: need typeof really or another way to get types by name:
                result.add_ancestor(_type_mapper.get_type(typeof object));
            fi

            let exclude_disposable = false;

            if type.is_interface /\ type.is_generic_type /\ type.get_generic_type_definition() == typeof Collections.Iterator then
                exclude_disposable = true;
            fi
            
            for i in type.get_interfaces() do
                @IF.debug() Std.error.write_line("IIIIII: " + type + ": implemented interface is: " + i);

                if exclude_disposable /\ i == typeof System.IDisposable then
                    continue;
                fi

                result.add_ancestor(_type_mapper.get_type(i));
            od

            IoC.CONTAINER.instance.symbol_table.enter_scope(result);
            result.pull_down_super_symbols();
            IoC.CONTAINER.instance.symbol_table.leave_scope(result);
            
            for s in result.symbols do
                @IF.debug() Std.error.write_line("member: " + s);
            od                
        si
        
        add_members(result: Symbols.Scoped, type: TYPE) is
            let properties = new MAP[System.Reflection.MethodInfo,PROPERTY_DETAILS]();

            let arguments = result.argument_names;
            let argument_types = result.arguments;

            if type.is_generic_type_definition then
                for argument in type.generic_type_arguments do
                    argument_types.add(_type_mapper.get_type(argument));
                    arguments.add(argument.name);
                od
            fi

            // @IF.debug() Std.error.write_line("result is: " + result.description);

            for p in type.get_properties() do
                add_property(result, type, properties, p);
            od

            for t in type.get_members(cast System.Reflection.BindingFlags(64 + 4 + 32 + 16 + 8)) do
                add_member(result, type, properties, t);                    
            od
        si

        add_members(result: Symbols.ENUM_, type: TYPE) is
            let assembly_name = get_assembly_name(type);

            result.il_name_override = "class ['" + assembly_name + "']" + type.full_name;

            // @IF.debug() Std.error.write_line("result is: " + result.description);

            for t in type.get_members() do
                add_member(result, type, null, t);
            od
        si

        add_member(owner: Symbols.Scoped, type: TYPE, properties: MAP[System.Reflection.MethodInfo,PROPERTY_DETAILS], member: MemberInfo) -> Symbols.Symbol is
            /*
            Constructor	1	
            Custom	64	
            Event	2	
            Field	4	
            Method	8	
            NestedType	128	
            Property	16	
            TypeInfo	32	
            */

            let member_type = cast int(member.member_type);

            if member_type == 1 then
                add_constructor(owner, cast ConstructorInfo(member));                
            elif member_type == 4 then
                add_field(owner, type, cast FieldInfo(member));
            elif member_type == 8 then
                add_method(owner, type, properties, cast MethodInfo(member));
            else
                @IF.debug() Std.error.write_line("ignoring unknown kind of member: " + member + " (" + member_type + " " + (member_type & 8) + ")");
            fi            
        si

        add_constructor(owner: Symbols.Scoped, method: ConstructorInfo) is
            let result: Symbols.Function;
            let location = Source.LOCATION.reflected;

            if method.is_private then
                return;
            fi

            if method.is_static then
                result = new Symbols.STATIC_METHOD(location, owner, "init", owner);
            elif owner.is_value_type then                
                result = new Symbols.STRUCT_METHOD(location, owner, "init", owner);
            elif method.is_abstract then
                result = new Symbols.ABSTRACT_METHOD(location, owner, "init", owner);
            else
                result = new Symbols.INSTANCE_METHOD(location, owner, "init", owner);
            fi

            result.il_name_override = method.name;

            let argument_names = new LIST[string]();
            let argument_types = new LIST[Type]();

            for a in method.get_parameters() do
                argument_names.add(a.name);
                argument_types.add(_type_mapper.get_type(a.parameter_type));
            od

            result.argument_names = argument_names;
            result.arguments = argument_types;

            result.return_type = _innate_types.get_ghul_void_type();
            
            owner.add_member(result);

            // @IF.debug() Std.error.write_line("added constructor member: " + method);
        si

        add_field(owner: Symbols.Scoped, type: TYPE, field: FieldInfo) is
            if field.is_private then
                return;
            fi
            
            let result: Symbols.Field;
            let location = Source.LOCATION.reflected;

            let field_name = field.name;

            let name: string;

            if field_name.length == 5 /\ field.name.starts_with("Item") /\ type.is_generic_type then
                let unspecialized_type = type.get_generic_type_definition();

                let is_tuple = false;

                for t in _tuple_types do
                    if unspecialized_type == t then
                        is_tuple = true;
                        break;
                    fi
                od
                
                if is_tuple then
                    name = "_" + (cast int(field_name.get_chars(field_name.length-1)) - 49); 
                fi
            fi

            if !name? then
                name = _type_name_map.get_member_name(owner.qualified_name, field.name, false);
            fi

            if field.is_static then
                result = new Symbols.STATIC_FIELD(location, owner, name);
            else 
                result = new Symbols.INSTANCE_FIELD(location, owner, name);
            fi

            result.il_name_override = field.name;

            result.set_type(_type_mapper.get_type(field.field_type));

            owner.add_member(result);

            // @IF.debug() Std.error.write_line("added field member: " + field);
        si

        add_property(owner: Symbols.Scoped, type: TYPE, properties: MAP[System.Reflection.MethodInfo,PROPERTY_DETAILS], property: PropertyInfo) is
            let index_parameters = property.get_index_parameters();

            if index_parameters? /\ index_parameters.count > 0 then
                add_indexer(owner, property, index_parameters);
                return;
            fi

            if property.name =~ "Current" then
                if property.declaring_type == typeof Collections.MoveNext then
                    @IF.debug() Std.error.write_line("CCCCCC: ignore property in " + property.declaring_type + " vs " + typeof Collections.MoveNext);
                    return;
                else
                    @IF.debug() Std.error.write_line("CCCCCC: property OK in " + property.declaring_type);
                fi
            fi            

            let result: Symbols.Property;
            let name = _type_name_map.get_member_name(owner.qualified_name, property.name, false);

            let getter = property.get_method;
            let setter = property.set_method;

            @IF.debug() 
            if setter? then
                Std.error.write_line("ASSIGNABLE: " + type + ": property " + property + " getter: " + getter + " setter: " + setter);
            else
                Std.error.write_line("read only: " + type + ": property " + property + " getter: " + getter + " setter: " + setter);
            fi

            if setter? /\ !getter? then
                @IF.debug() Std.error.write_line("ignore write only property " + property + " getter: " + getter + " setter: " + setter);                
                return;
            fi
            
            let is_static = false;

            if getter? /\ getter.is_static then
                is_static = true;
            elif setter? /\ setter.is_static then
                is_static = true;
            fi

            if is_static then
                result = new Symbols.STATIC_PROPERTY(Source.LOCATION.reflected, owner, name, setter?);
            else
                result = new Symbols.INSTANCE_PROPERTY(Source.LOCATION.reflected, owner, name, setter?);
            fi

            result.set_type(_type_mapper.get_type(property.property_type));
            result.il_name_override = property.name;

            owner.add_member(result);

            let property_details = new PROPERTY_DETAILS(result, property.get_get_method(), property.get_set_method());

            if getter then
                properties[getter] = property_details;
            fi

            if setter then
                properties[setter] = property_details;
            fi
        si

        add_indexer(owner: Symbols.Scoped, indexer: PropertyInfo, parameters: List[ParameterInfo]) is
            // @IF.debug() Std.error.write_line("III: ignore indexer: " + owner + " . " + indexer);
        si

        add_method(owner: Symbols.Scoped, type: TYPE, properties: MAP[System.Reflection.MethodInfo,PROPERTY_DETAILS], method: MethodInfo) is
            if method.is_private then
                @IF.debug() Std.error.write_line("" + type + ": ignore private method: " + method + " owner: " + method.declaring_type);              
                return;
            fi

            // FIXME: what is up with this? Is this actually affecting all methods inherited from System.Object?
            if method.name =~ "GetType" /\ method.declaring_type != typeof object /\ method.get_parameters().count == 0 then
                return;
            fi
            
            let result: Symbols.Function;
            let location = Source.LOCATION.reflected;

            let name: string;

            let property_details: PROPERTY_DETAILS;

            if properties.try_get_value(method, property_details ref) then
                name = "$" + _type_name_map.get_member_name(owner.qualified_name, method.name, method.is_private);
            elif method.name =~ "get_Item" \/ method.name =~ "set_Item" then
                name = method.name;
            elif method.name =~ "get_Current" /\ method.declaring_type == typeof Collections.MoveNext then
                return;
            elif method.name =~ "GetEnumerator" then
                if method.declaring_type == typeof Collections.NonGenericIterable then
                    return;
                fi

                name = "$get_iterator";

                let iterator_property = new Symbols.INSTANCE_PROPERTY(Source.LOCATION.reflected, owner, "iterator", false);
                iterator_property.set_type(_type_mapper.get_type(method.return_type));

                owner.add_member(iterator_property);

                @IF.debug() Std.error.write_line("IIIIII: " + type + ": read iterator property " + method + " owner: " + method.declaring_type);

                property_details = new PROPERTY_DETAILS(iterator_property, method, null);

                // properties.add(iterator_property);
            else
                name = _type_name_map.get_member_name(owner.qualified_name, method.name, method.is_private);
            fi

            let declaring_symbol = owner;

            if method.declaring_type != type then
                declaring_symbol = _symbol_table.get_symbol(method.declaring_type);
            fi

            if method.is_static then
                result = new Symbols.STATIC_METHOD(location, declaring_symbol, name, owner);
            elif method.declaring_type.is_value_type then
                result = new Symbols.STRUCT_METHOD(location, declaring_symbol, name, owner);
            elif method.is_abstract then
                result = new Symbols.ABSTRACT_METHOD(location, declaring_symbol, name, owner);
            elif method.is_virtual then
                result = new Symbols.INSTANCE_METHOD(location, declaring_symbol, name, owner);
            else
                result = new Symbols.INSTANCE_METHOD(location, declaring_symbol, name, owner);
            fi

            if method.is_generic_method then
                result.is_generic = true;

                let generic_arguments = new LIST[Type]();

                for p in method.get_generic_arguments() do
                    generic_arguments.add(_type_mapper.get_type(p));
                od
                
                result.generic_arguments = generic_arguments;
            fi
            
            result.il_name_override = method.name;
            
            let argument_names = new LIST[string]();
            let argument_types = new LIST[Type]();

            for a in method.get_parameters() do
                argument_names.add(a.name);
                argument_types.add(_type_mapper.get_type(a.parameter_type));
            od

            result.argument_names = argument_names;
            result.arguments = argument_types;

            result.return_type = _type_mapper.get_type(method.return_type);

            if property_details? then
                let accessor_method_name = method.name;

                if method == property_details.dotnet_get_method then
                    property_details.ghul_property.read_function = result;
                    property_details.ghul_property.read_function_il_name_override = method.name;
                elif method == property_details.dotnet_set_method then
                    property_details.ghul_property.assign_function = result;
                    property_details.ghul_property.assign_function_il_name_override = method.name;
                fi
            fi
            
            owner.add_member(result);
        si

        get_assembly_name(type: TYPE) -> string is
            let assembly = type.assembly;

            let result: string;

            if _assembly_names.try_get_value(assembly, result ref) then
                return result;
            fi

            result = assembly.get_name().name;

            _assembly_names.add(assembly, result);

            return result;
        si
        
        get_il_name(type: TYPE) -> string is
            let buffer = new System.Text.StringBuilder();

            let seen_any = false;
            for name in type.full_name.split(['.']) do
                if seen_any then
                    buffer.append('.');
                fi

                if name.contains('+') then

                let inner_seen_any = false;
                for inner_name in name.split(['+']) do
                    if inner_seen_any then
                        buffer.append('/');
                    fi
                    
                    buffer
                        .append('\'')
                        .append(inner_name)
                        .append('\'');

                    inner_seen_any = true;
                od

                else
                    buffer
                        .append('\'')
                        .append(name)
                        .append('\'');
                fi

                seen_any = true;
            od
            
            return buffer.to_string();
        si

    si
si