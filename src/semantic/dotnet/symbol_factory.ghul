namespace Semantic.DotNet is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    @IF.not.v3() use TYPE = System.Type2;

    use System.Reflection;

    use Collections.List;
    use Collections.MutableList;
    use Collections.LIST;
    use Collections.MAP;

    use Types.Type;

    class SYMBOL_FACTORY is
        _namespaces: NAMESPACES;
        _innate_types: INNATE_TYPES;
        _type_name_map: TYPE_NAME_MAP;
        _type_mapper: TYPE_MAPPER;
        _assembly_names: MAP[Assembly,string];

        _non_generic_get_enumerator: MethodInfo;

        _tuple_types: List[TYPE];

        init(
            namespaces: NAMESPACES,
            innate_types: INNATE_TYPES,
            type_name_map: TYPE_NAME_MAP,
            type_mapper: TYPE_MAPPER
        ) is
            _namespaces = namespaces;
            _innate_types = innate_types;
            _type_name_map = type_name_map;
            _type_mapper = type_mapper;
            _assembly_names = new MAP[Assembly,string]();

            let mnt = typeof Collections.MoveNext;
            _non_generic_get_enumerator = mnt.get_method("GetEnumerator");

            _tuple_types = [
                typeof TUPLE_1,
                typeof TUPLE_2,
                typeof TUPLE_3,
                typeof TUPLE_4,
                typeof TUPLE_5,
                typeof TUPLE_6,
                typeof TUPLE_7,
                typeof TUPLE_8
            ];
        si

        create_symbol(type: TYPE, ghul_name: string, il_name: string) -> Symbols.Scoped is        
            if type.is_class || type.is_value_type || type.is_interface || type.is_enum then
                return create_class(type, ghul_name, il_name);
            fi
        si

        create_class(type: TYPE, ghul_name: string, il_name: string) -> Symbols.Scoped is
            let ghul_type_name = new TYPE_NAME(ghul_name);
            // let namespace_name = new TYPE_NAME(ghul_type_name.namespace_name);

            let owner = new EMPTY_SCOPE(ghul_type_name.namespace_name);
            //  _namespaces.find_or_add_namespace(namespace_name.name, "." + namespace_name.qualified_name);

            let arguments = new LIST[string]();

            let result: Symbols.Classy;

            if type.is_class then
                result = new Symbols.CLASS(Source.LOCATION.reflected, owner, ghul_type_name.name, arguments, true, owner);
                result._are_overrides_resolved = true;
            elif type.is_value_type then
                result = new Symbols.STRUCT(Source.LOCATION.reflected, owner, ghul_type_name.name, arguments, true, owner);
                result._are_overrides_resolved = true;
            elif type.is_interface then
                result = new Symbols.TRAIT(Source.LOCATION.reflected, owner, ghul_type_name.name, arguments, true, owner);
                @IF.debug() Std.error.write_line("create trait: " + ghul_type_name + " from " + type);
            fi

            if il_name? then
                result.il_name_override = il_name;
            else
                result.il_name_override = _type_name_map.get_il_name(type);
            fi

            if type.is_generic_type && type.contains_generic_parameters then
                let argument_types = type.get_generic_arguments();

                for a in argument_types do
                    if a.is_generic_type_parameter then
                        arguments.add(a.name);
                    fi
                od
            fi
                        
            return result;
        si

        create_enum(type: TYPE, ghul_name: TYPE_NAME) -> Symbols.ENUM_ is
            let namespace_name = new TYPE_NAME(ghul_name.namespace_name);

            // @IF.debug() Std.error.write_line("get class: " + namespace_name + " " + ghul_name.name + " (" + ghul_name.qualified_name + ")");

            let owner = _namespaces.find_or_add_namespace(namespace_name.name, "." + namespace_name.qualified_name);

            let result = new Symbols.ENUM_(Source.LOCATION.reflected, owner, ghul_name.name);

            // FIXME:
            let assembly_name = get_assembly_name(type);

            result.il_name_override = "class ['" + assembly_name + "']" + type.full_name;
        si 

        add_ancestors(symbol: Symbols.Scoped, type: TYPE) is
            if !isa Symbols.Classy(symbol) then
                @IF.debug() Std.error.write_line("not a classy: " + type);
                return;
            fi

            let result = cast Symbols.Classy(symbol);

            if type.base_type? then
                result.add_ancestor(_type_mapper.get_type(type.base_type));
            elif type.is_interface then
                // FIXME: need typeof really or another way to get types by name:
                result.add_ancestor(_type_mapper.get_type(typeof object));
            fi

            let exclude_disposable = false;

            if type.is_interface && type.is_generic_type && type.get_generic_type_definition() == typeof Collections.Iterator then
                exclude_disposable = true;
            fi
            
            for i in type.get_interfaces() do
                @IF.debug() Std.error.write_line("IIIIII: " + type + ": implemented interface is: " + i);

                if exclude_disposable && i == typeof System.IDisposable then
                    continue;
                fi

                result.add_ancestor(_type_mapper.get_type(i));
            od

            IoC.CONTAINER.instance.symbol_table.enter_scope(result);
            result.pull_down_super_symbols();
            IoC.CONTAINER.instance.symbol_table.leave_scope(result);
            
            for s in result.symbols do
                @IF.debug() Std.error.write_line("member: " + s);
            od                
        si
        
        add_members(result: Symbols.Scoped, type: TYPE) is
            let properties = new LIST[Symbols.Property]();

            let arguments = result.argument_names;
            let argument_types = result.arguments;

            if type.is_generic_type_definition then
                for argument in type.generic_type_arguments do
                    argument_types.add(_type_mapper.get_type(argument));
                    arguments.add(argument.name);
                od
            fi

            // @IF.debug() Std.error.write_line("result is: " + result.description);

            for t in type.get_members(cast System.Reflection.BindingFlags(64 + 4 + 32 + 16 + 8)) do
                add_member(result, type, properties, t);
            od

            for p in properties do
                fixup_property(result, type, p);
            od
        si

        add_members(result: Symbols.ENUM_, type: TYPE) is
            let assembly_name = get_assembly_name(type);

            result.il_name_override = "class ['" + assembly_name + "']" + type.full_name;

            // @IF.debug() Std.error.write_line("result is: " + result.description);

            for t in type.get_members() do
                add_member(result, type, null, t);
            od
        si

        add_member(owner: Symbols.Scoped, type: TYPE, properties: MutableList[Symbols.Property], member: MemberInfo) -> Symbols.Symbol is
            /*
            Constructor	1	
            Custom	64	
            Event	2	
            Field	4	
            Method	8	
            NestedType	128	
            Property	16	
            TypeInfo	32	
            */

            let member_type = cast int(member.member_type);

            if member_type == 1 then
                add_constructor(owner, cast ConstructorInfo(member));                
            elif member_type == 4 then
                add_field(owner, type, cast FieldInfo(member));
            elif member_type == 8 then
                add_method(owner, type, properties, cast MethodInfo(member));
            elif member_type == 16 then
                add_property(owner, type, properties, cast PropertyInfo(member));
            else
                @IF.debug() Std.error.write_line("ignoring unknown kind of member: " + member + " (" + member_type + " " + (member_type & 8) + ")");
            fi            
        si

        fixup_property(owner: Symbols.Scoped, type: TYPE, property: Symbols.Property) is
            let read_accessor = owner.find_direct("__read_" + property.name);

            if !read_accessor? then
                Std.error.write_line("reflection: no read accessor method found for property " + property.qualified_name);
                return;
            fi

            // assert read_accessor? else "no read accessor method found for property " + property.qualified_name;

            assert
                isa Symbols.FUNCTION_GROUP(read_accessor)
            else
                "read accessor method is not a function group " + read_accessor + " (" + read_accessor.get_type() + ")";

            let read_group = cast Symbols.FUNCTION_GROUP(read_accessor);

            property.read_function = read_group.collapse_group_or_null();

            // assert property.read_function? else "more than one function in read group " + read_group;

            if property.is_assignable then
                let assign_accessor = owner.find_direct("__assign_" + property.name);

                // assert assign_accessor? else "no assign accessor method found for writeable property " + property.qualified_name;

                if !assign_accessor? then
                    return;
                fi
                
                assert 
                    isa Symbols.FUNCTION_GROUP(assign_accessor)
                else 
                    "assign accessor method is not a function group " + assign_accessor + " (" + assign_accessor.get_type() + ")";

                let assign_group = cast Symbols.FUNCTION_GROUP(assign_accessor);

                property.assign_function = assign_group.collapse_group_or_null();

                assert property.assign_function? else "more than one function in assign group " + assign_group;
            fi

        si

        add_constructor(owner: Symbols.Scoped, method: ConstructorInfo) is
            let result: Symbols.Function;
            let location = Source.LOCATION.reflected;

            if method.is_private then
                return;
            fi

            if method.is_static then
                result = new Symbols.STATIC_METHOD(location, owner, "init", owner);
            elif owner.is_value_type then                
                result = new Symbols.STRUCT_METHOD(location, owner, "init", owner);
            elif method.is_abstract then
                result = new Symbols.ABSTRACT_METHOD(location, owner, "init", owner);
            else
                result = new Symbols.INSTANCE_METHOD(location, owner, "init", owner);
            fi

            result.il_name_override = method.name;

            let argument_names = new LIST[string]();
            let argument_types = new LIST[Type]();

            for a in method.get_parameters() do
                argument_names.add(a.name);
                argument_types.add(_type_mapper.get_type(a.parameter_type));
            od

            result.argument_names = argument_names;
            result.arguments = argument_types;

            result.return_type = _innate_types.get_ghul_void_type();
            
            owner.add_member(result);

            // @IF.debug() Std.error.write_line("added constructor member: " + method);
        si

        add_field(owner: Symbols.Scoped, type: TYPE, field: FieldInfo) is
            // @IF.debug() Std.error.write_line("add field: " + owner + " . " + field);

            if field.is_private then
                return;
            fi
            
            let result: Symbols.Field;
            let location = Source.LOCATION.reflected;

            let field_name = field.name;

            let name: string;

            if field_name.length == 5 && field.name.starts_with("Item") && type.is_generic_type then
                let unspecialized_type = type.get_generic_type_definition();

                let is_tuple = false;

                for t in _tuple_types do
                    if unspecialized_type == t then
                        is_tuple = true;
                        break;
                    fi
                od
                
                if is_tuple then
                    name = "_" + (cast int(field_name.get_at(field_name.length-1)) - 49); 
                fi
            fi

            if !name? then
                name = _type_name_map.get_member_name(owner.qualified_name, field.name, false);
            fi

            if field.is_static then
                result = new Symbols.STATIC_FIELD(location, owner, name);
            else
                result = new Symbols.INSTANCE_FIELD(location, owner, name);
            fi

            result.il_name_override = field.name;

            result.set_type(_type_mapper.get_type(field.field_type));

            owner.add_member(result);

            // @IF.debug() Std.error.write_line("added field member: " + field);
        si

        add_property(owner: Symbols.Scoped, type: TYPE, properties: MutableList[Symbols.Property], property: PropertyInfo) is
            let index_parameters = property.get_index_parameters();

            if index_parameters? && index_parameters.count > 0 then
                add_indexer(owner, property, index_parameters);
                return;
            fi

            if property.name =~ "Current" then
                if property.declaring_type == typeof Collections.MoveNext then
                    @IF.debug() Std.error.write_line("CCCCCC: ignore property in " + property.declaring_type + " vs " + typeof Collections.MoveNext);
                    return;
                else
                    @IF.debug() Std.error.write_line("CCCCCC: property OK in " + property.declaring_type);
                fi
            elif property.name =~ "iterator" && type.get_method("GetEnumerator")? then
                return;
            fi            

            let result: Symbols.Property;
            let name = _type_name_map.get_member_name(owner.qualified_name, property.name, false);

            let getter = property.get_method;
            let setter = property.set_method;

            if setter? then
                @IF.debug() Std.error.write_line("ASSIGNABLE: " + type + ": property " + property + " getter: " + getter + " setter: " + setter);
            else
                @IF.debug() Std.error.write_line("read only: " + type + ": property " + property + " getter: " + getter + " setter: " + setter);
            fi

            if setter? && !getter? then
                @IF.debug() Std.error.write_line("ignore write only property " + property + " getter: " + getter + " setter: " + setter);                
                return;
            fi
            
            let is_static = false;

            if getter? && getter.is_static then
                is_static = true;
            elif setter? && setter.is_static then
                is_static = true;
            fi

            if is_static then
                result = new Symbols.STATIC_PROPERTY(Source.LOCATION.reflected, owner, name, setter?);
            else
                result = new Symbols.INSTANCE_PROPERTY(Source.LOCATION.reflected, owner, name, setter?);
            fi

            result.set_type(_type_mapper.get_type(property.property_type));

            owner.add_member(result);

            properties.add(result);
        si

        add_indexer(owner: Symbols.Scoped, indexer: PropertyInfo, parameters: List[ParameterInfo]) is
            // @IF.debug() Std.error.write_line("III: ignore indexer: " + owner + " . " + indexer);
        si

        add_method(owner: Symbols.Scoped, type: TYPE, properties: MutableList[Symbols.Property], method: MethodInfo) is
            if method.is_private then
                @IF.debug() Std.error.write_line("" + type + ": ignore private method: " + method + " owner: " + method.declaring_type);              
                return;
            fi

            // FIXME: what is up with this?
            if method.name =~ "GetType" && method.declaring_type != typeof object then
                return;
            fi
            
            let result: Symbols.Function;
            let location = Source.LOCATION.reflected;

            let name: string;

            if method.is_special_name then
                if method.name =~ "get_Item" || method.name =~ "set_Item" then
                    name = method.name;
                elif method.name =~ "get_Current" && method.declaring_type == typeof Collections.MoveNext then
                    return;
                elif method.name.starts_with("get_") then
                    name = "__read_" + _type_name_map.de_camel(method.name.substring(4));
                elif method.name.starts_with("set_") then
                    name = "__assign_" + _type_name_map.de_camel(method.name.substring(4));
                else
                    return;
                    // name = _type_name_map.get_member_name(owner.qualified_name, method.name, method.is_private);

                    // @IF.debug() Std.error.write_line("maybe should ignore: " + method + " (" + method.get_hash_code() + ")");
                fi
            elif method.name =~ "GetEnumerator" then
                if method.declaring_type == typeof Collections.NonGenericIterable then
                    return;
                fi

                name = "__read_iterator";

                let iterator_property = new Symbols.INSTANCE_PROPERTY(Source.LOCATION.reflected, owner, "iterator", false);
                iterator_property.set_type(_type_mapper.get_type(method.return_type));

                owner.add_member(iterator_property);

                @IF.debug() Std.error.write_line("IIIIII: " + type + ": read iterator property " + method + " owner: " + method.declaring_type);

                properties.add(iterator_property);
            elif method.name =~ "Reset" && method.declaring_type == typeof Collections.MoveNext then
                return;
            else
                name = _type_name_map.get_member_name(owner.qualified_name, method.name, method.is_private);
            fi
            
            if method.is_static then
                // @IF.debug() Std.error.write_line("is static");                
                result = new Symbols.STATIC_METHOD(location, owner, name, owner);
            elif owner.is_value_type then                
                // @IF.debug() Std.error.write_line("is struct");                
                result = new Symbols.STRUCT_METHOD(location, owner, name, owner);
            elif method.is_abstract then
                // @IF.debug() Std.error.write_line("is abstract");                
                result = new Symbols.ABSTRACT_METHOD(location, owner, name, owner);
            elif method.is_virtual then
                @IF.debug() Std.error.write_line("virtual instance method" + method + " owner: " + method.declaring_type);
                result = new Symbols.INSTANCE_METHOD(location, owner, name, owner);
            else
                @IF.debug() Std.error.write_line("non-virtual instance method: " + method + " owner: " + method.declaring_type);
                result = new Symbols.INSTANCE_METHOD(location, owner, name, owner);
            fi
            
            result.il_name_override = method.name;
            
            let argument_names = new LIST[string]();
            let argument_types = new LIST[Type]();

            for a in method.get_parameters() do
                argument_names.add(a.name);
                argument_types.add(_type_mapper.get_type(a.parameter_type));
            od

            result.argument_names = argument_names;
            result.arguments = argument_types;

            result.return_type = _type_mapper.get_type(method.return_type);

            @IF.debug() Std.error.write_line("" + type + ": add method: " + method + " (" + result.get_hash_code() + ") owner: " + method.declaring_type);

            owner.add_member(result);
        si

        get_assembly_name(type: TYPE) -> string is
            let assembly = type.assembly;

            let result: string;

            if _assembly_names.try_get_value(assembly, result ref) then
                return result;
            fi

            result = assembly.get_name().name;

            _assembly_names.add(assembly, result);

            return result;
        si        
    si
si