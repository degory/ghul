namespace Semantic.DotNet is
    use TYPE = System.Type2;

    use System.Reflection;
    use System.Text.StringBuilder;

    use IO.Std;
    
    use Collections.Iterable;
    use Collections.Map;
    use Collections.MutableMap;
    use Collections.SET;
    use Collections.LIST;
    use Collections.MAP;

    class TYPE_NAME_MAP is
        _is_started: bool;
        _build_flags: Driver.BUILD_FLAGS;

        _type_details_lookup: TYPE_DETAILS_LOOKUP;

        _ghul_keywords: SET[string];

        type_details_by_dotnet_type: MutableMap[TYPE,TYPE_DETAILS];

        namespace_details_by_dotnet_namespace: MutableMap[string,NAMESPACE_DETAILS];
        namespace_details_by_ghul_name: MutableMap[string,NAMESPACE_DETAILS];

        init(build_flags: Driver.BUILD_FLAGS, type_details_lookup: TYPE_DETAILS_LOOKUP) is
            _build_flags = build_flags;
            _type_details_lookup = type_details_lookup;
            _ghul_keywords = new SET[string]();

            type_details_by_dotnet_type = new MAP[TYPE,TYPE_DETAILS]();

            namespace_details_by_dotnet_namespace = new MAP[string,NAMESPACE_DETAILS]();
            namespace_details_by_ghul_name = new MAP[string,NAMESPACE_DETAILS]();
        si
        
        start() is
            if _is_started then
                @IF.debug() Std.error.write_line("type map already started...");
                return;
            fi

            // Mappings: ghul name -> .NET type / IL name
    
            _ghul_keywords.add("namespace");
            _ghul_keywords.add("class");
            _ghul_keywords.add("struct");
            _ghul_keywords.add("enum");
            _ghul_keywords.add("public");
            _ghul_keywords.add("protected");
            _ghul_keywords.add("private");
            _ghul_keywords.add("const");
            _ghul_keywords.add("static");
            _ghul_keywords.add("innate");
            _ghul_keywords.add("if");
            _ghul_keywords.add("else");
            _ghul_keywords.add("while");
            _ghul_keywords.add("do");
            _ghul_keywords.add("for");
            _ghul_keywords.add("in");
            _ghul_keywords.add("case");
            _ghul_keywords.add("when");
            _ghul_keywords.add("default");
            _ghul_keywords.add("break");
            _ghul_keywords.add("continue");
            _ghul_keywords.add("ref");
            _ghul_keywords.add("ptr");
            _ghul_keywords.add("new");
            _ghul_keywords.add("throw");
            _ghul_keywords.add("return");
            _ghul_keywords.add("cast");
            _ghul_keywords.add("var");
            _ghul_keywords.add("try");
            _ghul_keywords.add("let");
            _ghul_keywords.add("catch");
            _ghul_keywords.add("finally");
            _ghul_keywords.add("self");
            _ghul_keywords.add("super");
            _ghul_keywords.add("null");
            _ghul_keywords.add("use");
            _ghul_keywords.add("trait");
            _ghul_keywords.add("isa");
            _ghul_keywords.add("typeof");
            _ghul_keywords.add("operator");
            _ghul_keywords.add("is");
            _ghul_keywords.add("si");
            _ghul_keywords.add("then");
            _ghul_keywords.add("elif");
            _ghul_keywords.add("fi");
            _ghul_keywords.add("esac");
            _ghul_keywords.add("od");
            _ghul_keywords.add("yrt");
            _ghul_keywords.add("true");
            _ghul_keywords.add("false");
            _ghul_keywords.add("assert");

            map_namespace("Collections", "System.Collections.Generic", null);
            map_namespace("DotNet.NonGeneric.Collections", "System.Collections", null);
            map_namespace("IO", "System.IO", null);

            map_type(typeof void, "Ghul", "void", "void", "System.Runtime", "5:0:0:0");
            map_type(typeof bool, "Ghul", "bool", "bool", "System.Runtime", "5:0:0:0");
            map_type(typeof char, "Ghul", "char", "char", "System.Runtime", "5:0:0:0");
            map_type(typeof ubyte, "Ghul", "ubyte", "unsigned int8", "System.Runtime", "5:0:0:0");
            map_type(typeof byte, "Ghul", "byte", "int8", "System.Runtime", "5:0:0:0");
            map_type(typeof ushort, "Ghul", "ushort", "unsigned int16", "System.Runtime", "5:0:0:0");
            map_type(typeof short, "Ghul", "short", "int16", "System.Runtime", "5:0:0:0");
            map_type(typeof uint, "Ghul", "uint", "unsigned int32", "System.Runtime", "5:0:0:0");
            map_type(typeof int, "Ghul", "int", "int32", "System.Runtime", "5:0:0:0");
            map_type(typeof ulong, "Ghul", "ulong", "unsigned int64", "System.Runtime", "5:0:0:0");
            map_type(typeof long, "Ghul", "long", "int64", "System.Runtime", "5:0:0:0");
            map_type(typeof uword, "Ghul", "uword", "native unsigned int", "System.Runtime", "5:0:0:0");
            map_type(typeof word, "Ghul", "word", "native int", "System.Runtime", "5:0:0:0");
            map_type(typeof single, "Ghul", "single", "float32", "System.Runtime", "5:0:0:0");
            map_type(typeof double, "Ghul", "double", "float64", "System.Runtime", "5:0:0:0");

            map_type(typeof object, "Ghul", "object", null, "System.Runtime", "5:0:0:0");
            map_type(typeof string, "Ghul", "string", null, "System.Runtime", "5:0:0:0");

            map_type(typeof FUNCTION_0, "Ghul", "FUNCTION_0");
            map_type(typeof FUNCTION_1, "Ghul", "FUNCTION_1");
            map_type(typeof FUNCTION_2, "Ghul", "FUNCTION_2");
            map_type(typeof FUNCTION_3, "Ghul", "FUNCTION_3");
            map_type(typeof FUNCTION_4, "Ghul", "FUNCTION_4");
            map_type(typeof FUNCTION_5, "Ghul", "FUNCTION_5");
            map_type(typeof FUNCTION_6, "Ghul", "FUNCTION_6");
            map_type(typeof FUNCTION_7, "Ghul", "FUNCTION_7");
            map_type(typeof FUNCTION_8, "Ghul", "FUNCTION_8");

            map_type(typeof ACTION_0, "Ghul", "ACTION_0");
            map_type(typeof ACTION_1, "Ghul", "ACTION_1");
            map_type(typeof ACTION_2, "Ghul", "ACTION_2");
            map_type(typeof ACTION_3, "Ghul", "ACTION_3");
            map_type(typeof ACTION_4, "Ghul", "ACTION_4");
            map_type(typeof ACTION_5, "Ghul", "ACTION_5");
            map_type(typeof ACTION_6, "Ghul", "ACTION_6");
            map_type(typeof ACTION_7, "Ghul", "ACTION_7");
            map_type(typeof ACTION_8, "Ghul", "ACTION_8");

            map_type(typeof TUPLE_1, "Ghul", "TUPLE_1");
            map_type(typeof TUPLE_2, "Ghul", "TUPLE_2");
            map_type(typeof TUPLE_3, "Ghul", "TUPLE_3");
            map_type(typeof TUPLE_4, "Ghul", "TUPLE_4");
            map_type(typeof TUPLE_5, "Ghul", "TUPLE_5");
            map_type(typeof TUPLE_6, "Ghul", "TUPLE_6");
            map_type(typeof TUPLE_7, "Ghul", "TUPLE_7");
            map_type(typeof TUPLE_8, "Ghul", "TUPLE_8");

            map_type(typeof System.Type2, "System", "Type2");
            map_type(typeof IO.Std, "IO", "Std");

            map_type(typeof Collections.NonGenericIterable, "Collections", "NonGenericIterable");

            map_type(typeof Collections.Bag, "Collections", "Bag");
            map_type(typeof Collections.MoveNext, "Collections", "MoveNext");
            map_type(typeof Collections.Iterable, "Collections", "Iterable");
            map_type(typeof Collections.Iterator, "Collections", "Iterator");

            map_type(typeof Collections.LIST, "Collections", "LIST");
            map_type(typeof Collections.MutableList, "Collections", "MutableList");
            map_type(typeof Collections.List, "Collections", "List");

            map_type(typeof Collections.MAP, "Collections", "MAP");
            map_type(typeof Collections.MutableMap, "Collections", "MutableMap");
            map_type(typeof Collections.Map, "Collections", "Map");

            map_type(typeof Collections.SET, "Collections", "SET");
            map_type(typeof Collections.STACK, "Collections", "STACK");

            map_type(typeof System.Text.UTF8Encoding, "System.Text", "UTF8Encoding");
            
            _is_started = true;
        si

        map_type(dotnet_type: TYPE, namespace_name: string, type_name: string) is
            map_type(dotnet_type, namespace_name, type_name, null, null, null);
        si

        map_type(dotnet_type: TYPE, namespace_name: string, type_name: string, il_name: string, assembly_name: string, assembly_version: string) is
            let type_details = new TYPE_DETAILS(dotnet_type, namespace_name, type_name, il_name, assembly_name, assembly_version);

            type_details_by_dotnet_type.add(dotnet_type, type_details);

            _type_details_lookup.add_type(type_details);
        si

        map_namespace(ghul_namespace_name: string, dotnet_namespace_name: string, dotnet_assembly: string) is
            let namespace_details = new NAMESPACE_DETAILS(ghul_namespace_name, dotnet_namespace_name, dotnet_assembly);

            namespace_details_by_dotnet_namespace.add(dotnet_namespace_name, namespace_details);

            namespace_details_by_ghul_name.add(ghul_namespace_name, namespace_details);
        si

        get_type_details(type: TYPE) -> TYPE_DETAILS is
            let result: TYPE_DETAILS;
            type_details_by_dotnet_type.try_get_value(type, result ref);

            return result;
        si

        get_namespace_details(type: TYPE) -> NAMESPACE_DETAILS is
            let result: NAMESPACE_DETAILS;

            namespace_details_by_dotnet_namespace.try_get_value(type.`namespace, result ref);

            return result;
        si

        get_namespace_details(ghul_namespace_name: string) -> NAMESPACE_DETAILS is
            let result: NAMESPACE_DETAILS;
            namespace_details_by_ghul_name.try_get_value(ghul_namespace_name, result ref);

            return result;
        si
        
        get_member_name(owner_ghul_name: string, member_dotnet_name: string, is_private: bool) -> string is
            let result: string;

            result = de_camel(member_dotnet_name);

            if is_private then
                result = "_" + result;
            fi

            if _ghul_keywords.contains(result) then
                result = "`" + result;
            fi
        
            return result;
        si

        get_constant_name(owner_ghul_name: string, member_dotnet_name: string, is_private: bool) -> string is
            let result: string;

            result = de_camel(member_dotnet_name).to_upper_invariant();

            if is_private then
                result = "_" + result;
            fi

            if _ghul_keywords.contains(result) then
                result = "`" + result;
            fi
        
            return result;
        si

        de_camel(name: string) -> string is
            let buffer = new StringBuilder();
            let seenAnyLowerCase = false;

            for c in name do
                // FIXME: use System.Char.IsUpper here:

                if c >= 'A' /\ c <= 'Z' then
                    if seenAnyLowerCase /\ buffer.get_chars(buffer.length -1) != '_' then
                        buffer.append('_');
                    fi

                    buffer.append(c - 'A' + 'a');
                elif c != '$' then
                    seenAnyLowerCase = true;
                    buffer.append(c);
                fi
            od

            let result = buffer.to_string();

            return result;
        si

        get_type_name(
            name_map: MutableMap[string,string],
            namespace_name_map: Map[string,string], 
            qualified_name: string
        ) -> string
        is
            let result: string;
            
            // First look for an exact mapping for the qualified name
            if name_map.try_get_value(qualified_name, result ref) then
                Std.error.write_line("MAP: manually mapped: " + qualified_name + " -> " + result);
                return result;
            fi

            let type_name = new TYPE_NAME(qualified_name);

            // Get the namespace name from the qualified name:
            let namespace_name = type_name.namespace_name;

            // Is the name qualified with a namespace?
            if !namespace_name? then
                Std.error.write_line("MAP: not qualified: " + qualified_name + " -> " + qualified_name);
                return qualified_name;
            fi

            // Is the namespace name mapped to something else?
            if namespace_name_map.try_get_value(namespace_name, result ref) then
                Std.error.write_line("MAP: namespace mapped: " + qualified_name + " -> " + result + "." + type_name.name);
                return result + "." + type_name.name;
            fi

            // no mapping:
            Std.error.write_line("MAP: no mapping: " + qualified_name + " -> " + qualified_name);
            return qualified_name;            
        si

        /*
        get_ghul_type_name(type: TYPE) -> string =>
            get_ghul_type_name(type.full_name);
        
        get_dotnet_type_name(qualified_name: string) -> string =>


            get_type_name(ghul_to_dotnet_type_name_map, qualified_name);

        get_ghul_type_name(qualified_name: string) -> string is
            
        si
        */
    si
si