namespace Semantic is
    use object = System.Object;
    use string = System.String;
    use STD = System.Console;

        use System.Console;

    use Semantic.Symbol.NAMESPACE;

    use IoC;
    use Logging;
    use Source;

    /*
        a namespace block with associated uses of other namespaces + symbols
        declaration of symbols is forwarded to the aggregate namespace symbol
        symbol search needs to be done in a specific order:
          1) symbols declared directly within the namespace
          2) symbols imported into this namespace block by uses
          3) symbols declared directly in namespaces imported into this namespace block by uses
          4) symbols declared in aggregate namespaces that enclose this one
    */


    class NAMESPACE_SCOPE: object, Scope, NamespaceContext, DeclarationContext  is
        _namespace: Symbol.NAMESPACE;

        _symbols: Collections.MAP[string,Symbol.BASE];
        _used_symbols: Collections.MAP[string,Symbol.BASE];
        _used_namespaces: Collections.LIST[Symbol.NAMESPACE];

        type: Type.BASE => Type.NONE.instance;

        unspecialized_symbol: Symbol.BASE => null;

        name: string => _namespace.name;
        qualified_name: string => _namespace.qualified_name;
        symbols: Collections.Iterable[Symbol.BASE] => _namespace.symbols;

        is_trait: bool => false;

        init(namespace_: Symbol.NAMESPACE) is
            _namespace = namespace_;
            _symbols = new Collections.MAP[string,Symbol.BASE]();
            _used_symbols = new Collections.MAP[string,Symbol.BASE]();
            _used_namespaces = new Collections.LIST[Symbol.NAMESPACE]();
        si

        qualify(name: string) -> string => _namespace.qualify(name);

        find_direct(name: string) -> Symbol.BASE => _namespace.find_direct(name);

        find_direct_matches(prefix: string, matches: Collections.MAP[string,Semantic.Symbol.BASE]) is
            _namespace.find_direct_matches(prefix, matches);
        si        

        find_member_matches(prefix: string, results: Collections.MAP[string,Semantic.Symbol.BASE]) is
            _namespace.find_member_matches(prefix, results);
        si        

        cache_result(search: NAMESPACE_SEARCH) -> Symbol.BASE is
            let result = search.get_result();

            if result? then
                _symbols[search.name] = result;
            fi

            return result;
        si

        find_member(name: string) -> Symbol.BASE is
            return find_enclosing(name);            
        si
        
        find_enclosing(name: string) -> Symbol.BASE is
            let ns_location = _namespace.location;

            if _symbols.contains_key(name) then
                return _symbols[name];
            fi

            let search = new NAMESPACE_SEARCH(self._namespace, name);

            var symbol = find_direct(name);
            
            if search.add(ns_location, symbol, false) then    
                return cache_result(search);
            fi

            if _used_symbols.contains_key(name) then
                symbol = _used_symbols[name];
                
                if search.add(ns_location, symbol, true) then
                    return cache_result(search);
                fi                    
            fi

            for ns in _used_namespaces do
                symbol = ns.find_direct(name);
                
                if search.add(ns_location, symbol, false) then    
                    return cache_result(search);                    
                fi
            od

            if _namespace.enclosing_scope? then
                symbol = _namespace.enclosing_scope.find_enclosing(name);

                if search.add(ns_location, symbol, false) then
                    
                    return cache_result(search);
                fi                    
            fi

            return cache_result(search);
        si

        find_enclosing_matches(prefix: string, matches: Collections.MAP[string,Semantic.Symbol.BASE]) is
            _namespace.find_enclosing_matches(prefix, matches);

            for n in _used_namespaces do
                _namespace.find_direct_matches(prefix, matches);
            od

            for s in _used_symbols do
                Semantic.SYMBOL_MAP.add_match(s.key, s.value, matches);
            od
        si
        
        declare_class(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_class(location, name, arguments, is_stub, enclosing, symbol_definition_listener);
        
        declare_trait(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_trait(location, name, arguments, is_stub, enclosing, symbol_definition_listener);
        
        declare_struct(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_struct(location, name, arguments, is_stub, enclosing, symbol_definition_listener);
        
        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_type(location, name, index, symbol_definition_listener);

        declare_enum(location: LOCATION, name: string, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_enum(location, name, symbol_definition_listener);
        
        declare_enum_member(location: LOCATION, name: string, value: string, symbol_definition_listener: SymbolDefinitionListener) is
            _namespace.declare_enum_member(location, name, value, symbol_definition_listener);           
        si
        
        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_closure(location, name, owner, enclosing, symbol_definition_listener);

        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_innate(location, name, innate_name, enclosing, symbol_definition_listener);

        declare_function(location: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_function(location, name, is_static, is_private, enclosing, symbol_definition_listener);

        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_variable(location, name, is_static, symbol_definition_listener);           
        
        declare_property(location: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope =>
            _namespace.declare_property(location, name, is_static, is_private, is_assignable, symbol_definition_listener);

        declare_label(location: LOCATION, name: string, symbol_definition_listener: SymbolDefinitionListener) is
            _namespace.declare_label(location, name, symbol_definition_listener);
        si
        
        declare_namespace(location: LOCATION, name: string, namespace_: Symbol.NAMESPACE, symbol_definition_listener: SymbolDefinitionListener) is
            _namespace.declare_namespace(location, name, namespace_, symbol_definition_listener);
        si

        add(namespace_: Symbol.NAMESPACE) is
            _used_namespaces.add(namespace_);
        si

        add(name: string, symbol: Symbol.BASE) is
            _used_symbols[name] = symbol;
        si        

        to_string() -> string => "namespace scope for: " + _namespace.name;
    si
si