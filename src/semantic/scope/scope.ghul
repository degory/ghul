namespace Semantic is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System.Text.StringBuilder;
    
    use IoC;
    use Logging;
    use Source;

    use Types.Type;

    trait Scope is
        name: string;
        qualified_name: string;

        symbols: Collections.Iterable[Symbols.Symbol];

        type: Type;

        unspecialized_symbol: Symbols.Symbol;

        is_trait: bool;
        
        qualify(name: string) -> string;
        find_direct(name: string) -> Symbols.Symbol;
        find_member(name: string) -> Symbols.Symbol;
        find_enclosing(name: string) -> Symbols.Symbol;

        find_direct_matches(prefix: string, matches: Collections.MAP[string,Symbols.Symbol]);
        find_member_matches(prefix: string, matches: Collections.MAP[string,Symbols.Symbol]);
        find_enclosing_matches(prefix: string, matches: Collections.MAP[string,Symbols.Symbol]);

        gen_dotted_name(buffer: StringBuilder, want_trailing_dot: bool);

        gen_reference(buffer: StringBuilder);
        gen_type(buffer: StringBuilder);
    si

    trait DeclarationContext is
        declare_stable(symbol: Semantic.Symbols.Symbol);
        declare_class(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_trait(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_struct(location: LOCATION, name: string, arguments: Collections.LIST[string], is_stub: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_enum(location: LOCATION, name: string, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_enum_member(location: LOCATION, name: string, value: string, symbol_definition_listener: SymbolDefinitionListener);
        declare_closure(location: LOCATION, name: string, owner: Scope, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_innate(location: LOCATION, name: string, innate_name: string, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;

        declare_function(location: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_property(location: LOCATION, name: string, is_static: bool, is_private: bool, is_assignable: bool, symbol_definition_listener: SymbolDefinitionListener) -> Scope;
        declare_label(location: LOCATION, name: string, symbol_definition_listener: SymbolDefinitionListener);
    si

    trait NamespaceContext is
        declare_namespace(location: LOCATION, name: string, namespace_: Symbols.NAMESPACE, symbol_definition_listener: SymbolDefinitionListener);
    si
si
