namespace Semantic is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use STD = System.Console;

    use System;
        use Collections;

    use Source;

    trait SymbolUseListener is
        add_symbol_use(location: LOCATION, symbol: Symbol.BASE);
    si

    class SYMBOL_USE_LOCATIONS: object, SymbolUseListener is
        _symbol_use_map: LOCATION_MAP[Symbol.BASE];
        _symbol_reference_map: Collections.MAP[Symbol.BASE,Collections.SET[LOCATION]];

        init() is
            clear();
        si

        dump_counts() is
            _symbol_use_map.dump_counts();
            STD.error.write_line("symbol reference map: " + _symbol_reference_map.count);
        si        

        clear() is
            _symbol_use_map = new LOCATION_MAP[Symbol.BASE]();
            _symbol_reference_map = new Collections.MAP[Symbol.BASE,Collections.SET[LOCATION]](65521);
        si

        add_symbol_use(location: LOCATION, symbol: Symbol.BASE) is
            if 
                symbol? && 
                !symbol.location.is_internal &&
                !symbol.name.starts_with("__")
            then
                _symbol_use_map.put(location, symbol);

                add_symbol_reference(location, symbol);
            fi
        si

        add_symbol_reference(location: LOCATION, symbol: Symbol.BASE) is
            if symbol.overridees? then
                for o in symbol.overridees do
                    // STD.error.write_line("add overridden symbol reference: " + symbol + " overrides " + o);
                    add_symbol_reference(location, o);
                od  
            fi

            let set_ = get_references_set(symbol);
                
            if !set_.contains(location) then
                // FIXME: why is this getting called multiple times for the same symbol and location?
                set_.add(location);
            fi
        si

        find_definition_from_use(file_name: string, line: int, column: int) -> Symbol.BASE is
            let matches = _symbol_use_map.find_all(file_name, line, column);

            if matches.count == 0 then
                return null;
            elif matches.count == 1 then
                return matches[0].value;
            else
                let shortest_length = 1_000_000_000;
                let best_match: Symbol.BASE;

                for m in matches do
                    let location = m.location;
                    let symbol = m.value;
                    let length = location.length;

                    if length < shortest_length then
                        best_match = symbol;
                        shortest_length = length;
                    elif location.length == shortest_length && isa Symbol.Function(symbol) then
                        best_match = symbol;
                    fi                                        
                od
                
                return best_match;
            fi
        si

        find_references_to_symbol(symbol: Symbol.BASE) -> Collections.Iterable[LOCATION] is
            return get_references_set(symbol);    
        si

        get_references_set(symbol: Symbol.BASE) -> Collections.SET[LOCATION] is
            let result: Collections.SET[LOCATION];

            let unspecialized_symbol = symbol.root_specialized_from;

            if _symbol_reference_map.try_get_value(unspecialized_symbol, result ref) then
                return result;                
            fi

            result = new Collections.SET[LOCATION]();

            _symbol_reference_map[unspecialized_symbol] = result;

            return result;            
        si
    si

    class LOCATION_MAP[T] is
        file_name_to_file: Collections.MAP[string, Collections.MAP[int, Collections.LIST[Pair[LOCATION,T]]]];

        init() is
            file_name_to_file = new Collections.MAP[string, Collections.MAP[int, Collections.LIST[Pair[LOCATION,T]]]]();
        si

        dump_counts() is
            STD.error.write_line("file name to file map: " + file_name_to_file.count);
        si

        put(location: LOCATION, value: T) is
            let file = _get_file(location.file_name);

            if file == null then
                file = new Collections.MAP[int, Collections.LIST[Pair[LOCATION,T]]]();
                file_name_to_file[location.file_name] = file;
            fi

            let start_line = location.start_line;
            let end_line = location.end_line;

            let list: Collections.LIST[Pair[LOCATION,T]];

            for line in start_line::end_line do
                if file.contains_key(line) then
                    list = file[line];
                else
                    list = new Collections.LIST[Pair[LOCATION,T]]();
                    file[line] = list;
                fi
                list.add(new Pair[LOCATION,T](location,value));
            od
        si

        find_all(file_name: string, line: int, column: int) -> List[LOCATION_SEARCH_RESULT[T]] is
            let file = _get_file(file_name);

            if !file? || !file.contains_key(line) then
                return null;
            fi

            let list = file[line];

            if list == null then
                return null;
            fi

            let line_column = LOCATION.pair(line, column);

            let result = new LIST[LOCATION_SEARCH_RESULT[T]]();

            for p in list do
                if p.key.contains(line_column) then
                    result.add(new LOCATION_SEARCH_RESULT[T](p.key, p.value));
                fi
            od

            return result;
        si
        
        _get_file(file_name: string) -> Collections.MAP[int, Collections.LIST[Pair[LOCATION,T]]] is
            if file_name_to_file.contains_key(file_name) then
                return file_name_to_file[file_name];
            fi
        si        
    si
    
    struct LOCATION_SEARCH_RESULT[T] is
        location: LOCATION;
        value: T;
        
        init(location: LOCATION, value: T) is
            self.location = location;
            self.value = value;
        si 
    si
    
si
