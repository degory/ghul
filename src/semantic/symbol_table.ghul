namespace Semantic is
    use IO.Std;

    use Logging;
    use Source;

    use Syntax.Trees;

    // the symbol table helps keeps track of what scope the compiler is currently working in. it does not
    // manage searching for symbols within or across scopes: that's handled by the scopes themselves

    class SYMBOL_TABLE is
        _logger: Logger;
        _scopes: Collections.MAP[Node,Scope];
        _stack: Collections.LIST[Scope];

        stack: Collections.List[Scope] => _stack;

        current_scope: Scope =>
            if _stack.count > 0 then
                _stack[_stack.count-1];
            else
                null;
            fi;

        global_scope: Scope => _stack[0];

        current_namespace_context: NamespaceContext =>
            _current_scope[NamespaceContext]();

        current_extension_method_search_context: ExtensionMethodSearchContext =>
            _current_scope[ExtensionMethodSearchContext]();

        current_declaration_context: DeclarationContext =>
            _current_scope[DeclarationContext]();

        current_instance_context: Symbols.Classy =>
            _current_scope[Symbols.Classy]();

        current_union_context: Symbols.UNION =>
            _current_scope[Symbols.UNION]();
    
        current_function: Symbols.Function =>
            _current_scope[Symbols.Function]();

        current_closure_context: ClosureContext =>
            let result = _current_scope[ClosureContext]() in
            if result? then
                result
            else
                throw System.InvalidOperationException("no current closure context");
            fi;

        current_capture_context: Symbols.Symbol =>
            _current_scope[Symbols.Symbol]();

        current_closure: Symbols.Closure =>
            _current_scope[Symbols.Closure]();

        current_function_group: Symbols.FUNCTION_GROUP =>
            _current_scope[Symbols.FUNCTION_GROUP]();

        current_property: Symbols.Property =>
            _current_scope[Symbols.Property]();

        all_classes: Collections.Iterable[Symbols.Classy] =>
            _scopes.values | .filter(s => s.is_classy) .map(s => cast Symbols.Classy(s));

        all_namespaces: Collections.Iterable[Symbols.NAMESPACE] =>
            _scopes.values | .filter(s => s.is_namespace) .map(s => cast Symbols.NAMESPACE(s));
                    
        init(logger: Logger) is
            _logger = logger;

            clear();
        si

        dump_counts() is
            Std.error.write_line("scopes map: {_scopes.count}");
        si        

        clear() is
            _stack = Collections.LIST[Scope](50);
            _scopes = Collections.MAP[Node,Scope](65521);

            enter_scope(Symbols.NAMESPACE(LOCATION.internal, "", null, "", true));
        si

        scope_for(node: Node) -> Scope is
            if _scopes.contains_key(node) then
                return _scopes[node];
            fi
        si

        associate_node_with_scope(node: Node, scope: Scope) is
            _scopes[node] = scope;
        si

        mark_scope_stack() -> int is
            return _stack.count;
        si

        release_scope_stack(mark: int) is
            assert mark <= _stack.count;

            while _stack.count > mark do
                _stack.remove_at(_stack.count - 1);
            od
        si

        enter_scope(node: Syntax.Trees.Node) is
            if !_scopes.contains_key(node) then
                _logger.poison(node.location, "no scope found for {node.get_type()}");

                return;
            fi

            let scope = _scopes[node];

            enter_scope(scope);
        si

        enter_scope(scope: Scope) is
            _stack.add(scope);
        si

        leave_scope(node: Syntax.Trees.Node) is
            if !_scopes.contains_key(node) then
                _logger.poison(node.location, "no scope found for node");
                return;
            fi

            leave_scope(_scopes[node]);
        si

        leave_scope(scope: Scope) is
            assert current_scope == scope else "scope stack corrupt: stack top: {current_scope} leaving scope: {scope}";
            
            _stack.remove_at(_stack.count - 1);
        si

        leave_scope() is
            let scope = _stack[_stack.count - 1];

            _stack.remove_at(_stack.count - 1);
        si

        to_string() -> string is
            let result = System.Text.StringBuilder();

            result.append("symbol table:\n");

            for scope in Collections.LIST_REVERSE_ITERATOR[Semantic.Scope](_stack) do
                result
                    .append(scope)
                    .append("\n");
            od

            result.append("\n");

            return result.to_string();
        si

        _current_scope[T]() -> T =>
            Collections.LIST_REVERSE_ITERABLE(_stack) |
                .find_map_not_default(scope => cast T(scope));
    si
si
