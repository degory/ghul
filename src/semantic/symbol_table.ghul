namespace Semantic is
    use IO.Std;

    use Logging;
    use Source;

    use Syntax.Trees;

    // the symbol table helps keeps track of what scope the compiler is currently working in. it does not
    // manage searching for symbols within or across scopes: that's handled by the scopes themselves

    class SYMBOL_TABLE_STATE is
        _logger: Logging.Logger;
        _symbol_table: SYMBOL_TABLE;

        _stack: Collections.LIST[Scope];

        init(logger: Logging.Logger, symbol_table: SYMBOL_TABLE) is
            _logger = logger;
            _symbol_table = symbol_table;

            _stack = new Collections.LIST[Scope](50);

            enter_scope(global_scope);
        si

        current_scope: Scope is
            if _stack.count > 0 then
                return _stack[_stack.count-1];
            else
                return null;
            fi
        si

        global_scope: Scope static;

        current_namespace_context: NamespaceContext is
            for scope in new Collections.LIST_REVERSE_ITERATOR[Scope](_stack) do
                if isa NamespaceContext(scope) then
                    return cast NamespaceContext(scope);
                fi
            od
            
            assert false else "no current namespace";
        si

        current_declaration_context: DeclarationContext is
            for scope in new Collections.LIST_REVERSE_ITERATOR[Scope](_stack) do
                if isa DeclarationContext(scope) then
                    return cast DeclarationContext(scope);
                fi
            od
        si

        current_instance_context: Symbols.Classy is
            for scope in new Collections.LIST_REVERSE_ITERATOR[Scope](_stack) do
                if isa Symbols.CLASS(scope) \/ isa Symbols.TRAIT(scope) \/ isa Symbols.STRUCT(scope) then
                    return cast Symbols.Classy(scope);
                fi
            od

            Std.error.write_line("current instance context: nothing found: " + new System.Diagnostics.StackTrace().to_string().replace('\n', ' '));
        si
        
        current_function: Symbols.Function is
            for scope in new Collections.LIST_REVERSE_ITERATOR[Scope](_stack) do
                if isa Symbols.Function(scope) then
                    return cast Symbols.Function(scope);
                fi
            od
        si

        current_function_group: Symbols.FUNCTION_GROUP is
            for scope in new Collections.LIST_REVERSE_ITERATOR[Scope](_stack) do
                if isa Symbols.FUNCTION_GROUP(scope) then
                    return cast Symbols.FUNCTION_GROUP(scope);
                fi
            od
        si

        current_property: Symbols.Property is
            for scope in new Collections.LIST_REVERSE_ITERATOR[Scope](_stack) do
                if isa Symbols.Property(scope) then
                    return cast Symbols.Property(scope);
                fi
            od
        si 
        
        mark_scope_stack() -> int is
            return _stack.count;
        si

        release_scope_stack(mark: int) is
            assert mark <= _stack.count;

            while _stack.count > mark do
                _stack.remove_at(_stack.count - 1);
            od
        si

        enter_scope(node: Syntax.Trees.Node) is
            let scope = _symbol_table.scope_for(node);
            
            if !scope? then
                @IF.debug()
                _logger.poison(node.location, "no scope found for " + node + " from " + new System.Diagnostics.StackTrace());

                @IF.not.debug()
                _logger.poison(node.location, "no scope found for " + node);

                return;
            fi

            // let scope = _scopes[node];

            enter_scope(scope);
        si

        enter_scope(scope: Scope) is
            @IF.debug() Std.error.write_line("enter scope: " + scope + " of type " + scope.get_type() + " hash: " + scope.get_hash_code());

            _stack.add(scope);
        si
        

        leave_scope(node: Syntax.Trees.Node) is
            let scope = _symbol_table.scope_for(node);
            
            if !scope? then
                _logger.poison(node.location, "no scope found for node");
                return;
            fi

            leave_scope(scope);
        si

        leave_scope(scope: Scope) is
            @IF.debug() Std.error.write_line("leave scope: " + scope + " of type " + scope.get_type() + " hash: " + scope.get_hash_code());

            assert current_scope == scope else "scope stack corrupt: stack top: " + current_scope + " leaving scope: " + scope;
            
            _stack.remove_at(_stack.count - 1);
        si

        leave_scope() is
            _stack.remove_at(_stack.count - 1);
        si
    si
    
    class SYMBOL_TABLE is
        _logger: Logger;
        _scopes: Collections.MAP[Node,Scope];

        all_classes: Collections.Iterable[Symbols.Classy] is
            let result = new Collections.LIST[Symbols.Classy]();
            
            for scope in _scopes.values do
                if isa Symbols.Classy(scope) then
                    result.add(cast Symbols.Classy(scope));
                fi
                
            od

            return result;
        si
        
        init(logger: Logger) is
            _logger = logger;

            clear();
        si

        dump_counts() is
            Std.error.write_line("scopes map: " + _scopes.count);
        si        

        clear() is
            _scopes = new Collections.MAP[Node,Scope](65521);
        si

        scope_for(node: Node) -> Scope is
            if _scopes.contains_key(node) then
                return _scopes[node];
            fi
        si

        associate_node_with_scope(node: Node, scope: Scope) is
            _scopes[node] = scope;
        si
    si
si
