namespace Semantic is
    use System;
    use Generic;

    class GENERIC_KEY is
        // FIXME: if symbol.owner is correct, then we don't need this
        specialized_for: Symbol.BASE;
        symbol: Symbol.BASE;
        arguments: Collections.LIST[Type.BASE];

        init(specialized_for: Symbol.BASE, symbol: Symbol.BASE, arguments: Collections.LIST[Type.BASE]) is
            self.specialized_for = specialized_for;
            self.symbol = symbol;
            self.arguments = arguments;
        si

        @IF.legacy()
        hash() -> int is
            var result = symbol.hash();

            result = result + specialized_for.hash();

            for a in arguments do
                result = result + a.hash();
            od

            return result;
        si

        @IF.dotnet()
        get_hash_code() -> int is
            var result = symbol.get_hash_code();

            result = result + specialized_for.get_hash_code();

            for a in arguments do
                result = result + a.get_hash_code();
            od

            return result;
        si

        =~(other: GENERIC_KEY) -> bool is
            if symbol != other.symbol then
                return false;
            fi

            for i in 0..arguments.count do
                if arguments[i] !~ other.arguments[i] then
                    return false;
                fi
            od

            return true;
        si

        to_string() -> String =>
            specialized_for.qualified_name + "[" + new Shim.JOIN[Type.BASE](arguments) + "] / " + symbol.qualified_name;                

        @IF.legacy()
        toString() -> String => to_string();

    si

    class GENERIC_CACHE is
        specializations: Collections.MAP[GENERIC_KEY,Symbol.BASE];

        // members: Dict[Symbol.BASE,List[Symbol.BASE]];

        init() is
            super.init();

            clear();
        si

        [key: GENERIC_KEY]: Symbol.BASE public
            is 
                if specializations.contains_key(key) then
                    return specializations[key];
                fi            
            si,           
            = value is
                specializations[key] = value;

                if key.arguments? then
                    for a in key.arguments do
                        if !a? then
                            System.Console.error.write_line("null type argument specializing " + key.symbol.qualified_name);
                        fi
                    od
                fi
            si

        dump_counts() is
            System.Console.error.write_line("specializations: " + specializations.count);
            // System.Console.error.write_line("members: " + members.count);
        si        

        clear() is
            specializations = new Collections.MAP[GENERIC_KEY,Symbol.BASE]();
            // members = new Map[Symbol.BASE,List[Symbol.BASE]]();
        si
    si
si