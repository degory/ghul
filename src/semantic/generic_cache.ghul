namespace Semantic is
    use System;
    use Generic;

    class GENERIC_KEY is
        // FIXME: if symbol.owner is correct, then we don't need this
        specialized_for: Symbol.BASE;
        symbol: Symbol.BASE;
        arguments: Collections.LIST[Type.BASE];

        init(specialized_for: Symbol.BASE, symbol: Symbol.BASE, arguments: Collections.LIST[Type.BASE]) is
            self.specialized_for = specialized_for;
            self.symbol = symbol;
            self.arguments = arguments;
        si

        hash() -> int is
            var result = symbol.hash();

            result = result + specialized_for.hash();

            for a in arguments do
                result = result + a.hash();
            od

            return result;
        si

        =~(other: GENERIC_KEY) -> bool is
            if symbol != other.symbol then
                return false;
            fi

            for i in 0..arguments.count do
                if arguments[i] !~ other.arguments[i] then
                    return false;
                fi
            od

            return true;
        si

        toString() -> String is
            return
                specialized_for.qualified_name + "[" + arguments.get_inner() + "] / " + symbol.qualified_name;
        si
    si

    class GENERIC_CACHE is
        specializations: Dict[GENERIC_KEY,Symbol.BASE];

        // members: Dict[Symbol.BASE,List[Symbol.BASE]];

        init() is
            super.init();

            clear();
        si

        [key: GENERIC_KEY]: Symbol.BASE public
            => specializations[key],           
            = value is
                specializations[key] = value;

                if key.arguments? then
                    for a in key.arguments do
                        if !a? then
                            IO.Std.err.println("null type argument specializing " + key.symbol.qualified_name);

                            IO.Std.err.println(new Backtrace().toString());
                        fi
                    od
                fi

                /*
                key.specialized_for.add_specialization(new GENERIC_KEY(
                    key.specialized_for,
                    key.specialized_for,
                    key.arguments
                ));
                */
                
                /*
                var l = members[key.symbol];

                if !l? then
                    l = new Collections.LIST[Symbol.BASE]();

                    members[key.symbol] = l;
                fi

                l.add(value);
                */
            si

        dump_counts() is
            IO.Std.err.println("specializations: " + specializations.Length);
            // IO.Std.err.println("members: " + members.Length);
        si        

        clear() is
            specializations = new Map[GENERIC_KEY,Symbol.BASE]();
            // members = new Map[Symbol.BASE,List[Symbol.BASE]]();
        si

        toString() -> String =>
            "generics: " + specializations.toString();
    si
si