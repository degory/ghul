namespace Semantic is
    use System;
    use Generic;

    class InnateSymbolLookup is
        _logger: Logging.Logger;
        _symbol_table: SYMBOL_TABLE;
        _namespace_name: String;

        namespace_scope: Scope => _symbol_table.global_scope.find_direct(_namespace_name);

        init(
            logger: Logging.Logger,
            symbol_table: SYMBOL_TABLE,
            namespace_name: String
        ) is
            _logger = logger;
            _symbol_table = symbol_table;
            _namespace_name = namespace_name;
        si

        get_type(
            name: String,
            create: (
                Source.LOCATION,
                Semantic.Symbol.Classy
            ) -> Semantic.Type.NAMED
        ) -> Semantic.Type.NAMED is
            _logger.assert(
                create?,
                null,
                "no create function supplied");

            return create(
                    Source.LOCATION.dummy,
                    get_class(name)
                );
        si

        get_type(
            name: String,
            type: Type.BASE,
            create: (
                Source.LOCATION,
                Semantic.Symbol.Classy,
                Collections.LIST[Type.BASE]
            ) -> Semantic.Type.NAMED
        ) -> Semantic.Type.NAMED
        => get_type(name, new Collections.LIST[Type.BASE]([type]), -1, create);

        get_type(
            name: String,
            types: Collections.LIST[Type.BASE],
            create: (
                Source.LOCATION,
                Semantic.Symbol.Classy,
                Collections.LIST[Type.BASE]
            ) -> Semantic.Type.NAMED
        ) -> Semantic.Type.NAMED
        => get_type(name, types, 0, create);

        get_type(
            name: String,
            types: Collections.LIST[Type.BASE],
            exclude_count: int,
            create: (
                Source.LOCATION,
                Semantic.Symbol.Classy,
                Collections.LIST[Type.BASE]
            ) -> Semantic.Type.NAMED
        ) -> Semantic.Type.NAMED
        is
            if types.count > 0 then
                if exclude_count >= 0 then
                    name = name + "_" + (types.count - exclude_count);
                fi

                let symbol = get_class(name);

                if create? then
                    let result = create(
                        Source.LOCATION.dummy,
                        symbol,
                        types
                    );

                    return result;
                else
                    return new Semantic.Type.GENERIC(Source.LOCATION.dummy, symbol, types);
                fi
            else
                return get_type(name + "_0");
            fi
        si

        get_type(name: String) -> Semantic.Type.NAMED is
            let symbol = get_class(name);

            return new Semantic.Type.NAMED(
                symbol
            );
        si

        get_class(name: String) -> Semantic.Symbol.Classy
            => cast Semantic.Symbol.Classy(get_symbol(name));

        get_symbol(name: String) -> Semantic.Symbol.BASE is
            _logger.assert(
                namespace_scope?,
                null,
                "innate symbol lookup has no namespace for '" + _namespace_name + "'");

            let result = namespace_scope.find_direct(name);

            _logger.assert(
                result?,
                null,
                "could not find innate symbol " + _namespace_name + "." + name);

            return result;
        si
    si

    class GHUL_SYMBOL_LOOKUP: InnateSymbolLookup is
        init(
            logger: Logging.Logger,
            symbol_table: SYMBOL_TABLE
        ) is
            super.init(
                logger,
                symbol_table,
                "Ghul");
        si

        get_enum_type(type: Type.BASE) -> Semantic.Type.NAMED =>
            get_type(
                "ENUM",
                type,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                    new Semantic.Type.ENUM(location, symbol, types)
            );

        get_tuple_type(types: Collections.LIST[Type.BASE]) -> Semantic.Type.NAMED =>
            get_type(
                "TUPLE",
                types,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                    new Semantic.Type.TUPLE(location, symbol, types)
            );

        get_function_type(types: Collections.LIST[Type.BASE]) -> Semantic.Type.NAMED is
            if types[types.count - 1].symbol != get_void_type().symbol then
                return get_type(
                    "FUNCTION",
                    types,
                    1,
                    (
                        location: Source.LOCATION,
                        symbol: Semantic.Symbol.Classy,
                        types: Collections.LIST[Type.BASE]
                    ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.FUNCTION(location, symbol, types)
                );
            elif types.count == 1 then
                let result = get_type(
                    "ACTION_0",
                    (
                        location: Source.LOCATION,
                        symbol: Semantic.Symbol.Classy
                    ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.ACTION_0(symbol)
                );

                return result;
            else
                let action_types = new Collections.LIST[Type.BASE](types.count - 1);

                for i in 0..types.count - 1 do
                    action_types.add(types[i]);
                od
                
                let result = get_type(
                    "ACTION",
                    action_types,
                    0,
                    (
                        location: Source.LOCATION,
                        symbol: Semantic.Symbol.Classy,
                        types: Collections.LIST[Type.BASE]
                    ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.FUNCTION(location, symbol, types)
                );

                return result;
            fi
        si
        
        get_array_type(type: Type.BASE) -> Semantic.Type.NAMED =>
            get_type(
                "ARRAY",
                type,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.ARRAY(location, symbol, types)
            );

        get_pointer_type(type: Type.BASE) -> Semantic.Type.NAMED =>
            get_type(
                "POINTER",
                type,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.POINTER(location, symbol, types)
            );

        get_reference_type(type: Type.BASE) -> Semantic.Type.NAMED =>
            get_type(
                "REFERENCE",
                type,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.REFERENCE(location, symbol, types)
            );

        get_bool_type() -> Semantic.Type.NAMED =>
            get_type(
                "bool",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.BOOL(symbol)
            );


        get_char_type() -> Semantic.Type.NAMED =>
            get_type(
                "char",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.CHAR(symbol)
            );

        get_byte_type() -> Semantic.Type.NAMED =>
            get_type(
                "byte",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.BYTE(symbol)
            );

        get_ubyte_type() -> Semantic.Type.NAMED =>
            get_type(
                "ubyte",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.UBYTE(symbol)
            );
            
        get_short_type() -> Semantic.Type.NAMED =>
            get_type(
                "short",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.SHORT(symbol)
            );

        get_ushort_type() -> Semantic.Type.NAMED =>
            get_type(
                "ushort",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.USHORT(symbol)
            );
            
        get_int_type() -> Semantic.Type.NAMED =>
            get_type(
                "int",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.INT(symbol)
            );

        get_uint_type() -> Semantic.Type.NAMED =>
            get_type(
                "uint",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.UINT(symbol)
            );

        get_long_type() -> Semantic.Type.NAMED =>
            get_type(
                "long",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.INT(symbol)
            );
            
        get_ulong_type() -> Semantic.Type.NAMED =>
            get_type(
                "ulong",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.INT(symbol)
            );

        get_word_type() -> Semantic.Type.NAMED =>
            get_type(
                "long",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.INT(symbol)
            );            

        get_void_type() -> Semantic.Type.NAMED =>
            get_type("void");
    si

    class SYSTEM_SYMBOL_LOOKUP: InnateSymbolLookup is
        init(
            logger: Logging.Logger,
            symbol_table: SYMBOL_TABLE
        ) is
            super.init(
                logger,
                symbol_table,
                "System"
            );
        si

        get_object_type() -> Semantic.Type.NAMED =>
            get_type("Object");

        get_value_type() -> Semantic.Type.NAMED =>
            get_type("ValueType");

        get_string_type() -> Semantic.Type.NAMED =>
            get_type("String");

        get_exception_type() -> Semantic.Type.NAMED =>
            get_type("Exception");
    si

    class COLLECTIONS_SYMBOL_LOOKUP: InnateSymbolLookup is
        init(
            logger: Logging.Logger,
            symbol_table: SYMBOL_TABLE
        ) is
            super.init(
                logger,
                symbol_table,
                "Collections"
            );
        si

        get_unspecialized_iterator_type() -> Semantic.Type.NAMED =>
            get_type("Iterator");
    si
si