namespace Semantic is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use STD = System.Console;
    @IF.not.v3() use TYPE = System.Type2;

    use System;
    
    class InnateSymbolLookup is
        _logger: Logging.Logger;
        _symbol_table: SYMBOL_TABLE;
        _dotnet_symbol_table: LAZY[DotNet.SYMBOL_TABLE];
        _namespace_name: string;

        namespace_scope: Scope => _symbol_table.global_scope.find_direct(_namespace_name);

        init(
            logger: Logging.Logger,
            symbol_table: SYMBOL_TABLE,
            dotnet_symbol_table: LAZY[DotNet.SYMBOL_TABLE],
            namespace_name: string
        ) is
            _logger = logger;
            _symbol_table = symbol_table;
            _dotnet_symbol_table = dotnet_symbol_table;
            _namespace_name = namespace_name;
        si

        get_type(
            name: string,
            create: (
                Source.LOCATION,
                Semantic.Symbol.Classy
            ) -> Semantic.Type.NAMED
        ) -> Semantic.Type.NAMED is
            assert
                create?
            else
                "no create function supplied";

            return
                create(
                    Source.LOCATION.dummy,
                    get_class(name)
                );
        si

        get_type(
            name: string,
            type: Type.BASE,
            create: (
                Source.LOCATION,
                Semantic.Symbol.Classy,
                Collections.LIST[Type.BASE]
            ) -> Semantic.Type.NAMED
        ) -> Semantic.Type.NAMED
            => get_type(name, new Collections.LIST[Type.BASE]([type]), -1, create);

        get_type(
            name: string,
            types: Collections.LIST[Type.BASE],
            create: (
                Source.LOCATION,
                Semantic.Symbol.Classy,
                Collections.LIST[Type.BASE]
            ) -> Semantic.Type.NAMED
        ) -> Semantic.Type.NAMED
            => get_type(name, types, 0, create);

        get_type(
            name: string,
            types: Collections.LIST[Type.BASE],
            exclude_count: int,
            create: (
                Source.LOCATION,
                Semantic.Symbol.Classy,
                Collections.LIST[Type.BASE]
            ) -> Semantic.Type.NAMED
        ) -> Semantic.Type.NAMED
        is
            if types.count > 0 then
                if exclude_count >= 0 then
                    name = name + "_" + (types.count - exclude_count);
                fi

                let symbol = get_class(name);

                if create? then
                    let result = create(
                        Source.LOCATION.dummy,
                        symbol,
                        types
                    );

                    return result;
                else
                    return new Semantic.Type.GENERIC(Source.LOCATION.dummy, symbol, types);
                fi
            else
                return get_type(name + "_0", cast TYPE(null));
            fi
        si

        // TODO: if consuming .NET types from assemblies then lookup type in the .NET symbol table: 
        get_type(name: string, type: TYPE) -> Semantic.Type.NAMED 
            => new Semantic.Type.NAMED(get_class(name));

        get_class(name: string) -> Semantic.Symbol.Classy
            => cast Semantic.Symbol.Classy(get_symbol(name));

        get_symbol(name: string) -> Semantic.Symbol.BASE is
            assert
                namespace_scope?
            else
                "innate symbol lookup has no namespace " + _namespace_name;

            let result = namespace_scope.find_direct(name);

            assert
                result?
            else
                "could not find innate symbol " + name;

            return result;
        si
    si

    class GHUL_SYMBOL_LOOKUP: InnateSymbolLookup is
        init(
            logger: Logging.Logger,
            symbol_table: SYMBOL_TABLE,
            dotnet_symbol_table: LAZY[DotNet.SYMBOL_TABLE]
        ) is
            super.init(
                logger,
                symbol_table,
                dotnet_symbol_table,
                "Ghul");
        si

        get_enum_type(type: Type.BASE) -> Semantic.Type.NAMED =>
            get_type(
                "ENUM",
                type,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                    new Semantic.Type.ENUM(location, symbol, types)
            );

        get_tuple_type(types: Collections.LIST[Type.BASE]) -> Semantic.Type.NAMED =>
            get_type(
                "TUPLE",
                types,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                    new Semantic.Type.TUPLE(location, symbol, types)
            );

        get_function_type(types: Collections.LIST[Type.BASE]) -> Semantic.Type.NAMED is
            if types[types.count - 1].symbol != get_void_type().symbol then
                return get_type(
                    "FUNCTION",
                    types,
                    1,
                    (
                        location: Source.LOCATION,
                        symbol: Semantic.Symbol.Classy,
                        types: Collections.LIST[Type.BASE]
                    ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.FUNCTION(location, symbol, types)
                );
            elif types.count == 1 then
                let result = get_type(
                    "ACTION_0",
                    (
                        location: Source.LOCATION,
                        symbol: Semantic.Symbol.Classy
                    ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.ACTION_0(symbol)
                );

                return result;
            else
                let action_types = new Collections.LIST[Type.BASE](types.count - 1);

                for i in 0..types.count - 1 do
                    action_types.add(types[i]);
                od
                
                let result = get_type(
                    "ACTION",
                    action_types,
                    0,
                    (
                        location: Source.LOCATION,
                        symbol: Semantic.Symbol.Classy,
                        types: Collections.LIST[Type.BASE]
                    ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.FUNCTION(location, symbol, types)
                );

                return result;
            fi
        si
        
        get_array_type(type: Type.BASE) -> Semantic.Type.NAMED =>
            get_type(
                "ARRAY",
                type,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.ARRAY(location, symbol, types)
            );

        get_pointer_type(type: Type.BASE) -> Semantic.Type.NAMED =>
            get_type(
                "POINTER",
                type,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.POINTER(location, symbol, types)
            );

        get_reference_type(type: Type.BASE) -> Semantic.Type.NAMED =>
            get_type(
                "REFERENCE",
                type,
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy,
                    types: Collections.LIST[Type.BASE]
                ) -> Semantic.Type.NAMED =>
                        new Semantic.Type.REFERENCE(location, symbol, types)
            );

        get_bool_type() -> Semantic.Type.NAMED =>
            get_type(
                "bool",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.BOOL(symbol)
            );


        get_char_type() -> Semantic.Type.NAMED =>
            get_type(
                "char",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.CHAR(symbol)
            );

        get_byte_type() -> Semantic.Type.NAMED =>
            get_type(
                "byte",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.BYTE(symbol)
            );

        get_ubyte_type() -> Semantic.Type.NAMED =>
            get_type(
                "ubyte",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.UBYTE(symbol)
            );
            
        get_short_type() -> Semantic.Type.NAMED =>
            get_type(
                "short",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.SHORT(symbol)
            );

        get_ushort_type() -> Semantic.Type.NAMED =>
            get_type(
                "ushort",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.USHORT(symbol)
            );
            
        get_int_type() -> Semantic.Type.NAMED =>
            get_type(
                "int",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.INT(symbol)
            );

        get_uint_type() -> Semantic.Type.NAMED =>
            get_type(
                "uint",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.UINT(symbol)
            );

        get_long_type() -> Semantic.Type.NAMED =>
            get_type(
                "long",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.LONG(symbol)
            );
            
        get_ulong_type() -> Semantic.Type.NAMED =>
            get_type(
                "ulong",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.ULONG(symbol)
            );

        get_word_type() -> Semantic.Type.NAMED =>
            get_type(
                "word",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.WORD(symbol)
            );            

        get_uword_type() -> Semantic.Type.NAMED =>
            get_type(
                "uword",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.WORD(symbol)
            );   
             
        get_single_type() -> Semantic.Type.NAMED =>
            get_type(
                "single",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.SINGLE(symbol)
            );            

        get_double_type() -> Semantic.Type.NAMED =>
            get_type(
                "double",
                (
                    location: Source.LOCATION,
                    symbol: Semantic.Symbol.Classy
                ) -> Semantic.Type.NAMED
                    => new Semantic.Type.DOUBLE(symbol)
            );                        
            
        get_void_type() -> Semantic.Type.NAMED =>
            get_type("void", typeof void);

        get_unspecialized_enum_type() -> Semantic.Type.NAMED =>
            get_type("ENUM", cast TYPE(null));
    si

    class SYSTEM_SYMBOL_LOOKUP: InnateSymbolLookup is
        init(
            logger: Logging.Logger,
            symbol_table: SYMBOL_TABLE,
            dotnet_symbol_table: LAZY[DotNet.SYMBOL_TABLE]
        ) is
            super.init(
                logger,
                symbol_table,
                dotnet_symbol_table,
                "System"
            );
        si

        get_object_type() -> Semantic.Type.NAMED =>
            get_type("Object", typeof object);

        get_value_type() -> Semantic.Type.NAMED =>
            get_type("ValueType", typeof ValueType);

        get_string_type() -> Semantic.Type.NAMED =>
            get_type("String", typeof string);

        get_exception_type() -> Semantic.Type.NAMED =>
            get_type("Exception", typeof Exception);

        get_type_type() -> Semantic.Type.NAMED =>
            get_type("Type2", typeof TYPE);
    si

    class COLLECTIONS_SYMBOL_LOOKUP: InnateSymbolLookup is
        init(
            logger: Logging.Logger,
            symbol_table: SYMBOL_TABLE,
            dotnet_symbol_table: LAZY[DotNet.SYMBOL_TABLE]
        ) is
            super.init(
                logger,
                symbol_table,
                dotnet_symbol_table,
                "Collections"
            );
        si

        get_unspecialized_iterable_type() -> Semantic.Type.NAMED =>
            get_type("Iterable", typeof Collections.Iterable);

        get_unspecialized_iterator_type() -> Semantic.Type.NAMED =>
            get_type("Iterator", typeof Collections.Iterator);
    si
si