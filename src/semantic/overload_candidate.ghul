namespace Semantic is
    class OVERLOAD_CANDIDATE is
        _invalid: OVERLOAD_CANDIDATE static;

        _matches: Collections.LIST[Types.MATCH];

        INVALID: OVERLOAD_CANDIDATE static is
            if !_invalid? then
                _invalid = new OVERLOAD_CANDIDATE(null, 0);
                _invalid._set_different();
            fi

            return _invalid;
        si

        function: Symbols.Function;

        count: int => _matches.count;

        match: Types.MATCH; // worst match
        matches: Collections.List[Types.MATCH] => _matches;

        is_valid: bool => match != Types.MATCH.DIFFERENT;

        init(
            function: Symbols.Function,
            capacity: int // might need to be argument count + 1?
        ) is
            match = Types.MATCH.SAME;
            _matches = new Collections.LIST[Types.MATCH](capacity);

            self.function = function;
        si

        set(function: Symbols.Function) is
            self.function = function;
        si
        
        set(function: Symbols.Function, match: Types.MATCH) is
            self.function = function;
            self.match = match;
        si

        compare_to(others: Collections.Iterable[OVERLOAD_CANDIDATE]) -> int is
            for other in others do
                let diff = compare_to(other);

                if diff > 0 then
                    return 1;
                elif diff == 0 then
                    return 0;
                fi                
            od
            
            return -1;
        si
        
        compare_to(other: OVERLOAD_CANDIDATE) -> int is
            if other.match == Types.MATCH.DIFFERENT then
                if match == Types.MATCH.DIFFERENT then
                    return 0;
                else
                    return -1;
                fi
            elif match == Types.MATCH.DIFFERENT then                
                return 1;
            fi

            assert count == other.count;

            if count == 0 then
                return 0;
            fi
            
            let seen_any_better_than_self = false;
            let seen_any_worse_than_self = false;

            for i in 0..count do
                let self_match = cast int(_matches[i]);
                let other_match = cast int(other._matches[i]);

                // FIXME: Types.MATCH.PARTIAL

                if self_match > other_match then
                    seen_any_better_than_self = true;
                elif self_match < other_match then
                    seen_any_worse_than_self = true;
                fi

                if seen_any_better_than_self /\ seen_any_worse_than_self then
                    return 0; // ambiguous
                fi
            od

            if seen_any_worse_than_self then
                return -1;
            elif seen_any_better_than_self then                
                return 1;
            fi
            
            assert false else "do not expect ambiguous result here";
        si



        add(match: Types.MATCH) is
            if cast int(match) > cast int(self.match) then
                self.match = match;
            fi
            
            _matches.add(match);
        si

        _compare_arg(other: OVERLOAD_CANDIDATE, index: int) -> int is
            let a = cast int(_matches[index]);
            let b = cast int(other._matches[index]);
            
            if a < b then
                return -1;
            elif a > b then
                return 1;
            else
                return 0;
            fi
        si

        _set_different() is
            match = Types.MATCH.DIFFERENT;
        si        
    si
si
