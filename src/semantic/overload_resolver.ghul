namespace Semantic is
    use System.Exception;

    use Logging;
    use Source;

    use Types.Type;

    class OVERLOAD_RESOLVE_RESULT is
        function: Symbols.Function;
        score: Types.MATCH;

        init(function: Symbols.Function, score: Types.MATCH) is
            self.function = function;
            self.score = score;
        si
    si

    class OVERLOAD_MATCHES_RESULT is
        results: Collections.List[Symbols.Function];
        best_result_index: int;
        current_parameter_index: int public;

        init(
            results: Collections.List[Symbols.Function],
            best_result_index: int,
            current_parameter_index: int
        )
        is
            self.results = results;
            self.best_result_index = best_result_index;
            self.current_parameter_index = current_parameter_index;
        si
    si

    class OVERLOAD_RESOLVER is
        _logger: Logger;

        init(logger: Logger) is
            super.init();

            _logger = logger;
        si

        resolve(
            location: LOCATION,
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type],
            want_infer: bool,
            want_instance: bool
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            let mark = _logger.mark();

            try
                return _resolve(location, group, arguments, want_infer, want_instance);
            catch e: Exception
                _logger.release(mark);

                _logger.exception(location, e, "exception resolving overload: {group} arguments {arguments}");
                return null;

            finally
                _logger.release(mark);
            yrt
        si

        find_matches(
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type]
        ) -> OVERLOAD_MATCHES_RESULT
        is
            let mark = _logger.mark();

            try
                return _find_matches(group, arguments);
            catch e: Exception
                _logger.release(mark);

                _logger.exception(null, e, "exception resolving overload: {group} arguments {arguments}");
                return null;

            finally
                _logger.release(mark);
            yrt
        si

        _resolve(
            location: LOCATION,
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type],
            want_infer: bool,
            want_instance: bool
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            if group == null \/ group.functions == null \/ arguments == null then
                return null;
            fi

            let use debug_dispose = debug_enter();

            // TODO pass this in as this is not a reliable check - user could
            // be calling "init" directly
            let is_constructor_call = group.name =~ "init";

            // FIXME: this could just as well be applied to any parameters of generic type, not just anon functions
            let needs_second_call = want_infer /\ arguments | .any(a => a? /\ a.is_function_with_any_implicit_argument_types);

            let is_ambiguous = false;

            let best_score = cast int (Types.MATCH.DIFFERENT);
            let result: Symbols.Function;

            let ambiguous_matches: Collections.LIST[Symbols.Function];

            let functions_to_search = group.functions | .filter(f => want_instance \/ !f.is_instance);

            // We need to return PARTIAL if any actual argument types are wild. 'PARTIAL' provides
            // the caller with the best match we can find, and the caller is expecte to use that
            // to bind any unknown types in the actual arguments and retry

            for f in functions_to_search do
                let actual = f;

                if f.arguments == null then
                    return OVERLOAD_RESOLVE_RESULT(f, Types.MATCH.DIFFERENT);
                elif f.arguments.count == 0 /\ arguments.count == 0 then
                    return OVERLOAD_RESOLVE_RESULT(f, Types.MATCH.SAME);
                elif f.arguments.count == arguments.count then
                    let any_wild = false;
                    let any_other_wild = false;
                    let score = cast int(Types.MATCH.SAME);

                    let owner_symbol = cast Symbols.Classy(f.owner);

                    for i in 0..f.arguments.count do
                        let match: Types.MATCH;

                        let f_arg = f.arguments[i];
                        let arg = arguments[i];

                        if f_arg? /\ arg? then
                            match = f_arg.compare(arg);

                            debug("arg #{i} match {match} {f_arg} vs {arg}");

                            if match == Types.MATCH.DIFFERENT then
                                // if any argument type compare returns DIFFERENT then
                                // this overload cannot match the supplied arguments
                                // even allowing for type argument inference of any
                                // type arguments in the formal arguments or of
                                // unknown types in the actual arguments, so
                                // bail on this overload immediately:
                                score = cast int(Types.MATCH.DIFFERENT);
                                break;
                            fi

                            // MATCH.WILD could mean:
                            // 1. the formal argument is 'wild', i.e. its type expression includes
                            // a generic type argument that may be free and we should try to bind it
                            // based on pattern matching the actual argument type
                            // 2. the actual argument is 'wild', which means its type expression
                            // may include unknown types

                            // in scenario 1. we need to try to bind the arguments, but in scenario 2.
                            // the caller will try again with concrete types. Both scenarios are possible
                            // across the function's arguments or within a single argument

                            if match == Types.MATCH.WILD then
                                // either of both of the following has occurred:
                                // 1. the formal argument type is 'wild', i.e. its type expression
                                // includes at least one generic type argument that could be free
                                // to be bound to the type in corresponding position in the actual
                                // argument type. The type argument could be appear inside the type
                                // expression at any depth, for example `List[T]` or `int -> T`
                                // 2. the actual argument type is 'any', i.e. its type expression
                                // includes at least one unknown type where the actual type can
                                // potentially be infered based on the formal argument type
                               
                                // we need first to figure out which it is. If it's both then type
                                // inference probably isn't possible, but we can still attempt it

                                // try to determine if the 

                                if !f.is_generic /\ f.is_instance /\ !is_constructor_call then
                                    // this is an instance method, it's not generic and it's not a constructor call
                                    // we don't support type inference for scenario 1 here, so this overload is
                                    // no good as-is

                                    if arg.is_wild then
                                        debug("formal arg may be generic but not free. actual arg is wild");

                                        // but the caller may retry with concrete types
                                        any_other_wild = true;
                                    else
                                        debug("formal arg may be generic but not free. actual arg is not wild");
                                    fi
                                    match = Types.MATCH.DIFFERENT;
                                elif !f_arg.is_wild then
                                    // this formal argument isn't wild, but we got a wild match, so the actual
                                    // argument must be wild:

                                    if arg.is_wild then
                                        debug("function may be generic but formal arg is not wild. actual arg is wild");

                                        // the caller may retry with concrete types
                                        any_other_wild = true;
                                    else
                                        debug("function may be generic but neither formal arg nor actual arg are wild");

                                        _logger.info(location, "weird arg #{i} wild match but neither formal nor actual types are wild {f_arg} vs {arg}");
                                    fi

                                    match = Types.MATCH.DIFFERENT;
                                else
                                    debug("context is generic and formal arg is wild. actual arg wild {arg.is_wild}");

                                    // this is either a generic static method or a generic constructor call, and
                                    // this formal argument is wild. we're assuming this means the arg
                                    // is an unbound type argument, although I'm not certain we can actually
                                    // rely on this.

                                    // we need to attempt to bind generic arguments

                                    any_wild = true;

                                    if arg.is_wild then
                                        any_other_wild = true;
                                    fi

                                    match = Types.MATCH.SAME;
                                fi
                            fi
                        else
                            debug("bogus argument - treat as assignable");
                            match = Types.MATCH.ASSIGNABLE;
                        fi

                        score = cast int(score) + cast int(match);
                    od

                    let function_generic_argument_bindings = 
                        if any_wild /\ f.is_generic /\ score <= best_score /\ score != cast int(Types.MATCH.DIFFERENT) then
                            f.try_bind_generic_arguments(location, arguments);
                        else
                            null;
                        fi;

                    let owner_generic_argument_bindings =
                        if any_wild /\ owner_symbol? /\ owner_symbol.is_generic /\
                            (!want_instance \/ f.name =~ "init") /\
                            score <= best_score /\ score != cast int(Types.MATCH.DIFFERENT)
                        then
                            f.try_bind_owner_generic_arguments(location, arguments);
                        else
                            null
                        fi;

                    if function_generic_argument_bindings? then
                        if function_generic_argument_bindings.is_bound then
                            actual = f.specialize_function(function_generic_argument_bindings.map, null);
                        elif want_infer then
                            actual = f.specialize_function(function_generic_argument_bindings.map, null);
                            score = cast int(Types.MATCH.PARTIAL);
                        else
                            score = cast int(Types.MATCH.DIFFERENT);
                        fi
                    elif owner_generic_argument_bindings? then
                        if owner_generic_argument_bindings.is_bound then
                            let specialized_owner = Symbols.GENERIC.try_create_from(location, owner_symbol, owner_generic_argument_bindings.map);

                            if specialized_owner? then
                                actual = specialized_owner.find_specialized_function(f);
                            else
                                score = cast int(Types.MATCH.DIFFERENT);
                            fi
                        elif want_infer then
                            let specialized_owner = Symbols.GENERIC.try_create_from(location, owner_symbol, owner_generic_argument_bindings.map);

                            if specialized_owner? then
                                actual = specialized_owner.find_specialized_function(f);
                                score = cast int(Types.MATCH.PARTIAL);
                            else
                                score = cast int(Types.MATCH.DIFFERENT);
                            fi
                        else
                            score = cast int(Types.MATCH.DIFFERENT);
                        fi
                    elif any_wild then
                        score = cast int(Types.MATCH.DIFFERENT);
                    elif any_other_wild then
                        score = cast int(Types.MATCH.PARTIAL);                        
                    fi

                    // TODO what if both are bound? Could happen with a generic static method in a generic class 

                    if score == best_score /\ score != cast int(Types.MATCH.DIFFERENT) then
                        if !ambiguous_matches? then
                            ambiguous_matches = Collections.LIST[Symbols.Function]();
                        fi

                        if ambiguous_matches.count == 0 then
                            ambiguous_matches.add(result);
                        fi

                        ambiguous_matches.add(actual);

                        is_ambiguous = true;
                    elif score < best_score then
                        if ambiguous_matches? then
                            ambiguous_matches.clear();
                        fi

                        is_ambiguous = false;
                        best_score = score;
                        result = actual;
                    fi
                fi
            od

            if is_ambiguous then
                let non_object_matches = 
                    ambiguous_matches |
                        .filter(f => !f.arguments | .any(a => a.is_object));

                let count = non_object_matches | .count();

                if count == 1 then
                    result = non_object_matches | .only();
                    is_ambiguous = false;
                elif count > 1 then
                    ambiguous_matches = Collections.LIST[Symbols.Function](non_object_matches);
                fi
            fi

            if is_ambiguous then
                let non_generic_matches = 
                    ambiguous_matches | 
                        .filter(f => !f.is_generic);

                let count = non_generic_matches | .count();

                if count == 1 then
                    result = non_generic_matches | .only();
                    is_ambiguous = false;
                elif count > 1 then
                    ambiguous_matches = Collections.LIST[Symbols.Function](non_generic_matches);
                fi
            fi

            if result? /\ !is_ambiguous then
                if needs_second_call then
                    best_score = cast int(Types.MATCH.PARTIAL);
                fi
                
                return OVERLOAD_RESOLVE_RESULT(result, cast Types.MATCH(best_score));
            fi

            if 
                arguments | .any(a => a.is_error \/ (!want_infer /\ a.is_any))
            then
                return null;
            fi

            let tried = Collections.LIST[Symbols.Function](20);

            for f in functions_to_search do
                if f.arguments.count == arguments.count then
                    tried.add(f);
                fi
            od

            let maybe_static = "";

            if !want_instance then
                maybe_static = "static ";
            fi

            if is_ambiguous then
                _logger.error(
                    location, 
                    "call is ambiguous {group.name}({arguments|}), tried {get_sorted_function_list_as_string(ambiguous_matches)}"
                );
            elif tried.count > 0 then
                _logger.error(
                    location, 
                    "no {maybe_static}overload found for {group.name}({arguments|}), tried {get_sorted_function_list_as_string(tried)}"
                );
            else
                _logger.error(location, "no {maybe_static}overload found for {group.name}({arguments|})");
            fi

            return null;
        si

        get_sorted_function_list_as_string(functions: Collections.Iterable[Symbols.Function]) -> string static =>
            functions |
                .map(f => f.to_string())
                .sort()
                .to_string();        

        _find_matches(
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type]
        ) -> OVERLOAD_MATCHES_RESULT
        is
            if group == null \/ group.functions == null \/ arguments == null then
                return null;
            fi

            if group.functions.count == 0 then
                return null;
            fi

            if group.functions.count == 1 \/ arguments.count == 0 then
                return OVERLOAD_MATCHES_RESULT(group.functions, 0, -1);
            fi

            let results = Collections.LIST[Symbols.Function]();

            let best_score = cast int(Types.MATCH.DIFFERENT) * arguments.count;
            let best_index = -1;

            for f in group.functions do
                if f.arguments.count >= arguments.count then
                    let score = cast int(Types.MATCH.SAME);

                    for i in 0..arguments.count do
                        let match: Types.MATCH;

                        if f.arguments[i]? /\ arguments[i]? then
                            match = f.arguments[i].compare(arguments[i]);

                            if match == Types.MATCH.DIFFERENT then
                                score = cast int(Types.MATCH.DIFFERENT);
                            fi
                        else
                            match = Types.MATCH.ASSIGNABLE;
                        fi

                        score = score + cast int(match);
                    od

                    results.add(f);

                    if score < best_score then
                        best_score = score;
                        best_index = results.count - 1;
                    fi
                fi
            od

            return
                OVERLOAD_MATCHES_RESULT(
                    results,
                    best_index,
                    -1
                );
        si
    si
si