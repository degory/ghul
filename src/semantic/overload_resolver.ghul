namespace Semantic is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use Std = System.Console;

    use System;
    
    use Logging;
    use Source;

    use Types.Type;

    class OVERLOAD_RESOLVE_RESULT is
        function: Symbols.Function;
        score: Types.MATCH;

        init(function: Symbols.Function, score: Types.MATCH) is
            self.function = function;
            self.score = score;
        si
    si

    class OVERLOAD_MATCHES_RESULT is
        results: Collections.LIST[Symbols.Function];
        best_result_index: int;
        current_parameter_index: int public;

        init(
            results: Collections.LIST[Symbols.Function],
            best_result_index: int,
            current_parameter_index: int
        )
        is
            self.results = results;
            self.best_result_index = best_result_index;
            self.current_parameter_index = current_parameter_index;
        si
    si

    class OVERLOAD_RESOLVER is
        _logger: Logger;

        init(logger: Logger) is
            super.init();

            _logger = logger;
        si

        resolve(
            location: LOCATION,
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.LIST[Type],
            want_error: bool
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            try
                return _resolve(location, group, arguments, want_error);
            catch e: Exception
                _logger.exception(location, e, "exception resolving overload: " + group + " arguments " + arguments);
                return null;
            yrt
        si

        find_matches(
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.LIST[Type]
        ) -> OVERLOAD_MATCHES_RESULT
        is
            try
                return _find_matches(group, arguments);
            catch e: Exception
                _logger.exception(null, e, "exception resolving overload: " + group + " arguments " + arguments);
                return null;
            yrt            
        si

        _resolve(
            location: LOCATION,
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.LIST[Type],
            want_error: bool            
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            if group == null || group.functions == null || arguments == null then
                return null;
            fi

            let is_ambiguous = false;

            let best_score = Types.MATCH.DIFFERENT;
            var result: Symbols.Function;

            let ambiguous_matches: Collections.LIST[Symbols.Function];

            let seen_any_any = false;

            for f in group.functions do
                if f.arguments == null then
                    return new OVERLOAD_RESOLVE_RESULT(f, Types.MATCH.DIFFERENT);
                elif f.arguments.count == 0 && arguments.count == 0 then
                    return new OVERLOAD_RESOLVE_RESULT(f, Types.MATCH.SAME);
                elif f.arguments.count == arguments.count then
                    var score = Types.MATCH.SAME;

                    for i in 0..f.arguments.count do
                        var match: Types.MATCH;

                        let f_arg = f.arguments[i];
                        let arg = arguments[i];

                        if f_arg? && arg? then
                            match = f_arg.compare(arg);

                            if match == Types.MATCH.DIFFERENT then
                                score = Types.MATCH.DIFFERENT;

                                @IF.debug()
                                if f.name.contains("split") then
                                    Std.error.write_line("callee: " + f.arguments[i]);
                                    dump_ancestors(f.arguments[i], 1);
                                    Std.error.write_line("caller: " + arguments[i]);
                                    dump_ancestors(arguments[i], 1);    
                                fi
                                
                                break;
                            elif arg.is_any then
                                seen_any_any = true;
                            fi
                        else
                            match = Types.MATCH.ASSIGNABLE;
                        fi

                        score = cast Types.MATCH(cast int(score) + cast int(match));
                    od

                    if score == best_score && score != Types.MATCH.DIFFERENT then
                        if !ambiguous_matches? then
                            ambiguous_matches = new Collections.LIST[Symbols.Function]();
                        fi

                        if ambiguous_matches.count == 0 then
                            ambiguous_matches.add(result);
                        fi

                        ambiguous_matches.add(f);
                        is_ambiguous = true;
                    elif score < best_score then
                        if ambiguous_matches? then
                            ambiguous_matches.clear();
                        fi
                        is_ambiguous = false;
                        best_score = score;
                        result = f;
                    fi
                fi
            od

            if result? && !is_ambiguous then
                return new OVERLOAD_RESOLVE_RESULT(result, best_score);
            fi

            if want_error && !seen_any_any then
                let tried = new Collections.LIST[Symbols.Function](20);

                for f in group.functions do
                    if f.arguments.count == arguments.count then
                        tried.add(f);
                    fi
                od

                if is_ambiguous then
                    _logger.error(
                        location, 
                        "call is ambiguous " + group.name + "(" + new Shim.JOIN[Type](arguments) + "), tried " + new Shim.JOIN_SORTED[Symbols.Function](ambiguous_matches)
                    );
                elif tried.count > 0 then
                    _logger.error(
                        location, 
                        "no overload found for " + group.name + "(" + new Shim.JOIN[Type](arguments) + "), tried " + new Shim.JOIN_SORTED[Symbols.Function](tried)
                    );
                else
                    _logger.error(location, "no overload found for " + group.name + "(" + new Shim.JOIN[Type](arguments) + ")");
                fi
            fi

            return null;
        si        

        _find_matches(
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.LIST[Type]
        ) -> OVERLOAD_MATCHES_RESULT
        is
            if group == null || group.functions == null || arguments == null then
                return null;
            fi

            let results = new Collections.LIST[Symbols.Function]();

            let best_score = Types.MATCH.DIFFERENT;
            var best_index = -1;

            for f in group.functions do
                if f.arguments.count >= arguments.count then
                    var score = Types.MATCH.SAME;

                    for i in 0..arguments.count do
                        var match: Types.MATCH;

                        if f.arguments[i]? && arguments[i]? then
                            match = f.arguments[i].compare(arguments[i]);

                            if match == Types.MATCH.DIFFERENT then
                                score = Types.MATCH.DIFFERENT;
                                break;
                            fi
                        else
                            match = Types.MATCH.ASSIGNABLE;
                        fi

                        score = cast Types.MATCH(cast int(score) + cast int(match));
                    od

                    results.add(f);

                    if score < best_score then
                        best_score = score;
                        best_index = results.count - 1;
                    fi
                fi
            od

            return
                new OVERLOAD_MATCHES_RESULT(
                    results,
                    best_index,
                    -1
                );
        si
        
        @IF.not.blah() 
        dump_ancestors(type: Type, depth: int) static is
            for i in 0..depth do
                Std.error.write("  ");
            od
            
            Std.error.write_line("DDDDDD: " + type + "...");

            if !isa Semantic.Types.NAMED(type) then
                return;
            fi

            Std.error.write_line("DDDDDD: " + type + " symbol is a " + type.symbol.get_type());

            Std.error.write_line("DDDDDD: " + type + " unspecialized is " + type.symbol.root_unspecialized_symbol + " " + type.symbol.root_unspecialized_symbol.get_hash_code());

            for a in cast Semantic.Types.NAMED(type).symbol.ancestors do
                for i in 0..depth do
                    Std.error.write("  ");
                od

                Std.error.write_line("DDDDDD: " + type + " has ancestor " + a + " " + a.symbol + " (" + a.symbol.get_hash_code() + ") [" + new Shim.JOIN[Type](a.arguments) + "]");

                dump_ancestors(a, depth + 1);
            od
        si

    si
si