namespace Semantic is
    use System.Exception;

    use Logging;
    use Debugging;
    use Source;

    use Types.Type;

    class OVERLOAD_RESOLVE_RESULT is
        function: Symbols.Function;
        score: Types.MATCH;

        init(function: Symbols.Function, score: Types.MATCH) is
            self.function = function;
            self.score = score;
        si

        to_string() -> string => "{function} @ {score}";
    si

    class OVERLOAD_MATCHES_RESULT is
        results: Collections.List[Symbols.Function];
        best_result_index: int;
        current_parameter_index: int public;

        init(
            results: Collections.List[Symbols.Function],
            best_result_index: int,
            current_parameter_index: int
        )
        is
            self.results = results;
            self.best_result_index = best_result_index;
            self.current_parameter_index = current_parameter_index;
        si
    si

    class OVERLOAD_RESOLVER is
        _logger: Logger;
        _unbound_checker: UnboundChecker;

        init(logger: Logger, unbound_checker: UnboundChecker) is
            super.init();

            assert logger? else "logger is null";
            assert unbound_checker? else "unbound checker is null";

            _logger = logger;
            _unbound_checker = unbound_checker;
        si

        resolve(
            location: LOCATION,
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type],
            want_infer: bool,
            want_instance: bool,
            is_constructor_call: bool
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            let mark = _logger.mark();

            try
                return _resolve(location, group, arguments, want_infer, want_instance, is_constructor_call);
            catch e: Exception
                _logger.release(mark);

                _logger.exception(location, e, "exception resolving overload: {group} arguments {arguments}");
                return null;

            finally
                _logger.release(mark);
            yrt
        si

        find_matches(
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type]
        ) -> OVERLOAD_MATCHES_RESULT
        is
            let mark = _logger.mark();

            try
                return _find_matches(group, arguments);
            catch e: Exception
                _logger.release(mark);

                _logger.exception(null, e, "exception resolving overload: {group} arguments {arguments}");
                return null;

            finally
                _logger.release(mark);
            yrt
        si

        _resolve(
            location: LOCATION,
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type],
            want_infer: bool,
            want_instance: bool,
            is_constructor_call: bool
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            if group == null \/ group.functions == null \/ arguments == null then
                return null;
            fi

            let needs_second_call = want_infer; // /\ arguments | .any(a => a? /\ a.is_any_any);

            let is_ambiguous = false;
            let some_generic = false;
            let all_generic = true;

            let best_score = cast int (Types.MATCH.DIFFERENT);
            let result: Symbols.Function;

            let ambiguous_matches: Collections.LIST[Symbols.Function];

            let functions_to_search = group.functions | .filter(f => want_instance \/ !f.is_instance /\ f.arguments.count == arguments.count);

            let multiple_possible = functions_to_search.count() > 1;

            // We need to return PARTIAL if any actual argument types are wild. 'PARTIAL' provides
            // the caller with the best match we can find, and the caller is expected to use that
            // to bind any unknown types in the actual arguments and then try overload resolution
            // again

            let use debug_dispose = debug_enter();

            debug("resolve {group.name} {arguments|} ...");

            for f in functions_to_search do
                let actual = f;

                let any_unbound_generic_arguments = false;
                let unbound_arg_count = 0;

                if f.arguments == null then
                    return OVERLOAD_RESOLVE_RESULT(f, Types.MATCH.DIFFERENT);
                elif f.arguments.count == 0 /\ arguments.count == 0 then
                    return OVERLOAD_RESOLVE_RESULT(f, Types.MATCH.SAME);
                elif f.arguments.count == arguments.count then
                    let (want_try_bind_owner_generic_arguments, want_try_bind_function_generic_arguments) =
                        _get_try_bind_generic_arguments(f, is_constructor_call);

                    debug("consider {f} {f.arguments |} vs {arguments |}");

                    let try_bind_generic_arguments = false;
                    let score = cast int(Types.MATCH.SAME);

                    let owner_symbol = cast Symbols.Classy(f.owner);

                    for i in 0..f.arguments.count do
                        let use debug_dispose = debug_enter();
                        let match: Types.MATCH;

                        let formal_arg = f.arguments[i];
                        let actual_arg = arguments[i];
                        
                        if formal_arg? /\ actual_arg? then
                            match = formal_arg.compare(actual_arg);

                            let f_arg_unbound_count = formal_arg.unbound_count(_unbound_checker);
                            let a_arg_unbound_count = actual_arg.unbound_count(_unbound_checker);

                            if actual_arg.unbound_count(_unbound_checker) > 0 then
                                any_unbound_generic_arguments = true;
                            fi

                            debug("arg #{i} {formal_arg} ({f_arg_unbound_count}) vs {actual_arg} ({a_arg_unbound_count}) match {match}");

                            if match == Types.MATCH.DIFFERENT then
                                // if any argument type compare returns DIFFERENT then
                                // this overload cannot match the supplied arguments
                                // even allowing for type argument inference of any
                                // type arguments in the formal arguments or of
                                // unknown types in the actual arguments, so
                                // bail on this overload immediately:
                                score = cast int(Types.MATCH.DIFFERENT);
                                break;
                            elif match == Types.MATCH.WILD then
                                // either or both of the following has occurred:
                                // 1. the formal argument type is 'wild', i.e. its type expression
                                //    includes at least one generic type argument that could be free
                                //    to be bound to the type in corresponding position in the actual
                                //    argument type. The type argument could be appear inside the type
                                //    expression at any depth, for example `List[T]` or `int -> T`
                                // 2. the actual argument type is 'any', i.e. its type expression
                                //    includes at least one unknown type where the actual type can
                                //    potentially be infered based on the formal argument type
                               
                                // we need first to figure out which it is. If it's both then type
                                // inference probably isn't possible, but we will still attempt it

                                if formal_arg.is_wild then
                                    // this formal argument is wild, we need to figure out if any
                                    // type arguments in it could be free in this context

                                    // if the overload is an instance method we then can't supply
                                    // actual type parameters to its owning class/struct either explicitly
                                    // or via inference - they're already applied to the instance we're
                                    // calling the method on

                                    // if the overload is a static method, we can potentially supply
                                    // actual type arguments for its owning class

                                    // and in either case we can supply actual type arguments for the
                                    // method itself

                                    // if the function is a global function then we can supply actual
                                    // type arguments for it

                                    // if the function is a constructor, and we're calling it for a
                                    // constructor expression, it cannot have generic arguments but
                                    // its owning type can, and we do want to supply them if we
                                    // can infer them from this overload
                                    match = Types.MATCH.SAME;

                                    try_bind_generic_arguments = true;
                                else
                                    // other argument is wild
                                    // TODO need proper pattern match here
                                fi
/* 
                            elif actual_arg.is_any_any then
                                // FIXME don't think this can be hit
                                debug("actual argument {actual_arg} is any any {actual_arg.any_count}");

                                // The actual argument is any, or is constructed from any. Treat this argument as if it
                                // matches and see if that results in an unambiguous overload result. If so, the caller
                                // can use the argument type from that result to try to infer the actual type of this
                                // argument
                                
                                // FIXME not sure it makes sense to be setting score here - should be match
                                score = cast int(Types.MATCH.PARTIAL);
*/
                            fi
                        else
                            // something wrong with the argument - treat it as a moderate quality match
                            match = Types.MATCH.ASSIGNABLE;
                        fi

                        score = cast int(score) + cast int(match);

                        if score == cast int(Types.MATCH.PARTIAL) then
                            debug("oops accidentally PARTIAL");
                            score = score + 1;
                        fi
                    od

                    // FIXME improves some scenarios, breaks others
                    if any_unbound_generic_arguments /\ multiple_possible then
                        debug("unbound generic arguments: ignore");
                        // if all actual args are wildcards then 
                        // TODO we should pattern match to improve this - we shouldn't 'wild' match
                        // any type expression with a 'wild' type anywhere in it - the shape of
                        // the expressions need to match


                        // TODO how 'wild' a generic type argument is depends on context
                        // if it's inside the function or type that declares it it's not actually wild

                        continue;
                    else
                        debug("possible candidate any unbound: {any_unbound_generic_arguments} multiple possible: {multiple_possible}");
                    fi

                    if try_bind_generic_arguments /\ score <= best_score /\ score < cast int(Types.MATCH.DIFFERENT) then
                        debug("try bind generic arguments");

                        // if we saw any generic argument types in any of the function formal argument types
                        // then we need to try to bind them to concrete types from the corresponding actual
                        // argument types

                        let function_generic_argument_bindings = 
                            if want_try_bind_function_generic_arguments then
                                debug("try bind function generic arguments");
                                some_generic = true;
                                f.try_bind_generic_arguments(location, arguments);
                            else
                                null;
                            fi;

                        let owner_generic_argument_bindings =
                            if want_try_bind_owner_generic_arguments then
                                debug("try bind owner generic arguments");
                                some_generic = true;
                                f.try_bind_owner_generic_arguments(location, arguments);
                            else
                                null
                            fi;

                        if function_generic_argument_bindings? then
                            if function_generic_argument_bindings.is_bound then
                                actual = f.specialize_function(function_generic_argument_bindings.map, null);
                                debug("specialized function is {actual}");
                            elif needs_second_call then
                                actual = f.specialize_function(function_generic_argument_bindings.map, null);
                                debug("specialized function is {actual}");
                                score = cast int(Types.MATCH.PARTIAL);
                                debug("PARTIAL because incomplete function generic binding {function_generic_argument_bindings.bindings.values |}");
                            else
                                score = cast int(Types.MATCH.DIFFERENT);
                            fi
                        elif owner_generic_argument_bindings? then
                            if owner_generic_argument_bindings.is_bound then
                                let specialized_owner = Symbols.GENERIC.try_create_from(location, owner_symbol, owner_generic_argument_bindings.map);

                                if specialized_owner? then
                                    actual = specialized_owner.find_specialized_function(f);
                                    debug("specialized member function is {actual}");                                    
                                else
                                    score = cast int(Types.MATCH.DIFFERENT);
                                fi
                            elif needs_second_call then
                                let specialized_owner = Symbols.GENERIC.try_create_from(location, owner_symbol, owner_generic_argument_bindings.map);

                                if specialized_owner? then
                                    actual = specialized_owner.find_specialized_function(f);
                                    debug("specialized member function is {actual}");
                                    score = cast int(Types.MATCH.PARTIAL);
                                    debug("PARTIAL because incomplete owner generic binding {owner_generic_argument_bindings.bindings.values}");
                                else
                                    score = cast int(Types.MATCH.DIFFERENT);
                                fi
                            else
                                score = cast int(Types.MATCH.DIFFERENT);
                            fi
                        else
                            score = cast int(Types.MATCH.DIFFERENT);                        
                        fi
                    else
                        all_generic = false;
                    fi

                    if score == best_score /\ score != cast int(Types.MATCH.DIFFERENT) then
                        if !ambiguous_matches? then
                            ambiguous_matches = Collections.LIST[Symbols.Function]();
                        fi

                        if ambiguous_matches.count == 0 then
                            ambiguous_matches.add(result);
                        fi

                        ambiguous_matches.add(actual);

                        is_ambiguous = true;
                    elif score < best_score then
                        if ambiguous_matches? then
                            ambiguous_matches.clear();
                        fi

                        is_ambiguous = false;
                        best_score = score;
                        result = actual;
                    fi
                fi
            od

            if is_ambiguous then
                debug("ambiguous");

                let non_object_matches = 
                    ambiguous_matches |
                        .filter(f => !f.arguments | .any(a => a.is_object));

                let count = non_object_matches | .count();

                if count == 1 then
                    result = non_object_matches | .only();
                    is_ambiguous = false;
                elif count > 1 then
                    ambiguous_matches = Collections.LIST(non_object_matches);
                fi
            fi

            if is_ambiguous then
                debug("ambiguous");

                let non_generic_matches = 
                    ambiguous_matches | 
                        .filter(f => !f.is_generic);

                let count = non_generic_matches | .count();

                if count == 1 then
                    result = non_generic_matches | .only();
                    is_ambiguous = false;
                elif count > 1 then
                    ambiguous_matches = Collections.LIST(non_generic_matches);
                fi
            fi

            if result? /\ !is_ambiguous then
                debug("have result {result}");

                if needs_second_call then
                    debug("PARTIAL because needs second call");
                    best_score = cast int(Types.MATCH.PARTIAL);
                fi
                
                return OVERLOAD_RESOLVE_RESULT(result, cast Types.MATCH(best_score));
            fi

            if 
                arguments | .any(a => a.is_error \/ (!want_infer /\ a.is_any))
            then
                return null;
            fi

            let tried =
                functions_to_search |
                    .filter(f => f.arguments.count == arguments.count)
                    .collect();

            let maybe_static =
                if want_instance then
                    ""
                else
                    "static ";
                fi;

            if is_ambiguous then
                _logger.error(
                    location, 
                    "call is ambiguous {group.name}({arguments|}), tried {_get_sorted_function_list_as_string(ambiguous_matches)}"
                );

                let type_args_hint = _get_possible_type_argument_names_hint(ambiguous_matches, is_constructor_call, some_generic /\ all_generic);

                if type_args_hint? then
                    _logger.hint(location, type_args_hint)
                fi
            elif tried.count > 0 then
                _logger.error(
                    location, 
                    "no {maybe_static}overload found for {group.name}({arguments|}), tried {_get_sorted_function_list_as_string(tried)}"
                );

                let type_args_hint = _get_possible_type_argument_names_hint(tried, is_constructor_call, some_generic /\ all_generic);

                if type_args_hint? then
                    _logger.hint(location, type_args_hint)
                fi
            else
                _logger.error(location, "no {maybe_static}overload found for {group.name}({arguments|})");
            fi

            return null;
        si

        _get_try_bind_generic_arguments(f: Symbols.Function, is_constructor_call: bool) -> (bool, bool) =>
            if is_constructor_call then
                // construct call we can only bind type arguments
                // on the owning type - the constructor itself
                // cannot be generic:
                (f.owner.is_generic, false)
            elif f.is_instance then
                // instance functions can be generic but an instance
                // call cannot bind type parameters of the owning
                // type
                (false, f.is_generic)
            else
                // static or global function can bind function
                // arguments or owning type's arguments, if
                // present
                (f.owner.is_generic, f.is_generic)
            fi;

        _get_possible_type_argument_names_hint(functions: Collections.Iterable[Symbols.Function], is_constructor_call: bool, any_generic: bool) -> string =>
            let possible_type_argument_names =
                if any_generic then
                    _get_possible_type_argument_names(functions, is_constructor_call)
                else
                    System.Array.empty[string]()
                fi,
                result = possible_type_argument_names | .to_string()
            in
                if result.length > 0 then
                    "try supplying explicit type arguments {result}"
                else
                    null
                fi;

        _get_possible_type_argument_names(functions: Collections.Iterable[Symbols.Function], is_constructor_call: bool) -> Collections.Iterable[string] is
            let possible_type_arguments = Collections.SET[string]();

            for f in functions do
                let (want_try_bind_owner_generic_arguments, want_try_bind_function_generic_arguments) =
                    _get_try_bind_generic_arguments(f, is_constructor_call);
                
                if want_try_bind_function_generic_arguments then
                    for a in f.generic_argument_names do
                        possible_type_arguments.add(a);
                    od
                fi

                if want_try_bind_owner_generic_arguments then
                    let owning_classy = cast Symbols.Classy(f.owner);

                    if owning_classy? then
                        for a in owning_classy.argument_names do
                            possible_type_arguments.add(a);
                        od
                    fi
                fi
            od

            return possible_type_arguments;
        si

        _get_sorted_function_list_as_string(functions: Collections.Iterable[Symbols.Function]) -> string static =>
            functions |
                .map(f => f.to_string())
                .sort()
                .to_string();        

        _find_matches(
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type]
        ) -> OVERLOAD_MATCHES_RESULT
        is
            if group == null \/ group.functions == null \/ arguments == null then
                return null;
            fi

            if group.functions.count == 0 then
                return null;
            fi

            if group.functions.count == 1 \/ arguments.count == 0 then
                return OVERLOAD_MATCHES_RESULT(group.functions, 0, -1);
            fi

            let results = Collections.LIST[Symbols.Function]();

            let best_score = cast int(Types.MATCH.DIFFERENT) * arguments.count;
            let best_index = -1;

            for f in group.functions do
                if f.arguments.count >= arguments.count then
                    let score = cast int(Types.MATCH.SAME);

                    for i in 0..arguments.count do
                        let match: Types.MATCH;

                        if f.arguments[i]? /\ arguments[i]? then
                            match = f.arguments[i].compare(arguments[i]);

                            if match == Types.MATCH.DIFFERENT then
                                score = cast int(Types.MATCH.DIFFERENT);
                            fi
                        else
                            match = Types.MATCH.ASSIGNABLE;
                        fi

                        score = score + cast int(match);
                    od

                    results.add(f);

                    if score < best_score then
                        best_score = score;
                        best_index = results.count - 1;
                    fi
                fi
            od

            return
                OVERLOAD_MATCHES_RESULT(
                    results,
                    best_index,
                    -1
                );
        si
    si
si