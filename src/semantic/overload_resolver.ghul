namespace Semantic is
    use System.Exception;

    use Logging;
    use Source;

    use Types.Type;
    
    class OVERLOAD_RESOLVER is
        _logger: Logger;

        init(logger: Logger) is
            super.init();

            _logger = logger;
        si

        resolve_call(
            location: LOCATION,
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type],
            want_infer: bool,
            want_instance: bool
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            try
                if group == null \/ group.functions == null \/ arguments == null then
                    return null;
                fi

                let functions = group.functions | .filter(f => want_instance \/ !f.is_instance);

                let search_type = "";

                if !want_instance then
                    search_type = "static ";
                fi

                // FIXME: this could just as well be applied to any parameters of generic type, not just anon functions
                let needs_second_call = want_infer /\ arguments | .has(a => a? /\ a.is_function_with_any_implicit_argument_types);
                        
                return _resolve(location, group.name, functions, arguments, null, want_infer, needs_second_call, search_type);
            catch e: Exception
                _logger.exception(location, e, "exception resolving overload: " + group + " arguments " + arguments);
                return null;
            yrt
        si

        resolve_binary(
            location: LOCATION,
            name: string,
            functions: Collections.Iterable[Symbols.Function],
            left: Type,
            right: Type
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            try
                let search_type = "operator ";
                        
                return _resolve(location, name, functions, [right], [left, right], false, false, search_type);
            catch e: Exception
                _logger.exception(location, e, "exception resolving overload: " + left + " " + name + " " + right);
                return null;
            yrt
        si

        find_matches(
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type]
        ) -> OVERLOAD_MATCHES_RESULT
        is
            try
                return _find_matches(group, arguments);
            catch e: Exception
                _logger.exception(null, e, "exception resolving overload: " + group + " arguments " + arguments);
                return null;
            yrt
        si

        _resolve(
            location: LOCATION,
            name: string,
            functions: Collections.Iterable[Symbols.Function],
            instance_arguments: Collections.List[Type],
            static_arguments: Collections.List[Type],
            want_infer: bool,
            needs_second_call: bool,
            search_type: string
        ) -> OVERLOAD_RESOLVE_RESULT
        is
            let candidates = new Collections.LIST[OVERLOAD_CANDIDATE]();

            for f in functions do
                let actual = f;

                let arguments: Collections.List[Type];

                if !f.is_instance /\ static_arguments? then
                    arguments = static_arguments;
                else
                    arguments = instance_arguments;
                fi

                if f.arguments == null then
                    return new OVERLOAD_RESOLVE_RESULT(f, Types.MATCH.DIFFERENT);
                elif f.arguments.count == 0 /\ arguments.count == 0 then
                    // FIXME: could be ambiguous
                    return new OVERLOAD_RESOLVE_RESULT(f, Types.MATCH.SAME);
                elif f.arguments.count == arguments.count then
                    // need to track each argument's score separately along with a
                    // score for the whole function

                    let candidate = _get_function_candidate(f, arguments);

                    if !candidate.is_valid then
                        continue;
                    fi

                    let diff = candidate.compare_to(candidates);

                    if diff > 0 then
                        continue;
                    fi
                    
                    if f.is_generic then
                        let bindings = f.try_bind_generic_arguments(location, arguments);

                        if !bindings? then
                            continue;
                        elif bindings.is_bound then
                            actual = f.specialize_function(bindings.map, null);

                            candidate.set(actual);
                        elif want_infer then
                            actual = f.specialize_function(bindings.map, null);

                            candidate.set(actual, Types.MATCH.PARTIAL);
                            // FIXME: what here?
                            // score = cast int(Types.MATCH.PARTIAL);
                        else
                            continue;
                        fi
                    fi

                    
                fi
            od
            

            if is_ambiguous then
                let non_object_matches = 
                    current_matches |
                        .filter(f => !f.arguments | .has(a: Type => a.is_object)); // FIXME: intermittent issue in VSCE if a's type not explicit here

                let count = non_object_matches | .count();

                if count == 1 then
                    result = non_object_matches | .only();
                    is_ambiguous = false;
                elif count > 1 then
                    current_matches = new Collections.LIST[Symbols.Function](non_object_matches);
                fi
            fi

            if is_ambiguous then
                let non_generic_matches = 
                    current_matches | 
                        .filter(f => !f.is_generic);

                let count = non_generic_matches | .count();

                if count == 1 then
                    result = non_generic_matches | .only();
                    is_ambiguous = false;
                elif count > 1 then
                    current_matches = new Collections.LIST[Symbols.Function](non_generic_matches);
                fi
            fi

            if is_ambiguous /\ static_arguments? then
                let instance_matches = 
                    current_matches |
                        .filter(f => f.is_instance);

                let count = instance_matches | .count();

                if count == 1 then
                    result = instance_matches | .only();
                    is_ambiguous = false;
                elif count > 1 then
                    current_matches = new Collections.LIST[Symbols.Function](instance_matches);
                fi
            fi

            if result? /\ !is_ambiguous then
                if needs_second_call then
                    best_score = cast int(Types.MATCH.PARTIAL);
                fi
                
                return new OVERLOAD_RESOLVE_RESULT(result, cast Types.MATCH(best_score));
            fi

            if 
                instance_arguments | .has(a => a.is_error \/ (!want_infer /\ a.is_any))
            then
                IO.Std.error.write_line("ignore ambiguous because error or any typed arg");
                return null;
            fi

            let tried = new Collections.LIST[Symbols.Function](20);

            for f in functions do
                if 
                    f.arguments.count == instance_arguments.count \/
                    (static_arguments? /\ !f.is_instance /\ f.arguments.count == static_arguments.count)
                then
                    tried.add(f);
                fi
            od

            if is_ambiguous then
                _logger.error(
                    location, 
                    "call is ambiguous " + name + "(" + instance_arguments| + "), tried " + _get_sorted_function_list_as_string(current_matches)
                );
            elif tried.count > 0 then
                let arguments = instance_arguments;

                if static_arguments? then
                    arguments = static_arguments;
                fi                

                _logger.error(
                    location, 
                    "no " + search_type + "overload found for " + name + "(" + arguments| + "), tried " + _get_sorted_function_list_as_string(tried)
                );
            else
                _logger.error(location, "no " + search_type + "overload found for " + name + "(" + instance_arguments| + ")");
            fi

            return null;
        si

        _get_function_candidate(function: Symbols.Function, arguments: Collections.List[Type]) -> OVERLOAD_CANDIDATE is
            let result = new OVERLOAD_CANDIDATE(arguments.count);

            for i in 0..function.arguments.count do
                let argument_match: Types.MATCH;

                let f_arg = function.arguments[i];
                let arg = arguments[i];

                if f_arg? /\ arg? then
                    argument_match = f_arg.compare(arg);

                    if argument_match == Types.MATCH.DIFFERENT then
                        return OVERLOAD_CANDIDATE.INVALID;
                    fi

                    if argument_match == Types.MATCH.WILD then
                        argument_match = Types.MATCH.SAME;
                    fi
                else
                    argument_match = Types.MATCH.ASSIGNABLE;
                fi

                result.add(argument_match);
            od
        si
        
        _get_sorted_function_list_as_string(functions: Collections.Iterable[Symbols.Function]) -> string static =>
            functions |
                .map(f => f.to_string())
                .sort()
                .to_string();        

        _find_matches(
            group: Symbols.FUNCTION_GROUP,
            arguments: Collections.List[Type]
        ) -> OVERLOAD_MATCHES_RESULT
        is
            if group == null \/ group.functions == null \/ arguments == null then
                return null;
            fi

            let results = new Collections.LIST[Symbols.Function]();

            let best_score = cast int(Types.MATCH.DIFFERENT);
            let best_index = -1;

            for f in group.functions do
                if f.arguments.count >= arguments.count then
                    let score = cast int(Types.MATCH.SAME);

                    for i in 0..arguments.count do
                        let match: Types.MATCH;

                        if f.arguments[i]? /\ arguments[i]? then
                            match = f.arguments[i].compare(arguments[i]);

                            if match == Types.MATCH.DIFFERENT then
                                score = cast int(Types.MATCH.DIFFERENT);
                            fi
                        else
                            match = Types.MATCH.ASSIGNABLE;
                        fi

                        score = score + cast int(match);
                    od

                    results.add(f);

                    if score < best_score then
                        best_score = score;
                        best_index = results.count - 1;
                    fi
                fi
            od

            return
                new OVERLOAD_MATCHES_RESULT(
                    results,
                    best_index,
                    -1
                );
        si
    si
si