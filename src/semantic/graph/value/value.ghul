namespace Semantic.Graph.Value is
    use System;

    use Generic;

    class BASE: Object, Semantic.Type.Typed is
        has_type: bool => false;
        is_value_type: bool => has_type && type.is_value_type;
        has_address: bool => false;

        type: Type.BASE is
            throw new NotImplementedException(Object.dump(self) + " has no type");
        si

        gen(context: IR.CONTEXT) is
            throw new NotImplementedException(Object.dump(self));
        si

        gen_address(context: IR.CONTEXT) is            
            throw new NotImplementedException(Object.dump(self));
        si
        
        gen(value: BASE, context: IR.CONTEXT) static is
            if value? then
                value.gen(context);
            else
                context.fixme("null value");
            fi
        si

        init() is si
    si

    class SKIP: BASE is
        init() is
            super.init();
        si
    si

    class NEW: BASE is
        has_type: bool => type?;
        type: Type.BASE;
        constructor: Symbol.Function;
        arguments: Collections.LIST[BASE];

        init(
            type: Type.BASE,
            constructor: Symbol.Function,
            arguments: Collections.LIST[BASE]
        ) is
            super.init();

            assert(type?, "type is null");
            assert(constructor?, "constructor is null");
            assert(arguments?, "arguments is null");

            self.type = type;
            self.constructor = constructor;
            self.arguments = arguments;
        si

        gen(context: IR.CONTEXT) is
            for a in arguments do
                gen(a, context);
            od
            
            context.println("newobj instance " + constructor.il_type_name, type);
        si

        toString() -> String =>
            "new:[" + type + "](\"" + constructor.name + "\"," + arguments.get_inner() + ")";
    si

    class TYPE_WRAPPER: BASE is
        has_type: bool => type?;
        type: Type.BASE;
        value: BASE;

        init(
            type: Type.BASE,
            value: BASE
        ) is
            super.init();

            assert(type?, "type is null");
            assert(value?, "value is null");

            self.type = type;
            self.value = value;
        si

        gen(context: IR.CONTEXT) is
            gen(value, context);
        si

        toString() -> String =>
            "type_wrapper:[" + type + "](" + value + ")";        
    si

    class ADDRESS: BASE is
        _next_id: int static;

        has_type: bool => value.has_type;
        type: Type.BASE => value.type;
        value: BASE;

        name: String;

        next_name: String static is
            let result = "'.address." + _next_id + "'";

            _next_id = _next_id + 1;

            return result;
        si

        init(
            value: BASE
        ) is
            super.init();

            assert(value?, "value is null");

            self.value = value;

            name = next_name;
        si

        gen(context: IR.CONTEXT) is
            if value.has_address then
                value.gen_address(context);
            else
                context.println(".locals init (" + type.il_type_name + " " + name + ")");

                value.gen(context);
                context.println("stloc " + name);
                context.println("ldloca " + name);
            fi
        si

        toString() -> String =>
            "type_wrapper:[" + type + "](" + value + ")";        
    si

    class BOX: BASE is
        value: BASE;
        has_type: bool => type?;
        type: Type.BASE => value.type;
        is_value_type: bool => false;

        init(
            value: BASE
        ) is
            super.init();

            assert(value?, "value is null");

            self.value = value;
        si

        gen(context: IR.CONTEXT) is
            gen(value, context);

            context.println("box " + type.il_type_name);
        si

        toString() -> String =>
            "box:[" + type + "](" + value + ")";        
    si

    class UNBOX: BASE is
        value: BASE;
        has_type: bool => type?;
        type: Type.BASE => value.type;
        is_value_type: bool => true;

        init(
            value: BASE
        ) is
            super.init();

            assert(value?, "value is null");

            self.value = value;
        si

        gen(context: IR.CONTEXT) is
            gen(value, context);

            context.println("unbox.any " + type.il_type_name);
        si

        toString() -> String =>
            "unbox:[" + type + "](" + value + ")";        
    si
    
    class CAST: BASE is
        has_type: bool => type?;
        type: Type.BASE;
        value: BASE;

        init(
            type: Type.BASE,
            value: BASE
        ) is
            super.init();

            assert(type?, "type is null");

            // native generates null values, which cannot easily be prevented and which propogate, and must be cast before use: 
            // assert(value?, "value is null");

            self.type = type;
            self.value = value;
        si

        gen(context: IR.CONTEXT) is
            gen(value, context);

            context.println("castclass " + type.il_type_name);
        si

        toString() -> String =>
            "cast:[" + type + "](" + value + ")";
    si

    class ISA: BASE is
        has_type: bool => type?;
        type: Type.BASE;
        isa_type: Type.BASE;
        value: BASE;

        init(
            type: Type.BASE,
            isa_type: Type.BASE,
            value: BASE
        ) is
            super.init();

            assert(type?, "type is null");
            assert(isa_type?, "isa_type is null");
            assert(value?, "value is null");

            self.type = type;
            self.isa_type = type;
            self.value = value;
        si

        gen(context: IR.CONTEXT) is
            gen(value, context);

            context.println("isinst " + isa_type.il_type_name);
            context.println("ldnull");
            context.println("cgt.un");
        si

        toString() -> String =>
            "isa:[" + isa_type + "](" + value + ")";
    si

    class HAS_VALUE: BASE, Type.Typed is
        has_type: bool => type?;
        type: Type.BASE;

        value: BASE;

        init(
            value: BASE,
            type: Type.BASE
        ) is
            super.init();

            assert(type?, "type is null");
            assert(value?, "value is null");

            self.value = value;
            self.type = type;
        si

        gen(context: IR.CONTEXT) is
            gen(value, context);

            context.println("ldnull");
            context.println("cgt.un");
        si
    si

    class NOT: BASE, Type.Typed is
        value: BASE;

        has_Type: bool => type?;
        type: Type.BASE => value.type;
        is_value_type: bool => value.is_value_type;

        init(value: BASE) is
            super.init();

            assert(value?, "value is null");

            self.value = value;
        si

        gen(context: IR.CONTEXT) is
            BASE.gen(value, context);

            context.println("ldc.i4 0");
            context.println("ceq");
        si
    si

    class NULL: BASE, Type.Typed is
        has_type: bool => type?;
        type: Type.BASE;

        init(
            type: Type.BASE
        ) is
            super.init();

            assert(type?, "type is null");

            self.type = type;
        si

        gen(context: IR.CONTEXT) is
            context.println("ldnull");
        si
    si

    class DUMMY: BASE, Type.Typed is
        has_type: bool => type?;
        type: Type.BASE;

        init(type: Type.BASE) is
            super.init();

            assert(type?, "type is null");

            self.type = type;
        si

        gen(context: IR.CONTEXT) is
            context.fixme("dummy " + type);
        si
    si

    class NATIVE: BASE, Type.Typed is
        has_type: bool => type?;
        type: Type.BASE;

        init(type: Type.BASE) is
            super.init();

            assert(type?, "type is null");

            self.type = type;
        si

        gen(context: IR.CONTEXT) is
            context.println("native" + type);
        si
    si

    class TUPLE: BASE, Type.Typed is
        has_type: bool => type?;
        type: Type.BASE;

        values: Collections.Iterable[BASE];

        init(type: Type.BASE, values: Collections.Iterable[BASE]) is
            super.init();

            assert(type?, "type is null");
            assert(values?, "values is null");

            self.type = type;
            self.values = values;
        si

        gen(context: IR.CONTEXT) is
            for v in values do
                gen(v, context);

                context.println("tuple " + type);
            od
            
        si

        toString() -> String => "tuple:[" + type + "](" + values + ")";
    si

    namespace Need is
        class STORE: BASE is
            has_type: bool => value? && value.has_type;
            type: Type.BASE => value.type;
            value: BASE;

            init(value: BASE) is
                super.init();

                assert(value?, "value is null");    

                self.value = value;
            si

            gen(context: IR.CONTEXT) is
                gen(value, context);
                context.println("unresolved need store");
            si

            toString() -> String =>
                "need-store:[" + type + "]";
        si
    si

    namespace Expect is
        class STORABLE: BASE is
            has_type: bool => type?;
            type: Type.BASE;

            init(type: Type.BASE) is
                super.init();

                assert(type?, "type is null");
                    
                self.type = type;
            si

            gen(context: IR.CONTEXT) is
                context.println("unresolved expect");
            si

            toString() -> String =>
                "expect-storable:[" + type + "]";
        si
    si

    namespace Load is
        class SELF: BASE, Type.Typed is
            self_: Symbol.BASE;
            has_type: bool => type?;
            type: Type.BASE;

            has_address: bool => true;

            init(self_: Symbol.BASE) is
                init(self_, null);

                // IO.Std.err.println("initializing load with null type: " + self);
                // IO.Std.err.println("initializing load with null type from: " + new System.Backtrace());
            si
            
            init(self_: Symbol.BASE, type: Type.BASE) is
                super.init();

                assert(self_?, "self is null");

                assert(self_?, ClassName + " arg is null");
 
                self.self_ = self_;

                if type? then
                    self.type = type;
                elif isa Semantic.Type.Typed(self_) then
                    self.type = cast Semantic.Type.Typed(self_).type;
                fi
            si

            gen(context: IR.CONTEXT) is
                context.println("ldarg.0", "self " + type);
            si

            gen_address(context: IR.CONTEXT) is
                context.println("ldarg.0", "self " + type);
            si

            toString() -> String => "self:[" + type + "]";
        si

        class TEMP: BASE, Type.Typed is
            name: String;

            type: Type.BASE;
            has_type: bool => type?;

            has_address: bool => true;

            init(name: String, type: Type.BASE) is
                self.name = name;
                self.type = type;
            si

            gen(context: IR.CONTEXT) is
                context.println("ldloc " + name, "temp " + type);
            si

            gen_address(context: IR.CONTEXT) is
                context.println("ldloca " + name, "temp " + type);
            si

            toString() -> String =>
                "load:[" + type + "](" + name + "\")";
        si

        class SYMBOL: BASE, Type.Typed is
            symbol: Symbol.BASE;
            symbol_as_typed: Type.Typed => cast Type.Typed(symbol);
            has_type: bool => type?;
            has_address: bool => true;
            type: Type.BASE => symbol_as_typed.type;
            from: BASE;

            init(from: BASE, symbol: Symbol.BASE) is
                super.init();

                assert(symbol?, ClassName + " arg is null");

                self.from = from;
                self.symbol = symbol;
            si

            gen(context: IR.CONTEXT) is
                gen(from, context);
                context.fixme("load member " + symbol.il_qualified_name);
            si

            gen_address(context: IR.CONTEXT) is
                gen(from, context);
                context.fixme("load member address " + symbol.il_qualified_name);
            si

            toString() -> String =>
                "load:[" + type + "](" + from + ",\"" + symbol.name + "\")";
        si

        class LOCAL_VARIABLE: SYMBOL, Type.Typed is
            init(symbol: Symbol.BASE) is
                super.init(null, symbol);
            si

            gen(context: IR.CONTEXT) is
                context.println("ldloc " + symbol.il_name, symbol);
            si

            gen_address(context: IR.CONTEXT) is
                context.println("ldloca " + symbol.il_name, symbol);
            si

            toString() -> String =>
                "load:[" + type + "](" + from + ",\"" + symbol.name + "\")";
        si

        class LOCAL_ARGUMENT: SYMBOL, Type.Typed is
            init(symbol: Symbol.BASE) is
                super.init(null, symbol);
            si

            gen(context: IR.CONTEXT) is
                context.println("ldarg " + symbol.il_name, symbol);
            si

            gen_address(context: IR.CONTEXT) is
                context.println("ldarga " + symbol.il_name, symbol);
            si

            toString() -> String =>
                "load:[" + type + "](" + from + ",\"" + symbol.name + "\")";
        si

        class INSTANCE_FIELD: SYMBOL, Type.Typed is
            init(from: BASE, symbol: Symbol.BASE) is
                super.init(from, symbol);

                assert(from?, "from is null");
            si

            gen(context: IR.CONTEXT) is
                gen(from, context);
                context.println("ldfld " + symbol.il_type_name, symbol);
            si

            gen_address(context: IR.CONTEXT) is
                gen(from, context);
                context.println("ldflda " + symbol.il_type_name, symbol);
            si

            toString() -> String =>
                "load:[" + type + "](" + from + ",\"" + symbol.name + "\")";
        si

        class STATIC_FIELD: SYMBOL, Type.Typed is
            init(symbol: Symbol.BASE) is
                super.init(null, symbol);
            si

            gen(context: IR.CONTEXT) is
                context.println("ldsfld " + symbol.il_type_name, symbol);
            si

            gen_address(context: IR.CONTEXT) is
                context.println("ldsflda " + symbol.il_type_name, symbol);
            si

            toString() -> String =>
                "load:[" + type + "](\"" + symbol.name + "\")";
        si

        class INSTANCE_CLOSURE: SYMBOL, Type.Typed is
            func_type: Semantic.Type.BASE;

            has_address: bool => false;

            init(symbol: Symbol.BASE, func_type: Semantic.Type.BASE) is
                super.init(null, symbol);

                assert(func_type?, "func_type is null");
                
                self.func_type = func_type;
            si

            gen(context: IR.CONTEXT) is
                // gen(from, context);
                // context.println("ldarg.0");
                context.println("ldarg.0");
                context.println("ldftn instance " + symbol.il_type_name, symbol);
                context.println("newobj instance void " + func_type.il_type_name + "::'.ctor'(object, native int)");
            si

            toString() -> String =>
                "load:[" + type + "](" + from + ",\"" + symbol.name + "\")";
        si

    si

    namespace Store is
        class SYMBOL: BASE, Type.Typed is
            symbol: Symbol.BASE;
            symbol_as_typed: Type.Typed => cast Type.Typed(symbol);
            type: Type.BASE => symbol_as_typed.type;
            from: BASE;
            value: Graph.Value.BASE;

            init(from: BASE, symbol: Symbol.BASE, value: Graph.Value.BASE) is
                super.init();

                assert(symbol?, ClassName + " arg is null");
                assert(value?, "value is null");

                self.from = from;
                self.symbol = symbol;
                self.value = value;
            si

            gen(context: IR.CONTEXT) is
                gen(from, context);
                gen(value, context);

                context.println("store member " + symbol);
            si            

            toString() -> String =>
                "store:[" + type + "](" + from + ",\"" + symbol.name + "\"," + value + ")";
        si

        class LOCAL_VARIABLE: SYMBOL is
            init(symbol: Symbol.BASE, value: Graph.Value.BASE) is
                super.init(null, symbol, value);
            si

            gen(context: IR.CONTEXT) is
                gen(value, context);
                
                context.println("stloc " + symbol.il_name, symbol);
            si            

            toString() -> String =>
                "store:[" + type + "](" + from + ",\"" + symbol.name + "\"," + value + ")";
        si

        class LOCAL_ARGUMENT: SYMBOL, Type.Typed is
            init(symbol: Symbol.BASE, value: Graph.Value.BASE) is
                super.init(null, symbol, value);
            si

            gen(context: IR.CONTEXT) is
                gen(value, context);

                context.println("starg " + symbol.il_name, symbol);
            si

            toString() -> String =>
                "load:[" + type + "](" + from + ",\"" + symbol.name + "\")";
        si

        class INSTANCE_FIELD: SYMBOL is
            init(from: Graph.Value.BASE, symbol: Symbol.BASE, value: Graph.Value.BASE) is
                super.init(from, symbol, value);

                assert(from?, "from is null");
            si

            gen(context: IR.CONTEXT) is
                gen(from, context);
                gen(value, context);

                context.println("stfld " + symbol.il_type_name, symbol);
            si            

            toString() -> String =>
                "store:[" + type + "](" + from + ",\"" + symbol.name + "\"," + value + ")";
        si

        class STATIC_FIELD: SYMBOL is
            init(symbol: Symbol.BASE, value: Graph.Value.BASE) is
                super.init(null, symbol, value);
            si

            gen(context: IR.CONTEXT) is
                gen(value, context);

                context.println("stsfld " + symbol.il_type_name, symbol);
            si            

            toString() -> String =>
                "store:[" + type + "](\"" + symbol.name + "\"," + value + ")";
        si
    si

    namespace Call is
        class INNATE: BASE, Type.Typed is
            function: Semantic.Symbol.InnateFunction;
            from: BASE;
            arguments: Collections.LIST[BASE];
            type: Type.BASE;
            has_type: bool => type?;

            actual_operation: String public;
            
            innate_name: String => function.innate_name;
            type_name: String => innate_name.substring(0, innate_name.indexOf('.'));
            op_name: String => innate_name.substring(innate_name.indexOf('.') + 1);    

            init(
                function: Semantic.Symbol.InnateFunction,
                from: BASE,
                arguments: Collections.LIST[BASE],
                type: Type.BASE) is
                super.init();

                assert(function?, "function is null");
                assert(arguments?, "arguments is null");

                self.function = function;
                self.arguments = arguments;

                if type? then
                    self.type = type;
                else
                    self.type = function.return_type;
                fi
            si

            gen(context: IR.CONTEXT) is
                IoC.CONTAINER.instance.innate_operation_generator.gen(self, context);
            si

            toString() -> String =>
                "innate-call:[" + type + "](\"" + function.name + "\"," + from + "," + arguments + ")";
        si

        class GLOBAL: BASE, Type.Typed is
            function: Symbol.Function;
            arguments: Collections.LIST[BASE];
            type: Type.BASE;
            has_type: bool => type?;

            init(function: Symbol.Function, arguments: Collections.LIST[BASE], type: Type.BASE) is
                super.init();

                self.function = function;
                self.arguments = arguments;

                if type? then
                    self.type = type;
                else
                    self.type = function.return_type;
                fi

                assert(self.type?, "type is null");
            si

            gen(context: IR.CONTEXT) is
                for a in arguments do
                    gen(a, context);
                od

                context.println("call " + function.il_type_name);                
            si

            toString() -> String =>
                "global-call:[" + type + "](\"" + function.name + "\"," + arguments + ")";
        si

        class INSTANCE: BASE, Type.Typed is
            from: Value.BASE;
            function: Symbol.Function;
            arguments: Collections.LIST[BASE];
            type: Type.BASE;
            has_type: bool => type?;

            init(from: Value.BASE, function: Symbol.Function, arguments: Collections.LIST[BASE], type: Type.BASE) is
                super.init();

                self.from = from;
                self.function = function;
                self.arguments = arguments;

                if type? then
                    self.type = type;
                else
                    self.type = function.return_type;
                fi

                assert(self.type?, "type is null");                
            si

            gen(context: IR.CONTEXT) is
                gen(from, context);

                for a in arguments do
                    gen(a, context);
                od
   
                context.println("callvirt " + function.il_type_name, function);
            si

            toString() -> String =>
                "instance-call:[" + type + "](" + from + ",\"" + function.name + "\"," +  arguments + ")";
        si

        class STRUCT: BASE, Type.Typed is
            from: Value.BASE;
            function: Symbol.Function;
            arguments: Collections.LIST[BASE];
            type: Type.BASE;
            has_type: bool => type?;

            init(from: Value.BASE, function: Symbol.Function, arguments: Collections.LIST[BASE], type: Type.BASE) is
                super.init();

                self.from = from;
                self.function = function;
                self.arguments = arguments;

                if type? then
                    self.type = type;
                else
                    self.type = function.return_type;
                fi

                assert(self.type?, "type is null");                
            si

            gen(context: IR.CONTEXT) is
                gen(from, context);

                for a in arguments do
                    gen(a, context);
                od
   
                context.println("call instance " + function.il_type_name);
            si

            toString() -> String =>
                "struct-call:[" + type + "](" + from + ",\"" + function.name + "\"," +  arguments + ")";
        si

        class STATIC: BASE, Type.Typed is
            function: Symbol.Function;
            arguments: Collections.LIST[BASE];
            type: Type.BASE;
            has_type: bool => type?;

            init(function: Symbol.Function, arguments: Collections.LIST[BASE], type: Type.BASE) is
                super.init();

                self.function = function;
                self.arguments = arguments;

                if type? then
                    self.type = type;
                else
                    self.type = function.return_type;
                fi

                assert(self.type?, "type is null");
            si

            gen(context: IR.CONTEXT) is
                for a in arguments do
                    gen(a, context);
                od

                context.println("call " + function.il_type_name);
            si

            toString() -> String =>
                "static-call:[" + type + "](\"" + function.name + "\"," +  arguments + ")";
        si

        class CLOSURE: BASE, Type.Typed is
            from: BASE;
            type: Type.BASE;
            has_type: bool => type?;

            func_type: Type.BASE;
            arguments: Collections.LIST[BASE];

            init(
                from: BASE,
                type: Type.BASE,
                func_type: Type.BASE,
                arguments: Collections.LIST[BASE]
            ) is
                super.init();

                assert(type?, "type is null");
                assert(func_type?, "func_type is null");
                assert(arguments?, "type is null");

                self.from = from;
                self.type = type;
                self.func_type = func_type;
                self.arguments = arguments;
            si

            gen(context: IR.CONTEXT) is
                gen(from, context);

                let count = 0;
                for a in arguments do
                    gen(a, context);

                    count = count + 1;
                od

                let call = new StringBuffer();

                call
                    .append("callvirt instance !")
                    .append(count) // including return type
                    .append(" ")
                    .append(func_type.il_type_name)
                    .append("::Invoke(");

                for i in 0..count do
                    if i > 0 then
                        call.append(",");
                    fi
                    
                    call
                        .append("!")
                        .append(i);                    
                od

                call.append(")");
                
                context.println(call);
            si
            
            toString() -> String =>
                "closure-call:[" + type + "](" + from + "," + arguments + ")";
        si
    si

    namespace Literal is
        class INTEGER: BASE, Type.Typed is
            string: String;
            type: Type.BASE;
            has_type: bool => type?;

            init(string: String, type: Type.BASE) is
                super.init();

                assert(string?, "string is null");
                assert(type?, "type is null");

                self.string = string;
                self.type = type;
            si

            gen(context: IR.CONTEXT) is
                context.println("ldc.i4 " + string);
            si

            toString() -> String =>
                "literal:[" + type + "](" + string + ")";
        si

        class STRING: BASE, Type.Typed is
            string: String;
            type: Type.BASE;
            has_type: bool => type?;

            init(string: String, type: Type.BASE) is
                super.init();

                assert(string?, "string is null");
                assert(type?, "type is null");

                self.string = string;
                self.type = type;
            si

            gen(context: IR.CONTEXT) is
                let result = new StringBuffer(string.Length * 8);

                for c in string do
                    if c < cast char(0) then
                        result
                            .append("0 ");
                    elif c < cast char(16) then
                        result
                            .append("0")
                            .append(cast int(c), 16)
                            .append(" 00 ");
                    else
                        result
                            .append(cast int(c), 16)
                            .append(" 00 ");
                    fi
                od
                
                context.println("ldstr bytearray (" + result + ")");
            si

            toString() -> String =>
                "literal:[" + type + "](\"" + string + "\")";
        si
    si
si
