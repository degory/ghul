namespace Diagnostics is
    use System.Exception;

    use Collections.MutableList;
    use Collections.MutableMap;
    use Collections.MAP;
    use Collections.LIST;
    use Collections.STACK;

    use Logging.Logger;
    use Logging.LoggerState;

    class DIAGNOSTIC_STORE is
        _state_stack: STACK[DIAGNOSTIC_STATE];
        _current: DIAGNOSTIC_STATE => _state_stack.peek();

        // TODO: avoid allocating diagnostic state objects immediately on speculate
        // instead, track speculate depth - increase on push/decrease on pop - and only
        // actually push a new state if it's needed to hold an error

        is_poisoned: bool => _current.is_poisoned;
        has_errors: bool => _current.has_errors;

        init() is
            _state_stack = new STACK[DIAGNOSTIC_STATE]();
            IO.Std.error.write_line("!!! !!! DIAG " + _state_stack.count + ": INIT");
            push();
        si

        clear() is
            IO.Std.error.write_line("!!! !!! DIAG " + _state_stack.count + ": CLEAR");
            _state_stack.clear();
            push();
        si

        reset() is
            IO.Std.error.write_line("!!! !!! DIAG " + _state_stack.count + ": RESET");
            _state_stack.clear();
            push();
        si        

        write_to(writer: DiagnosticWriter) is
            IO.Std.error.write_line("### ### DIAG " + _state_stack.count + ": WRITE");
            _current.write_to(writer);
        si

        poison() is
            _current.poison();
        si
        
        add(uri: string, diagnostic: DIAGNOSTIC) is
            IO.Std.error.write_line("+++ +++ DIAG " + _state_stack.count + ": ADD: " + uri + " " + diagnostic);
            _current.add(uri, diagnostic);
        si
        
        push() is
            IO.Std.error.write_line(">>> >>> DIAG " + _state_stack.count + ": PUSH");
            _state_stack.push(new DIAGNOSTIC_STATE());
        si

        merge_down() =>
            merge(pop());
        
        pop() -> DIAGNOSTIC_STATE is
            assert _state_stack.count > 0 else "cannot pop empty stack";

            IO.Std.error.write_line("<<< <<< DIAG " + (_state_stack.count - 1) + ": POP");
            return _state_stack.pop();
        si
            
        merge(state: DIAGNOSTIC_STATE) is
            assert _state_stack.count > 0 else "cannot merge into empty stack";
            
            if state.has_errors \/ state.is_poisoned then
                IO.Std.error.write_line("~~~ ~~~ DIAG " + _state_stack.count + ": MERGE");                
            fi
            
            _current.merge(state);
        si
    si
si
