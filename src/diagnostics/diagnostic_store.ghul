namespace Diagnostics is
    use System.Exception;

    use Collections.MutableList;
    use Collections.MutableMap;
    use Collections.MAP;
    use Collections.LIST;
    use Collections.STACK;

    use Logging.Logger;
    use Logging.LoggerState;

    class DIAGNOSTIC_STORE is
        _state_stack: STACK[DIAGNOSTIC_STATE];
        _current: DIAGNOSTIC_STATE => _state_stack.peek();
        _pending_speculates: int;

        // TODO: avoid allocating diagnostic state objects immediately on speculate
        // instead, track speculate depth - increase on push/decrease on pop - and only
        // actually push a new state if it's needed to hold an error

        is_poisoned: bool => _current.is_poisoned;
        has_errors: bool => _current.has_errors;

        init() is
            _state_stack = new STACK[DIAGNOSTIC_STATE]();
            IO.Std.error.write_line("!!! !!! DIAG " + _state_stack.count + ": INIT");
            push();
        si

        clear() is
            IO.Std.error.write_line("!!! !!! DIAG " + _state_stack.count + ": CLEAR");
            _state_stack.clear();
            push();
        si

        reset() is
            IO.Std.error.write_line("!!! !!! DIAG " + _state_stack.count + ": RESET");
            _state_stack.clear();
            push();
        si        

        write_to(writer: DiagnosticWriter) is
            if _pending_speculates > 0 then
                IO.Std.error.write_line("### ### DIAG " + _state_stack.count + ": NOTHING TO WRITE");
                return;
            fi

            IO.Std.error.write_line("### ### DIAG " + _state_stack.count + ": WRITE");
            _current.write_to(writer);
        si

        poison() is
            _catch_up_push();

            _current.poison();
        si
        
        add(uri: string, diagnostic: DIAGNOSTIC) is
            _catch_up_push();
            IO.Std.error.write_line("+++ +++ DIAG " + _state_stack.count + ": ADD: " + uri + " " + diagnostic);
            _current.add(uri, diagnostic);
        si
        
        push() is
            // IO.Std.error.write_line("--- --- DIAG " + _state_stack.count + ": SPECULATE");
            _pending_speculates = _pending_speculates + 1;
        si

        merge_down() is
            if _maybe_pop() then
                // IO.Std.error.write_line("--- --- DIAG " + _state_stack.count + ": DISCARD");
                return;
            fi
            
            merge(pop());
        si
        
        pop() -> DIAGNOSTIC_STATE is
            if _maybe_pop() then
                // IO.Std.error.write_line("--- --- DIAG " + _state_stack.count + ": DISCARD");

                return new DIAGNOSTIC_STATE();
            fi

            assert _state_stack.count > 0 else "cannot pop empty stack";

            IO.Std.error.write_line("<<< <<< DIAG " + (_state_stack.count - 1) + ": POP");
            return _state_stack.pop();
        si
            
        merge(state: DIAGNOSTIC_STATE) is
            _catch_up_push();

            assert _state_stack.count > 0 else "cannot merge into empty stack";
            
            if state.has_errors \/ state.is_poisoned then
                IO.Std.error.write_line("~~~ ~~~ DIAG " + _state_stack.count + ": MERGE");                
            fi
            
            _current.merge(state);
        si

        _catch_up_push() is
            while _pending_speculates > 0 do
                IO.Std.error.write_line(">>> >>> DIAG " + _state_stack.count + ": ACTUAL PUSH");
                _state_stack.push(new DIAGNOSTIC_STATE());
    
                _pending_speculates = _pending_speculates - 1;
            od
        si

        _maybe_pop() -> bool is
            if _pending_speculates > 0 then
                _pending_speculates = _pending_speculates - 1;

                return true;
            fi
        si
    si
si
