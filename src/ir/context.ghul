namespace IR is
    use Generic;
    use System;

    use Semantic.Graph.Value.Call;

    class FILE is
        path: String;
        writer: IO.Writer;
        want_comments: bool;

        init(
            path: String,
            writer: IO.Writer,
            want_comments: bool
        ) is
            super.init();

            self.path = path;
            self.writer = writer;
            self.want_comments = want_comments;
        si
    si

    class CONTEXT is
        seen: Set[String];
        files: Vector[FILE];

        init() is
            seen = new Set[String]();
            files = new Vector[FILE]();
            files.add(new FILE("(stderr)", IO.Std.err, true));
        si

        println(value: Object) is
            if current_file.want_comments then
                current_file.writer.println("        " + value);
            else
                current_file.writer.println(value);
            fi
        si

        println(value: Object, comment: Object) is
            if current_file.want_comments then
                current_file.writer.println("        " + value + "        // " + comment);
            else
                current_file.writer.println(value);
            fi
        si

        current_file: FILE => files.Top;

        enter_file(path: String) is
            let writer: IO.Writer;

            if seen.contains(path) then
                writer = IO.File.openAppend(path);
            else
                writer = IO.File.openCreate(path);
                seen.add(path);
            fi
            
            files.add(new FILE(path, writer, false));
        si

        leave_file(path: String) is
            while files.Length > 0 do                
                if current_file.path =~ path then
                    current_file.writer.close();
                    files.pop();
                    return;
                else
                    IO.Std.err.println("oops - IL output context stack corrupt");
                fi

                files.pop();
            od
            IO.Std.err.println("oops - IL output context stack corrupt");
        si        
    si

    class INNATE_OPERATION_GENERATOR is
        _operations: Dict[String,(INNATE,CONTEXT) -> void];

        init() is
            _operations = new Map[String,(INNATE,CONTEXT) -> void]();

            _operations["int.add"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["int.sub"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["int.mul"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["int.div"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;

            _operations["long.add"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["long.sub"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["long.mul"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["long.div"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
        si

        gen(value: INNATE, context: CONTEXT) is
            if !value? || !value.function? then
                context.println("innate operation function is null: " + value.operation);
                return;
            fi

            if !value.function.innate_name? then
                context.println("innate operation function has no innate operation name: " + value.operation);
                return;
            fi

            let operation = _operations[value.function.innate_name];

            if operation? then
                operation(value, context);
            else
                for a in value.arguments do
                    INNATE.gen(a, context);
                od

                context.println("unknown innate operation " + value.function.innate_name);
            fi
        si        

        gen_arguments(value: INNATE, context: CONTEXT) is
            for a in value.arguments do
                INNATE.gen(a, context);
            od            
        si
        
        gen_integer(value: INNATE, context: CONTEXT) is
            gen_arguments(value, context);

            let innate_name = value.function.innate_name;

            let operation = innate_name.substring(innate_name.lastIndexOf('.') + 1);

            // FIXME: do we need to convert the inputs or outputs?
            context.println(operation);
        si
    si
si
