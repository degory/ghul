namespace IR is
    use Generic;
    use System;

    use Semantic.Graph.Value.Call;

    class FILE is
        path: String;
        writer: IO.Writer;
        want_comments: bool;

        init(
            path: String,
            writer: IO.Writer,
            want_comments: bool
        ) is
            super.init();

            self.path = path;
            self.writer = writer;
            self.want_comments = want_comments;
        si

        close() is
            writer.close();
        si

        println(indent: int, value: Object) is
            if !writer? then
                return;
            elif want_comments then
                print_indent(indent);
                writer.println(value);
            else
                writer.println(value);
            fi
        si

        println(indent: int, value: Object, comment: Object) is
            if !writer? then
                return;
            elif want_comments then
                print_indent(indent);
                writer.println("" + value + "        // " + comment);
            else
                writer.println(value);
            fi
        si

        print_indent(indent: int) is
            for i in 0..indent do
                writer.print("  ");
            od            
        si
                
    si

    class CONTEXT is
        _indent: int;

        _seen: Set[String];
        _files: Vector[FILE];

        init() is
            _seen = new Set[String]();
            _files = new Vector[FILE]();
            _files.add(new FILE("(stderr)", IO.Std.out, true));
        si

        current_file: FILE => _files.Top;

        println(value: Object) is
            current_file.println(_indent, value);
        si

        println(value: Object, comment: Object) is
            current_file.println(_indent, value, comment);
        si

        indent() is
            _indent = _indent + 1;
        si

        outdent() is
            _indent = _indent - 1;
        si

        enter_stub() is
            _files.add(new FILE("stub", null, false));
        si

        leave_stub() is
            _files.pop();
        si

        enter_file(path: String) is
            let writer: IO.Writer;

            if _seen.contains(path) then
                writer = IO.File.openAppend(path);
            else
                writer = IO.File.openCreate(path);
                _seen.add(path);
            fi
            
            _files.add(new FILE(path, writer, false));
        si

        leave_file(path: String) is
            while _files.Length > 0 do                
                if current_file.path =~ path then
                    current_file.close();
                    _files.pop();
                    return;
                else
                    IO.Std.err.println("oops - IL output context stack corrupt");
                fi

                _files.pop();
            od
            IO.Std.err.println("oops - IL output context stack corrupt");
        si        
    si

    class INNATE_OPERATION_GENERATOR is
        _operations: Dict[String,(INNATE,CONTEXT) -> void];

        init() is
            _operations = new Map[String,(INNATE,CONTEXT) -> void]();

            _operations["box"] = (value: INNATE, context: CONTEXT) -> void is gen_box(value, context); si;

            _operations["int.add"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["int.sub"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["int.mul"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["int.div"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;

            _operations["long.add"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["long.sub"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["long.mul"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
            _operations["long.div"] = (value: INNATE, context: CONTEXT) -> void is gen_integer(value, context); si;
        si

        gen(value: INNATE, context: CONTEXT) is
            if !value? || !value.function? then
                context.println("innate operation function is null: " + value.operation);
                return;
            fi

            if !value.function.innate_name? then
                context.println("innate operation function has no innate operation name: " + value.operation);
                return;
            fi

            let operation = _operations[value.function.innate_name];

            if operation? then
                operation(value, context);
            else
                for a in value.arguments do
                    INNATE.gen(a, context);
                od

                context.println("unknown innate operation " + value.function.innate_name);
            fi
        si        

        gen_arguments(value: INNATE, context: CONTEXT) is
            for a in value.arguments do
                INNATE.gen(a, context);
            od            
        si
        
        gen_integer(value: INNATE, context: CONTEXT) is
            gen_arguments(value, context);

            let innate_name = value.function.innate_name;

            let operation = innate_name.substring(innate_name.lastIndexOf('.') + 1);

            // FIXME: do we need to convert the inputs or outputs?
            context.println(operation);
        si
        
        gen_box(value: INNATE, context: CONTEXT) is
            gen_arguments(value, context);

            IO.Std.err.println("gen box: " + value);

            context.println("box " + value.arguments[0].type.il_type_name);
        si
    si

    class LOCAL_ID_GENERATOR is
        _next_id_stack: Vector[int];

        next_id: int is
            let result = _next_id_stack.Top;

            _next_id_stack[_next_id_stack.Length - 1] = result + 1;

            return result;
        si

        // FIXME: could keep a set of local variable names seen in the current function and
        // only add a suffix if the name is actually not unique 
        get_unique_il_name_for(name: String) -> String => "'" + name + "." + next_id + "'";
        
        init() is
            _next_id_stack = new Vector[int]();            
        si

        enter_function() is
            _next_id_stack.add(0);
        si

        leave_function() is
            _next_id_stack.pop();
        si
    si
si
