namespace IR is
    use Generic;
    use System;

    use Semantic.Graph.Value.Call;

    class AssemblyOutput is
        want_comments: bool;
        
        init(want_comments: bool) is
            self.want_comments = want_comments;
        si

        print(value: Object) is
            throw new NotImplementedException("assembly output must implement println");            
        si
        
        println(value: Object) is
            print(value);
            print("\n");
        si
        
        println(indent: int, value: Object) is
            if want_comments then
                print_indent(indent);
                println(value);
            else
                println(value);
            fi
        si

        println(indent: int, value: Object, comment: Object) is
            if want_comments then
                print_indent(indent);
                println("" + value + "        // " + comment);
            else
                println(value);
            fi
        si

        print_indent(indent: int) is
            for i in 0..indent do
                print("  ");
            od            
        si

        close() is
            
        si
    si

    class FILE_ASSEMBLER_OUTPUT: AssemblyOutput is
        path: String;
        writer: IO.Writer;

        init(
            path: String,
            writer: IO.Writer,
            want_comments: bool
        ) is
            super.init(want_comments);

            self.path = path;
            self.writer = writer;
        si

        print(value: Object) is
            writer.print(value);
        si

        close() is
            writer.close();
        si
    si

    class STUB_ASSEMBLER_OUTPUT: AssemblyOutput is
        init() is
            super.init(false);
        si

        print(value: Object) is
            // do nothing
        si
    si

    class BUFFER_ASSEMBLER_OUTPUT: AssemblyOutput is
        buffer: StringBuffer;

        init(want_comments: bool) is
            super.init(want_comments);

            buffer = new StringBuffer();
        si

        print(value: Object) is
            buffer.append(value);
        si
    si
    
    class CONTEXT is
        _logger: Logging.Logger;
        _indent: int;

        _seen: Set[String];
        _outputs: Vector[AssemblyOutput];

        init(logger: Logging.Logger) is
            _logger = logger;
            _seen = new Set[String]();
            _outputs = new Vector[AssemblyOutput]();
            _outputs.add(new STUB_ASSEMBLER_OUTPUT());
        si

        current_output: AssemblyOutput => _outputs.Top;

        println(value: Object) is
            current_output.println(_indent, value);
        si

        println(value: Object, comment: Object) is
            current_output.println(_indent, value, comment);
        si

        indent() is
            _indent = _indent + 1;
        si

        outdent() is
            _indent = _indent - 1;
        si

        enter_stub() is
            _outputs.add(new STUB_ASSEMBLER_OUTPUT());
        si

        leave_stub() is
            assert(
                _outputs.Length > 0 &&
                isa STUB_ASSEMBLER_OUTPUT(current_output),
                "IL output context stack corrupt"
            );

            _outputs.pop();
        si

        enter_file(path: String, want_comments: bool) is
            let writer: IO.Writer;

            if _seen.contains(path) then
                writer = IO.File.openAppend(path);
            else
                writer = IO.File.openCreate(path);
                _seen.add(path);
            fi
            
            _outputs.add(new FILE_ASSEMBLER_OUTPUT(path, writer, want_comments));
        si

        leave_file(path: String) is
            assert(
                _outputs.Length > 0 &&
                isa FILE_ASSEMBLER_OUTPUT(current_output) &&
                cast FILE_ASSEMBLER_OUTPUT(current_output).path =~ path,
                "IL output context stack corrupt"
            );
            
            current_output.close();
            _outputs.pop();
        si
        
        enter_buffer(want_comments: bool) is
            IO.Std.err.println("enter buffer");

            _outputs.add(new BUFFER_ASSEMBLER_OUTPUT(want_comments));
        si

        leave_buffer() -> String is
            IO.Std.err.println("leave buffer");

            assert(
                _outputs.Length > 0 &&
                isa BUFFER_ASSEMBLER_OUTPUT(current_output),
                "IL output context stack corrupt"
            );

            let result = cast BUFFER_ASSEMBLER_OUTPUT(current_output).buffer;

            _outputs.pop();

            return result;
        si        
    si
si
