namespace IR is
    use Generic;
    use Semantic;

    class VALUE_BOXER is
        _logger: Logging.Logger;

        want_boxing: bool public;

        init(logger: Logging.Logger) is
            super.init();

            _logger = logger;
        si

        box_if_value(value: Graph.Value.BASE) -> Graph.Value.BASE is
            if want_boxing && value.is_value_type then
                return new Graph.Value.BOX(value);
            else
                return value;
            fi
        si
        
        box_arguments(arguments: List[Graph.Value.BASE], argument_types: List[Type.BASE]) -> List[Graph.Value.BASE] is
            if !want_boxing then
                return arguments;
            fi

            if arguments? then
                IO.Std.err.println("have " + arguments.Length + " arguments");

                for a in arguments do
                    IO.Std.err.println("argument: " + a);
                od                
            fi
            
            if argument_types? then
                IO.Std.err.println("have " + argument_types.Length + " types");

                for t in argument_types do
                    IO.Std.err.println("type: " + t);
                od                
            fi

            assert(
                arguments? &&
                argument_types? &&
                arguments.Length == argument_types.Length,
                "cannot box incomplete arguments"
            );

            let any_need_boxing = false;

            for i in 0..arguments.Length do
                assert(
                    argument_types[i]? &&
                    arguments[i]? &&
                    arguments[i].has_type,
                    "cannot box broken argument"
                );
                
                if !argument_types[i].is_value_type && arguments[i].type.is_value_type then
                    any_need_boxing = true;
                    break;
                fi
            od

            if !any_need_boxing then
                IO.Std.err.println("none need boxing");
                return arguments;
            fi

            IO.Std.err.println("some need boxing");

            let result = new Vector[Graph.Value.BASE](arguments.Length);

            for i in 0..arguments.Length do
                if !argument_types[i].is_value_type && arguments[i].type.is_value_type then
                    IO.Std.err.println("boxing: " + arguments[i]);

                    result.add(new Graph.Value.BOX(arguments[i]));
                else
                    IO.Std.err.println("using unboxed: " + arguments[i]);

                    result.add(arguments[i]);                    
                fi
            od

            IO.Std.err.println("result: " + result);

            return result;
        si
    si    
si
