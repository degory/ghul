namespace IR.Values is
    use Semantic.Types.Type;

    use Logging;

    class WRAPPER: Value is
        _value: Value;

        has_type: bool => type?;
        has_address: bool => value.has_address;
        type: Type => if value? then value.type else null fi;
        value: Value public 
            => _value, 
            = v is
                assert v? else "updated wrapper value is null";
                assert v.type? else "updated wrapper value {v} has no type";

                debug("update wrapper value to {v} of type {v.type}");

                _value = v;
            si

        init(
            type: Type,
            value: Value
        ) is
            super.init();

            assert value? else "value is null";

            self.value = value;
        si

        init() is
            super.init();

            debug("initialize empty wrapper");
        si

        gen(context: IR.CONTEXT) is
            assert value? else "generate wrapper without value";

            gen(value, context);
        si

        gen_address(context: IR.CONTEXT) is
            assert value? else "generate wrapper without value";

            value.gen_address(context);
        si
        
        to_string() -> string =>
            "wrapper:[{type}]({value})";        
    si
si
