namespace IR.Values is
    use System.NotImplementedException;

    use TypeTyped = Semantic.Types.Typed;
    use Semantic.Types.Type;

    class Value: TypeTyped is
        has_type: bool => false;
        is_value_type: bool => has_type /\ type.is_value_type;
        is_self: bool => false;
        is_super: bool => false;
        has_address: bool => false;
        is_consumable: bool => true;

        non_consumable_message: string => "cannot use this here";

        type: Type is
            throw new NotImplementedException("value has no type");
        si

        check_is_consumable(logger: Logging.Logger, location: Source.LOCATION, value: Value) -> bool static => 
            value? /\
            value.check_is_consumable(logger, location) /\
            value.type?;
        
        check_is_consumable(logger: Logging.Logger, location: Source.LOCATION) -> bool is
            if !is_consumable then
                logger.error(location, non_consumable_message);
                return false;
            fi

            return true;
        si        

        copy_from(other: Value) is
            assert other?;

            for field in self.get_type().get_fields() do
                let value = field.get_value(other);
                field.set_value(self, value);
            od

            for property in self.get_type().get_properties() | .filter(p => p.can_read /\ p.can_write) do
                let value = property.get_value(other);
                property.set_value(self, value);
            od
        si

        gen(context: IR.CONTEXT) is
            throw new NotImplementedException("value gen");
        si

        gen_address(context: IR.CONTEXT) is            
            throw new NotImplementedException("value gen address: " + get_type() + " " + self);
        si
        
        gen(value: Value, context: IR.CONTEXT) static is
            if value? then
                value.gen(context);
            else
                context.fixme("null value");
            fi
        si

        init() is si
    si
si
