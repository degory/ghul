namespace IR.Values is
    use System.NotImplementedException;

    use TypeTyped = Semantic.Types.Typed;
    use Semantic.Types.Type;
    use Semantic.Symbols.Symbol;

    class Value: TypeTyped is
        has_type: bool => false;
        has_symbol: bool => false;
        is_value_type: bool => has_type /\ type.is_value_type;
        is_self: bool => false;
        is_super: bool => false;
        is_deref: bool => false;
        has_address: bool => false;
        is_consumable: bool => true;
        is_need_store: bool => false;
        is_block: bool => false;
        is_lightweight_pure: bool => false;

        non_consumable_message: string => "cannot use this here";

        type: Type is
            throw new NotImplementedException("value has no type");
        si

        symbol: Symbol is
            throw new NotImplementedException("value has no symbol");
        si

        check_is_consumable(logger: Logging.Logger, location: Source.LOCATION, value: Value) -> bool static => 
            value? /\
            value.check_is_consumable(logger, location) /\
            value.type?;
        
        check_is_consumable(logger: Logging.Logger, location: Source.LOCATION) -> bool is
            if !is_consumable then
                logger.error(location, non_consumable_message);
                return false;
            fi

            if type? /\ type.is_void then
                logger.error(location, "cannot use void value here");                
            fi

            return true;
        si        

        check_is_consumable_allow_void(logger: Logging.Logger, location: Source.LOCATION, value: Value) -> bool static => 
            value? /\
            value.check_is_consumable_allow_void(logger, location) /\
            value.type?;

        check_is_consumable_allow_void(logger: Logging.Logger, location: Source.LOCATION) -> bool is
            if !is_consumable then
                logger.error(location, non_consumable_message);
                return false;
            fi

            return true;
        si

        get_temp_copier(context: IR.CONTEXT, prefix: string) -> (() -> Value) =>
            if is_lightweight_pure then
                () => self;
            else
                let temp = new TEMP(context, prefix, self);
                () => temp.load();
            fi;
        
        update_from(other: Value) is
            assert other?;

            for field in self.get_type().get_fields() do
                let value = field.get_value(other);
                field.set_value(self, value);
            od

            for property in self.get_type().get_properties() | .filter(p => p.can_read /\ p.can_write) do
                let value = property.get_value(other);
                property.set_value(self, value);
            od
        si

        gen(context: IR.CONTEXT) is
            throw new NotImplementedException("value gen");
        si

        gen_address(context: IR.CONTEXT) is            
            throw new NotImplementedException("value gen address: {get_type()} {self}");
        si
        
        gen(value: Value, context: IR.CONTEXT) static is
            if value? then
                value.gen(context);
            else
                context.fixme("null value");
            fi
        si

        init() is si
    si
si
