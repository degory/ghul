namespace IR is
    use System;
    use Generic;
    use Semantic.Graph.Value.Call;

    class INNATE_OPERATION_GENERATOR is
        _logger: Logging.Logger;
        _boxer: VALUE_BOXER;
        _brancher: IR.BRANCHER;
        _type_and_operation_handlers: Collections.MAP[String,(INNATE,CONTEXT) -> void];
        _operation_handlers: Collections.MAP[String,(INNATE,CONTEXT) -> void];
        _type_handlers: Collections.MAP[String,(INNATE,CONTEXT) -> void];

        init(
            logger: Logging.Logger,
            boxer: VALUE_BOXER,
            brancher: IR.BRANCHER
        ) is
            _logger = logger;
            _boxer = boxer;
            _brancher = brancher;

            _type_and_operation_handlers = new Collections.MAP[String,(INNATE,CONTEXT) -> void]();
            _operation_handlers = new Collections.MAP[String,(INNATE,CONTEXT) -> void]();
            _type_handlers = new Collections.MAP[String,(INNATE,CONTEXT) -> void]();


            _type_and_operation_handlers["compare.order"] = (value: INNATE, context: CONTEXT) -> void is gen_compare_order(value, false, context); si;
            _type_and_operation_handlers["compare.uorder"] = (value: INNATE, context: CONTEXT) -> void is gen_compare_order(value, true, context); si;
            _type_and_operation_handlers["compare.value"] = (value: INNATE, context: CONTEXT) -> void is gen_compare_value(value, context); si;
            _type_and_operation_handlers["compare.reference"] = (value: INNATE, context: CONTEXT) -> void is gen_compare_reference(value, context); si;

            _type_and_operation_handlers["bool.not"] = (value: INNATE, context: CONTEXT) -> void is gen_bool_not(value, context); si;

            _type_handlers["bool"] = (value: INNATE, context: CONTEXT) -> void is gen_short_circuit_bool(value, context); si;
            _type_handlers["arithmetic"] = (value: INNATE, context: CONTEXT) -> void is gen_arithmetic(value, context); si;
            _type_handlers["string"] = (value: INNATE, context: CONTEXT) -> void is gen_string(value, context); si;
            _type_handlers["range"] = (value: INNATE, context: CONTEXT) -> void is gen_range(value, context); si;

            // _type_handlers["object"] = (value: INNATE, context: CONTEXT) -> void is gen_object(value, context); si;
        si
                
        gen(value: INNATE, context: CONTEXT) is
            _assert
                value? &&
                value.function? &&
                value.function.innate_name?
            else
                "innate operation value or function is null";

            let innate_name = value.innate_name;

            if try_handle(innate_name, _type_and_operation_handlers, value, context) then
                return;
            fi
            
            let operation_name = value.op_name;

            if try_handle(operation_name, _operation_handlers, value, context) then
                return;
            fi
            
            let type_name = value.type_name;

            if try_handle(type_name, _type_handlers, value, context) then
                return;
            fi
            
            for a in value.arguments do
                INNATE.gen(a, context);
            od

            context.fixme("unknown innate operation: " + value.function.innate_name);
        si     
        
        try_handle(
            key: String,
            handlers: Collections.MAP[String,(INNATE,CONTEXT) -> void],
            value: INNATE,
            context: IR.CONTEXT) -> bool is
            let handler = handlers[key];

            if handler? then
                handler(value, context);
                return true;
            fi
        si

        gen_arithmetic(value: INNATE, context: CONTEXT) is
            gen_arguments(value, context);

            let operation = value.op_name;

            // FIXME: do we need to convert the inputs or outputs?
            context.write_line(operation);
        si

        gen_bool_not(value: INNATE, context: CONTEXT) is
            _assert value.arguments? && value.arguments.count == 1 else "not bool missing arguments";

            gen_arguments(value, context);


            context.write_line("ldc.i4 0");
            context.write_line("ceq", "boolean not");
        si        

        gen_short_circuit_bool(value: INNATE, context: CONTEXT) is
            _assert value.arguments? && value.arguments.count == 2 else "short circuit bool missing arguments";

            let exit = new IR.LABEL();
            let operation = value.op_name;

            // push speculative result:
            if operation =~ "and_then" then
                context.write_line("ldc.i4 0", "&& false if left is false");
            else
                context.write_line("ldc.i4 1", "|| true if left is true");
            fi

            // branch to exit if speculative result is correct based on evaluating left argument:
            if operation =~ "and_then" then
                _brancher.branch(IR.BRANCH.Z, value.arguments[0], exit, "&&");
            else
                _brancher.branch(IR.BRANCH.NZ, value.arguments[0], exit, "||");
            fi

            // speculative result may not be correct, discard it:
            context.write_line("pop");
            
            // result is value of right side: 
            gen_argument(value, 1, context);

            _brancher.label(exit);
        si

        gen_compare_order(value: INNATE, is_unsigned: bool, context: CONTEXT) is
            _assert value.arguments? && value.arguments.count == 2 else "compare order missing arguments";

            gen_arguments(value, context);

            let actual_operation = value.actual_operation;

            let needs_not = false;
            let instruction: String = "unknown compare order: " + actual_operation;

            if actual_operation =~ ">" then
                instruction = "cgt";
            elif actual_operation =~ ">=" then
                instruction = "clt";
                needs_not = true;
            elif actual_operation =~ "<" then
                instruction = "clt";
            elif actual_operation =~ "<=" then
                instruction = "cgt";
                needs_not = true;
            fi

            if is_unsigned then
                instruction = instruction + ".un";
            fi
                            
            context.write_line(instruction, value.actual_operation);

            if needs_not then
                context.write_line("ldc.i4 0");
                context.write_line("ceq");
            fi            
        si        
        
        gen_string(value: INNATE, context: CONTEXT) is
            let innate_name = value.function.innate_name;

            if innate_name =~ "string.add" then
                Semantic.Graph.Value.BASE.gen(value.arguments[0], context);

                Semantic.Graph.Value.BASE.gen(_boxer.box_if_value(value.arguments[1]), context);
    
                context.write_line("call string string::Concat(object,object)");
            elif innate_name =~ "string.equals" then
                gen_arguments(value, context);

                context.write_line("call bool string::op_Equality(string, string)");

                if value.actual_operation =~ "!~" then	
                    context.write_line("ldc.i4 0");	
                    context.write_line("ceq");	
                fi                             
            else
                context.fixme("unknown innate operation: " + value.function.innate_name);

                return;
            fi
        si

        gen_compare_reference(value: INNATE, context: CONTEXT) is
            _assert value.arguments? && value.arguments.count == 2 else "compare reference missing arguments";

            let left = value.arguments[0];
            let right = value.arguments[1];

            if left.is_value_type != right.is_value_type then
                left = _boxer.box_if_value(left);
                right = _boxer.box_if_value(right);
            fi
            
            Semantic.Graph.Value.BASE.gen(left, context);
            Semantic.Graph.Value.BASE.gen(right, context);

            context.write_line("ceq");

            if value.actual_operation =~ "!=" then
                context.write_line("ldc.i4 0");
                context.write_line("ceq");
            fi                
        si

        gen_compare_value(value: INNATE, context: CONTEXT) is
            _assert value.arguments? && value.arguments.count == 2 else "compare value missing arguments";

            gen_arguments(value, context);

            context.write_line("ceq");

            if value.actual_operation =~ "!=" then
                context.write_line("ldc.i4 0");
                context.write_line("ceq");
            fi                
        si

        gen_range(value: INNATE, context: CONTEXT) is
            _assert value.arguments? && value.arguments.count == 2 else "create range missing arguments";

            gen_arguments(value, context);

            if value.op_name =~ "inclusive" then
                context.write_line("newobj instance void valuetype 'Ghul'.'INT_RANGE_INCLUSIVE'::'init'(int32,int32)");
            elif value.op_name =~ "exclusive" then
                context.write_line("newobj instance void valuetype 'Ghul'.'INT_RANGE'::'init'(int32,int32)");                                
            else
                throw new Exception("unexpected range innate operation: " + value.innate_name);
            fi
        si

        gen_argument(value: INNATE, index: int, context: CONTEXT) is
            Semantic.Graph.Value.BASE.gen(value.arguments[index], context);
        si

        gen_arguments(value: INNATE, context: CONTEXT) is
            for a in value.arguments do
                Semantic.Graph.Value.BASE.gen(a, context);
            od
        si        
    si
si
