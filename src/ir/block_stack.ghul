namespace IR is
    use Logging;

    class BLOCK_STACK: BlockContext is
        _blocks: Collections.STACK[Values.BLOCK];

        is_in_block: bool => _blocks.count > 0;

        init() is
            _blocks = new Collections.STACK[Values.BLOCK]();
        si

        mark() -> int => _blocks.count;

        release(mark: int) is
            while _blocks.count > mark do
                _blocks.pop();
            od
        si

        current_block: Values.BLOCK is
            // if _blocks.count == 0 then
            //     debug_always("BS {get_hash_code()}: UNDERFLOW depth {_blocks.count} at {new System.Diagnostics.StackTrace().to_string().replace_line_endings(" ")}");
            // else
            //     debug_always("BS {get_hash_code()}: get block at depth {_blocks.count} at {new System.Diagnostics.StackTrace().to_string().replace_line_endings(" ")}");
            // fi

            assert _blocks.count > 0 else "BS {get_hash_code()}: no block on stack";

            return _blocks.peek();
        si
        
        enter_block(block: Values.BLOCK) is
            _blocks.push(block);
            // debug_always("BS {get_hash_code()}: entering block depth {_blocks.count} at {new System.Diagnostics.StackTrace().to_string().replace_line_endings(" ")}");
        si

        enter_block(type: Semantic.Types.Type) is
            enter_block(new Values.BLOCK(type));
        si

        enter_block() is
            enter_block(new Values.BLOCK());
        si

        leave_block() is
            // debug_always("BS {get_hash_code()}: leaving block depth {_blocks.count} at {new System.Diagnostics.StackTrace().to_string().replace_line_endings(" ")}");
            _blocks.pop();
        si

        add(value: Values.Value) is
            current_block.add(value);
        si

        add(raw: string) is
            current_block.add(raw);
        si
    si
si