namespace IR is
    use IO.Std;

    use Values;

    class LABEL is
        _next_id: int static;

        id: int;

        init() is
            id = _next_id;

            _next_id = _next_id + 1;
        si

        reset_id() static is
            _next_id = 0;
        si
        
        to_string() -> string => "L_{id}";
    si

    enum COMPARE is
        NONE,
        EQ,
        GE,
        GEU,
        GT,
        GTU,
        LE,
        LEU,
        LT,
        LTU,
        NE,
        Z,
        NZ
    si

    enum BRANCH is
        NONE,
        EQ,
        GE,
        GEU,
        GT,
        GTU,
        LE,
        LEU,
        LT,
        LTU,
        NE,
        Z,
        NZ,
        ALWAYS
    si
    
    class BRANCHER is
        _blocks: BLOCK_STACK;

        _branch_instructions: Collections.MAP[BRANCH, string];
        _compare_instructions: Collections.MAP[COMPARE, string];

        init(blocks: BLOCK_STACK) is
            _blocks = blocks;

            _branch_instructions = new Collections.MAP[BRANCH, string]();
            _compare_instructions = new Collections.MAP[COMPARE, string]();

            _branch_instructions[BRANCH.EQ] = "beq";
            _branch_instructions[BRANCH.GE] = "bge";
            _branch_instructions[BRANCH.GEU] = "bge.un";
            _branch_instructions[BRANCH.GT] = "bgt";
            _branch_instructions[BRANCH.GTU] = "bgt.un";
            _branch_instructions[BRANCH.LE] = "ble";
            _branch_instructions[BRANCH.LEU] = "ble.un";
            _branch_instructions[BRANCH.LT] = "blt";
            _branch_instructions[BRANCH.LTU] = "blt.un";
            _branch_instructions[BRANCH.NE] = "bne.un";
            _branch_instructions[BRANCH.Z] = "brfalse";
            _branch_instructions[BRANCH.NZ] = "brtrue";
            _branch_instructions[BRANCH.ALWAYS] = "br";

            _compare_instructions[COMPARE.EQ] = "ceq";
            _compare_instructions[COMPARE.GE] = "cge";
            _compare_instructions[COMPARE.GEU] = "cge.un";
            _compare_instructions[COMPARE.GT] = "cgt";
            _compare_instructions[COMPARE.GTU] = "cgt.un";
            _compare_instructions[COMPARE.LE] = "cle";
            _compare_instructions[COMPARE.LEU] = "cle.un";
            _compare_instructions[COMPARE.LT] = "clt";
            _compare_instructions[COMPARE.LTU] = "clt.un";
            _compare_instructions[COMPARE.NE] = "cne.un";
            _compare_instructions[COMPARE.Z] = "ctrue";
            _compare_instructions[COMPARE.NZ] = "cfalse";
        si
        
        label(l: LABEL, comment: string) is
            _blocks.add("{l}:");
        si

        label(l: LABEL) is
            _blocks.add("{l}:");
        si

        leave(l: LABEL) is
            _blocks.add("leave {l}");
        si
        
        branch(b: BRANCH, value: Value, l: LABEL, comment: string) is
            _blocks.add(value);
            
            _blocks.add("{get_branch_instruction(b)} {l}");
        si

        branch(b: BRANCH, value: Value, l: LABEL) is
            _blocks.add(value);
            
            _blocks.add("{get_branch_instruction(b)} {l}");
        si

        branch(b: BRANCH, left: Value, right: Value, l: LABEL, comment: string) is
            _blocks.add(left);
            _blocks.add(right);
            
            _blocks.add("{get_branch_instruction(b)} {l}");
        si

        branch(b: BRANCH, left: Value, right: Value, l: LABEL) is
            _blocks.add(left);
            _blocks.add(right);
            
            _blocks.add("{get_branch_instruction(b)} {l}");
        si

        branch(l: LABEL, comment: string) is
            _blocks.add("{_branch_instructions[BRANCH.ALWAYS]} {l}");
        si

        branch(l: LABEL) is
            _blocks.add("{_branch_instructions[BRANCH.ALWAYS]} {l}");
        si

        get_branch_instruction(b: BRANCH) -> string is
            let instruction = _branch_instructions[b];

            if instruction? then
                return instruction;
            fi

            return "unknown branch instruction: {b}";
        si
    si
si