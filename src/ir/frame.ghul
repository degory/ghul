namespace IR is
    use System;
    use Generic;

    class Frame is
        enclosing: Frame => null;

        alloc_variable(builder: IR.BUILDER, name: String, type: IR.Type) -> int is
            throw new NotImplementedException(ClassName + " cannot allocate variable");
        si

        alloc_function(builder: IR.BUILDER, name: String, type:IR.Type) -> int is
            throw new NotImplementedException(ClassName + " cannot allocate function");            
        si

        get_address(base: IR.Value, index: int) -> IR.Value is
            throw new NotImplementedException(ClassName + " cannot get address");
        si

        get_address(base: IR.Value, frame: Frame, index: int) -> IR.Value is
            throw new NotImplementedException(ClassName + " cannot get address");
        si

        types_array: IR.Type[] is
            throw new NotImplementedException(ClassName + " cannot get types array");
        si
    si

    class GLOBAL_FRAME: Frame is
        types: List[IR.Type];

        init() is
            super.init();

            types = new Vector[IR.Type]();
        si

        alloc_variable(builder: IR.BUILDER, name: String, type: IR.Type) -> int is
            types.add(type);
        si

        alloc_function(builder: IR.BUILDER, name: String, type: IR.Type) -> int is
            types.add(type);
        si
    si

    class INSTANCE_FRAME: Frame is
        enclosing: Frame;
        types: Vector[IR.Type];

        types_array: IR.Type[] =>
            types.Array;
        
        init(enclosing: Frame) is
            super.init();

            self.enclosing = enclosing;

            types = new Vector[IR.Type]();
        si

        alloc_variable(builder: IR.BUILDER, type: IR.Type) -> int is
            types.add(type);
        si
    si

    class HEAP_FRAME: Frame is
        enclosing: Frame;
        types: Vector[IR.Type];

        types_array: IR.Type[] =>
            types.Array;
        
        init(enclosing: Frame) is
            super.init();

            self.enclosing = enclosing;

            types = new Vector[IR.Type]();
        si

        alloc_variable(builder: IR.BUILDER, type: IR.Type) -> int is
            types.add(type);

            return types.Length - 1;
        si

        get_address(base: IR.Value, index: int) -> IR.Value is
        si

        get_address(base: IR.Value, frame: Frame, index: int) -> IR.Value is
        si
    si

    class STACK_FRAME: Frame is
        enclosing: Frame;
        captured: Frame;

        slot: int;

        init(enclosing: Frame, captured: Frame) is
            super.init();

            self.enclosing = enclosing;
            self.captured = captured;

            slot = -1;
        si

        alloc_variable(builder: IR.BUILDER, type: IR.Type) -> int is
            slot = slot + 1;

            return slot;
        si

        /*
        get_address(base: IR.Value, index: int) -> IR.Value is
            return index;
        si

        get_address(base: IR.Value, frame: Frame, index: int) -> IR.Value is
            if frame == self then
                return get_address(base, index);
            elif frame == captured then
                // FIXME: wrong
                return captured.get_address(base, index);
            elif enclosing? then
                return enclosing.get_address(base, frame, index);
            else
                throw new Exception("frame not found: " + frame);
            fi            
        si
        */
    si
si
