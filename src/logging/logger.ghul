namespace Logging is
    use System.Exception;
    use System.NotImplementedException;

    use Collections.STACK;

    use IO.Std;
    use IO.TextWriter;
    use IO.StringWriter;

    use Source;
 
    trait Logger is
        is_poisoned: bool;
        error_count: int;
        any_errors: bool;

        // writer: TextWriter;

        // FIXME: pull these out?
        reset();
        speculate();
        roll_back() -> DIAGNOSTICS_STATE;
        commit();

        // FIXME: probably should be called 'merge()'
        set_state(state: DIAGNOSTICS_STATE);

        /*
        set_state(writer: TextWriter, error_count: int, is_poisoned: bool);
        write(text: string); 
        write(text: string, error_count: int, is_poisoned: bool);
        */

        exception(location: LOCATION, exception: Exception, message: string);
        fatal(location: LOCATION, message: string);
        error(location: LOCATION, message: string);
        warn(location: LOCATION, message: string);
        poison(location: LOCATION, message: string);
        info(location: LOCATION, message: string);

        @IF.release()
        write_poison_messages();

        clear();

        write_all_diagnostics(writer: TextWriter, format: (DIAGNOSTIC_MESSAGE) -> string);
    si

    class LoggerBase is
        @IF.release()
        _poison_messages: Collections.LIST[string];

        is_poisoned: bool;
        error_count: int;
        writer: IO.TextWriter;
        any_errors: bool => error_count > 0;

        init(writer: IO.TextWriter) is
            super.init();
            self.writer = writer;
        si

        reset();
        speculate();
        roll_back() -> (text: string, error_count: int, is_poisoned: bool);
        commit();

        set_state(writer: TextWriter, error_count: int, is_poisoned: bool) is
            self.writer = writer;
            self.error_count = error_count;
            self.is_poisoned = is_poisoned;
        si

        write(text: string) is
            writer.write(text);
        si

        write(text: string, error_count: int, is_poisoned: bool) is
            writer.write(text);
            self.error_count = self.error_count + error_count;
            // self.is_poisoned = self.is_poisoned \/ is_poisoned;
        si

        write(location: LOCATION, severity: string, message: string) is
            throw new NotImplementedException("abstract: implement me");
        si

        check_internal(location: LOCATION, message: string) -> bool is
            throw new NotImplementedException("abstract: implement me");
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            throw new NotImplementedException("abstract: implement me");
        si

        fatal(location: LOCATION, message: string) is
            write(location, "error", message);
        si

        error(location: LOCATION, message: string) is
            error_count = error_count + 1;
            if error_count >= 5000 then
                throw new Exception("too many errors");
            fi

            if check_internal(location, message) then
                return;
            fi
                        
            write(location, "error", message);
        si

        warn(location: LOCATION, message: string) is
            write(location, "warn", message);
        si

        poison(location: LOCATION, message: string) is
            is_poisoned = true;

            @IF.not.release()
            write(location, "info", message);

            @IF.release()
            buffer_poison_message(location, message);
        si

        @IF.release()
        buffer_poison_message(location: LOCATION, message: string) is
            if !_poison_messages? then
                _poison_messages = new Collections.LIST[string]();
            fi

            let temp = writer;

            try
                writer = new IO.StringWriter();

                write(location, "error", message);

                _poison_messages.add(writer.to_string());
            finally
                writer = temp;
            yrt
            
            // _poison_messages.add(
            //     string.format(
            //         "{0}: {1},{2}..{3},{4}: {5}: {6}\n",
            //         [
            //             location.file_name, 
            //             location.start_line, 
            //             location.start_column, 
            //             location.end_line, 
            //             location.end_column+1, 
            //             "error", 
            //             message
            //         ] 
            //     )
            // );
        si

        @IF.release()
        write_poison_messages() is
            if is_poisoned then
                for message in _poison_messages do
                    writer.write(message);
                od                
            fi
        si

        info(location: LOCATION, message: string) is
            write(location, "info", message);
        si
        
        clear() is
            error_count = 0;
        si
    si
si
