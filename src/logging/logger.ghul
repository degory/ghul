namespace Logging is
    use System.Exception;
    use System.NotImplementedException;

    use Collections.STACK;

    use IO.Std;
    use IO.TextWriter;
    use IO.StringWriter;

    use Source;

    trait Logger is
        is_poisoned: bool;
        has_consumed_error: bool;
        has_consumed_any: bool;

        error_count: int;
        any_errors: bool;

        is_clean: bool;
        
        depth: int;

        speculate();
        roll_back() -> DIAGNOSTICS_STATE;
        commit();
        mark() -> int;
        release(mark: int);

        speculate_then_commit() -> LOGGER_SPECULATE_THEN_COMMIT;
        speculate_then_backtrack() -> LOGGER_SPECULATE_THEN_BACKTRACK;
        mark_then_release() -> MARK_THEN_RELEASE;

        start_analysis();
        end_analysis();

        merge(state: DIAGNOSTICS_STATE);

        exception(location: LOCATION, exception: Exception, message: string);
        fatal(location: LOCATION, message: string);
        error(location: LOCATION, message: string);
        warn(location: LOCATION, message: string);
        poison(location: LOCATION, message: string);
        info(location: LOCATION, message: string);
        hint(location: LOCATION, message: string);

        poison(location: LOCATION);
        mark_consumed_error();
        mark_consumed_any();

        clear_consumed_error();
        clear_consumed_any();

        write_poison_messages();

        clear(path: string, analysis_only: bool);

        write_all_diagnostics(writer: TextWriter, formatter: DiagnosticFormatter);
    si

    struct LOGGER_SPECULATE_THEN_COMMIT: Disposable is
        _logger: Logger;

        has_consumed_any: bool => _logger.has_consumed_any;
        has_consumed_error: bool => _logger.has_consumed_error;

        any_errors: bool => _logger.any_errors;

        is_speculating: bool => _logger != null;

        init(logger: Logger) is
            _logger = logger;
            _logger.speculate();
        si

        backtrack() -> DIAGNOSTICS_STATE is
            let result = _logger.roll_back();
            _logger = null;
            return result;
        si

        backtrack_if_speculating() -> DIAGNOSTICS_STATE is
            if _logger != null then
                return backtrack();
            else
                return null;
            fi
        si

        backtrack_and_restart() -> DIAGNOSTICS_STATE is
            let result = _logger.roll_back();
            _logger.speculate();
            return result;
        si

        commit() is
            _logger.commit();
            _logger = null;
        si

        cancel() is
            _logger = null;
        si        

        dispose() is
            if _logger != null then
                _logger.commit();
                _logger = null;
            fi
        si
    si
    
    struct LOGGER_SPECULATE_THEN_BACKTRACK: Disposable is
        _logger: Logger;

        has_consumed_any: bool => _logger.has_consumed_any;
        has_consumed_error: bool => _logger.has_consumed_error;

        any_errors: bool => _logger.any_errors;

        is_speculating: bool => _logger != null;

        init(logger: Logger) is
            _logger = logger;
            _logger.speculate();
        si

        backtrack() -> DIAGNOSTICS_STATE is
            let result = _logger.roll_back();
            _logger = null;
            return result;
        si

        backtrack_and_restart() -> DIAGNOSTICS_STATE is
            let result = _logger.roll_back();
            _logger.speculate();
            return result;
        si

        commit() is
            _logger.commit();
            _logger = null;
        si

        cancel() is
            _logger = null;
        si

        dispose() is
            if _logger != null then
                _logger.roll_back();
                _logger = null;
            fi
        si
    si

    struct MARK_THEN_RELEASE: Disposable is
        _logger: Logger;
        _mark: int;

        init(logger: Logger) is
            _logger = logger;
            _mark = _logger.mark();
        si

        dispose() is
            _logger.release(_mark);
        si
    si
si
