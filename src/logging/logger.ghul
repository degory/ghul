namespace Logging is
    use System.Exception;
    use System.NotImplementedException;

    use Collections.STACK;

    use IO.Std;
    use IO.TextWriter;
    use IO.StringWriter;

    use Source;
 
    trait Logger is
        is_poisoned: bool;
        error_count: int;
        any_errors: bool;
        writer: TextWriter;

        // FIXME: pull these out?
        reset();
        speculate();
        roll_back() -> LoggerRollback;
        commit();
        
        set_state(writer: TextWriter, error_count: int, is_poisoned: bool);
        write(text: string);
        write(text: string, error_count: int, is_poisoned: bool);

        exception(location: LOCATION, exception: Exception, message: string);
        fatal(location: LOCATION, message: string);
        error(location: LOCATION, message: string);
        warn(location: LOCATION, message: string);
        poison(location: LOCATION, message: string);
        info(location: LOCATION, message: string);

        @IF.release()
        write_poison_messages();

        clear();
    si

    trait LoggerRollback is
        has_errors: bool;

        roll_forward();
    si
    
    class LOGGER_BASE_ROLL_BACK: LoggerRollback is
        _logger: Logger;
        _is_poisoned: bool;
        _value: string;

        has_errors: bool => _value?;

        roll_forward() is
            if _value? then
                _logger.write(_value);
            fi

            _value = null;
        si        
    si

    class LOGGER_STATE_STACK is
        stack: STACK[(writer: TextWriter, error_count: int, is_poisoned: bool)];

        depth: int => stack.count;

        init() is
            stack = new STACK[(TextWriter, int, bool)]();
        si

        speculate(logger: LoggerBase) is            
            stack.push((logger.writer, logger.error_count, logger.is_poisoned));

            logger.set_state(new StringWriter(), logger.error_count, logger.is_poisoned);
        si

        roll_back(logger: LoggerBase) -> (text: string, error_count: int, is_poisoned: bool) is
            let result = (cast StringWriter(logger.writer).to_string(), logger.error_count, logger.is_poisoned);

            let previous_state = stack.pop();

            logger.set_state(previous_state.writer, previous_state.error_count, previous_state.is_poisoned);

            return result;
        si

        commit(logger: LoggerBase) is
            let previous_state = stack.pop();

            let buffered_text = cast StringWriter(logger.writer).to_string();

            logger.set_state(previous_state.writer, logger.error_count, logger.is_poisoned);

            logger.write(buffered_text);
        si
    si

    /* LOGGER_WRAPPER holds a logger which can be switched on the fly
     * so Logger can be passed once at startup to classes that
     * depend on it, and the underlying logger can be changed 
     * as needed without updating existing references
     */     
    class LOGGER_WRAPPER: Logger is
        state_stack: LOGGER_STATE_STACK;
        logger: Logger public;

        writer: TextWriter => logger.writer;

        is_poisoned: bool => logger.is_poisoned;
        error_count: int => logger.error_count;
        any_errors: bool => logger.any_errors;

        init(logger: Logger) is
            self.logger = logger;

            state_stack = new LOGGER_STATE_STACK();
        si

        reset() is
            let need_to_poison = false;

            for i in 0..state_stack.depth-1 do
                let state = state_stack.roll_back(self);

                need_to_poison = need_to_poison \/ state.is_poisoned;
            od

            if need_to_poison then
                self.poison(Source.LOCATION.internal, "logger state stack corrupt");
            fi
        si

        speculate() is
            state_stack.speculate(self);
        si
        
        roll_back() -> (text: string, error_count: int, is_poisoned: bool) =>
            state_stack.roll_back(self);

        commit() is
            state_stack.commit(self);
        si

        set_state(writer: TextWriter, error_count: int, is_poisoned: bool) is
            logger.set_state(writer, error_count, is_poisoned);
        si

        write(text: string) is
            logger.write(text);
        si

        write(text: string, error_count: int, is_poisoned: bool) is
            logger.write(text, error_count, is_poisoned);
        si
      
        exception(location: LOCATION, exception: Exception, message: string) is
            logger.exception(location, exception, message);
        si
        
        fatal(location: LOCATION, message: string) is
            logger.fatal(location, message);
        si

        error(location: LOCATION, message: string) is
            logger.error(location, message);
        si

        warn(location: LOCATION, message: string) is
            logger.warn(location, message);
        si

        poison(location: LOCATION, message: string) is
            logger.poison(location, message);
        si

        @IF.release()
        write_poison_messages() is
            logger.write_poison_messages();
        si        

        info(location: LOCATION, message: string) is
            logger.info(location, message);
        si

        clear() is
            logger.clear();
        si
    si

    class LoggerBase is
        @IF.release()
        _poison_messages: Collections.LIST[string];

        is_poisoned: bool;
        error_count: int;
        writer: IO.TextWriter;
        any_errors: bool => error_count > 0;

        init(writer: IO.TextWriter) is
            self.writer = writer;
        si

        reset();
        speculate();
        roll_back() -> (text: string, error_count: int, is_poisoned: bool);
        commit();

        set_state(writer: TextWriter, error_count: int, is_poisoned: bool) is
            self.writer = writer;
            self.error_count = error_count;
            self.is_poisoned = is_poisoned;
        si

        write(text: string) is
            writer.write(text);
        si

        write(text: string, error_count: int, is_poisoned: bool) is
            writer.write(text);
            self.error_count = self.error_count + error_count;
            // self.is_poisoned = self.is_poisoned \/ is_poisoned;
        si

        write(location: LOCATION, severity: string, message: string) is
            throw new NotImplementedException("abstract: implement me");
        si

        check_internal(location: LOCATION, message: string) -> bool is
            throw new NotImplementedException("abstract: implement me");
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            throw new NotImplementedException("abstract: implement me");
        si

        fatal(location: LOCATION, message: string) is
            write(location, "error", message);
        si

        error(location: LOCATION, message: string) is
            error_count = error_count + 1;
            if error_count >= 5000 then
                throw new Exception("too many errors");
            fi

            if check_internal(location, message) then
                return;
            fi
                        
            write(location, "error", message);
        si

        warn(location: LOCATION, message: string) is
            write(location, "warn", message);
        si

        poison(location: LOCATION, message: string) is
            is_poisoned = true;

            @IF.not.release()
            write(location, "info", message);

            @IF.release()
            buffer_poison_message(location, message);
        si

        @IF.release()
        buffer_poison_message(location: LOCATION, message: string) is
            if !_poison_messages? then
                _poison_messages = new Collections.LIST[string]();
            fi

            let temp = writer;

            try
                writer = new IO.StringWriter();

                write(location, "error", message);

                _poison_messages.add(writer.to_string());
            finally
                writer = temp;
            yrt
        si

        @IF.release()
        write_poison_messages() is
            if is_poisoned then
                for message in _poison_messages do
                    writer.write(message);
                od                
            fi
        si

        info(location: LOCATION, message: string) is
            write(location, "info", message);
        si
        
        clear() is
            error_count = 0;
        si
    si

    class HUMAN_READABLE_LOGGER: LoggerBase, Logger is        
        init(writer: IO.TextWriter) is
            super.init(writer);
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            if !location? then
                location = LOCATION.internal;
            fi
            
            Std.error.write_line(exception);

            fatal(location, message);
        si

        fatal(location: LOCATION, message: string) is
            super.fatal(location, message);

            // FIXME: #562 terminate on fatal exceptions
            throw new Exception("fatal error");
        si

        check_internal(location: LOCATION, message: string) -> bool is
            if location.is_internal then
                fatal(location, "error in internal symbol: " + message);
                return true;
            fi
        si

        write(location: LOCATION, severity: string, message: string) is
            writer.write(
                "{0}: {1},{2}..{3},{4}: {5}: {6}\n",
                [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ] 
            );
        si
    si

    class MSBUILD_LOGGER: LoggerBase, Logger is
        init(writer: IO.TextWriter) is
            super.init(writer);
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            if !location? then
                location = LOCATION.internal;
            fi
            
            Std.error.write_line(exception);

            fatal(location, message);
        si

        fatal(location: LOCATION, message: string) is
            super.fatal(location, message);

            // FIXME: #562 terminate on fatal exceptions
            throw new Exception("fatal error");
        si

        check_internal(location: LOCATION, message: string) -> bool is
            if location.is_internal then
                fatal(location, "error in internal symbol: " + message);
                return true;
            fi
        si

        write(location: LOCATION, severity: string, message: string) is
            if severity =~ "warn" then
                severity = "warning";
            fi

            writer.write(
                "{0}({1},{2}): {3}: {4}\n",
                [
                    location.file_name,
                    location.start_line,
                    location.start_column,
                    severity,
                    message
                ]
            );
        si
    si

    class TAB_DELIMITED_LOGGER: LoggerBase, Logger is
        init(writer: IO.TextWriter) is
            super.init(writer);
        si

        check_internal(location: LOCATION, message: string) -> bool is
            if location.is_internal then
                @IF.not.release()                
                Std.error.write_line("ignore error for internal symbol: " + location + ": " + message);
                return true;
            fi

            return false;
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            @IF.not.release()            
            Std.error.write_line("exception: " + location + ": " + exception.get_type() + ": " + exception.to_string().replace('\n', ' '));
        si

        write(location: LOCATION, severity: string, message: string) is
            let s = string.format(
                "{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}",
                [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ]
            ).replace('\n', ' ') + '\n';

            if s.contains("{6}") then
                Std.error.write_line("garbled error: " + s);
                return;    
            fi            

            writer.write(s);
        si
    si    
si
