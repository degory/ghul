namespace Logging is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use STD = System.Console;

    use System;
    use Source;
 
    trait Logger is
        is_poisoned: bool;
        error_count: int;
        any_errors: bool;

        exception(location: LOCATION, exception: Exception, message: string);
        fatal(location: LOCATION, message: string);
        error(location: LOCATION, message: string);
        warn(location: LOCATION, message: string);
        poison(location: LOCATION, message: string);
        info(location: LOCATION, message: string);

        @IF.release()
        write_poison_messages();

        clear();
    si

    /* LOGGER_WRAPPER holds a logger which can be switched on the fly
     * so Logger can be passed once at startup to classes that
     * depend on it, and the underlying logger can be changed 
     * as needed without updating existing references
     */     
    class LOGGER_WRAPPER: object, Logger is
        logger: Logger public;

        is_poisoned: bool => logger.is_poisoned;
        error_count: int => logger.error_count;
        any_errors: bool => logger.any_errors;

        init(logger: Logger) is
            self.logger = logger;
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            logger.exception(location, exception, message);
        si
        
        fatal(location: LOCATION, message: string) is
            logger.fatal(location, message);
        si

        error(location: LOCATION, message: string) is
            logger.error(location, message);
        si

        warn(location: LOCATION, message: string) is
            logger.warn(location, message);
        si

        poison(location: LOCATION, message: string) is
            logger.poison(location, message);
        si

        @IF.release()
        write_poison_messages() is
            logger.write_poison_messages();
        si        

        info(location: LOCATION, message: string) is
            logger.info(location, message);
        si

        clear() is
            logger.clear();
        si
    si

    class LoggerBase is
        @IF.release()
        _poison_messages: Collections.LIST[string];

        is_poisoned: bool;
        error_count: int;
        writer: IO2.TextWriter;
        any_errors: bool => error_count > 0;

        init(writer: IO2.TextWriter) is
            super.init();
            self.writer = writer;
        si

        write(location: LOCATION, severity: string, message: string) is
            throw new NotImplementedException("abstract: implement me");
        si

        check_internal(location: LOCATION, message: string) -> bool is
            throw new NotImplementedException("abstract: implement me");
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            throw new NotImplementedException("abstract: implement me");
        si

        fatal(location: LOCATION, message: string) is
            write(location, "error", message);
        si

        error(location: LOCATION, message: string) is
            error_count = error_count + 1;
            if error_count >= 5000 then
                throw new Exception("too many errors");
            fi

            if check_internal(location, message) then
                return;
            fi
                        
            write(location, "error", message);
        si

        warn(location: LOCATION, message: string) is
            write(location, "warn", message);
        si

        poison(location: LOCATION, message: string) is
            is_poisoned = true;

            @IF.not.release()
            write(location, "info", message);

            @IF.release()
            buffer_poison_message(location, message);
        si

        @IF.release()
        buffer_poison_message(location: LOCATION, message: string) is
            if !_poison_messages? then
                _poison_messages = new Collections.LIST[string]();
            fi

            _poison_messages.add(
                string.format(
                    "{0}: {1},{2}..{3},{4}: {5}: {6}\n",
                    [
                        location.file_name, 
                        location.start_line, 
                        location.start_column, 
                        location.end_line, 
                        location.end_column+1, 
                        "error", 
                        message
                    ] 
                )
            );
        si

        @IF.release()
        write_poison_messages() is
            if is_poisoned then
                for message in _poison_messages do
                    writer.write(message);
                od                
            fi
        si

        info(location: LOCATION, message: string) is
            write(location, "info", message);
        si
        
        clear() is
            error_count = 0;
        si
    si

    class HUMAN_READABLE_LOGGER: LoggerBase, Logger is
        
        init(writer: IO2.TextWriter) is
            super.init(writer);
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            if !location? then
                location = LOCATION.dummy;
            fi
            
            STD.error.write_line(exception);

            fatal(location, message);
        si

        fatal(location: LOCATION, message: string) is
            super.fatal(location, message);

            // FIXME: #562 terminate on fatal exceptions
            throw new Exception("fatal error");
        si

        check_internal(location: LOCATION, message: string) -> bool is
            if location.is_internal then
                fatal(location, "error in internal symbol: " + message);
                return true;
            fi
        si

        write(location: LOCATION, severity: string, message: string) is
            writer.write(
                "{0}: {1},{2}..{3},{4}: {5}: {6}\n",
                [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ] 
            );
        si
    si

    class TAB_DELIMITED_LOGGER: LoggerBase, Logger is
        init(writer: IO2.TextWriter) is
            super.init(writer);
        si

        check_internal(location: LOCATION, message: string) -> bool is
            if location.is_internal then
                @IF.not.release()                
                STD.error.write_line("ignore error for internal symbol: " + location + ": " + message);
                return true;
            fi

            return false;
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            @IF.not.release()            
            STD.error.write_line("exception: " + location + ": " + exception.get_type() + ": " + exception.message);
        si

        write(location: LOCATION, severity: string, message: string) is
            let s = string.format(
                "{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}",
                [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ]
            ).replace('\n', ' ') + '\n';

            if s.contains("{6}") then
                STD.error.write_line("garbled error: " + s);
                return;    
            fi            

            writer.write(s);
        si
    si    
si
