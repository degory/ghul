namespace Logging is
    use System.Exception;
    use System.NotImplementedException;

    use Collections.STACK;

    use IO.Std;
    use IO.TextWriter;
    use IO.StringWriter;

    use Source;

    struct DEBUG_THEN_EXIT: Disposable is
        _initialized: bool;
        _depth: int;

        init(depth: int) is
            _initialized = true;
            _depth = depth;
        si

        dispose() is
            if _initialized then
                _debug_depth = _depth;
            fi

            _initialized = false;
        si
    si

    _debug_depth: int;

    debug_enter() -> DEBUG_THEN_EXIT is
        let result = new DEBUG_THEN_EXIT(_debug_depth);

        _debug_depth = _debug_depth + 1;

        return result;
    si

    in_debug() -> bool is
        return _debug_depth > 0;
    si

    debug_enter(want_debug: bool) is
        if want_debug then
            debug_enter();
        fi
    si

    debug_exit() is
        _debug_depth = _debug_depth - 1;
    si

    debug_exit(want_debug: bool) is
        if want_debug then
            debug_exit();
        fi
    si

    debug_reset() is
        _debug_depth = 0;
    si

    debug_indent() is
        if _debug_depth > 0 then
            _debug_depth = _debug_depth + 1;
        fi
    si

    debug_unindent() is
        if _debug_depth > 0 then
            _debug_depth = _debug_depth - 1;
        fi
    si

    debug(message: string) is
        if _debug_depth > 0 then
            debug_always(message);
        fi
    si

    debug_always(message: string) is
        for i in 0.._debug_depth do
            IO.Std.error.write("  ");
        od
        
        IO.Std.error.write_line(message);

        IO.Std.error.flush();
    si
 
    trait Logger is
        is_poisoned: bool;
        error_count: int;
        any_errors: bool;
        
        depth: int;

        speculate();
        roll_back() -> DIAGNOSTICS_STATE;
        commit();
        mark() -> int;
        release(mark: int);

        speculate_then_commit() -> LOGGER_SPECULATE_THEN_COMMIT;
        speculate_then_backtrack() -> LOGGER_SPECULATE_THEN_BACKTRACK;

        start_analysis();
        end_analysis();

        merge(state: DIAGNOSTICS_STATE);

        exception(location: LOCATION, exception: Exception, message: string);
        fatal(location: LOCATION, message: string);
        error(location: LOCATION, message: string);
        warn(location: LOCATION, message: string);
        poison(location: LOCATION, message: string);
        info(location: LOCATION, message: string);

        @IF.release()
        write_poison_messages();

        clear(path: string, analysis_only: bool);

        write_all_diagnostics(writer: TextWriter, formatter: DiagnosticFormatter);
    si

    struct LOGGER_SPECULATE_THEN_COMMIT: Disposable is
        _logger: Logger;

        is_speculating: bool => _logger != null;

        init(logger: Logger) is
            debug_enter();
            debug(">> logger speculate then commit...");

            _logger = logger;
            _logger.speculate();
        si

        backtrack() -> DIAGNOSTICS_STATE is
            debug("-- logger state: explicit backtrack");

            let result = _logger.roll_back();
            _logger = null;
            return result;
        si

        backtrack_and_restart() -> DIAGNOSTICS_STATE is
            debug("-- logger state: explicit backtrack and restart");

            let result = _logger.roll_back();
            _logger.speculate();
            return result;
        si

        commit() is
            debug("-- logger state: explicit commit");

            _logger.commit();
            _logger = null;
        si

        cancel() is
            debug("-- logger state: explicit cancel");

            _logger = null;
        si        

        dispose() is
            if _logger != null then
                debug("-- logger state: implicit commit");

                _logger.commit();
                _logger = null;
            fi

            debug("<< logger state exit");
            debug_exit();
        si
    si
    
    struct LOGGER_SPECULATE_THEN_BACKTRACK: Disposable is
        _logger: Logger;

        is_speculating: bool => _logger != null;

        init(logger: Logger) is
            debug_enter();
            debug(">> logger speculate then backtrack...");

            _logger = logger;
            _logger.speculate();
        si

        backtrack() -> DIAGNOSTICS_STATE is
            debug("-- logger state: explicit backtrack");

            let result = _logger.roll_back();
            _logger = null;
            return result;
        si

        backtrack_and_restart() -> DIAGNOSTICS_STATE is
            debug("-- logger state: explicit backtrack and restart");

            let result = _logger.roll_back();
            _logger.speculate();
            return result;
        si

        commit() is
            debug("-- logger state: explicit commit");

            _logger.commit();
            _logger = null;
        si

        cancel() is
            debug("-- logger state: explicit cancel");            

            _logger = null;
        si

        dispose() is
            if _logger != null then
                debug("-- logger state: implicit backtrack");

                _logger.roll_back();
                _logger = null;
            fi

            debug("<< logger state exit");
            debug_exit();
        si
    si
si
