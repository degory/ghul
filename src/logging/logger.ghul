namespace Logging is
    use System;
    use Generic;
    use Source;
    
    trait Logger is
        error_count: int;
        any_errors: bool;

        fatal(location: LOCATION, message: String);
        error(location: LOCATION, message: String);
        warn(location: LOCATION, message: String);
        info(location: LOCATION, message: String);

        clear();
    si

    /* LOGGER_WRAPPER holds a logger which can be switched on the fly
     * so Logger can be passed once at startup to classes that
     * depend on it, and the underlying logger can be changed 
     * as needed without updating existing references
     */     
    class LOGGER_WRAPPER: Object, Logger is
        logger: Logger public;

        error_count: int => logger.error_count;
        any_errors: bool => logger.any_errors;

        init(logger: Logger) is
            self.logger = logger;
        si

        fatal(location: LOCATION, message: String) is
            logger.fatal(location, message);
        si

        error(location: LOCATION, message: String) is
            logger.error(location, message);
        si

        warn(location: LOCATION, message: String) is
            logger.warn(location, message);
        si

        info(location: LOCATION, message: String) is
            logger.info(location, message);
        si

        clear() is
            logger.clear();
        si
    si

    class LoggerBase is
        error_count: int;
        writer: IO2.TextWriter;
        any_errors: bool => error_count > 0;

        init(writer: IO2.TextWriter) is
            super.init();
            self.writer = writer;
        si

        write(location: LOCATION, severity: String, message: String) is
            throw new NotImplementedException("abstract: implement me");
        si

        fatal(location: LOCATION, message: String) is
            write(location, "error", message);
        si

        error(location: LOCATION, message: String) is
            write(location, "error", message);

            error_count = error_count + 1;
            if error_count >= 5000 then
                throw new Exception("too many errors");
            fi
        si

        warn(location: LOCATION, message: String) is
            write(location, "warn", message);
        si

        info(location: LOCATION, message: String) is
            write(location, "info", message);
        si
        
        clear() is
            error_count = 0;
        si
    si

    class HUMAN_READABLE_LOGGER: LoggerBase, Logger is
        init(writer: IO2.TextWriter) is
            super.init(writer);
        si

        fatal(location: LOCATION, message: String) is
            super.fatal(location, message);
            throw new Exception("fatal error");
        si

        @IF.legacy()
        write(location: LOCATION, severity: String, message: String) is
            writer.write(
                "%: %,%..%,%: %: %\n" % [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ] 
            );
        si

        @IF.dotnet()
        write(location: LOCATION, severity: String, message: String) is
            writer.write(
                "{0}: {1},{2}..{3},{4}: {5}: {6}\n",
                [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ]
            );
        si
    si

    class TAB_DELIMITED_LOGGER: LoggerBase, Logger is
        init(writer: IO2.TextWriter) is
            super.init(writer);
        si

        write(location: LOCATION, severity: String, message: String) is
            @IF.legacy()
            writer.write(
                "%\t%\t%\t%\t%\t%\t%\n" % [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ] 
            );            

            @IF.dotnet()
            writer.write(
                "{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\n",
                [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ] 
            );            

        si
    si    
si
