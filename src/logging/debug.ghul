namespace Logging is
    use System.Exception;
    use System.NotImplementedException;

    use Collections.STACK;

    use IO.Std;
    use IO.TextWriter;
    use IO.StringWriter;

    use Source;

    struct DEBUG_THEN_EXIT: Disposable is
        _initialized: bool;
        _depth: int;

        init(depth: int) is
            _initialized = true;
            _depth = depth;
        si

        init() is
            // not debugging, so dispose doesn't need to do anything
        si

        dispose() is
            if _initialized then
                while _debug_depth > _depth do
                    debug_exit();
                od
            fi

            _initialized = false;
        si
    si

    _debug_depth: int;

    debug_enter() -> DEBUG_THEN_EXIT is
        debug_always(">>>");
        let result = DEBUG_THEN_EXIT(_debug_depth);

        _debug_depth = _debug_depth + 1;

        return result;
    si

    in_debug() -> bool is
        return _debug_depth > 0;
    si

    debug_enter(want_debug: bool) -> DEBUG_THEN_EXIT =>
        if want_debug then
            debug_enter();
        else
            DEBUG_THEN_EXIT();
        fi;

    debug_exit() is
        _debug_depth = _debug_depth - 1;
        debug_always("<<<");
    si

    debug_exit(want_debug: bool) is
        if want_debug then
            debug_exit();
        fi
    si

    debug_reset() is
        _debug_depth = 0;
    si

    debug_indent() is
        if _debug_depth > 0 then
            _debug_depth = _debug_depth + 1;
        fi
    si

    debug_unindent() is
        if _debug_depth > 0 then
            _debug_depth = _debug_depth - 1;
        fi
    si

    debug(message: string) is
        if _debug_depth > 0 then
            debug_always(message);
        fi
    si

    debug_always(message: string) is
        for m in message.replace_line_endings("\n").split(['\n']) do
            for i in 0.._debug_depth do
                IO.Std.error.write("  ");
            od

            IO.Std.error.write_line(m);
        od
        
        IO.Std.error.flush();
    si
si