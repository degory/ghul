namespace Logging is
    use System.Exception;

    use Collections.Map;
    use Collections.MutableMap;
    use Collections.List;
    use Collections.MutableList;
    use Collections.Iterable;

    use Collections.MAP;
    use Collections.LIST;
    use Collections.STACK;

    use IO.TextWriter;

    use Source.LOCATION;

    /*
    
    Need: 

    A single view of diagnostic state that can return diagnostic messages by source file path

    A way to track which source file diagnostic messages are synched with the language server client

    Ideally we want to be able to query it and have it return a polymorphic list where each item is either:
    - file name and list of diagnostics OR
    - file name and flag that says unchanged
    - want reasonably efficient conversion to LSP diagnostics DTOs
    - need speculated state stack to operate at the global store level, not per file.

    */

    struct DIAGNOSTIC_MESSAGE is
        severity: DIAGNOSTIC_SEVERITY;
        location: LOCATION;
        text: string;
    si

    class DIAGNOSTICS_LIST is
        _path: string;
        _dirty: bool;
        _diagnostics: LIST[DIAGNOSTIC_MESSAGE];

        count: int => _diagnostics.count;
        diagnostics: List[DIAGNOSTIC_MESSAGE] => _diagnostics;

        init(path: string) is
            _path = path;
            _diagnostics = new LIST[DIAGNOSTIC_MESSAGE]();
        si

        add(diagnostic_message: DIAGNOSTIC_MESSAGE) is
            _dirty = true;

            _diagnostics.add(diagnostic_message);
        si

        write_all_diagnostics(writer: TextWriter, format: (DIAGNOSTIC_MESSAGE) -> string) is
            for diagnostic in _diagnostics do
                writer.write_line(format(diagnostic));
            od            
        si
    si

    class DIAGNOSTICS_STATE is
        is_poisoned: bool;
        error_count: int => _diagnostics_by_source_path.values | .reduce(0, (r, d) => r + d.count);
        any_errors: bool => _diagnostics_by_source_path.values | .has(d => d.count > 0);

        _diagnostics_by_source_path: MutableMap[string, DIAGNOSTICS_LIST];

        init() is
            _diagnostics_by_source_path = new MAP[string, DIAGNOSTICS_LIST]();
        si

        get_diagnostics_list(source_path: string) -> DIAGNOSTICS_LIST is
            let diagnostics_for_path: DIAGNOSTICS_LIST;

            if !_diagnostics_by_source_path.try_get_value(source_path, diagnostics_for_path ref) then
                diagnostics_for_path = new DIAGNOSTICS_LIST(source_path);

                _diagnostics_by_source_path.add(source_path, diagnostics_for_path);
            fi

            return diagnostics_for_path;
        si

        add_diagnostic_message(source_path: string, message: DIAGNOSTIC_MESSAGE) is
            get_diagnostics_list(source_path).add(message);
        si

        merge(state: DIAGNOSTICS_STATE) is
            for i in state._diagnostics_by_source_path do
                add_diagnostic_message(i.key, i.value.diagnostics);
            od
        si        

        add_diagnostic_message(source_path: string, diagnostics: Iterable[DIAGNOSTIC_MESSAGE]) is
            let list = get_diagnostics_list(source_path);

            for d in diagnostics do
                list.add(d);
            od
        si

        write_all_diagnostics(writer: TextWriter, format: (DIAGNOSTIC_MESSAGE) -> string) is
            for list in _diagnostics_by_source_path.values do
                list.write_all_diagnostics(writer, format);
            od
        si
    si

    class DIAGNOSTICS_STORE: Logger is
        _states: STACK[DIAGNOSTICS_STATE];

        is_poisoned: bool => _states.peek().is_poisoned;
        error_count: int => _states.peek().error_count;
        any_errors: bool => _states.peek().any_errors;

        init() is
            _states = new STACK[DIAGNOSTICS_STATE]();
            _states.push(new DIAGNOSTICS_STATE());
        si

        reset() => init();

        clear() is
            // do what?
        si

        speculate() is
            _states.push(new DIAGNOSTICS_STATE());
        si

        roll_back() -> DIAGNOSTICS_STATE is
            return _states.pop();
        si
 
        commit() is
            let to_merge = _states.pop();

            _states.peek().merge(to_merge);
        si

        set_state(state: DIAGNOSTICS_STATE) is
            // FIXME: is this right?
            _states.peek().merge(state);
        si

        write_all_diagnostics(writer: TextWriter, format: (DIAGNOSTIC_MESSAGE) -> string) is
            if _states.count > 1 then
                IO.Std.write_line("oops: expected exactly one committed diagnostics state");
            fi

            _states.peek().write_all_diagnostics(writer, format);
        si

        exception(location: LOCATION, exception: Exception, message: string) is
        si
        
        fatal(location: LOCATION, message: string) is
        si

        error(location: LOCATION, message: string) is
        si

        warn(location: LOCATION, message: string) is
        si

        info(location: LOCATION, message: string) is
        si

        poison(location: LOCATION, message: string) is
        si
    si

    class MSBUILD_DIAGNOSTIC_FORMATTER is
        _store: DIAGNOSTICS_STORE;

        init(store: DIAGNOSTICS_STORE) is
            _store = store;
        si

        write_to(writer: TextWriter) is

        si    
    si
si