namespace Logging is
    use Collections.Map;
    use Collections.MutableMap;
    use Collections.MutableList;
    use Collections.Iterable;

    use Collections.MAP;
    use Collections.LIST;
    use Collections.STACK;

    use Source.LOCATION;

    /*

    Need:

    A single view of diagnostic state that can return diagnostic messages by source file path

    A way to track which source file diagnostic messages are synched with the language server client

    Ideally we want to be able to query it and have it return a polymorphic list where each item is either:
    - file name and list of diagnostics OR
    - file name and flag that says unchanged
    - want reasonably efficient conversion to LSP diagnostics DTOs
    - need speculated state stack to operate at the global store level, not per file.


    */

    struct DIAGNOSTIC_MESSAGE is
        severity: DIAGNOSTIC_SEVERITY;
        location: LOCATION;
        text: string;
    si

    class DIAGNOSTICS_LIST is
        _path: string;
        _dirty: bool;
        _diagnostics: MutableList[DIAGNOSTIC_MESSAGE];

        init(path: string) is
            _path = path;
            _diagnostics = new LIST[DIAGNOSTIC_MESSAGE]();
        si

        add(diagnostic_message: DIAGNOSTIC_MESSAGE) is
            _dirty = true;

            _diagnostics.add(diagnostic_message);
        si
    si

    class DIAGNOSTICS_STATE is
        _diagnostics_by_source_path: MutableMap[string, DIAGNOSTICS_LIST];

        init() is
            _diagnostics_by_source_path = new MAP[string, DIAGNOSTICS_LIST]();
        si

        get_diagnostics_list(source_path: string) -> DIAGNOSTICS_LIST is
            let diagnostics_for_path: DIAGNOSTICS_LIST;

            if !_diagnostics_by_source_path.try_get_value(source_path, diagnostics_for_path ref) then
                diagnostics_for_path = new DIAGNOSTICS_LIST(source_path);

                _diagnostics_by_source_path.add(source_path, diagnostics_for_path);
            fi

            return diagnostics_for_path;
        si

        add_diagnostic_message(source_path: string, message: DIAGNOSTIC_MESSAGE) is
            get_diagnostics_list(source_path).add(message);
        si  

        add_diagnostic_message(source_path: string, diagnostics: Iterable[DIAGNOSTIC_MESSAGE]) is
            let list = get_diagnostics_list(source_path);

            for d in diagnostics do
                list.add(d);
            od
        si
    si

    class DIAGNOSTICS_STORE is
        _states: STACK[DIAGNOSTICS_STATE];

        init() is
            _states = new STACK[DIAGNOSTICS_STATE]();
        si

        speculate() is
            _states.push(new DIAGNOSTICS_STATE());
        si

        rollback() is
            _states.pop();
        si

        commit() is
        
        si
    si
si