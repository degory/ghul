namespace Logging is
    use System.Exception;

    use Collections.Map;
    use Collections.MutableMap;
    use Collections.List;
    use Collections.MutableList;
    use Collections.Iterable;

    use Collections.MAP;
    use Collections.LIST;
    use Collections.STACK;

    use IO.TextWriter;

    use Source.LOCATION;

    /*
    
    Need: 

    A single view of diagnostic state that can return diagnostic messages by source file path

    A way to track which source file diagnostic messages are synched with the language server client

    Ideally we want to be able to query it and have it return a polymorphic list where each item is either:
    - file name and list of diagnostics OR
    - file name and flag that says unchanged
    - want reasonably efficient conversion to LSP diagnostics DTOs
    - need speculated state stack to operate at the global store level, not per file.

    */

    struct DIAGNOSTIC_MESSAGE is
        is_analysis: bool;
        severity: DIAGNOSTIC_SEVERITY;
        location: LOCATION;
        text: string;
        is_fatal: bool => (severity == DIAGNOSTIC_SEVERITY.FATAL \/ severity == DIAGNOSTIC_SEVERITY.EXCEPTION);

        init(
            is_analysis: bool,
            severity: DIAGNOSTIC_SEVERITY,
            location: LOCATION,
            text: string
        ) is
            self.is_analysis = is_analysis;
            self.severity = severity;
            self.location = location;
            self.text = text;
        si

        to_string() -> string is
            return string.format("{{0}} {{1}} {{2}}", [severity, location, text]);
        si
    si

    trait DiagnosticFormatter is
        want_filter_error_cascades: bool;
        format(diagnostic: DIAGNOSTIC_MESSAGE) -> string;
    si

    class TAB_DELIMITED_DIAGNOSTIC_FORMATTER: DiagnosticFormatter is
        want_filter_error_cascades: bool => true;

        init() is
        si

        format(diagnostic: DIAGNOSTIC_MESSAGE) -> string is
            /*
            if diagnostic.is_fatal then
                // IO.Std.error.write_line("suppress fatal diagnostic: {diagnostic}");
                return null;
            fi
            */

            let location = diagnostic.location;
            let severity = 
                if diagnostic.is_fatal then
                    cast int(DIAGNOSTIC_SEVERITY.HINT);
                else
                    cast int(diagnostic.severity);
                fi;

            let message = diagnostic.text;

            let s = string.format(
                "{{0}}\t{{1}}\t{{2}}\t{{3}}\t{{4}}\t{{5}}\t{{6}}",
                [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    cast int(severity), 
                    message
                ]
            ).replace('\n', ' ');

            return s;        
        si
    si

    class HUMAN_READABLE_DIAGNOSTIC_FORMATTER: DiagnosticFormatter is
        want_filter_error_cascades: bool => false;

        init() is
        si

        format(diagnostic: DIAGNOSTIC_MESSAGE) -> string is
            if diagnostic.is_fatal then
                IO.Std.error.write_line("suppress fatal diagnostic: {diagnostic}");
                return null;
            fi

            let location = diagnostic.location;
            let severity = diagnostic.severity.to_string().to_lower();
            let message = diagnostic.text;

            let s = string.format(
                "{{0}}: {{1}},{{2}}..{{3}},{{4}}: {{5}}: {{6}}",
                [
                    location.file_name, 
                    location.start_line, 
                    location.start_column, 
                    location.end_line, 
                    location.end_column+1, 
                    severity, 
                    message
                ] 
            );
    
            return s;
        si
    si

    class MSBUILD_DIAGNOSTIC_FORMATTER: DiagnosticFormatter is
        want_filter_error_cascades: bool => false;

        init() is
        si

        format(diagnostic: Logging.DIAGNOSTIC_MESSAGE) -> string is
            let location = diagnostic.location;
            let severity = diagnostic.severity;
            let message = diagnostic.text;

            let s = string.format(
                "{{0}}({{1}},{{2}}): {{3}}: {{4}}",
                [
                    location.file_name,
                    location.start_line,
                    location.start_column,
                    severity,
                    message
                ]
            );
    
            return s;
        si
    si

    class DIAGNOSTICS_LIST is
        _path: string;
        _dirty: bool;
        _diagnostics: LIST[DIAGNOSTIC_MESSAGE];

        is_poisoned: bool;
        any_errors: bool => _diagnostics | .any(d => d.severity == DIAGNOSTIC_SEVERITY.ERROR);
        any_warnings: bool => _diagnostics | .any(d => d.severity == DIAGNOSTIC_SEVERITY.WARN);
        
        count: int => _diagnostics.count;
        syntax_count: int => _diagnostics | .filter(d => !d.is_analysis) .count();
        analysis_count: int => _diagnostics | .filter(d => d.is_analysis) .count();

        diagnostics: List[DIAGNOSTIC_MESSAGE] => _diagnostics;

        init(path: string) is
            _path = path;
            _diagnostics = new LIST[DIAGNOSTIC_MESSAGE]();
        si

        add(diagnostic_message: DIAGNOSTIC_MESSAGE) is
            _dirty = true;

            if diagnostic_message.severity == DIAGNOSTIC_SEVERITY.FATAL \/ diagnostic_message.severity == DIAGNOSTIC_SEVERITY.EXCEPTION then
                is_poisoned = true;
            fi

            _diagnostics.add(diagnostic_message);
        si

        poison() is
            is_poisoned = true;
        si

        clear(analysis_only: bool) is
            if analysis_only == false then
                _dirty = true;
                _diagnostics.clear();
            else
                let n = new LIST[DIAGNOSTIC_MESSAGE](_diagnostics.count);

                for d in _diagnostics do
                    if !d.is_analysis then
                        n.add(d);
                    fi
                od

                _diagnostics = n;
            fi
        si

        write_all_diagnostics(writer: TextWriter, formatter: DiagnosticFormatter) is
            if _diagnostics.count == 0 then
                // FIXME: we only want to do this for the LSP connection
                writer.write(_path);
                writer.write("\n");

                return;
            fi

            for diagnostic in _diagnostics do
                let formatted = formatter.format(diagnostic);

                if formatted? then
                    writer.write(formatted);
                    writer.write("\n");
                fi
            od            
        si

        write_filtered_diagnostics(writer: TextWriter, formatter: DiagnosticFormatter) is
            if _diagnostics | .filter(d => !d.is_analysis) .count() == 0 then
                // clear errors in the client if none are present

                // FIXME: we only want to do this for the LSP connection
                writer.write(_path);
                writer.write("\n");

                return;
            fi

            // only write the first 15 syntax diagnostics per source file, on the assumption that
            // the first few are probably the root cause of the whole error cascade. Note this
            // relies on errors being written in the order they are discovered, which is guaranteed
            // for syntax errors, but not for analysis errors.
            for diagnostic in _diagnostics | .filter(d => !d.is_analysis) | .take(15) do
                let formatted = formatter.format(diagnostic);

                if formatted? then
                    writer.write(formatted);
                    writer.write("\n");
                fi
            od            
        si
    si

    class DIAGNOSTICS_STATE is
        count: int => _diagnostics_by_source_path.values | .reduce(0, (r, d) => r + d.count);
        is_poisoned: bool => _diagnostics_by_source_path.values | .any(d => d.is_poisoned);
        any_errors: bool => _diagnostics_by_source_path.values | .any(d => d.any_errors);
        any_warnings: bool => _diagnostics_by_source_path.values | .any(d => d.any_warnings);

        is_possible_error_cascade: bool =>
            (_diagnostics_by_source_path.values | .any(d => d.syntax_count > 0)) /\ 
            (_diagnostics_by_source_path.values | .reduce(0, (r, d) => r + d.count) > 30);
        
        _diagnostics_by_source_path: MutableMap[string, DIAGNOSTICS_LIST];

        init() is
            _diagnostics_by_source_path = new MAP[string, DIAGNOSTICS_LIST]();
        si

        clear() is
            for i in _diagnostics_by_source_path.values do
                i.clear(false);
            od

            init();
        si

        clear(source_path: string, analysis_only: bool) is
            get_diagnostics_list(source_path).clear(analysis_only);
        si

        get_diagnostics_list(source_path: string) -> DIAGNOSTICS_LIST is
            let diagnostics_for_path: DIAGNOSTICS_LIST;

            if !_diagnostics_by_source_path.try_get_value(source_path, diagnostics_for_path ref) then
                diagnostics_for_path = new DIAGNOSTICS_LIST(source_path);

                _diagnostics_by_source_path.add(source_path, diagnostics_for_path);
            fi

            return diagnostics_for_path;
        si

        add_diagnostic_message(source_path: string, message: DIAGNOSTIC_MESSAGE) is
            get_diagnostics_list(source_path).add(message);
        si

        poison(source_path: string) is
            get_diagnostics_list(source_path).poison();
        si

        merge(state: DIAGNOSTICS_STATE) is
            for i in state._diagnostics_by_source_path do
                add_diagnostic_message(i.key, i.value.diagnostics);
            od
        si        

        add_diagnostic_message(source_path: string, diagnostics: Iterable[DIAGNOSTIC_MESSAGE]) is
            let list = get_diagnostics_list(source_path);

            for d in diagnostics do
                list.add(d);
            od
        si

        write_all_diagnostics(writer: TextWriter, formatter: DiagnosticFormatter) is
            for list in _diagnostics_by_source_path.values do
                list.write_all_diagnostics(writer, formatter);
            od
        si

        write_filtered_diagnostics(writer: TextWriter, formatter: DiagnosticFormatter) is
            for list in _diagnostics_by_source_path.values do
                list.write_filtered_diagnostics(writer, formatter);
            od
        si
    si

    class DIAGNOSTICS_STORE: Logger is
        _states: STACK[DIAGNOSTICS_STATE];

        is_poisoned: bool => _states.peek().is_poisoned;
        error_count: int => _states.peek().count;
        any_errors: bool => _states.peek().any_errors;
        any_warnings: bool => _states.peek().any_warnings;

        is_analysis: bool public;

        depth: int => _states.count;

        init() is
            _states = new STACK[DIAGNOSTICS_STATE]();
            _states.push(new DIAGNOSTICS_STATE());
        si

        start_analysis() is
            is_analysis = true;
        si

        end_analysis() is
            is_analysis = false;
        si

        only: DIAGNOSTICS_STATE is
            assert _states.count == 1 else "expected exactly one stacked diagnostics state, found {_states.count}";

            return _states.peek();
        si

        top: DIAGNOSTICS_STATE is
            assert _states.count >= 1 else "expected at least one stacked diagnostics state";

            return _states.peek();
        si

        pop() -> DIAGNOSTICS_STATE is
            assert _states.count >= 1 else "expected at least one stacked diagnostics state";

            return _states.pop();
        si

        clear(source_path: string, analysis_only: bool) is
            only.clear(source_path, analysis_only);
        si

        speculate() is
            _states.push(new DIAGNOSTICS_STATE());
        si

        roll_back() -> DIAGNOSTICS_STATE is
            let result = pop();

            return result;
        si
 
        commit() is
            let to_merge = pop();

            top.merge(to_merge);
        si

        mark() -> int is
            return _states.count;
        si

        release(mark: int) is
            if _states.count == mark then
                return;
            fi

            // IO.Std.error.write_line("diagnostics store: re-sync from depth {_states.count} to {mark}");

            while _states.count > mark do
                pop();
            od
        si

        speculate_then_commit() -> LOGGER_SPECULATE_THEN_COMMIT =>
            new LOGGER_SPECULATE_THEN_COMMIT(self);

        speculate_then_backtrack() -> LOGGER_SPECULATE_THEN_BACKTRACK =>
            new LOGGER_SPECULATE_THEN_BACKTRACK(self);

        mark_then_release() -> MARK_THEN_RELEASE =>
            new MARK_THEN_RELEASE(self);

        merge(state: DIAGNOSTICS_STATE) is
            top.merge(state);
        si

        write_all_diagnostics(writer: TextWriter, formatter: DiagnosticFormatter) is
            let state = only;

            if formatter.want_filter_error_cascades /\ state.is_possible_error_cascade then
                state.write_filtered_diagnostics(writer, formatter);
            else
                state.write_all_diagnostics(writer, formatter);
            fi
        si

        exception(location: LOCATION, exception: Exception, message: string) is
            if _states.count == 0 then
                IO.Std.error.write_line("diagnostics store: exception depth {_states.count}: {location}: {message}: {exception}");
            fi

            top.add_diagnostic_message(location.file_name, new DIAGNOSTIC_MESSAGE(is_analysis, DIAGNOSTIC_SEVERITY.EXCEPTION, location, "{message}: {exception}"));
        si
        
        fatal(location: LOCATION, message: string) is
            IO.Std.error.write_line("diagnostics store: fatal depth {_states.count}: {location}: {message}");

            top.add_diagnostic_message(location.file_name, new DIAGNOSTIC_MESSAGE(is_analysis, DIAGNOSTIC_SEVERITY.FATAL, location, message));
        si

        error(location: LOCATION, message: string) is
            top.add_diagnostic_message(location.file_name, new DIAGNOSTIC_MESSAGE(is_analysis, DIAGNOSTIC_SEVERITY.ERROR, location, message));
        si

        warn(location: LOCATION, message: string) is
            top.add_diagnostic_message(location.file_name, new DIAGNOSTIC_MESSAGE(is_analysis, DIAGNOSTIC_SEVERITY.WARN, location, message));
        si

        info(location: LOCATION, message: string) is
            top.add_diagnostic_message(location.file_name, new DIAGNOSTIC_MESSAGE(is_analysis, DIAGNOSTIC_SEVERITY.INFO, location, message));
        si

        poison(location: LOCATION, message: string) is
            top.add_diagnostic_message(location.file_name, new DIAGNOSTIC_MESSAGE(is_analysis, DIAGNOSTIC_SEVERITY.FATAL, location, message));
            top.poison(location.file_name);
        si

        @IF.release()
        write_poison_messages() is
            // FIXME
            if is_poisoned then
                IO.Std.error.write("internal compiler error\n");
            fi
        si
    si
si