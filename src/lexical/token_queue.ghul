namespace Lexical is
    use Collections;

    use Logging;

    class TOKEN_QUEUE is
        _buffer: LIST[TOKEN_PAIR];
        _speculate_index: int;
        _read_index: int;
        _write_index: int;
        _size: int;

        count: int => (_write_index - _read_index + _size) ∩ (_size - 1);

        avail: bool => count > 0;

        _peek_offset(index: int) -> int =>
            (_read_index + index) ∩ (_size - 1);

        _next_index(index: int) -> int =>
            (index + 1) ∩ (_size - 1);

        _prev_index(index: int) -> int =>
            (index - 1) ∩ (_size - 1);

        init() is
            _speculate_index = -1;
            _size = 512;
            _buffer = new LIST[TOKEN_PAIR](_size);

            // .NET can be very annoying sometimes...

            for i in 0.._size do
                _buffer.add(null);
            od
        si

        speculate_enter() is
            debug_always("speculate enter: {_read_index}");

            _speculate_index = _read_index;
        si

        speculate_exit() is
            debug_always("speculate enter: {_speculate_index}");

            _speculate_index = -1;
        si

        mark() -> int is
            debug_always("mark: {_read_index}");

            return _read_index;
        si

        release(index: int) is
            debug_always("release: {index}");

            _read_index = index;
        si

        peek() -> TOKEN_PAIR is
            assert _read_index != _write_index else "token queue underflow";

            return _buffer[_read_index];
        si

        enqueue(token: TOKEN_PAIR) is
            debug_always(">enqueue: {token.to_short_string()} W:{_write_index} R:{_read_index} S:{_speculate_index} C:{count} {_size}");

            _buffer[_write_index] = token;

            _write_index = _next_index(_write_index);

            debug_always("<enqueue: {token.to_short_string()} W:{_write_index} R:{_read_index} S:{_speculate_index} C:{count} {_size}");

            assert _write_index != _read_index /\ _write_index != _speculate_index else "token queue overflow";
        si

        dequeue() -> TOKEN_PAIR is
            assert _read_index != _write_index else "token queue underflow";

            let result = _buffer[_read_index];

            debug_always(">dequeue: {if result? then result.to_short_string() else "null" fi} W:{_write_index} R:{_read_index} S:{_speculate_index} C:{count} {_size}");

            _read_index = _next_index(_read_index);

            debug_always("<dequeue: {if result? then result.to_short_string() else "null" fi} W:{_write_index} R:{_read_index} S:{_speculate_index} C:{count} {_size}");
            
            return result;
        si
    si
si