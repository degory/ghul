namespace Lexical is
    use System.Exception;
    
    use Logging;
    use Source;

    class TOKEN_BUFFER  is
        _values: Collections.Queue`1[TOKEN_PAIR];

        init() is
            _values = new Collections.Queue`1[TOKEN_PAIR](10);
        si

        reset() is
            init();
        si

        avail: bool => _values.count > 0;

        write(t: TOKEN_PAIR) is
            _values.enqueue(t);
        si

        write(tokens: Collections.Iterable[TOKEN_PAIR]) is
            for t in tokens do
                _values.enqueue(t);                
            od
        si

        read() -> TOKEN_PAIR is
            return _values.dequeue();
        si
    si

    class TOKENIZER_EXCEPTION: Exception is
        init(s: string) is
            super.init(s);
        si
    si

    class TOKEN_MAP is
        _map: Collections.MAP[string,TOKEN];

        init() is
            super.init();
            _map = new Collections.MAP[string,TOKEN](223);
        si

        [s: string]: TOKEN public
            is
                if _map.contains_key(s) then
                    let t = _map[s];

                    return t;
                    // return cast TOKEN(t);
                else
                    return TOKEN.IDENTIFIER;
                fi
            si,
            = t is
                _map[s] = t;
            si

    si

    class TOKEN_PAIR  is
        token: TOKEN;
        location: LOCATION;
        value_string: string;

        name: string => TOKEN_NAMES[token];

        to_string() -> string => 
            "" + location + ": " + TOKEN_NAMES[token] + ": " + value_string;
    
        init(token: TOKEN, location: LOCATION, value: string) is
            super.init();
            self.token = token;
            self.location = location;
            self.value_string = value;
        si
    si

    class TOKENIZER is
        _prev_count: int;

        _logger: Logger;
        _token_pair: TOKEN_PAIR;
        _symbol_tokens: TOKEN_MAP static;
        _operator_chars: Collections.SET[char] static;
        _operator_tokens: Collections.MAP[string,TOKEN] static;
        _buffer: TOKEN_BUFFER;
        _input: IO.TextReader;
        _end_of_file: bool;
        _prev_char: char;
        _cursor: LOCATION_CURSOR;
        _token_name: string[];

        _interpolation_depth: int;

        static_init() static is 
            if _symbol_tokens == null then
                _operator_chars = new Collections.SET[char]([
                    '!', '$', '%', '^', '&', '*', '-', '+', '=', '|', ':', '@', '~', '#', '\\', '<', '>', '.', '?', '/'
                ]: char );

                _operator_tokens = new Collections.MAP[string,TOKEN]();
                _operator_tokens["="] = TOKEN.ASSIGN;
                _operator_tokens[":"] = TOKEN.COLON;
                _operator_tokens["."] = TOKEN.DOT;
                _operator_tokens["->"] = TOKEN.ARROW_THIN;
                _operator_tokens["=>"] = TOKEN.ARROW_FAT;
                _operator_tokens["?"] = TOKEN.QUESTION;
                _operator_tokens["@"] = TOKEN.AT;
                _symbol_tokens = new TOKEN_MAP();
                _symbol_tokens["namespace"] = TOKEN.NAMESPACE;
                _symbol_tokens["class"] = TOKEN.CLASS;
                _symbol_tokens["struct"] = TOKEN.STRUCT;
                _symbol_tokens["enum"] = TOKEN.ENUM;
                _symbol_tokens["public"] = TOKEN.PUBLIC;
                _symbol_tokens["protected"] = TOKEN.PROTECTED;
                _symbol_tokens["private"] = TOKEN.PRIVATE;
                _symbol_tokens["const"] = TOKEN.CONST;
                _symbol_tokens["static"] = TOKEN.STATIC;
                _symbol_tokens["innate"] = TOKEN.INNATE;
                _symbol_tokens["if"] = TOKEN.IF;
                _symbol_tokens["else"] = TOKEN.ELSE;
                _symbol_tokens["while"] = TOKEN.WHILE;
                _symbol_tokens["do"] = TOKEN.DO;
                _symbol_tokens["for"] = TOKEN.FOR;
                _symbol_tokens["in"] = TOKEN.IN;
                _symbol_tokens["case"] = TOKEN.CASE;
                _symbol_tokens["when"] = TOKEN.WHEN;
                _symbol_tokens["default"] = TOKEN.DEFAULT;
                _symbol_tokens["break"] = TOKEN.BREAK;
                _symbol_tokens["continue"] = TOKEN.CONTINUE;
                _symbol_tokens["ref"] = TOKEN.REF;
                _symbol_tokens["ptr"] = TOKEN.PTR;
                _symbol_tokens["new"] = TOKEN.NEW;
                _symbol_tokens["throw"] = TOKEN.THROW;
                _symbol_tokens["return"] = TOKEN.RETURN;
                _symbol_tokens["cast"] = TOKEN.CAST;
                _symbol_tokens["var"] = TOKEN.VAR;
                _symbol_tokens["try"] = TOKEN.TRY;
                _symbol_tokens["let"] = TOKEN.LET;
                _symbol_tokens["catch"] = TOKEN.CATCH;
                _symbol_tokens["finally"] = TOKEN.FINALLY;
                _symbol_tokens["self"] = TOKEN.SELF;
                _symbol_tokens["super"] = TOKEN.SUPER;
                _symbol_tokens["null"] = TOKEN.NULL;
                _symbol_tokens["use"] = TOKEN.USE;
                _symbol_tokens["trait"] = TOKEN.TRAIT;
                _symbol_tokens["isa"] = TOKEN.ISA;
                _symbol_tokens["typeof"] = TOKEN.TYPEOF;
                // _symbol_tokens["operator"] = TOKEN.OPERATOR;
                _symbol_tokens["is"] = TOKEN.IS;
                _symbol_tokens["si"] = TOKEN.SI;
                _symbol_tokens["then"] = TOKEN.THEN;
                _symbol_tokens["elif"] = TOKEN.ELIF;
                _symbol_tokens["fi"] = TOKEN.FI;
                _symbol_tokens["esac"] = TOKEN.ESAC;
                _symbol_tokens["od"] = TOKEN.OD;
                _symbol_tokens["yrt"] = TOKEN.YRT;
                _symbol_tokens["true"] = TOKEN.TRUE;
                _symbol_tokens["false"] = TOKEN.FALSE;
                _symbol_tokens["assert"] = TOKEN.ASSERT;
            fi
        si

        init(logger: Logger, file_name: string, i: IO.TextReader, is_internal_file: bool) is            
            super.init();

            _logger = logger;

            _buffer = new TOKEN_BUFFER();
            _end_of_file = false;
            _input = i;

            static_init();

            if is_internal_file then
                _cursor = new INTERNAL_LOCATION_CURSOR();
            else
                _cursor = new LOCATION_CURSOR(file_name);
            fi
            
            _token_pair = new TOKEN_PAIR(TOKEN.UNKNOWN, location, null);
        si

        is_end_of_file: bool => _end_of_file;

        location: LOCATION => _cursor.location;

        advance_cursor(c: char) is
            if c == cast char(13) then
                return;
            fi

            _cursor.next_column();

            if c == '\n' then
                _cursor.next_line();
            fi
        si

        next_char() -> char is
            let c: char;

            if _prev_char != cast char(0) then
                c = _prev_char;
                advance_cursor(c);
                _prev_char = cast char(0);
                return c;
            fi

            if _end_of_file then
                return ' ';
            fi
            
            let c0: int = _input.read();

            if c0 == 13 then
                c0 = 32;
            fi

            if c0 == -1 \/ c0 == 12 then
                _end_of_file = true;
                return ' ';
            fi

            c = cast char(c0);

            _cursor.save();
            advance_cursor(c);

            return c;
        si

        prev_char(c: char) is
            _cursor.restore();
            _prev_char = c;
        si

        current_string: string is
            return _token_pair.value_string;
        si

        read_escape() -> char is
            let c: char = next_char();
            let result: int = 0;
            if c == 't' then
                return cast char(9);
            elif c == 'n' then
                return '\n';
            elif c == 'r' then
                return cast char(13);
            elif c == '\\' then
                return '\\';
            elif c>='0' /\ c<='7' then
                while c >= '0' /\ c <= '7' do
                    result = 8 * result + cast int(c - '0');
                    c = next_char();
                od

                prev_char(c);
                return cast char(result);
            else
                return c;
            fi
        si

        current: TOKEN_PAIR => _token_pair;

        next() -> bool is
            _token_pair = read_token();
            return current.token != TOKEN.END_OF_INPUT;
        si

        skip_white_space() -> char is
            let c: char;
            do
                c = next_char();

                let is_white_space = (c==' ' \/ c==cast char(9) \/ c=='\n');

                let should_break = is_end_of_file \/ !is_white_space;

                if is_end_of_file \/ !is_white_space then
                    break;
                fi
            od
            return c;
        si

        write_token(token: TOKEN_PAIR) is
            _buffer.write(token);
        si

        write_tokens(tokens: Collections.Iterable[TOKEN_PAIR]) is
            _buffer.write(tokens);
        si

        read_token() -> TOKEN_PAIR is
            if _buffer.avail then
                return _buffer.read();
            fi

            let result = read_token_2();

            return result;
        si

        read_operator(c: char) -> TOKEN_PAIR is
            let _buffer = new System.Text.StringBuilder();

            while _operator_chars.contains(c) \/ (cast int(c) > 0x7E /\ char.is_symbol(c)) do
                _buffer.append(c);
                c = next_char();
            od

            prev_char(c);

            if _buffer.length < 1 then
                return new TOKEN_PAIR(TOKEN.FIRST, location, null);
            fi

            let s = _buffer.to_string();

            let r = TOKEN.OPERATOR;
            
            if _operator_tokens.contains_key(s) then
                r = _operator_tokens[s];
            fi

            return new TOKEN_PAIR(r, location, s);
        si

        read_token_2() -> TOKEN_PAIR is
            let r: TOKEN;

            let c = skip_white_space();

            if _end_of_file then
                return new TOKEN_PAIR(TOKEN.END_OF_INPUT, location, null);
            fi

            _cursor.start();

            let _buffer: System.Text.StringBuilder = null;

            if c >= '0' /\ c <= '9' then
                let is_float = false;

                _buffer = new System.Text.StringBuilder();
                _buffer.append(c);
                c = next_char();

                if c=='x' \/ c=='X' then
                    _buffer.append(c);
                    c = next_char();
                    while
                        (c>='0'/\c<='9') \/ (c>='A'/\c<='F') \/ (c>='a'/\c<='f') \/ c == '_'
                    do
                        if c != '_' then
                            _buffer.append(c);
                        fi
                        c = next_char();                                
                    od
                else
                    let seen_dot = false;
                    let pc: char;

                    while 
                        (c >= '0' /\ c <= '9') \/ c == '.' \/ c == '_'
                    do                        
                        if c == '.' then
                            if pc == '.' then
                                is_float = false;

                                // bodge: can only push back one char, so use Unicode '‥' to signal we actually want to push back '..'
                                c = '‥';
                                break;
                            elif seen_dot then
                                break;
                            else
                                is_float = true;
                                seen_dot = true;
                            fi
                        else
                            if pc == '.' then
                                _buffer.append('.');
                            fi
                            
                            if c != '_' then
                                _buffer.append(c);
                            fi
                        fi

                        pc = c;
                        c = next_char();
                    od
                fi

                if is_float then
                    if c == 'e' \/ c == 'E' then
                        _buffer.append(c);
                        c = next_char();

                        if c == '-' then
                            _buffer.append(c);                                
                            c = next_char();
                        fi
                        
                        if c >= '0' \/ c <= '9' \/ c == '_' then
                            while (c >= '0' /\ c <= '9') \/ c == '_' do
                                if c != '_' then
                                    _buffer.append(c);
                                fi
                                
                                c = next_char();
                            od
                        else
                            _logger.error(location, "expected exponent in float literal");
                        fi
                    fi

                    if c == 's' \/ c == 'S' \/ c == 'd' \/ c == 'D' then
                        _buffer.append(c);
                        c = next_char();
                    else
                        _buffer.append('S');
                    fi
                else
                    if c == 's' \/ c == 'S' \/ c == 'u' \/ c == 'U' then
                        _buffer.append(c);
                        c = next_char();
                    fi

                    if "bBcCsSiIlLwW".contains(c) then
                        _buffer.append(c);
                        c = next_char();
                    fi
                fi

                prev_char(c);

                if is_float then
                    return new TOKEN_PAIR(TOKEN.FLOAT_LITERAL, location, _buffer.to_string());
                else
                    return new TOKEN_PAIR(TOKEN.INT_LITERAL, location, _buffer.to_string());
                fi
                
            elif (c>='a'/\c<='z') \/ (c>='A'/\c<='Z') \/ c=='_' \/ c == '`' then
                if c == '`' then
                    c = next_char();

                    if c == '[' then
                        return new TOKEN_PAIR(TOKEN.SQUARE_OPEN_TICK, location, null);
                    elif _operator_chars.contains(c) \/ (cast int(c) > 0x7E /\ char.is_symbol(c)) then
                        let o = read_operator(c);
                        return new TOKEN_PAIR(TOKEN.IDENTIFIER, o.location, o.value_string);
                    else
                        prev_char(c);
                        
                        c = '`';
                    fi
                fi

                _buffer = new System.Text.StringBuilder();

                let prev_c: char;

                while (c>='a'/\c<='z') \/ (c>='A'/\c<='Z') \/ (c>='0'/\c<='9') \/ c=='_' \/ c == '`' do
                    _buffer.append(c);

                    prev_c = c;
                    c = next_char();
                od

                if prev_c == '`' /\ c == '[' then
                    _buffer.remove(_buffer.length - 1, 1);
                    c = '⟦';
                fi
                
                prev_char(c);
                let s = _buffer.to_string();
                r = _symbol_tokens[s];
                return new TOKEN_PAIR(r, location, s);
            elif c == '/' then
                c = next_char();
                if c == '/' then
                    _buffer = new System.Text.StringBuilder("//");
                    do
                        c = next_char();
                        if c != '\n' then
                            _buffer.append(c);
                        fi
                        
                        if !(!_end_of_file/\c!='\n') then
                            break;
                        fi
                    od

                    return read_token_2();
                elif c == '*' then
                    _buffer = new System.Text.StringBuilder("/*");
                    do
                        c = next_char();

                        if c == '*' then
                            c = next_char();
                            if c == '/' then
                                break;
                            fi

                            _buffer.append('*');
                        fi

                        _buffer.append(c);

                        if _end_of_file then
                            break;
                        fi
                    od

                    return read_token_2();
                else
                    prev_char(c);
                    return read_operator('/');
                fi
            elif _operator_chars.contains(c) \/ (cast int(c) > 0x7E /\ char.is_symbol(c)) then
                return read_operator(c);
            fi

            case c
            when cast char(34):
                _buffer = new System.Text.StringBuilder();
                c = next_char();
                while c != cast char(34) do
                    if c == cast char(92) then
                        c = read_escape();
                        _buffer.append(c);
                        c = next_char();
                    elif c == '\n' then
                        _logger.error(location, "newline in string literal");
                        c = next_char();
                        break;
                    else
                        _buffer.append(c);
                        c = next_char();
                    fi

                    if _end_of_file then
                        _logger.error(location, "end of file in string literal");
                        break;
                    fi
                od
                return new TOKEN_PAIR(TOKEN.STRING_LITERAL, location, _buffer.to_string());
                
            when cast char(39):
                _buffer = new System.Text.StringBuilder();

                c = next_char();
                while c != cast char(39) do
                    if c == cast char(92) then
                        c = read_escape();
                        _buffer.append(c);
                        c = next_char();
                    else
                        _buffer.append(c);
                        c = next_char();
                    fi

                    if _end_of_file then
                        _logger.error(location, "end of file in character literal");
                        break;
                    fi
                od

                if _buffer.length < 1 then
                    _logger.error(location, "zero length character literal");
                elif _buffer.length > 1 then
                    _logger.error(location, "character literal is too long");
                fi
                return new TOKEN_PAIR(TOKEN.CHAR_LITERAL, location, _buffer.to_string());

            when '(':
                return new TOKEN_PAIR(TOKEN.PAREN_OPEN, location, null);

            when ')':
                return new TOKEN_PAIR(TOKEN.PAREN_CLOSE, location, null);

            when '[':
                c = next_char();
                if _end_of_file then
                    return new TOKEN_PAIR(TOKEN.SQUARE_OPEN, location, null);
                elif c == ']' then
                    return new TOKEN_PAIR(TOKEN.ARRAY_DEF, location, null);
                else
                    prev_char(c);
                    return new TOKEN_PAIR(TOKEN.SQUARE_OPEN, location, null);
                fi

            when ']':
                return new TOKEN_PAIR(TOKEN.SQUARE_CLOSE, location, null);

            when ',':
                return new TOKEN_PAIR(TOKEN.COMMA, location, null);

            when ';':
                return new TOKEN_PAIR(TOKEN.SEMICOLON, location, null);

            when '‥':
                return new TOKEN_PAIR(TOKEN.OPERATOR, location, "..");

            when '⟦':
                return new TOKEN_PAIR(TOKEN.SQUARE_OPEN_TICK, location, null);

            when '{':
                return string_enter();

            when '}':
                return string_exit();
            
            esac
            
            return new TOKEN_PAIR(TOKEN.UNKNOWN, location, "" + c);
        si


        /*

        only the methods enter_string() and exit_string() actually handle the string parts of a string
        interpolation. The tokenizer proper just calls these methods when it encounters a '{' or '}' character.
        The tokenizer proper is always in normal mode when this happens. The tokenizer proper doesn't handle
        the string parts of a string interpolation at all.

        possible states:
        1. normal mode: not in a string with interpolations and not in an interpolated expression
        2. string mode: in a string with interpolations, in the string part between any interpolated expressions
        3. expression mode: in an interpolated expression

        When _interpolation_depth is zero we are in normal mode.
        When _interpolation_depth is non-zero we may be in string mode or in expression mode.

        String mode is handled entirely within the enter_string() and exit_string() methods.
        Expression mode is handled entirely within the read_token_2() method.

        The enter_string() and exit_string() methods are responsible for transitioning between normal mode and
        expression mode, and for handling the string parts of a string interpolation.

        when read_token_2 sees a '{' or '}' character, it calls enter_string() or exit_string()

        enter_string() and exit_string() can return just one token per invokation. The tokens they can return are:
        - ENTER_STRING carries the first part of the string, up to the first '{' character
        - CONTINUE_STRING carries the string part between interpolations
        - EXIT_STRING carries the last part of the string, up to the end of the string
        - STRING_LITERAL carries a simple string literal, with no interpolations

        - ENTER_STRING: we've read the first string part of a string interpolation, up to the first '{' character
          and what follows must be an expression. We're transitioning from normal mode to expression mode

        - CONTINUE_STRING: we've just exited the expression part of a string interpolation after reading a '}' character
          and what follows must be another string part. We're transitioning from expression mode to string mode

        - EXIT_STRING: we're leaving the string part of a string interpolation after reading a '}' character

        - STRING_LITERAL: we're in the string part of a string interpolation, and we've read a simple string literal
        consiting of only characters and no interpolations
        

        Expression mode could return any token, but for the purposes of the examples below it can return only
        IDENTIFIER, INT_LITERAL and OPERATOR

    Example 1
        {hello world}

    Returns:

        STRING_LITERAL 'hello world'


    Example 2
        {name is {name} age is {10} limbs {arms + legs} end} // name is an identifier, 10 is an int literal, arms and legs are identifiers

    Returns, in sequence:

        ENTER_STRING 'name is '
        IDENTIFIER 'name'
        CONTINUE_STRING ' age is '
        INT_LITERAL '10'
        CONTINUE_STRING ' limbs '
        IDENTIFIER 'arms'
        OPERATOR '+'
        IDENTIFIER 'legs'
        EXIT_STRING ' end'
        

    Example 3
        {name is {{bob}} ages is {{20}} end}

    Returns, in sequence:

        ENTER_STRING 'name is '
        STRING_LITERAL 'bob'
        CONTINUE_STRING ' ages is '
        STRING_LITERAL '20'
        EXIT_STRING ' end'
        

        */

        read_string_fragment() -> (fragment: string, c: char) is
            // read up to the next interpolation or the end of the string
            // assume any leading '{' has already been read

            let buffer = new System.Text.StringBuilder();

            let c = next_char();

            while c != '\n' /\ c != '{' /\ c != '}' do
                // TODO handle escape sequences
                buffer.append(c);

                c = next_char();
            od

            if c == '\n' then
                _logger.error(location, "newline in interpolation");                
            fi

            return (buffer.to_string(), c);
        si

        string_enter() -> TOKEN_PAIR is
            // we're entering the string part of a string interpolation
            // so we need to read up to the next interpolation or the end of the string
            // increment the interpolation depth so we know when to exit this string

            let fragment_c = read_string_fragment();

            let fragment = fragment_c.fragment;
            let c = fragment_c.c;

            if c == '\n' then
                // read_string_fragment will have already logged the error but we need to unwind
                // the interpolation depth, returning enough EXIT_INTERPOLATION tokens to get the
                // parser back to normal mode
                
                if _interpolation_depth == 0 then
                    return new TOKEN_PAIR(TOKEN.STRING_LITERAL, location, fragment);

                else
                    // while _interpolation_depth > 0 do
                    //     _interpolation_depth = _interpolation_depth - 1;
                    //     write_token(new TOKEN_PAIR(TOKEN.EXIT_INTERPOLATION, location, fragment));
                    // od
                    _interpolation_depth = 0;

                    // FIXME: return enough exits to get back to normal mode
                    return new TOKEN_PAIR(TOKEN.EXIT_STRING, location, fragment);
                fi
            elif c == '}' then
                // this is just a string literal, with no interpolation.
                // we need to consume the '}' character so it doesn't get included in the next token

                return new TOKEN_PAIR(TOKEN.STRING_LITERAL, location, fragment);
            elif c == '{' then
                // we're read the first part of a string interpolation, up to the first '{' character
                // and what follows must be an expression. We're transitioning from normal mode to expression mode

                // we need to return the fragment we've read so far and consume
                // the '{' character so it doesn't get included in the next token

                // we're now in the expression part of the interpolation and read_token_2 will
                // handle the rest of the interpolation, up to the closing '}'

                // as this is the first interpolation in the string, we need to increment the
                // interpolation depth:

                _interpolation_depth = _interpolation_depth + 1;

                return new TOKEN_PAIR(TOKEN.ENTER_STRING, location, fragment);
            else
                // oops, something went wrong

                assert false else "unexpected character in string interpolation";
            fi
        si

        string_exit() -> TOKEN_PAIR is
            // we're leaving the expression part of a string interpolation after reading a '}' character
            // we're transitioning from expression mode to string mode

            // we're expecting some more string and then either another interpolation, introduced with '{'
            // or the end of the string, delimited with '}'.

            // once we've read the string part, we'll transition to either expression mode or normal mode
            // depending on whether we've read a '{' or a '}' character (is that correct?)

            // if _interpolation_depth is zero then this '}' is outside of any string interpolation
            if _interpolation_depth == 0 then
                _logger.error(location, "unmatched '}'");
                next_char();
                return read_token_2();
            fi

            // read up to the next interpolation or the end of the string
            let fragment_c = read_string_fragment();

            let fragment = fragment_c.fragment;
            let c = fragment_c.c;

            if c == '\n' then
                // read_string_fragment will have already logged the error but we need to unwind
                // the interpolation depth, returning enough EXIT_INTERPOLATION tokens to get the
                // parser back to normal mode

                // while _interpolation_depth > 0 do
                //     _interpolation_depth = _interpolation_depth - 1;
                //     write_token(new TOKEN_PAIR(TOKEN.EXIT_INTERPOLATION, location, fragment));
                // od

                // FIXME: buffer enough exits to get back to normal mode
                _interpolation_depth = 0;
                write_token(new TOKEN_PAIR(TOKEN.EXIT_STRING, location, fragment));

            elif c == '}' then
                // we're at the end of the string part of a string interpolation
                // we need to drop the interpolation depth by one and return an EXIT_INTERPOLATION token

                _interpolation_depth = _interpolation_depth - 1;

                write_token(new TOKEN_PAIR(TOKEN.EXIT_STRING, location, fragment));
            elif c == '{' then
                // we're at the start of a new interpolation within the current string
                // we need to consume the '{' character so it doesn't get included in the next token
                // the tokenizer can start reading the expression part of the interpolation:

                // we're still in the same string, so we don't need to change the interpolation depth

                return new TOKEN_PAIR(TOKEN.CONTINUE_STRING, location, fragment);
            else
                // oops, something went wrong

                assert false else "unexpected character in string interpolation";
            fi

        si
    si
si
