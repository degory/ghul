namespace Semantic.Types is
    use IO.Std;

    use System.Text.StringBuilder;

    use Source;

    trait SettableTyped is
        set_type(value: Type);
    si

    trait Typed is
        type: Type;
    si

    enum MATCH is
        SAME = 0,
        ASSIGNABLE = 1,
        CONVERTABLE = 2,
        PARTIAL = 3,
        DIFFERENT = 100000
    si

    trait Type: Typed is
        name: string;
        scope: Scope;

        symbol: Symbols.Symbol;

        ancestors: Collections.List[Type];
        arguments: Collections.List[Type];

        short_description: string;

        unspecialized_symbol: Symbols.Symbol;
        
        // FIXME: better than isa XXXX, but still should not need these:
        is_none: bool;
        is_null: bool;
        is_any: bool;
        is_error: bool;
        is_wild: bool;
        is_object: bool;
        is_type_variable: bool;
        is_value_type: bool;
        is_inheritable: bool;
        is_class: bool;
        is_trait: bool;
        is_action: bool;
        is_function: bool;
        is_function_with_any_implicit_argument_types: bool;

        =~(other: Type) -> bool;

        is_assignable_from(other: Type) -> bool;

        compare(other: Type) -> MATCH;

        find_member(name: string) -> Symbols.Symbol;

        find_ancestor(type: Type) -> Type;        

        specialize(type_map: Collections.Map[string,Type]) -> Type;

        bind_type_variables(other: Type, results: GenericArgumentBindResults);
        
        get_il_type() -> string;

        get_il_class_name() -> string;
        
        // output IL name for this type in a normal context:
        gen_type(buffer: StringBuilder);

        // output IL name for this type in a context that requires a 'class name' (i.e. a type without 'class' or 'valuetype' prefix)
        gen_class_name(buffer: StringBuilder);

        format(result: StringBuilder);
    si
si