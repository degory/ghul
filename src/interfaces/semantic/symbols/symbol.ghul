namespace Semantic.Symbols is
    use System.Exception;
    use System.NotImplementedException;
    use System.Text.StringBuilder;

    use IO.Std;

    use Logging;
    use Source;

    use IR.Values.Value;

    use Semantic.Types.Type;

    enum ACCESS is
        PRIVATE, PUBLIC, PROTECTED 
    si

    // FIXME: think the language server needs to declare it can
    // use the newer list below for completions as well as symbol info:
    enum COMPLETION_KIND is
        UNDEFINED = 0,
        METHOD = 2,
        FUNCTION = 3,
        CONSTRUCTOR = 4,
        FIELD = 5,
        VARIABLE = 6,
        CLASS = 7,
        INTERFACE = 8,
        MODULE = 9,
        PROPERTY = 10,
        ENUM = 13,
        KEYWORD = 14,
        SNIPPET = 15,
        COLOR = 16,
        FILE = 17,
        REFERENCE = 18,
        FOLDER = 19,
        ENUM_MEMBER = 20,
        CONSTANT = 21,
        STRUCT = 22,
        EVENT = 23,
        OPERATOR = 24,
        TYPE_PARAMETER = 25    
    si

    enum SYMBOL_KIND is
        UNDEFINED = 0,
        FILE = 1,
        MODULE = 2,
        Namespace = 3,
        PACKAGE = 4,
        CLASS = 5,
        METHOD = 6,
        PROPERTY = 7,
        FIELD = 8,
        CONSTRUCTOR = 9,
        ENUM = 10,
        INTERFACE = 11,
        FUNCTION = 12,
        VARIABLE = 13,
        CONSTANT = 14,
        STRING = 15,
        NUMBER = 16,
        BOOLEAN = 17,
        ARRAY = 18,
        OBJECT = 19,
        KEY = 20,
        NULL = 21,
        ENUM_MEMBER = 22,
        STRUCT = 23,
        EVENT = 24,
        OPERATOR = 25,
        TYPE_PARAMETER = 26
    si

    trait Symbol: Scope, Types.SettableTyped is
        owner: Scope;
        overridees: Collections.Iterable[Symbol];
        root_unspecialized_symbol: Symbol;
        is_internal: bool;
        is_reflected: bool;
        is_object: bool;
        is_type: bool;
        is_argument: bool;
        is_field: bool;
        is_private: bool;
        is_public_readable: bool;
        is_assignable: bool;
        is_function_group: bool;
                
        il_name: string;

        il_name_override: string public;
        il_is_primitive_type: bool public;
       
        argument_names: Collections.List[string];        
        arguments: Collections.List[Type];
        ancestors: Collections.List[Type];

        specialized_from: Symbol public;

        root_specialized_from: Symbol;

        access: ACCESS;

        description: string;
        short_description: string;
        search_description: string;

        symbol_kind: SYMBOL_KIND;
        completion_kind: COMPLETION_KIND;

        is_stub: bool;
        is_value_type: bool;
        is_instance: bool;
        is_innate: bool;
        is_inheritable: bool;
        is_class: bool;
        is_variable: bool;
        is_workspace_visible: bool;

        =~(other: object) -> bool;
        =~(other: Symbol) -> bool;
    
        define() is
        si        
    
        add_member(function: Symbol) -> bool;

        get_ancestor(i: int) -> Type;
        
        compare_type(other: Symbol);

        specialize(type_map: Collections.Map[string,Type], owner: Generic) -> Symbol;

        try_specialize(
            location: LOCATION,
            logger: Logger,
            actual_type_arguments: Collections.List[Type]
        ) -> Symbol;
        
        load(location: LOCATION, from: Value, loader: IR.SymbolLoader) -> Value;

        load_outer(location: LOCATION, from: Value, loader: IR.SymbolLoader) -> Value;

        store(location: LOCATION, from: Value, value: Value, loader: IR.SymbolLoader, is_initialize: bool) -> Value;

        call(location: Source.LOCATION, from: Value, arguments: Collections.List[Value], type: Type, caller: IR.FunctionCaller) -> Value;

        try_pull_down_into(
            into: Classy,
            other_overridee_symbols: Collections.Iterable[Symbol],
            logger: Logging.Logger
        );

        assert_symbols_pulled_down();

        pull_down_super_symbols();

        find_owning_ancestor(o: Scope) -> Scope;
        find_ancestor(search_type: Type) -> Type;

        get_all_direct_ancestor_members() -> Collections.Iterable[Symbol];
        
        find_ancestor_matches(prefix: string, matches: Collections.MutableMap[string, Symbol]);

        collapse_group_if_single_member() -> Symbol;
        
        get_il_reference() -> string;

        gen_name(buffer: StringBuilder);

        gen_definition_header(buffer: StringBuilder);

        gen_definition_header(context: IR.Context);
        
        gen_type_prefix(buffer: StringBuilder);
        
        gen_class_name(buffer: StringBuilder);
    si
si
