namespace Semantic.Symbols is
    use IO.Std;

    use System.Exception;
    use System.NotImplementedException;
    use System.Text.StringBuilder;

    use Collections.Iterable;
    
    use Logging;
    use Source;

    use IR.Values.Value;

    use Types.Type;

    trait Function: Symbol, Types.SettableTyped is
        override_class: METHOD_OVERRIDE_CLASS;

        span: LOCATION;

        return_type: Type public;

        generic_arguments: Collections.List[Type] public;
        generic_argument_names: Collections.List[string] public;
        unspecialized_arguments: Collections.List[Type] public;
        unspecialized_return_type: Type public;

        is_generic: bool public;
        is_abstract: bool;

        argument_descriptions: string;

        short_argument_descriptions: string;

        generic_argument_descriptions: string;

        =~(other: Function) -> bool;

        set_arguments(argument_names: Collections.List[string], argument_types: Collections.List[Type]);

        add_overridee(overridee: Function);

        load_self(location: LOCATION, loader: IR.SymbolLoader) -> Value;

        load_outer_self(location: LOCATION, loader: IR.SymbolLoader) -> Value;
        
        load_captured_value(location: LOCATION, symbol: Variable, loader: IR.SymbolLoader) -> Value;

        load_outer_captured_value(location: LOCATION, symbol: Variable, loader: IR.SymbolLoader) -> Value;
                
        start_declaring_arguments();

        end_declaring_arguments();

        try_bind_generic_arguments(location: Source.LOCATION, args: Collections.List[Type]) -> Types.GenericArgumentBindResults;
        
        specialize_function(type_map: Collections.Map[string,Type], owner: Generic) -> Function;
        
        specialize(actual_type_arguments: Collections.List[Type]) -> Symbol;
        
        set_void_return_type();

        set_return_type(rt: Type);

        get_full_type(innate_symbol_lookup: Lookups.InnateSymbolLookup);

        try_override(into: Classy, function: Function, logger: Logger);

        try_instance_override_me(into: Classy, function: Function, logger: Logger);

        try_struct_override_me(into: Classy, function: Function, logger: Logger);

        try_abstract_override_me(into: Classy, function: Function, logger: Logger);

        inheritance_warn(logger: Logger, into: Classy, message: string);

        inheritance_error(logger: Logger, into: Classy, message: string);
                
        ensure_return_type_matches(into: Classy, overridee: Function, want_override: bool, logger: Logger) -> bool;

        ensure_il_name_matches(into: Classy, overridee: Function, override_type: string, logger: Logger) -> bool;

        declare_type(location: LOCATION, name: string, index: int, symbol_definition_listener: SymbolDefinitionListener);
                
        declare_variable(location: LOCATION, name: string, is_static: bool, symbol_definition_listener: SymbolDefinitionListener);

        declare_function(location: LOCATION, span: LOCATION, name: string, is_static: bool, is_private: bool, enclosing: Scope, symbol_definition_listener: SymbolDefinitionListener) -> Symbol;

        get_argument_description(index: int) -> string;

        get_short_argument_description(index: int) -> string;

        gen_entrypoint(context: IR.Context);

        gen_dot(buffer: StringBuilder);
        
        gen_reference_for_property(buffer: StringBuilder);

        gen_body_header(context: IR.Context);
        
        gen_access(buffer: StringBuilder);

        gen_flags(buffer: StringBuilder);

        gen_calling_convention(buffer: StringBuilder);

        gen_owner_name(buffer: StringBuilder);
        
        gen_formal_arguments_list(buffer: StringBuilder);

        gen_actual_arguments_list(buffer: StringBuilder);

        gen_generic_arguments_list(buffer: StringBuilder);
        
        gen_generic_arguments_names(buffer: StringBuilder);
    si
si