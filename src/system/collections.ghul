namespace Collections is
    trait Iterable[T] is
        iterator: Collections.Iterator2[T];
    si

    trait Bag[T]: Iterable[T] is
        count: int;
    si

    trait MutableBag[T]: Iterable[T] is
        count: int;

        add(item: T);

        clear();

        contains(item: T) -> bool;

        remove(item: T) -> bool;
    si

    trait Iterator2[T] is
        move_next() -> bool;
        current: T;

        hasMoreElements() -> bool;
        nextElement() -> T;
    si
        
    trait List[T]: Bag[T] is
        [index: int]: T;

        contains(item: T) -> bool;
    si

    trait MutableList[T]: MutableBag[T] is
        [index: int]: T, = value;

        copy_to(array: T[], array_index: int);

        remove(item: T) -> bool;
    si    
        
    class LIST[T]: System.Object, MutableList[T], List[T], Iterable[T] is
        _vector: Generic.Vector[T];

        count: int;
        capacity: int;

        iterator: Iterator2[T] => new ITERATOR_WRAPPER[T](_vector.Iterator);

        // FIXME: .NET doesn't have this:
        reverse_iterator: Iterator2[T] => new ITERATOR_WRAPPER[T](_vector.ReverseIterator);

        [index: int]: T public is
            return _vector[index];
        si,
        = value is
            _vector[index] = value;
        si

        getIterator() -> Generic.Iterator[T] => _vector.Iterator;

        init();
        init(capacity: int);
        init(collection: Collections.Iterable[T]);
        init(collection: Generic.Iterable[T]);
        
        add(item: T);

        add_range(collection: Collections.Iterable[T]);
        add_range(collection: Generic.Iterable[T]);

        clear();
        reverse();

        contains(item: T) -> bool;

        remove(item: T) -> bool;

        sort();

        to_array() -> T[];

        trim_excess();

        get_hash_code() -> int;
    si

    class STACK[T]: System.Object, Iterable[T] is
        _vector: Generic.Vector[T];

        count: int => _vector.Length;

        iterator: Iterator2[T] => new ITERATOR_WRAPPER[T](_vector.Iterator);

        // FIXME: .NET does not have this:
        [index: int]: T => _vector[index];

        init();
        init(capacity: int);
        init(collection: Iterable[T]);
        init(collection: Generic.Iterable[T]);

        clear();

        peek() -> T;
        pop() -> T;
        push(value: T);

        to_array() -> T[];

        trim_excess();        
    si

    class QUEUE[T]: System.Object, Iterable[T] is
        count: int;

        iterator: Iterator2[T];
        getIterator() -> Generic.Iterator[T];

        init();
        init(capacity: int);
        init(collection: Iterable[T]);
        init(collection: Generic.Iterable[T]);

        enqueue(value: T);
        dequeue() -> T;
        peek() -> T;
        to_array() -> T[];

        clear();
    si

    trait Set[T]: Bag[T] is
        contains(item: T) -> bool;
    si

    trait MutableSet[T]: MutableBag[T] is
    
    si

    class SET[T]: System.Object, Set[T], MutableSet[T] is
        count: int;

        iterator: Iterator2[T];
        getIterator() -> Generic.Iterator[T];

        init();
        init(capacity: int);
        init(collection: Iterable[T]);
        init(collection: Generic.Iterable[T]);

        add(value: T);
        remove(value: T) -> bool;
        contains(value: T) -> bool;

        to_array() -> T[];

        clear();
    si
            
    trait Map[K,V]: Bag[Generic.Pair[K,V]] is
        keys: Iterable[K];
        values: Iterable[V];

        [key: K]: V;

        contains_key(key: K) -> bool;
    si

    trait MutableMap[K,V]: MutableBag[Generic.Pair[K,V]] is
        keys: Iterable[K];
        values: Iterable[V];

        [key: K]: V, = value;

        contains_key(key: K) -> bool;
    si
    
    class MAP[K,V]: System.Object, Map[K,V], MutableMap[K,V] is
        _map: Generic.Map[K,V];

        count: int => _map.Length;

        keys: Iterable[K] => new ITERABLE_WRAPPER[K](_map.Keys);
        values: Iterable[V] => new ITERABLE_WRAPPER[V](_map);
        iterator: Iterator2[Generic.Pair[K,V]] => new ITERATOR_WRAPPER[Generic.Pair[K,V]](_map.Pairs.Iterator);

        [key: K]: V public => _map[key], = value is
            _map[key] = value;
        si
        
        init() is
            _map = new Generic.Map[K,V]();
        si

        init(capacity: int) is
            _map = new Generic.Map[K,V](capacity);
        si

        contains_key(key: K) -> bool => _map.contains(key);

        add(value: Generic.Pair[K,V]) is
            _map[value.key] = value.value;
        si
        
        clear() is
            _map.clear();
        si
    si

    class ITERABLE_WRAPPER[T]: System.Object, Iterable[T] is
        iterable: Generic.Iterable[T];

        iterator: ITERATOR_WRAPPER[T] => new ITERATOR_WRAPPER[T](iterable.Iterator);

        init(iterable: Generic.Iterable[T]) is
            self.iterable = iterable;
        si        
    si

    class ITERATOR_WRAPPER[T]: System.Object, Iterator2[T] is
        inner: Generic.Iterator[T];

        current: T;

        init(inner: Generic.Iterator[T]) is
            self.inner = inner;
        si

        move_next() -> bool is
            if inner.hasMoreElements() then
                current = inner.nextElement();

                return true;
            else
                return false;
            fi            
        si        
    si
    
si
