namespace Collections is
    @IF.legacy()
    trait Iterable[T] is
        iterator: Collections.Iterator2[T];
    si

    @IF.legacy()
    trait Bag[T]: Iterable[T] is
        count: int;
    si

    @IF.legacy()
    trait MutableBag[T]: Iterable[T] is
        count: int;

        add(item: T);

        clear();

        contains(item: T) -> bool;

        remove(item: T) -> bool;
    si

    @IF.legacy()
    trait Iterator2[T] is
        move_next() -> bool;
        current: T;

        hasMoreElements() -> bool;
        nextElement() -> T;
    si
        
    @IF.legacy()
    trait List[T]: Bag[T] is
        [index: int]: T;

        contains(item: T) -> bool;
    si

    @IF.legacy()
    trait MutableList[T]: MutableBag[T] is
        [index: int]: T, = value;

        // copy_to(array: T[], array_index: int);

        remove(item: T) -> bool;
    si    
        
    @IF.legacy()
    class LIST[T]: System.Object, MutableList[T], List[T], Iterable[T] is
        _vector: Generic.Vector[T];

        count: int => _vector.Length;
        capacity: int => _vector.Length * 2;

        iterator: Iterator2[T] => new ITERATOR_WRAPPER[T](_vector.Iterator);

        // FIXME: .NET doesn't have this:
        reverse_iterator: Iterator2[T] => new ITERATOR_WRAPPER[T](_vector.ReverseIterator);

        [index: int]: T public is
            return _vector[index];
        si,
        = value is
            _vector[index] = value;
        si

        // getIterator() -> Generic.Iterator[T] => _vector.Iterator;

        init() is
            _vector = new Generic.Vector[T]();
        si
        
        init(capacity: int) is
            _vector = new Generic.Vector[T](capacity);
        si
        
        init(collection: Collections.Iterable[T]) is
            _vector = new Generic.Vector[T]();

            for value in collection do
                _vector.add(value);
            od            
        si
    
        init(collection: Generic.Iterable[T]) is
            _vector = new Generic.Vector[T](collection);
        si
                
        add(item: T) is
            _vector.add(item);
        si
        
        add_range(collection: Collections.Iterable[T]) is
            for value in collection do
                _vector.add(value);
            od            
        si
        
        add_range(collection: Generic.Iterable[T]) is
            _vector.add(collection);
        si
        
        clear() is
            _vector.clear();
        si
        
        reverse() is
            let _new_vector = new Generic.Vector[T](_vector.Length);

            for value in _vector.ReverseIterator do
                _new_vector.add(value);
            od

            _vector = _new_vector;            
        si
        
        contains(item: T) -> bool => _vector.contains(item);
        
        remove(item: T) -> bool is
            let result = _vector.contains(item);

            _vector.remove(item);

            return result;
        si

        remove_at(index: int) is
            assert(index == _vector.Length - 1, "fixme: cannot remove element except index == count-1");

            _vector.pop();
        si
                
        sort() is
            cast Generic.Sort[T](null).sort(_vector);
        si
        
        to_array() -> T[] => _vector.Array;

        trim_excess() is si

        get_hash_code() -> int => _vector.hash();

        get_inner() -> Generic.Vector[T] => _vector;
    si

    @IF.legacy()
    class STACK[T]: System.Object, Iterable[T] is
        _vector: Generic.Vector[T];

        count: int => _vector.Length;

        iterator: Iterator2[T] => new ITERATOR_WRAPPER[T](_vector.Iterator);

        // FIXME: .NET does not have this:
        // [index: int]: T => _vector[index];

        init() is
            _vector = new Generic.Vector[T]();
        si
        
        init(capacity: int) is
            _vector = new Generic.Vector[T](capacity);
        si
        
        init(collection: Collections.Iterable[T]) is
            _vector = new Generic.Vector[T]();

            for value in collection do
                _vector.add(value);
            od            
        si
    
        init(collection: Generic.Iterable[T]) is
            _vector = new Generic.Vector[T](collection);
        si

        clear() is
            _vector.clear();
        si
        
        peek() -> T => _vector.Top;
        pop() -> T => _vector.pop();

        push(value: T) is
            _vector.add(value);
        si
        
        to_array() -> T[] => _vector.Array;

        trim_excess() is
            
        si        
    si

    @IF.legacy()
    class QUEUE[T]: System.Object, Iterable[T] is
        _vector: Generic.Vector[T];

        count: int => _vector.Length;

        iterator: Iterator2[T] => new ITERATOR_WRAPPER[T](_vector.Iterator);
        // getIterator() -> Generic.Iterator[T];

        init() is
            _vector = new Generic.Vector[T]();
        si
        
        init(capacity: int) is
            _vector = new Generic.Vector[T](capacity);
        si
        
        init(collection: Collections.Iterable[T]) is
            _vector = new Generic.Vector[T]();

            for value in collection do
                _vector.add(value);
            od            
        si
    
        init(collection: Generic.Iterable[T]) is
            _vector = new Generic.Vector[T](collection);
        si

        enqueue(value: T) is
            _vector.add(value);
        si
        
        dequeue() -> T => _vector.pull();
        peek() -> T => _vector[0];

        to_array() -> T[] => _vector.Array;

        trim_excess() is
            
        si        

        clear() is
            _vector.clear();
        si
    si

    @IF.legacy()
    trait Set[T]: Bag[T] is
        contains(item: T) -> bool;
    si

    @IF.legacy()
    trait MutableSet[T]: MutableBag[T] is
    
    si

    @IF.legacy()
    class SET[T]: System.Object, Set[T], MutableSet[T] is
        @IF.legacy()
        _set: Generic.Set[T];

        count: int => _set.Length;

        iterator: Iterator2[T] => new ITERATOR_WRAPPER[T](_set.Iterator);
        // getIterator() -> Generic.Iterator[T];

        init() is
            _set = new Generic.Set[T]();
        si
        
        init(capacity: int) is
            _set = new Generic.Set[T](capacity);
        si
        
        init(collection: Collections.Iterable[T]) is
            _set = new Generic.Set[T]();

            for value in collection do
                _set.add(value);
            od            
        si
    
        init(collection: Generic.Iterable[T]) is
            _set = new Generic.Set[T](collection);
        si

        add(value: T) is
            _set.add(value);
        si
        
        remove(value: T) -> bool is
            let result = _set.contains(value);

            _set.remove(value);

            return result;
        si

        contains(value: T) -> bool => _set.contains(value);

        to_array() -> T[] => new Generic.Vector[T](_set).Array;
        
        clear() is
            _set = new Generic.Set[T]();
        si        
    si
            
    @IF.legacy()
    trait Map[K,V]: Bag[Generic.Pair[K,V]] is
        keys: Iterable[K];
        values: Iterable[V];

        [key: K]: V;

        contains_key(key: K) -> bool;
    si

    @IF.legacy()
    trait MutableMap[K,V]: MutableBag[Generic.Pair[K,V]] is
        keys: Iterable[K];
        values: Iterable[V];

        [key: K]: V, = value;

        contains_key(key: K) -> bool;
    si
    
    @IF.legacy()
    class MAP[K,V]: System.Object, Map[K,V], MutableMap[K,V] is
        _map: Generic.Map[K,V];

        count: int => _map.Length;

        keys: Iterable[K] => new ITERABLE_WRAPPER[K](_map.Keys);
        values: Iterable[V] => new ITERABLE_WRAPPER[V](_map);
        iterator: Iterator2[Generic.Pair[K,V]] => new ITERATOR_WRAPPER[Generic.Pair[K,V]](_map.Pairs.Iterator);

        [key: K]: V public => _map[key], = value is
            _map[key] = value;
        si
        
        init() is
            _map = new Generic.Map[K,V]();
        si

        init(capacity: int) is
            _map = new Generic.Map[K,V](capacity);
        si

        contains_key(key: K) -> bool => _map.contains(key);

        // FIXME
        contains(value: Generic.Pair[K,V]) -> bool => false;

        add(value: Generic.Pair[K,V]) is
            _map[value.key] = value.value;
        si

        remove(value: Generic.Pair[K,V]) -> bool is
            let result = _map.contains(value.key);

            _map.delete(value.key);
            
            return result;
        si
        
        clear() is
            _map.clear();
        si

        get_inner() -> Generic.Map[K,V] => _map;
    si

    @IF.legacy()
    class ITERABLE_WRAPPER[T]: System.Object, Iterable[T] is
        iterable: Generic.Iterable[T];

        iterator: ITERATOR_WRAPPER[T] => new ITERATOR_WRAPPER[T](iterable.Iterator);

        init(iterable: Generic.Iterable[T]) is
            self.iterable = iterable;
        si        
    si

    @IF.legacy()
    class ITERATOR_WRAPPER[T]: System.Object, Iterator2[T] is
        inner: Generic.Iterator[T];

        current: T;

        init(inner: Generic.Iterator[T]) is
            self.inner = inner;
        si

        move_next() -> bool is
            if inner.hasMoreElements() then
                current = inner.nextElement();

                return true;
            else
                return false;
            fi            
        si
        
        hasMoreElements() -> bool => inner.hasMoreElements();
        nextElement() -> T => inner.nextElement(); 
    si
    
    @IF.legacy()
    class LIST_REVERSE_ITERATOR[T]: System.Object, Iterator2[T] is
        _list: LIST[T];
        _index: int;

        current: T => _list[_index];

        init(list: LIST[T]) is
            _list = list;
            _index = list.count;
        si

        nextElement() -> T is
            _index = _index - 1;

            return current;
        si

        hasMoreElements() -> bool => _index > 0;

        move_next() -> bool is
            let result = hasMoreElements();

            if result then
                nextElement();                
            fi

            return result;
        si
    si    
si
