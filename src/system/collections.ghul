
namespace Collections is
    trait Iterable[T] is
        iterator: Collections.Iterator[T];

        getIterator() -> Generic.Iterator[T];
    si

    trait Bag[T]: Iterable[T] is
        count: int;
    si

    trait MutableBag[T]: Iterable[T] is
        count: int;

        add(item: T);

        clear();

        contains(item: T) -> bool;

        copy_to(array: T[], array_index: int);

        remove(item: T) -> bool;
    si

    trait Iterator[T] is
        move_next() -> bool;
        current: T;

        hasMoreElements() -> bool;
        getNextElement() -> T;
    si
        
    trait List[T]: Bag[T] is
        [index: int]: T;
    si

    trait MutableList[T]: MutableBag[T] is
        [index: int]: T, = value;

        copy_to(array: T[], array_index: int);

        remove(item: T) -> bool;
    si    
        
    class LIST[T]: MutableList[T], List[T], Iterable[T] is
        _vector: Generic.Vector[T];

        count: int;
        capacity: int;

        iterator: Iterator[T] => new ITERATOR_WRAPPER[T](_vector.Iterator);
        getIterator() -> Generic.Iterator[T] => _vector.Iterator;

        init();
        init(capacity: int);
        init(collection: Collections.Iterable[T]);
        
        add(item: T);

        add_range(collection: Collections.Iterable[T]);
        add_range(collection: Generic.Iterable[T]);
        clear();

        contains(item: T) -> bool;

        remove(item: T) -> bool;

        sort();

        to_array() -> T[];

        trim_excess();

        get_hash_code() -> int;
    si

    // public class Stack<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.ICollection    

    class STACK[T]: Iterable[T] is
        count: int;

        init();
        init(capacity: int);
        init(collection: Iterable[T]);
        init(collection: Generic.Iterable[T]);

        clear();

        peek() -> T;
        pop() -> T;
        push(value: T);

        to_array() -> T[];

        trim_excess();        
    si

    class QUEUE[T]: Iterable[T] is
        count: int;

        iterator: Iterator[T];
        getIterator() -> Generic.Iterator[T];

        init();
        init(capacity: int);
        init(collection: Iterable[T]);
        init(collection: Generic.Iterable[T]);

        enqueue(value: T);
        dequeue() -> T;
        peek() -> T;
        to_array() -> T[];

        clear();
    si
        
    trait Map[K,V]: Bag[Generic.Pair[K,V]] is
        keys: Iterable[K];
        values: Iterable[V];

        [key: K]: V;
    si

    trait MutableMap[K,V]: MutableBag[Generic.Pair[K,V]] is
        keys: Iterable[K];
        values: Iterable[V];

        [key: K]: V, = value;
    si
    
    class MAP[K,V]: Map[K,V], MutableMap[K,V] is
        _map: Generic.Map[K,V];

        keys: Iterable[K] => new ITERABLE_WRAPPER[K](_map.Keys);
        values: Iterable[V] => new ITERABLE_WRAPPER[V](_map);
        iterator: Iterable[Generic.Pair[K,V]] => new ITERABLE_WRAPPER[Generic.Pair[K,V]](_map.Pairs);
    si

    class ITERABLE_WRAPPER[T]: Iterable[T] is
        inner: Generic.Iterable[T];

        iterator: ITERATOR_WRAPPER[T] => new ITERATOR_WRAPPER[T](inner.Iterator);
    si

    class ITERATOR_WRAPPER[T]: Iterator[T] is
        inner: Generic.Iterator[T];

        current: T;

        init(inner: Generic.Iterator[T]) is
            self.inner = inner;
        si

        move_next() -> bool is
            if inner.hasMoreElements() then
                current = inner.nextElement();

                return true;
            else
                return false;
            fi            
        si        
    si
    
si
