namespace IoC is
    @IF.not.v3() use Std = System.Console;

    use Syntax;
    use Parsers.LAZY_PARSER;

    class CONTAINER  is
        _instance: CONTAINER static;

        instance: CONTAINER static is
            if _instance == null then
                _instance = new CONTAINER();
            fi

            return _instance;
        si

        _logger_wrapper: Logging.LOGGER_WRAPPER;
        logger: Logging.Logger => _logger_wrapper;
        timers: Logging.TIMERS;

        path_config: Driver.PATH_CONFIG;

        identifier_parser: Syntax.Parsers.Parser[Trees.Identifiers.Identifier];
        identifier_qualified_parser: Syntax.Parsers.Parser[Trees.Identifiers.Identifier];
        identifier_function_name_parser: Syntax.Parsers.Parser[Trees.Identifiers.Identifier];
        modifier_parser: Syntax.Parsers.Parser[Trees.Modifiers.Modifier];
        type_parser: LAZY_PARSER[Trees.TypeExpressions.TypeExpression];
        type_list_parser: LAZY_PARSER[Trees.TypeExpressions.LIST];
        variable_parser: LAZY_PARSER[Trees.Variables.Variable];
        variable_list_parser: LAZY_PARSER[Trees.Variables.LIST];
        modifier_list_parser: LAZY_PARSER[Trees.Modifiers.LIST];
        definition_parser: LAZY_PARSER[Trees.Definitions.Definition];
        definition_list_parser: LAZY_PARSER[Trees.Definitions.LIST];
        definition_namespace_parser: LAZY_PARSER[Trees.Definitions.NAMESPACE];
        definition_class_parser: LAZY_PARSER[Trees.Definitions.CLASS];
        definition_use_parser: LAZY_PARSER[Trees.Definitions.USE];
        definition_trait_parser: LAZY_PARSER[Trees.Definitions.TRAIT];
        definition_struct_parser: LAZY_PARSER[Trees.Definitions.STRUCT];
        definition_enum_parser: LAZY_PARSER[Trees.Definitions.ENUM];
        definition_member_parser: LAZY_PARSER[Trees.Definitions.Definition];
        definition_function_parser: LAZY_PARSER[Trees.Definitions.FUNCTION];
        definition_property_parser: LAZY_PARSER[Trees.Definitions.PROPERTY];
        definition_indexer_parser: LAZY_PARSER[Trees.Definitions.INDEXER];
        definition_pragma_parser: LAZY_PARSER[Trees.Definitions.PRAGMA];
        pragma_node_parser: LAZY_PARSER[Trees.Pragmas.PRAGMA];
        expression_parser: LAZY_PARSER[Trees.Expressions.Expression];
        expression_list_parser: LAZY_PARSER[Trees.Expressions.LIST];
        expression_primary_parser: LAZY_PARSER[Trees.Expressions.Expression];
        expression_secondary_parser: LAZY_PARSER[Trees.Expressions.Expression];
        expression_tertiary_parser: LAZY_PARSER[Trees.Expressions.Expression];
        expression_tuple_parser: LAZY_PARSER[Trees.Expressions.TUPLE];
        statement_parser: LAZY_PARSER[Trees.Statements.Statement];
        statement_list_parser: LAZY_PARSER[Trees.Statements.LIST];
        statement_pragma_parser: LAZY_PARSER[Trees.Statements.PRAGMA];
        body_parser: LAZY_PARSER[Trees.Bodies.Body];

        dotnet_symbol_table: System.LAZY[Semantic.DotNet.SYMBOL_TABLE];
        symbol_factory: Semantic.DotNet.SYMBOL_FACTORY;
        type_mapper: Semantic.DotNet.TYPE_MAPPER;
        type_name_map: Semantic.DotNet.TYPE_NAME_MAP;
        innate_types: Semantic.DotNet.INNATE_TYPES;
        assemblies: Semantic.DotNet.ASSEMBLIES;

        stable_symbols: Semantic.STABLE_SYMBOLS;
        symbol_table: Semantic.SYMBOL_TABLE;
        namespaces: Semantic.NAMESPACES;
        symbol_loader: Semantic.SYMBOL_LOADER;
        innate_symbol_lookup: Semantic.Lookups.InnateSymbolLookup;
        function_caller: Semantic.FUNCTION_CALLER;
        overload_resolver: Semantic.OVERLOAD_RESOLVER;

        symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;
        symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS;

        value_boxer: IR.VALUE_BOXER;
        value_converter: IR.VALUE_CONVERTER;
        ir_context: IR.CONTEXT;
        brancher: IR.BRANCHER;
        innate_operation_generator: IR.INNATE_OPERATION_GENERATOR;
        local_id_generator: IR.LOCAL_ID_GENERATOR;
        boilerplate_generator: IR.BOILERPLATE_GENERATOR;

        conditional_compilation: Syntax.Process.CONDITIONAL_COMPILATION;
        expand_namespaces: Syntax.Process.EXPAND_NAMESPACES;
        add_accessors_for_properties: Syntax.Process.ADD_ACCESSORS_FOR_PROPERTIES;
        declare_symbols: Syntax.Process.DECLARE_SYMBOLS;
        resolve_uses: Syntax.Process.RESOLVE_USES;
        resolve_ancestors: Syntax.Process.RESOLVE_ANCESTORS;
        resolve_type_expressions: Syntax.Process.RESOLVE_TYPE_EXPRESSIONS;
        resolve_explicit_types: Syntax.Process.RESOLVE_EXPLICIT_TYPES;
        compile_expressions: Syntax.Process.COMPILE_EXPRESSIONS;
        resolve_overrides: Syntax.Process.RESOLVE_OVERRIDES;
        generate_il: Syntax.Process.GENERATE_IL;

        ghul_printer: Syntax.Process.Printer.GHUL => new Syntax.Process.Printer.GHUL();

        completer: Syntax.Process.COMPLETER;
        signature_help: Syntax.Process.SIGNATURE_HELP;

        init() is
            Source.LOCATION.init_static();

            _logger_wrapper = new Logging.LOGGER_WRAPPER(new Logging.HUMAN_READABLE_LOGGER(Std.error));
            timers = new Logging.TIMERS();

            path_config = new Driver.PATH_CONFIG();

            value_boxer = new IR.VALUE_BOXER(logger);

            ir_context = new IR.CONTEXT(logger);
            brancher = new IR.BRANCHER(ir_context);
            innate_operation_generator = new IR.INNATE_OPERATION_GENERATOR(logger, value_boxer, brancher);
            local_id_generator = new IR.LOCAL_ID_GENERATOR();
            boilerplate_generator = new IR.BOILERPLATE_GENERATOR(ir_context, path_config);

            identifier_parser = new Parsers.Identifiers.IDENTIFIER();
            identifier_qualified_parser = new Parsers.Identifiers.QUALIFIED();
            identifier_function_name_parser = new Parsers.Identifiers.FUNCTION_NAME();
            modifier_parser = new Parsers.Modifiers.MODIFIER();
            type_parser = new LAZY_PARSER[Trees.TypeExpressions.TypeExpression]();
            type_list_parser = new LAZY_PARSER[Trees.TypeExpressions.LIST]();
            variable_parser = new LAZY_PARSER[Trees.Variables.Variable]();
            variable_list_parser = new LAZY_PARSER[Trees.Variables.LIST]();
            modifier_list_parser = new LAZY_PARSER[Trees.Modifiers.LIST]();
            definition_parser = new LAZY_PARSER[Trees.Definitions.Definition]();
            definition_list_parser = new LAZY_PARSER[Trees.Definitions.LIST]();
            definition_namespace_parser = new LAZY_PARSER[Trees.Definitions.NAMESPACE]();
            definition_use_parser = new LAZY_PARSER[Trees.Definitions.USE]();
            definition_class_parser = new LAZY_PARSER[Trees.Definitions.CLASS]();
            definition_trait_parser = new LAZY_PARSER[Trees.Definitions.TRAIT]();
            definition_struct_parser = new LAZY_PARSER[Trees.Definitions.STRUCT]();
            definition_enum_parser = new LAZY_PARSER[Trees.Definitions.ENUM]();
            definition_member_parser = new LAZY_PARSER[Trees.Definitions.Definition]();
            definition_function_parser = new LAZY_PARSER[Trees.Definitions.FUNCTION]();
            definition_property_parser = new LAZY_PARSER[Trees.Definitions.PROPERTY]();
            definition_indexer_parser = new LAZY_PARSER[Trees.Definitions.INDEXER]();
            definition_pragma_parser = new LAZY_PARSER[Trees.Definitions.PRAGMA]();
            pragma_node_parser = new LAZY_PARSER[Trees.Pragmas.PRAGMA]();
            expression_parser = new LAZY_PARSER[Trees.Expressions.Expression]();
            expression_list_parser = new LAZY_PARSER[Trees.Expressions.LIST]();
            expression_primary_parser = new LAZY_PARSER[Trees.Expressions.Expression]();
            expression_secondary_parser = new LAZY_PARSER[Trees.Expressions.Expression]();
            expression_tertiary_parser = new LAZY_PARSER[Trees.Expressions.Expression]();
            expression_tuple_parser = new LAZY_PARSER[Trees.Expressions.TUPLE]();
            statement_parser = new LAZY_PARSER[Trees.Statements.Statement]();
            statement_list_parser = new LAZY_PARSER[Trees.Statements.LIST]();
            statement_pragma_parser = new LAZY_PARSER[Trees.Statements.PRAGMA]();
            body_parser = new LAZY_PARSER[Trees.Bodies.Body]();

            type_parser.create = () -> Parsers.Parser[Trees.TypeExpressions.TypeExpression] =>
                new Parsers.TypeExpressions.TYPE_EXPRESSION(identifier_qualified_parser, type_list_parser);

            type_list_parser.create = () -> Parsers.Parser[Trees.TypeExpressions.LIST] =>
                new Parsers.TypeExpressions.LIST(type_parser);

            variable_parser.create = () -> Parsers.Parser[Trees.Variables.Variable] =>
                new Parsers.Variables.VARIABLE(identifier_parser, type_parser, expression_parser);

            variable_list_parser.create = () -> Parsers.Parser[Trees.Variables.LIST] =>
                new Parsers.Variables.LIST(variable_parser);

            modifier_list_parser.create = () -> Parsers.Parser[Trees.Modifiers.LIST] =>
                new Parsers.Modifiers.LIST(modifier_parser);

            definition_parser.create = () -> Parsers.Parser[Trees.Definitions.Definition] =>
                new Parsers.Definitions.DEFINITION(
                    definition_namespace_parser,
                    definition_use_parser,
                    definition_class_parser,
                    definition_trait_parser,
                    definition_struct_parser,
                    definition_enum_parser,
                    definition_member_parser,
                    definition_pragma_parser
                );

            definition_list_parser.create = () -> Parsers.Parser[Trees.Definitions.LIST] =>
                new Parsers.Definitions.LIST(definition_parser);

            definition_namespace_parser.create = () -> Parsers.Parser[Trees.Definitions.NAMESPACE] is
                let result = new Parsers.Definitions.NAMESPACE(identifier_qualified_parser, definition_list_parser);

                return result;
            si;            

            definition_use_parser.create = () -> Parsers.Parser[Trees.Definitions.USE] =>
                new Parsers.Definitions.USE(identifier_qualified_parser);

            definition_class_parser.create = () -> Parsers.Parser[Trees.Definitions.CLASS] =>
                new Parsers.Definitions.CLASS(
                    identifier_parser,
                    type_parser,
                    type_list_parser,
                    modifier_list_parser,
                    definition_list_parser
                );

            definition_trait_parser.create = () -> Parsers.Parser[Trees.Definitions.TRAIT] =>
                new Parsers.Definitions.TRAIT(
                    identifier_parser,
                    type_parser,
                    type_list_parser,
                    modifier_list_parser,
                    definition_list_parser
                );

            definition_struct_parser.create = () -> Parsers.Parser[Trees.Definitions.STRUCT] =>
                new Parsers.Definitions.STRUCT(
                    identifier_parser,
                    type_parser,
                    type_list_parser,
                    modifier_list_parser,
                    definition_list_parser
                );

            definition_enum_parser.create = () -> Parsers.Parser[Trees.Definitions.ENUM] =>
                new Parsers.Definitions.ENUM(identifier_parser, modifier_list_parser, expression_parser);

            definition_member_parser.create = () -> Parsers.Parser[Trees.Definitions.Definition] =>
                new Parsers.Definitions.MEMBER(definition_function_parser, definition_property_parser, definition_indexer_parser);

            definition_function_parser.create = () -> Parsers.Parser[Trees.Definitions.FUNCTION] =>
                new Parsers.Definitions.FUNCTION(
                    identifier_function_name_parser,
                    type_parser,
                    type_list_parser,
                    modifier_list_parser,
                    body_parser,
                    variable_list_parser
                );

            definition_property_parser.create = () -> Parsers.Parser[Trees.Definitions.PROPERTY] =>
                new Parsers.Definitions.PROPERTY(
                    identifier_parser,
                    type_parser,
                    modifier_list_parser,
                    definition_list_parser,
                    body_parser
                );

            definition_indexer_parser.create = () -> Parsers.Parser[Trees.Definitions.INDEXER] =>
                new Parsers.Definitions.INDEXER(
                    identifier_parser,
                    type_parser,
                    modifier_list_parser,
                    variable_parser,
                    body_parser
                );

            definition_pragma_parser.create = () -> Parsers.Parser[Trees.Definitions.PRAGMA] =>
                new Parsers.Definitions.PRAGMA(pragma_node_parser, definition_parser);

            pragma_node_parser.create = () -> Parsers.Parser[Trees.Pragmas.PRAGMA] =>
                new Parsers.Pragmas.PRAGMA(identifier_qualified_parser, expression_list_parser);

            expression_parser.create = () -> Parsers.Parser[Trees.Expressions.Expression] =>
                new Parsers.Expressions.EXPRESSION(expression_tertiary_parser);

            expression_list_parser.create = () -> Parsers.Parser[Trees.Expressions.LIST] =>
                new Parsers.Expressions.LIST(expression_parser);

            expression_primary_parser.create = () -> Parsers.Parser[Trees.Expressions.Expression] =>
                new Parsers.Expressions.PRIMARY(
                    identifier_parser,
                    type_parser,
                    expression_parser,
                    expression_list_parser,
                    expression_tuple_parser
                );

            expression_secondary_parser.create = () -> Parsers.Parser[Trees.Expressions.Expression] =>
                new Parsers.Expressions.SECONDARY(
                    identifier_parser,
                    type_parser,
                    expression_parser,
                    expression_primary_parser,
                    expression_list_parser,
                    body_parser
                );

            expression_tertiary_parser.create = () -> Parsers.Parser[Trees.Expressions.Expression] =>
                new Parsers.Expressions.TERTIARY(
                    expression_secondary_parser
                );

            expression_tuple_parser.create = () -> Parsers.Parser[Trees.Expressions.TUPLE] =>
                new Parsers.Expressions.TUPLE(expression_list_parser);

            statement_parser.create = () -> Parsers.Parser[Trees.Statements.Statement] =>
                new Parsers.Statements.STATEMENT(
                    new Collections.LIST[Lexical.TOKEN]([Lexical.TOKEN.FOR, Lexical.TOKEN.WHILE, Lexical.TOKEN.DO]),
                    identifier_parser,
                    expression_parser,
                    expression_list_parser,
                    variable_parser,
                    variable_list_parser,
                    statement_list_parser,
                    statement_pragma_parser
                );

            statement_list_parser.create = () -> Parsers.Parser[Trees.Statements.LIST] =>
                new Parsers.Statements.LIST(
                    new Collections.LIST[Lexical.TOKEN]([
                        Lexical.TOKEN.ELSE,
                        Lexical.TOKEN.ELIF,
                        Lexical.TOKEN.FI,
                        Lexical.TOKEN.OD,
                        Lexical.TOKEN.CATCH,
                        Lexical.TOKEN.FINALLY,
                        Lexical.TOKEN.YRT,
                        Lexical.TOKEN.WHEN,
                        Lexical.TOKEN.DEFAULT,
                        Lexical.TOKEN.ESAC,
                        Lexical.TOKEN.SI,
                        Lexical.TOKEN.COMMA
                    ]),
                    statement_parser
                );

            statement_pragma_parser.create = () -> Parsers.Parser[Trees.Statements.PRAGMA] =>
                new Parsers.Statements.PRAGMA(pragma_node_parser, statement_parser);

            body_parser.create = () -> Parsers.Parser[Trees.Bodies.Body] =>
                new Parsers.Bodies.BODY(
                    expression_parser,
                    statement_parser,
                    statement_list_parser,
                    identifier_qualified_parser);

            stable_symbols = new Semantic.STABLE_SYMBOLS();

            symbol_table = new Semantic.SYMBOL_TABLE(logger);
            namespaces = new Semantic.NAMESPACES(logger, symbol_table);

            dotnet_symbol_table =
                new System.LAZY[Semantic.DotNet.SYMBOL_TABLE](
                    () -> Semantic.DotNet.SYMBOL_TABLE =>
                        new Semantic.DotNet.SYMBOL_TABLE(assemblies, type_name_map, symbol_factory)
                );

            type_name_map = new Semantic.DotNet.TYPE_NAME_MAP();
            assemblies = new Semantic.DotNet.ASSEMBLIES(timers, symbol_table, namespaces, type_name_map);

            innate_symbol_lookup = new Semantic.Lookups.LAZY_INNATE_SYMBOL_LOOKUP(
                () -> Semantic.Lookups.InnateSymbolLookup is
                    if assemblies._is_enabled then
                        return 
                            new Semantic.Lookups.REFLECTION_INNATE_SYMBOL_LOOKUP(
                                type_mapper, 
                                dotnet_symbol_table.value,
                                new Semantic.Lookups.GHUL_STUBS_SYMBOL_LOOKUP(logger, symbol_table)
                            );
                    else
                        return new Semantic.Lookups.STUBS_INNATE_SYMBOL_LOOKUP(logger, symbol_table);
                    fi
                si
            );

            type_mapper = new Semantic.DotNet.TYPE_MAPPER(dotnet_symbol_table, innate_symbol_lookup, type_name_map);

            innate_types = new Semantic.DotNet.INNATE_TYPES(assemblies, type_mapper);

            symbol_factory = new Semantic.DotNet.SYMBOL_FACTORY(namespaces, innate_types, type_name_map, type_mapper);

            value_converter = new IR.VALUE_CONVERTER(logger, innate_symbol_lookup);

            function_caller = new Semantic.FUNCTION_CALLER(symbol_table, value_boxer);

            symbol_loader =
                new Semantic.SYMBOL_LOADER(
                    logger, 
                    symbol_table, 
                    function_caller, 
                    value_boxer, 
                    innate_symbol_lookup);

            overload_resolver = new Semantic.OVERLOAD_RESOLVER(logger);

            symbol_use_locations = new Semantic.SYMBOL_USE_LOCATIONS();

            symbol_definition_locations = new Semantic.SYMBOL_DEFINITION_LOCATIONS(symbol_use_locations);

            conditional_compilation = new Syntax.Process.CONDITIONAL_COMPILATION();

            expand_namespaces = new Syntax.Process.EXPAND_NAMESPACES();

            add_accessors_for_properties = new Syntax.Process.ADD_ACCESSORS_FOR_PROPERTIES();

            declare_symbols = 
                new Syntax.Process.DECLARE_SYMBOLS(
                    logger, 
                    stable_symbols,
                    symbol_table, 
                    namespaces, 
                    symbol_definition_locations,
                    local_id_generator);

            resolve_uses = new Syntax.Process.RESOLVE_USES(logger, symbol_table, namespaces);

            resolve_ancestors =
                new Syntax.Process.RESOLVE_ANCESTORS(logger, stable_symbols, symbol_table, namespaces, innate_symbol_lookup);

            resolve_type_expressions =
                new Syntax.Process.RESOLVE_TYPE_EXPRESSIONS(
                    logger,
                    stable_symbols,
                    symbol_table,                    
                    namespaces,
                    symbol_use_locations,
                    innate_symbol_lookup);

            resolve_explicit_types =
                new Syntax.Process.RESOLVE_EXPLICIT_TYPES(
                    logger,
                    stable_symbols,
                    symbol_table,
                    namespaces,
                    innate_symbol_lookup
                );

            compile_expressions =
                new Syntax.Process.COMPILE_EXPRESSIONS(
                    logger,
                    stable_symbols,
                    symbol_table,
                    namespaces,
                    symbol_loader,
                    innate_symbol_lookup,
                    function_caller,
                    overload_resolver,
                    symbol_use_locations,
                    value_converter
                );

            resolve_overrides =
                new Syntax.Process.RESOLVE_OVERRIDES(
                    logger,
                    stable_symbols,                    
                    symbol_table,
                    namespaces
                );

            generate_il =
                new Syntax.Process.GENERATE_IL(
                    logger,
                    symbol_table,
                    namespaces,
                    symbol_loader,
                    innate_symbol_lookup,
                    function_caller,
                    overload_resolver,
                    symbol_use_locations,
                    ir_context,
                    brancher,
                    boilerplate_generator,
                    value_boxer
                );

            completer =
                new Syntax.Process.COMPLETER(
                    logger,
                    symbol_table,
                    namespaces,
                    dotnet_symbol_table
                );

            signature_help =
                new Syntax.Process.SIGNATURE_HELP(
                    logger,
                    symbol_table,
                    namespaces,
                    overload_resolver
                );
        si

        want_tab_delimited_logger(writer: System.IO2.TextWriter) is
            _logger_wrapper.logger = new Logging.TAB_DELIMITED_LOGGER(writer);
        si
    si
si
