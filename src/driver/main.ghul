namespace Driver is
    @IF.not.v3() use object = System.Object;
    @IF.not.v3() use string = System.String;
    @IF.not.v3() use STD = System.Console;

    @IF.not.v3() use FILE = System.IO2.File;
    @IF.not.v3() use DIRECTORY = System.IO2.Directory;
    @IF.not.v3() use PATH = System.IO2.Path;

    use System;
    use Collections.Iterable;
    use Collections.LIST;
    
    use IoC;
    use Logging;

    class Main is
        paths: Driver.PATH_CONFIG;
        project_name: string;
        container: IoC.CONTAINER;
        compiler: COMPILER;
        flags: BUILD_FLAGS;
        output_file_name_generator: OUTPUT_FILE_NAME_GENERATOR;
        assemblies: LIST[string];
        library_locations: LIST[string];
        ghul_source_files: LIST[string];

        standard_ghul_library_locations: Iterable[string] => new LIST[string](["dotnet/ghul", "dotnet/stubs"]);

        entry(arguments: string[]) static is
            @IL.entrypoint()

            let full_arguments = new LIST[string](arguments.count + 1);

            full_arguments.add("ghul.exe");

            full_arguments.add_range(arguments);

            let instance = new Main(new LIST[string](full_arguments));
        si
        
        init(arguments: LIST[string]) is
            let result = 1;

            try
                STD.input_encoding = new System.Text.UTF8Encoding(false);
                STD.output_encoding = new System.Text.UTF8Encoding(false);

                if arguments.count <= 1 then
                    STD.output.write_line("ghūl " + Source.BUILD.number + " on " + System.Environment.version);

                    STD.output.flush();

                    System.Environment.exit(0);
                fi

                container = IoC.CONTAINER.instance;

                paths = container.path_config;
                flags = new BUILD_FLAGS();
                compiler = new COMPILER();
                output_file_name_generator = new OUTPUT_FILE_NAME_GENERATOR();

                parse_flags(arguments);

                if flags.want_stubs then
                    IoC.CONTAINER.instance.assemblies.disable();                
                else
                    IoC.CONTAINER.instance.assemblies.import(assemblies);                
                fi   

                if flags.want_analyse then
                    analyse();

                    System.Environment.exit(0);
                fi

                start_build();

                compiler.post_parse();

                compiler.build();

                result = finish_build();
            catch e: Exception
                STD.error.write_line(e);
                STD.error.flush();

                result = 1;
            yrt

            if result == 0 then
                STD.error.write_line("*** succeeded ***");
            else
                STD.error.write_line("!!! failed !!!");
            fi
            
            // FIXME: the runtime should be doing this - wrapping the L stderr + stdout IO.Writers should not prevent them getting flushed:
            STD.error.flush();
            STD.output.flush();

            System.Environment.exit(result);
        si

        parse_flags(args: Iterable[string]) is
            assemblies = new LIST[string]();
            ghul_source_files = new LIST[string]();
            library_locations = new LIST[string]();

            let args_iterator = args.iterator;

            args_iterator.move_next();

            flags.want_stubs = true;
            flags.want_compile_expressions = true;
            flags.want_assembler = true;
            flags.want_executable = true;

            let want_type_check = false;
            let do_not_want_type_check = false;

            let get_next_argument = (a: Collections.Iterator[string]) -> string is
                a.move_next();
                return a.current.trim();
            si;

            let conditional_defines = new Collections.LIST[string]();

            for s in args_iterator do
                if s =~ "-A" || s =~ "--analyse" then
                    flags.want_analyse = true;
                    flags.want_assembler = false;
                    flags.want_executable = false;
                elif s =~ "-G" || s =~ "--type-check" then
                    flags.want_assembler = false;
                    flags.want_executable = false;
                elif s =~ "-g" || s =~ "--no-type-check" then
                    flags.want_compile_expressions = false;
                elif s =~ "-E" || s =~ "--ignore-errors" then
                    flags.ignore_errors = true;
                elif s =~ "-S" || s =~ "--assembler" then
                    flags.want_executable = false;
                elif s =~ "--debug" then
                    conditional_defines.add("debug");
                elif s =~ "--define" then
                    conditional_defines.add(get_next_argument(args_iterator));
                elif s =~ "--stubs" then
                    flags.want_stubs = true;
                elif s =~ "--no-stubs" then
                    flags.want_stubs = false;
                elif s =~ "-N" || s =~ "--dotnet" then
                    // do nothing - .NET is the only supported option
                elif s =~ "-o" || s =~ "--output" then
                    output_file_name_generator.force(get_next_argument(args_iterator));
                elif s =~ "-p" || s =~ "--library-prefix" then
                    paths.library_prefix = get_next_argument(args_iterator);
                elif s =~ "-l" || s =~ "--library" then
                    library_locations.add(get_next_argument(args_iterator));
                elif s =~ "-a" || s =~ "--assembly" then
                    assemblies.add(get_next_argument(args_iterator));
                elif s.starts_with('-') then
                    STD.error.write_line("warning: ignoring unknown option: " + s);
                elif SOURCE_FILE_CATEGORIZER.is_ghul(s) then
                    output_file_name_generator.seen_file(s);
                    ghul_source_files.add(s);
                fi
            od

            container.conditional_compilation.set_is_enabled(conditional_defines);
        si

        start_build() is
            @IF.not.release()
            container.timers.start("parse-all");

            @IF.not.release()
            container.timers.start("parse-lib");
            queue_library_locations();
            @IF.not.release()
            container.timers.finish("parse-lib");

            @IF.not.release()
            container.timers.start("parse-src");

            queue_source_files();

            @IF.not.release()
            container.timers.finish("parse-src");

            @IF.not.release()
            container.timers.finish("parse-all");

            @IF.not.release()
            STD.error.write_line(container.timers["parse-src"]);
            @IF.not.release()
            STD.error.write_line(container.timers["parse-lib"]);
            @IF.not.release()
            STD.error.write_line(container.timers["parse-all"]);

            if flags.want_assembler then
                container.value_boxer.want_boxing = true;
                container.ir_context.enter_file("out.il", true);

                container.boilerplate_generator.gen(
                    "header-v2", 
                    [PATH.get_file_name_without_extension(output_file_name_generator.result)]
                );
            fi
        si

        finish_build() -> int is
            if container.logger.any_errors && !flags.ignore_errors then
                return 1;
            elif container.logger.is_poisoned then
                @IF.release()
                container.logger.write_poison_messages();

                STD.error.write_line("internal error");
                return 2;
            fi

            if flags.want_assembler then
                return finish_build_dotnet();
            else
                return 0;
            fi
        si

        finish_build_dotnet() -> int is
            let ir_context = container.ir_context;
            let output_file = output_file_name_generator.result;

            if output_file.last_index_of('.') < 0 then
                output_file = output_file + ".exe";
            fi            

            ir_context.leave_file("out.il");

            if !flags.want_executable then
                return 0;
            fi

            let ilasm_path = "/usr/lib/ghul/ilasm/ilasm";

            if !FILE.exists(ilasm_path) then
                STD.error.write_line(".NET Core ILAsm not found: falling back to /usr/bin/ilasm");
                ilasm_path = "/usr/bin/ilasm";
            fi            
            
            let ilasm_args = 
                "-quiet out.il -output=" + output_file;

            @IF.not.release()
            container.timers.start("il-asm");

            let ilasm = System.Diagnostics.Process.start(ilasm_path, ilasm_args);

            @IF.not.release()
            container.timers.finish("il-asm");

            @IF.not.release()
            STD.error.write_line(container.timers["il-asm"]);

            ilasm.wait_for_exit();

            let result = ilasm.exit_code;

            if result != 0 then
                STD.error.write_line("error: ilasm failed");
    
                return result;
            fi

            let runtime_config_file: string;

            if output_file.last_index_of('.') == output_file.length - 4 then
                runtime_config_file = output_file.substring(0, output_file.last_index_of('.')) + ".runtimeconfig.json";
            else
                runtime_config_file = output_file + ".runtimeconfig.json";
            fi
            
            let runtime_config = FILE.create_text(runtime_config_file);
            runtime_config.write("{\"runtimeOptions\":{\"tfm\":\"netcoreapp5.0\",\"framework\":{\"name\":\"Microsoft.NETCore.App\",\"version\":\"5.0.0\"}}}");
            runtime_config.close();

            let chmod = System.Diagnostics.Process.start("/bin/chmod", "+x " + output_file);

            chmod.wait_for_exit();

            result = chmod.exit_code;

            if result != 0 then
                STD.error.write_line("compiled successfully but failed to set executable bit on resulting binary: " + output_file);
            fi

            return result;
        si
        
        queue_library_locations() is
            let cuttoff = 0;
            
            let locations_to_queue: Iterable[string];

            if library_locations.count > 0 then
                let explicit_locations = new LIST[string](library_locations.count);
                
                for location in library_locations do
                    explicit_locations.add(get_library_location(location));
                od

                locations_to_queue = explicit_locations;
            else
                locations_to_queue = get_library_locations(standard_ghul_library_locations);
            fi
            
            for directory in locations_to_queue do
                queue_library_location(directory);
            od
        si

        queue_library_location(directory: string) is
            if !directory.ends_with('/') then
                directory = directory + '/';
            fi

            let files: Iterable[string] = DIRECTORY.get_files(directory);
            
            for file in files do
                if file.ends_with(".ghul") then
                    queue_source_file(file);
                fi
            od
        si

        queue_source_files() is
            for file in ghul_source_files do
                if file.ends_with(".ghul") then
                    queue_source_file(file);                    
                fi
            od            
        si
        
        queue_source_file(path: string) is
            let reader = FILE.open_text(path);

            compiler.parse_and_queue(path, reader, flags.copy());
        si

        get_library_locations(directories: Iterable[string]) -> Iterable[string] is
            let result = new LIST[string]();
            
            for directory in directories do
                result.add(get_library_location(directory));
            od

            return result;            
        si

        get_library_location(directory: string) -> string is
            if !directory.starts_with('/') then
                directory = paths.library_prefix + directory;
            fi

            if !directory.ends_with('/') then
                directory = directory + '/';
            fi

            return directory;
        si        

        analyse() is
            let analyser = new ANALYSER(
                compiler,
                container.timers,
                container.symbol_table,
                container.symbol_use_locations,
                container.symbol_definition_locations,
                container.completer,
                container.signature_help,
                STD.input,
                STD.output,
                flags
            );

            STD.error.write_line("ghūl compiler " + Source.BUILD.number + ": serving analysis requests");

            analyser.run();
        si
    si
si

