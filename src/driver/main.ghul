namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;

    class Main is
        project_name: String;
        container: IoC.CONTAINER;
        compiler: COMPILER;
        flags: BUILD_FLAGS;
        output_file_name_generator: OUTPUT_FILE_NAME_GENERATOR;
        library_prefix: String;
        library_locations: List[String];
        ghul_source_files: List[String];
        legacy_source_files: List[String];
        legacy_compiler_flags: LEGACY_COMPILER_FLAGS;

        standard_ghul_library_locations: Iterable[String] => ["dotnet/ghul", "dotnet/stubs"];
        standard_legacy_library_locations: Iterable[String] => ["legacy/ghul"];

        entry() static is
            @IL.entrypoint()

            let instance = new Main();
        si
        
        init() is
            let result = 1;

            try
                if Arguments.ProgramArguments.Length == 1 then
                    IO.Std.out.println("ghūl " + Source.BUILD.number);
                    IO.Std.out.flush();
                    native.exit(0);
                fi

                container = IoC.CONTAINER.instance;

                flags = new BUILD_FLAGS();
                compiler = new COMPILER();
                output_file_name_generator = new OUTPUT_FILE_NAME_GENERATOR();

                IO.Std.err.println("command line arguments: " + Arguments.ProgramArguments);

                parse_flags();

                if flags.want_analyse then
                    if flags.want_legacy then
                        container.conditional_compilation.set_analysis_want_legacy(true);
                    else
                        container.conditional_compilation.set_analysis_want_legacy(false);                    
                    fi

                    analyse();

                    native.exit(0);
                fi

                IO.Std.err.FlushOnPrintln = true;

                parse_flags();

                start_build();

                compiler.build();

                IO.Std.err.flush();

                result = finish_build();
            catch e: Exception                
                IO.Std.err.println(e);
                IO.Std.err.flush();

                result = 1;
            yrt

            native.exit(result);
        si

        parse_flags() is
            legacy_compiler_flags = new LEGACY_COMPILER_FLAGS();
            legacy_source_files = new Vector[String]();
            ghul_source_files = new Vector[String]();
            library_locations = new Vector[String]();

            let args = Arguments.ProgramArguments.Iterator;
            args.nextElement();

            for s in args do
                if s =~ "-A" then
                    flags.want_analyse = true;
                elif s =~ "-L" then
                    flags.want_legacy = true;
                elif s =~ "-P" then
                    project_name = args.nextElement().trim();
                elif s =~ "-G" then
                    flags.want_compile_expressions = true;
                elif s =~ "-E" then
                    flags.ignore_errors = true;
                elif s =~ "-X" then
                    flags.want_dotnet_assembler = true;
                elif s =~ "-S" then
                    flags.want_dotnet_assembler = true;
                    flags.want_compile_expressions = true;
                elif s =~ "-D" then
                    flags.want_docker = true;
                elif s =~ "-N" then
                    flags.want_dotnet_executable = true;
                    flags.want_dotnet_assembler = true;
                    flags.want_compile_expressions = true;
                elif s =~ "-o" then
                    output_file_name_generator.force(args.nextElement().trim());
                elif s =~ "-p" then
                    library_prefix = args.nextElement().trim();
                elif s =~ "-l" then
                    library_locations.add(args.nextElement().trim());
                elif s.startsWith('-') then
                    IO.Std.err.println("warning: ignoring unknown option: " + s);
                elif SOURCE_FILE_CATEGORIZER.is_legacy(s) then
                    output_file_name_generator.seen_file(s);
                    legacy_source_files.add(s);
                elif SOURCE_FILE_CATEGORIZER.is_ghul(s) then
                    output_file_name_generator.seen_file(s);
                    ghul_source_files.add(s);
                fi
            od
        si

        start_build() is
            queue_library_locations();

            queue_source_files();

            if flags.want_dotnet_assembler then
                container.value_boxer.want_boxing = true;
                container.ir_context.enter_file("out.il", true);

                container.boilerplate_generator.gen("header");
            fi
        si

        finish_build() -> int is
            if container.logger.any_errors && !flags.ignore_errors then
                return 1;
            fi

            if flags.want_dotnet_assembler then
                return finish_build_dotnet();
            elif flags.want_legacy then
                return finish_build_legacy();
            else
                return 0;
            fi
        si

        finish_build_legacy() -> int is
            if  (compiler.generated_source_files.Length > 0 || legacy_source_files.Length > 0) then
                var to_run: String;

                let to_build = new Vector[String]();

                var lcache_name: String;

                if project_name? then
                    lcache_name = "lcache-" + project_name;
                else
                    lcache_name = "lcache";
                fi

                if flags.want_docker then
                    let uid = cast int(native.getuid());
                    let gid = cast int(native.getgid());

                    to_run = "/usr/bin/docker";
                    to_build.add(to_run);

                    to_build.add([
                        "run",
                        "--rm",
                        "-t",
                        "-u",
                        "" + uid + ":" + gid,
                        "-v",
                        IO.File.WorkingDirectory + ":/home/dev/source",
                        "-w",
                        "/home/dev/source",
                        "ghul/compiler:stable"
                    ]);
                else
                    to_run = "/usr/bin/lc";
                fi

                to_build.add("/usr/bin/lc");

                if !flags.want_docker && project_name? then
                    let mkdir_process = new Util.Process();

                    let lcache_result = mkdir_process.run("/bin/mkdir", ["-p", "/tmp/" + lcache_name], Arguments.ProgramEnvironment, true);

                    if lcache_result != 0 then
                        throw new Exception("failed to create lcache directory '/tmp/" + lcache_name + "'");
                    fi

                    to_build.add(["-P", project_name]);
                fi

                to_build.add(compiler.generated_source_files);

                to_build.add(legacy_source_files);

                to_build.add(legacy_compiler_flags.flags);

                to_build.add("-o");

                to_build.add(output_file_name_generator.result);

                let process = new Util.Process();

                let result = process.run(to_run, to_build.Array, Arguments.ProgramEnvironment, true);

                if result == 0 then
                    for f in compiler.generated_source_files do
                        if f.endsWith(".lo") then
                            IO.File.deleteQuiet(f);
                        fi
                    od
                fi

                return result;
            else
                return 0;
            fi
        si
        
        finish_build_dotnet() -> int is
            let ir_context = container.ir_context;
            let output_file = output_file_name_generator.result;

            ir_context.leave_file("out.il");

            if !flags.want_dotnet_executable then
                return 0;
            fi
            
            var to_run: String;

            let to_build = new Vector[String]();

            if flags.want_docker then
                let uid = cast int(native.getuid());
                let gid = cast int(native.getgid());

                let create_volume_process = new Util.Process();

                to_run = "/usr/bin/docker";
                to_build.add(to_run);

                to_build.add([
                    "run",
                    "--rm",
                    "-t",
                    "-u",
                    "" + uid + ":" + gid,
                    "-v",
                    IO.File.WorkingDirectory + ":/home/dev/source",
                    "-w",
                    "/home/dev/source",
                    "ghul/mono:stable"
                ]);
            else
                to_run = "/usr/bin/ilasm";
            fi

            to_build.add("ilasm");
            to_build.add("-debug");
            to_build.add("-quiet");
            to_build.add("out.il");
            to_build.add("-output:" + output_file);

            let ilasm = new Util.Process();

            let ilasm_stdout = IO.File.openCreateStream("ilasm.out");

            native.dup2(ilasm_stdout.Handle, 1);
            native.close(ilasm_stdout.Handle);

            let result = ilasm.run(to_run, to_build.Array, Arguments.ProgramEnvironment, true);

            if result != 0 then
                IO.Std.err.println("ilasm failed");
                IO.Std.err.println(IO.File.openRead("ilasm.out").readAll());

                IO.File.deleteQuiet("ilasm.out");
    
                return result;
            fi

            IO.File.deleteQuiet("ilasm.out");

            let runtime_config_file: String;

            if output_file.lastIndexOf('.') == output_file.Length - 4 then
                runtime_config_file = output_file.substring(0, output_file.lastIndexOf('.')) + ".runtimeconfig.json";
            else
                runtime_config_file = output_file + ".runtimeconfig.json";
            fi
            
            let runtime_config = IO.File.openCreate(runtime_config_file);
            runtime_config.write("{\"runtimeOptions\":{\"tfm\":\"netcoreapp3.1\",\"framework\":{\"name\":\"Microsoft.NETCore.App\",\"version\":\"3.1.0\"}}}");
            runtime_config.close();

            let chmod = new Util.Process();
            result = chmod.run("/usr/bin/chmod", ["chmod", "+x", output_file]);

            if result != 0 then
                IO.Std.err.println("compiled successfully but failed to set executable bit on resulting binary: " + output_file);
            fi

            return result;
        si

        queue_library_locations() is
            let locations_to_queue: Iterable[String];

            if !library_prefix? then
                library_prefix = "/usr/lib/ghul/";
            elif !library_prefix.endsWith('/') then
                library_prefix = library_prefix + '/';
            fi
            
            if library_locations.Length > 0 then
                locations_to_queue = library_locations;
            elif flags.want_legacy then
                locations_to_queue = get_library_locations(standard_legacy_library_locations);
            else
                locations_to_queue = get_library_locations(standard_ghul_library_locations);
            fi

            IO.Std.err.println("library locations: " + locations_to_queue);
            
            for directory in locations_to_queue do
                queue_library_location(directory);
            od
        si

        queue_library_location(directory: String) is
            if !directory.endsWith('/') then
                directory = directory + '/';
            fi

            IO.Std.err.println("queue library location: " + directory);
            
            for file in new IO.DIRECTORY(directory) do
                if file.endsWith(".ghul") then
                    IO.Std.err.println("library source file: " + file);

                    queue_source_file(file);
                fi
            od
        si

        queue_source_files() is
            for file in ghul_source_files do
                if file.endsWith(".ghul") then
                    queue_source_file(file);                    
                fi
            od            
        si
        
        queue_source_file(path: String) is
            IO.Std.err.println("queue source file: " + path);
            compiler.parse_and_queue(path, IO.File.openRead(path), flags.copy());
        si

        get_library_locations(directories: Iterable[String]) -> Iterable[String] is
            let result = new Vector[String]();

            if !library_prefix.endsWith('/') then
                library_prefix = library_prefix + '/';
            fi
            
            for directory in directories do
                if !directory.startsWith('/') then
                    directory = library_prefix + directory;
                fi

                if !directory.endsWith('/') then
                    directory = directory + '/';
                fi

                result.add(directory);
            od

            return result;            
        si

        analyse() is
            let analyser = new ANALYSER(
                compiler,
                container.symbol_table,
                container.symbol_use_locations,
                container.symbol_definition_locations,
                container.completer,
                container.signature_help,
                IO.Std.input,
                IO.Std.out,
                flags
            );

            IO.Std.err.println("ghūl: build " + Source.BUILD.number + " await analysis requests...");

            analyser.run();
        si
    si
si

