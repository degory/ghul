namespace Driver is
    use System.Exception;

    use System.Threading.Tasks.Task;
    use System.Threading.Tasks.Task`1;

    use IO.Std;

    use Collections.Iterable;
    use Collections.LIST;
    
    use IoC;
    use Logging;

    class COMPILER is
        container: CONTAINER;
        process_factory: Syntax.Process.FACTORY;
        logger: Logger;

        source_files: LIST[SOURCE_FILE];

        post_parse_passes: Collections.MutableList[Pass];

        build_passes: Collections.MutableList[Pass];

        generated_source_files: Collections.MutableList[string];

        init() is
            container = IoC.CONTAINER.instance;
            process_factory = container.process_factory;
            logger = container.logger;       

            source_files = new LIST[SOURCE_FILE]();
            generated_source_files = new LIST[string]();

            post_parse_passes = new LIST[Pass]();
            add_pass(post_parse_passes, "conditional-compilation", (source_file: SOURCE_FILE) -> void is conditional_compilation_pass(source_file); si);
            add_pass(post_parse_passes, "rewrite-syntax-trees", (source_file: SOURCE_FILE) -> void is rewrite_syntax_tree_pass(source_file); si);

            build_passes = new LIST[Pass]();
            add_pass(build_passes, "declare-symbols", (source_file: SOURCE_FILE) -> void is declare_symbols_pass(source_file); si);
            add_pass(build_passes, "resolve-uses", (source_file: SOURCE_FILE) -> void is resolve_uses_pass(source_file); si, true);
            add_pass(build_passes, "resolve-type-expressions", (source_file: SOURCE_FILE) -> void is resolve_type_expressions_pass(source_file); si, true);
            add_pass(build_passes, "resolve-ancestors", (source_file: SOURCE_FILE) -> void is resolve_ancestors_pass(source_file); si);
            add_pass(build_passes, "resolve-explicit-types", (source_file: SOURCE_FILE) -> void is resolve_explicit_types_pass(source_file); si, true);
            add_pass(build_passes, "resolve-overrides", (source_file: SOURCE_FILE) -> void is resolve_overrides_pass(source_file); si, true);
            add_pass(build_passes, "compile-expressions", (source_file: SOURCE_FILE) -> void is compile_expressions_pass(source_file); si, true);
            add_pass(
                build_passes, 
                "generate-il", 
                () -> void is
                    container.referenced_assemblies.gen();
                si,
                (source_file: SOURCE_FILE) -> void is generate_il_pass(source_file); si,
                () -> void is si
            );
        si

        clear_symbols() is
            cast Semantic.Symbols.NAMESPACE(Semantic.SYMBOL_TABLE_STATE.global_scope).clear();

            container.symbol_table.clear();
            container.namespaces.clear();
            container.symbol_use_locations.clear();
            container.symbol_definition_locations.clear();
            container.logger.clear();            
        si

        clear_queue() is
            source_files.clear();
        si

        add_pass(passes: Collections.MutableList[Pass], description: string, apply: SOURCE_FILE -> void) is
            passes.add(new PASS(container.timers, description, null, apply, null, false));
        si

        add_pass(passes: Collections.MutableList[Pass], description: string, apply: SOURCE_FILE -> void, is_task_safe: bool) is
            passes.add(new PASS(container.timers, description, null, apply, null, is_task_safe));
        si

        add_pass(
            passes: Collections.MutableList[Pass],
            description: string,
            start: () -> void,
            apply: SOURCE_FILE -> void, 
            finish: () -> void
        )
        is
            passes.add(new PASS(container.timers, description, start, apply, finish, false));
        si

        add_pass(
            passes: Collections.MutableList[Pass],
            description: string,
            start: () -> void,
            apply: SOURCE_FILE -> void, 
            finish: () -> void,
            is_task_safe: bool
        )
        is
            passes.add(new PASS(container.timers, description, start, apply, finish, is_task_safe));
        si

        add_pass(passes: Collections.MutableList[Pass], pass: Pass) is
            passes.add(pass);
        si

        parse_and_queue(path: string, reader: IO.TextReader, build_flags: BUILD_FLAGS) is
            queue(
                parse(path, reader, build_flags)
            );
        si

        queue(source_file: SOURCE_FILE) is
            source_files.add(source_file);
        si

        queue(source_files: Collections.Iterable[SOURCE_FILE]) is
            self.source_files.add_range(source_files);
        si

        parse(path: string, reader: IO.TextReader, build_flags: BUILD_FLAGS) -> SOURCE_FILE is
            let tokenizer = new Lexical.TOKENIZER(
                logger,
                path,
                reader
            );

            let context = new Syntax.Parsers.CONTEXT(
                tokenizer,
                logger
            );

            let definitions = new LIST[Syntax.Trees.Definitions.Definition]();

            while !context.is_end_of_file do
                var definition = container.definition_parser.parse(context);

                if definition? then
                    definitions.add(
                        definition
                    );
                fi
            od

            let result =
                new SOURCE_FILE(
                    build_flags.copy(),
                    path,
                    new Syntax.Trees.Definitions.LIST(
                        Source.LOCATION.internal,
                        definitions
                    )
                );

            return result;
        si

        post_parse(source_files: Iterable[SOURCE_FILE]) is
            build(post_parse_passes, source_files);            
        si

        post_parse() is
            build(post_parse_passes, source_files);
        si

        build() is
            container.assemblies.start();
            container.ghul_namespace_creator.create_namespaces();
            build(build_passes, source_files);

            container.stable_symbols.next_generation();
        si

        build(passes: Collections.Iterable[Pass], source_files: Collections.Iterable[SOURCE_FILE]) is
            for pass in passes do                
                if !pass? then                    
                    continue;
                fi

                pass.start();

                let tasks = new LIST[PASS_TASK]();
                
                for i in source_files do                    
                    let symbol_table = IoC.CONTAINER.instance.symbol_table;

                    let task = new PASS_TASK(pass, i);

                    task.start();

                    tasks.add(task);

                    if i.build_flags.dump_tree then
                        Std.error.write_line(i.definition);
                    fi
                od

                if pass.is_task_safe then
                    Task.wait_all(tasks| .map(t: PASS_TASK => t.task).collect_array());
                fi

                pass.finish();

                @IF.not.release()
                Std.error.write_line(container.timers[pass._description]);
            od
        si

        conditional_compilation_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;
            
            process_factory
                .create_conditional_compilation()
                .apply(
                    definition
                );
        si
        
        rewrite_syntax_tree_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;

            process_factory
                .create_add_accessors_for_properties()
                .apply(definition);
        si

        declare_symbols_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;

            process_factory
                .create_expand_namespaces()
                .apply(definition);

            if flags.want_declare_symbols \/ flags.want_compile_expressions then
                container
                    .declare_symbols
                    .apply(definition);
            fi
        si

        resolve_uses_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;

            if flags.want_declare_symbols \/ flags.want_compile_expressions then
                process_factory
                    .create_resolve_uses()
                    .apply(definition);
            fi
        si

        resolve_ancestors_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;

            if flags.want_declare_symbols \/ flags.want_compile_expressions then
                process_factory
                    .create_resolve_ancestors()
                    .apply(definition);
            fi
        si

        resolve_type_expressions_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;

            if flags.want_declare_symbols \/ flags.want_compile_expressions then
                process_factory
                    .create_resolve_type_expressions()
                    .apply(definition);
            fi
        si

        resolve_explicit_types_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;

            if flags.want_declare_symbols \/ flags.want_compile_expressions then
                process_factory
                    .create_resolve_explicit_types()
                    .apply(definition);
            fi
        si

        compile_expressions_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;

            if flags.want_compile_expressions then
                process_factory
                    .create_compile_expressions()
                    .apply(definition);
            fi
        si

        resolve_overrides_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;
            let definition = source_file.definition;

            if flags.want_compile_expressions then
                process_factory
                    .create_resolve_overrides()
                    .apply(definition);
            fi
        si

        generate_il_pass(source_file: SOURCE_FILE) is
            let flags = source_file.build_flags;

            if flags.want_assembler \/ flags.want_executable then
                container
                    .ir_context
                    .throw_on_fixme = false;
    
                let definition = source_file.definition;

                process_factory
                    .create_generate_il()
                    .apply(definition);
            fi
        si

        build(source_file: SOURCE_FILE) is
        si
    si
si