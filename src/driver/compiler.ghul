namespace Driver is
    use System;
    use Generic;

    use IoC;
    use Logging;

    class COMPILER is
        container: CONTAINER;
        logger: Logger;

        legacy_object_file_name_generator: LEGACY_OBJECT_FILE_NAME_GENERATOR;

        work_items: Collections.LIST[WORK_ITEM];

        post_parse_passes: Collections.MutableList[Pass];

        build_passes: Collections.MutableList[Pass];

        generated_source_files: Collections.MutableList[String];

        init() is
            container = IoC.CONTAINER.instance;
            logger = container.logger;       

            legacy_object_file_name_generator = new LEGACY_OBJECT_FILE_NAME_GENERATOR();

            work_items = new Collections.LIST[WORK_ITEM]();
            generated_source_files = new Collections.LIST[String]();

            post_parse_passes = new Collections.LIST[Pass]();
            add_pass(post_parse_passes, "conditional-compilation", (wi: WORK_ITEM) -> void is conditional_compilation_pass(wi); si);
            add_pass(post_parse_passes, "rewrite-syntax-trees", (wi: WORK_ITEM) -> void is rewrite_syntax_tree_pass(wi); si);

            build_passes = new Collections.LIST[Pass]();
            add_pass(build_passes, "declare-symbols", (wi: WORK_ITEM) -> void is declare_symbols_pass(wi); si);
            add_pass(build_passes, "resolve-uses", (wi: WORK_ITEM) -> void is resolve_uses_pass(wi); si);
            add_pass(build_passes, "resolve-type-expressions", (wi: WORK_ITEM ) -> void is resolve_type_expressions_pass(wi); si);
            add_pass(build_passes, "resolve-ancestors", (wi: WORK_ITEM) -> void is resolve_ancestors_pass(wi); si);
            add_pass(build_passes, "resolve-explicit-types", (wi: WORK_ITEM) -> void is resolve_explicit_types_pass(wi); si);
            add_pass(build_passes, "resolve-overrides", (wi: WORK_ITEM) -> void is resolve_overrides_pass(wi); si);
            add_pass(build_passes, "compile-expressions", (wi: WORK_ITEM) -> void is compile_expressions_pass(wi); si);
            add_pass(build_passes, "write-objects", (wi: WORK_ITEM) -> void is write_objects_pass(wi); si);

            add_pass(build_passes, "generate-il", (wi: WORK_ITEM) -> void is generate_il_pass(wi); si);
        si

        dump_counts() is 
            container.symbol_table.dump_counts();
            container.generic_cache.dump_counts();
            container.namespaces.dump_counts();
            container.symbol_use_locations.dump_counts();
            container.symbol_definition_locations.dump_counts();
        si

        clear_symbols() is
            container.symbol_table.clear();
            container.generic_cache.clear();
            container.namespaces.clear();
            container.symbol_use_locations.clear();
            container.symbol_definition_locations.clear();
            container.logger.clear();
        si

        clear_queue() is
            work_items.clear();
        si

        add_pass(passes: Collections.MutableList[Pass], description: String, apply: WORK_ITEM -> void) is
            passes.add(new PASS(description, apply));
        si

        add_pass(passes: Collections.MutableList[Pass], pass: Pass) is
            passes.add(pass);
        si

        parse_and_queue(path: String, reader: IO2.TextReader, build_flags: BUILD_FLAGS) is
            queue(
                parse(path, reader, build_flags)
            );
        si

        queue(work_item: WORK_ITEM) is
            work_items.add(work_item);
        si

        queue(work_items: Collections.Iterable[WORK_ITEM]) is
            self.work_items.add_range(work_items);
        si

        parse(path: String, reader: IO2.TextReader, build_flags: BUILD_FLAGS) -> WORK_ITEM is
            let tokenizer = new Lexical.TOKENIZER(
                logger,
                path,
                reader
            );

            let context = new Syntax.Parser.CONTEXT(
                tokenizer,
                logger
            );

            let definitions = new Collections.LIST[Syntax.Tree.Definition.NODE]();

            while !context.is_end_of_file do
                var definition = container.definition_parser.parse(context);

                if definition? then
                    definitions.add(
                        definition
                    );
                fi
            od

            let result =
                new WORK_ITEM(
                    build_flags.copy(),
                    legacy_object_file_name_generator.new_object_file_name_for(path),
                    new Syntax.Tree.Definition.LIST(
                        Source.LOCATION.dummy,
                        definitions
                    )
                );

            build(post_parse_passes, new Collections.LIST[Driver.WORK_ITEM]([result]));

            return result;
        si

        build() is
            build(build_passes, work_items);
        si

        build(passes: Collections.Iterable[Pass], work_items: Collections.Iterable[WORK_ITEM]) is
            for pass in passes do                
                if !pass? then
                    
                    continue;
                fi
                
                for i in work_items do                    
                    let symbol_table = IoC.CONTAINER.instance.symbol_table;
                    let mark = symbol_table.mark_scope_stack();

                    try
                        pass.apply(i);
                    catch e: Exception
                        System.Console.error.write_line("caught exception running pass " + pass + " on work item " + i + "\n" + e);

                        @IF.dotnet()
                        throw e;
                    yrt

                    symbol_table.release_scope_stack(mark);

                    IoC.CONTAINER.instance.namespaces.pop_all_namespaces();                    

                    if i.build_flags.dump_tree then
                        System.Console.error.write_line(i.definition);
                    fi
                od
            od
        si

        conditional_compilation_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;
            
            container
                .conditional_compilation
                .apply(
                    definition,
                    flags.want_debug,
                    flags.want_legacy,
                    flags.want_dotnet
                );
        si
        
        rewrite_syntax_tree_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            container
                .add_accessors_for_properties
                .apply(definition);
        si

        declare_symbols_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            container
                .expand_namespaces
                .apply(definition);

            if flags.want_declare_symbols || flags.want_compile_expressions then
                container
                    .declare_symbols
                    .apply(definition);
            fi
        si

        resolve_uses_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_declare_symbols || flags.want_compile_expressions then
                container
                    .resolve_uses
                    .apply(definition);
            fi
        si

        resolve_ancestors_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_declare_symbols || flags.want_compile_expressions then
                container
                    .resolve_ancestors
                    .apply(definition);
            fi
        si

        resolve_type_expressions_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_declare_symbols || flags.want_compile_expressions then
                container
                    .resolve_type_expressions
                    .apply(definition);
            fi
        si

        resolve_explicit_types_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_declare_symbols || flags.want_compile_expressions then
                container
                    .resolve_explicit_types
                    .apply(definition);
            fi
        si

        compile_expressions_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_compile_expressions then
                container
                    .compile_expressions
                    .apply(definition);
            fi
        si

        resolve_overrides_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;
            let definition = work_item.definition;

            if flags.want_compile_expressions then
                container
                    .resolve_overrides
                    .apply(definition);
            fi
        si

        write_objects_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;

            if flags.want_legacy then
                let definition = work_item.definition;
                let printer = container.legacy_printer;

                printer.write(definition);

                generated_source_files.add(work_item.legacy_object_file_name);

                var writer = Shim.FILE.open_create(work_item.legacy_object_file_name);

                writer.write(printer.result);

                writer.close();
            fi
        si

        generate_il_pass(work_item: WORK_ITEM) is
            let flags = work_item.build_flags;

            if flags.want_dotnet && (flags.want_assembler || flags.want_executable) then

                @IF.legacy()
                container
                    .ir_context
                    .throw_on_fixme = flags.want_executable;

                @IF.dotnet()
                container
                    .ir_context
                    .throw_on_fixme = false;
    
                let definition = work_item.definition;

                container
                    .generate_il
                    .apply(definition);
            fi
        si

        build(work_item: WORK_ITEM) is
        si
    si
si