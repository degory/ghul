namespace Driver is
    use System.Exception;
    use IO.Std;

    use Collections.Iterable;

    use Pair = Collections.KeyValuePair`2;

    use IoC;
    use Logging;
    use Source;

    trait CommandHandler is
        handle(reader: IO.TextReader, writer: IO.TextWriter);
    si

    trait WorkItemLookup is
        file_names: Iterable[string];
        find_work_item(file_name: string) -> SOURCE_FILE;
    si

    class ANALYSER is
        _log: IO.TextWriter;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _compiler: COMPILER;
        _timers: TIMERS;

        _command_map: Collections.MAP[string,CommandHandler];
        _despatcher: COMMAND_DESPATCHER;

        init(
            compiler: COMPILER,
            timers: TIMERS,
            symbol_table: Semantic.SYMBOL_TABLE,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS,
            completer: Syntax.Process.COMPLETER,
            signature_help: Syntax.Process.SIGNATURE_HELP,
            reader: IO.TextReader,
            writer: IO.TextWriter,
            library_files: Iterable[string],
            build_flags: BUILD_FLAGS
        ) is
            _log = Std.error;
            _compiler = compiler;
            _timers = timers;
            _symbol_table = symbol_table;

            _command_map = new Collections.MAP[string,CommandHandler]();

            let watchdog = new WATCHDOG();

            _despatcher = new COMMAND_DESPATCHER(reader, writer, _timers, _log, watchdog);

            build_flags.want_compile_expressions = true;

            let file_edited_handler = new FILE_EDITED_HANDLER(watchdog, compiler, build_flags, library_files);
            let analyse_handler = new ANALYSE_HANDLER(watchdog, compiler, symbol_table, file_edited_handler, file_edited_handler);
            let hover_handler = new HOVER_HANDLER(watchdog, symbol_use_locations);
            let find_definition_handler = new FIND_DEFINITION_HANDLER(watchdog, symbol_use_locations);
            let completion_handler = new COMPLETION_HANDLER(watchdog, completer, file_edited_handler);
            let signature_handler = new SIGNATURE_HANDLER(watchdog, signature_help, file_edited_handler);
            let symbols_handler = new SYMBOLS_HANDLER(watchdog, symbol_definition_locations, file_edited_handler);
            let references_handler = new REFERENCES_HANDLER(watchdog, symbol_use_locations);
            let restart_handler = new RESTART_HANDLER();

            _despatcher.add_handler(
                "EDIT", file_edited_handler
            );

            _despatcher.add_handler(
                "ANALYSE", analyse_handler
            );

            _despatcher.add_handler(
                "HOVER", hover_handler
            );

            _despatcher.add_handler(
                "DEFINITION", find_definition_handler
            );

            _despatcher.add_handler(
                "COMPLETE", completion_handler
            );

            _despatcher.add_handler(
                "SIGNATURE", signature_handler
            );

            _despatcher.add_handler(
                "SYMBOLS", symbols_handler
            );

            _despatcher.add_handler(
                "REFERENCES", references_handler
            );

            _despatcher.add_handler(
                "RESTART", restart_handler
            );
        si

        run() is
            do
                if !_despatcher.poll() then
                    _log.write_line("ghūl: exiting");
                    return;
                fi
            od
        si
    si
    
    class WATCHDOG is        
        operation_limit: int static => 500;

        _is_enabled: bool;
        _operation_count: int;

        _restart_count: int;

        want_restart: bool;
        init() is si

        request_restart() is
            _restart_count = _restart_count + 2;

            if _restart_count > 20 then
                want_restart = true;
            fi
        si

        enable() is
            _is_enabled = true;
        si

        increment(writer: IO.TextWriter) is
            if _is_enabled then
                _operation_count = _operation_count + 1;
            fi
            
            if want_restart \/ _operation_count > operation_limit then
                want_restart = false;

                if want_restart then
                    Std.error.write_line("watchdog: restart due to instability...");
                else
                    Std.error.write_line("watchdog: recycle...");
                fi
                
                Std.error.flush();

                writer.write_line("RESTART");
                writer.write("" + cast char(12));
                writer.flush();

                System.Environment.exit(1);
            fi

            if _restart_count > 0 then
                _restart_count = _restart_count - 1;
            fi
        si
    si

    class COMMAND_DESPATCHER is
        _timers: TIMERS;
        _log: IO.TextWriter;
        _watchdog: WATCHDOG;
        _reader: IO.TextReader;
        _writer: IO.TextWriter;
        _command_map: Collections.MAP[string,CommandHandler];

        _listening: bool;

        init(
            reader: IO.TextReader, 
            writer: IO.TextWriter, 
            timers: TIMERS,
            log: IO.TextWriter,
            watchdog: WATCHDOG
        ) is
            _reader = reader;
            _writer = writer;
            _timers = timers;
            _log = log;
            _watchdog = watchdog;

            _command_map = new Collections.MAP[string,CommandHandler]();
        si

        add_handler(command_name: string, command_handler: CommandHandler) is
            assert !_command_map.contains_key(command_name) else "replacing command handler for " + command_name;

            _command_map[command_name] = command_handler;
        si

        poll() -> bool is
            if !_listening then
                _writer.write_line("LISTEN");
                _writer.write("" + cast char(12));
                _writer.flush();

                _listening = true;
            fi

            let command = read_command();

            if command? then
                if _command_map.contains_key(command) then
                    let handler = _command_map[command];

                    if _watchdog.want_restart /\ command !~ "EDIT" /\ command !~ "ANALYSE" then
                        _log.write_line("poisoned: should ignore non-edit command: " + command);
                    fi

                    @IF.not.release()
                    _timers.start(command);

                    handler.handle(_reader, _writer);

                    @IF.not.release()
                    _timers.finish(command);
                    
                    @IF.not.release()
                    if command !~ "EDIT" then                        
                        _log.write_line(_timers[command]);
                    fi

                    _watchdog.increment(_writer);

                    return true;
                else
                    _log.write_line("ghūl: no handler found for command: '" + command + "' in " + _command_map);

                    _watchdog.request_restart();

                    return true;
                fi
            else
                _log.write_line("ghūl: reader is at end");
            fi

            _log.flush();

            return false;
        si

        read_command() -> string is
            let desynchronized = false;

            do
                let command = _reader.read_line();

                if !command? then
                    break;
                fi
                
                while command.starts_with('\014') do
                    command = command.substring(1);
                od

                if 
                    command.length >= 3 /\ 
                    command.starts_with('#') /\ 
                    command.ends_with('#')
                then
                    if desynchronized then
                        _log.write_line("ghūl: well-formed command received: resynchronized");
                    fi

                    return command.substring(1, command.length - 2);
                fi

                if !desynchronized then
                    let length = command.length;

                    if length > 20 then
                        length = 20;
                    fi
                    
                    _log.write_line("ghūl: garbled command: attempting to resynchronize: " + command.substring(0, length));

                    desynchronized = true;
                fi
            od

            return null;
        si

        restart(writer: IO.TextWriter) is
            throw new System.NotImplementedException("restart");
        si
    si

    class HOVER_HANDLER: CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            self._watchdog = watchdog;
            self._symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.read_line();
            let line = System.Convert.to_int32(reader.read_line());
            let column = System.Convert.to_int32(reader.read_line()) + 1;

            let written_header = false;
            
            try
                writer.write_line("HOVER");
                written_header = true;
                
                if !_watchdog.want_restart then
                    let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);

                    if symbol? then
                        writer.write_line(symbol.description);
                    fi
                fi
            catch e: Exception
                Std.error.write_line("HOVER: " + e.get_type() + e.message);

                _watchdog.request_restart();

                if !written_header then
                    writer.write_line("HOVER");                    
                fi
            yrt

            Std.error.flush();

            writer.write("" + cast char(12));
            writer.flush();
        si
    si

    class FIND_DEFINITION_HANDLER: CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            self._watchdog = watchdog;
            self._symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.read_line();
            let line = System.Convert.to_int32(reader.read_line());
            let column = System.Convert.to_int32(reader.read_line());

            let written_header = false;

            try
                writer.write_line("DEFINITION");
                written_header = true;
                
                if !_watchdog.want_restart then
                    let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);
                    
                    if symbol? /\ !symbol.is_internal /\ !symbol.is_reflected then
                        writer.write_line("" + symbol.location.file_name);
                        writer.write_line("" + symbol.location.start_line);
                        writer.write_line("" + symbol.location.start_column);
                        writer.write_line("" + symbol.location.end_line);
                        writer.write_line("" + symbol.location.end_column);
                    fi
                fi
            catch e: Exception
                Std.error.write_line("DEFINITION:" + e.get_type() + ": " + e.message);
                _watchdog.request_restart();

                if !written_header then
                    writer.write_line("DEFINITION");                    
                fi                
            yrt

            Std.error.flush();

            writer.write("" + cast char(12));
            writer.flush();
        si
    si

    class FILE_EDITED_HANDLER: CommandHandler, WorkItemLookup, Iterable[SOURCE_FILE] is
        _watchdog: WATCHDOG;
        _compiler: COMPILER;
        _work_items: Collections.MutableMap[string,SOURCE_FILE];
        _build_flags: BUILD_FLAGS;
        _library_files: Iterable[string];

        file_names: Iterable[string] => _work_items.keys;

        iterator: Collections.Iterator[SOURCE_FILE]
            => _work_items.values.iterator;

        init(
            watchdog: WATCHDOG,
            compiler: COMPILER,
            build_flags: BUILD_FLAGS,
            library_files: Iterable[string])
        is
            _watchdog = watchdog;
            _compiler = compiler;
            _work_items = new Collections.MAP[string,SOURCE_FILE]();
            _build_flags = build_flags;

            _library_files = library_files;
        si

        find_work_item(path: string) -> SOURCE_FILE is
            if _work_items.contains_key(path) then
                return _work_items[path];
            fi
        si

        parse_and_add_file(path: string, reader: IO.TextReader, is_internal_file: bool) is
            let source_file = _compiler.parse(path, reader, _build_flags, is_internal_file);
            _work_items[path] = source_file;

            _compiler.post_parse([source_file]);
        si
        
        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let node_id = Syntax.Trees.Node.debug_next_id;

            let path = reader.read_line();

            writer.write_line("DIAG PARSE");

            if _library_files? then
                for library_file_path in _library_files do
                    parse_and_add_file(library_file_path, IO.File.open_text(library_file_path), true);
                od  

                _library_files = null;                    
            fi

            try
                parse_and_add_file(path, reader, false);

                // let source_file = _compiler.parse(path, reader, _build_flags);
                // _work_items[path] = source_file;

                // _compiler.post_parse([source_file]);
            catch e: Exception
                Std.error.write_line("PARSE: " + e.get_type() + ": " + e.message);

                _watchdog.request_restart();
            yrt

            Std.error.flush();

            writer.write("" + cast char(12));
            writer.flush();
        si
    si

    class ANALYSE_HANDLER: CommandHandler is
        _watchdog: WATCHDOG;
        _compiler: COMPILER;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _work_item_source: Iterable[SOURCE_FILE];
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            compiler: COMPILER,
            symbol_table: Semantic.SYMBOL_TABLE,
            work_item_source: Iterable[SOURCE_FILE],
            work_item_lookup: WorkItemLookup
        ) is
            _watchdog = watchdog;
            _compiler = compiler;
            _symbol_table = symbol_table;
            _work_item_source = work_item_source;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            writer.write_line("DIAG ANALYSIS");
            let node_id = Syntax.Trees.Node.debug_next_id;

            let uris = reader.read_line().split(['\t']);

            try
                if !_watchdog.want_restart then
                    if uris.count >= 1 /\ uris[0] =~ "all" then
                        for i in _work_item_source do
                            i.build_flags.want_compile_expressions = true;
                        od
                    else
                        let count = 0;

                        for i in _work_item_source do
                            i.build_flags.want_declare_symbols = true;
                            i.build_flags.want_compile_expressions = false;
                        od

                        for uri in uris do
                            let i = _work_item_lookup.find_work_item(uri);

                            if i? then
                                count = count + 1;
                                i.build_flags.want_compile_expressions = true;
                            fi
                        od
                    fi
                        
                    _compiler.clear_symbols();

                    _compiler.queue(_work_item_source);

                    _compiler.build();
                fi

                writer.write("" + cast char(12));
                writer.write_line("ANALYSED");

                _watchdog.enable();

            catch e: Exception
                Std.error.write_line("ANALYSE:" + e.get_type() + ": " + e.message);

                _watchdog.request_restart();

                writer.write("" + cast char(12));
                writer.write_line("ANALYSED");
            finally
                _compiler.clear_queue();

                writer.write("" + cast char(12));
                writer.flush();
            yrt
        si
    si

    class COMPLETION_HANDLER: CommandHandler is
        _watchdog: WATCHDOG;
        _completer: Syntax.Process.COMPLETER;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            completer: Syntax.Process.COMPLETER,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _completer = completer;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            let written_header = false;

            try
                let path = reader.read_line();
                let target_line = System.Convert.to_int32(reader.read_line());
                let target_column = System.Convert.to_int32(reader.read_line());

                writer.write_line("COMPLETION");
                written_header = true;

                if !_watchdog.want_restart then
                    let results = find_completions(path, target_line, target_column);

                    if results? then
                        for pair in results do
                            writer.write_line("{0}\t{1}\t{2}", [pair.key, cast int(pair.value.completion_kind), pair.value.description]);
                        od
                    fi
                fi
            catch e: Exception
                Std.error.write_line("COMPLETION:" + e.get_type() + ": " + e.message);

                _watchdog.request_restart();

                if !written_header then
                    writer.write_line("COMPLETION");
                fi
            yrt

            Std.error.flush();

            writer.write("" + cast char(12));
            writer.flush();
        si

        find_completions(path: string, target_line: int, target_column: int) -> Iterable[Pair[string,Semantic.Symbols.Symbol]] is
            let i = _work_item_lookup.find_work_item(path);

            return _completer.find_completions(i.definition, target_line, target_column);
        si
    si

    class SIGNATURE_HANDLER: CommandHandler is
        _watchdog: WATCHDOG;
        _signature_help: Syntax.Process.SIGNATURE_HELP;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            signature_help: Syntax.Process.SIGNATURE_HELP,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _signature_help = signature_help;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            let written_header = false;

            try
                let path = reader.read_line();
                let target_line = System.Convert.to_int32(reader.read_line());
                let target_column = System.Convert.to_int32(reader.read_line());

                if !_watchdog.want_restart then
                    writer.write_line("SIGNATURE");
                    written_header = true;

                    let results = find_signatures(path, target_line, target_column);                    

                    if results? then
                        writer.write_line("" + results.best_result_index);
                        writer.write_line("" + results.current_parameter_index);
                        for symbol in results.results do
                            let line = get_function_doc_for(symbol);
                            writer.write_line(line);
                        od
                    fi
                fi
            catch e: Exception
                Std.error.write_line("SIGNATURE:" + e.get_type() + ": " + e.message);

                _watchdog.request_restart();

                if !written_header then
                    writer.write_line("SIGNATURE");
                fi
            yrt

            Std.error.flush();

            writer.write("" + cast char(12));
            writer.flush();
        si

        get_function_doc_for(function: Semantic.Symbols.Function) -> string is
            let result = new System.Text.StringBuilder();

            result
                .append(function.short_description);

            for i in 0..function.arguments.count do
                result
                    .append('\t')
                    .append(function.get_short_argument_description(i));
            od

            return result.to_string();
        si

        find_signatures(path: string, target_line: int, target_column: int) -> Semantic.OVERLOAD_MATCHES_RESULT is
            let i = _work_item_lookup.find_work_item(path);

            return _signature_help.find_signatures(i.definition, target_line, target_column);
        si
    si

    class SYMBOLS_HANDLER: CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _symbol_definition_locations = symbol_definition_locations;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            let written_header = false;

            try
                let path = reader.read_line();

                writer.write_line("SYMBOLS");
                written_header = true;

                if !_watchdog.want_restart then
                    if path? /\ path.length > 0 then
                        write_symbol_list_for_file(writer, path, _symbol_definition_locations.find_definitions_from_file(path, false));
                    else
                        for i in _work_item_lookup.file_names do
                            if i? /\ i.length > 0 then
                                write_symbol_list_for_file(writer, i, _symbol_definition_locations.find_definitions_from_file(i, true));
                            fi
                        od
                    fi
                fi
            catch e: Exception
                Std.error.write_line("SYMBOLS: " + e.get_type() + ": " + e.message + " " + e.to_string());

                _watchdog.request_restart();

                if !written_header then
                    writer.write_line("SYMBOLS");
                fi
            yrt

            Std.error.flush();

            writer.write("" + cast char(12));
            writer.flush();
        si

        write_symbol_list_for_file(writer: IO.TextWriter, path: string, symbols: Iterable[Semantic.Symbols.Symbol]) is
            writer.write_line(path);

            if symbols? then
                for symbol in symbols | .filter(s => s?) do
                    writer.write_line(
                        get_symbol_info_for(symbol)
                    );
                od
            fi
        si

        get_symbol_info_for(symbol: Semantic.Symbols.Symbol) -> string is
            let result = new System.Text.StringBuilder();
            let qualified_name = symbol.qualified_name;

            let qualifier = qualified_name.substring(0, qualified_name.length - symbol.name.length - 1);

            result
                .append(symbol.search_description)
                .append('\t')
                .append(cast int(symbol.symbol_kind))
                .append('\t')
                .append(symbol.span.start_line)
                .append('\t')
                .append(symbol.span.start_column)
                .append('\t')
                .append(symbol.span.end_line)
                .append('\t')
                .append(symbol.span.end_column)
                .append('\t')
                .append(qualifier);

            return result.to_string();
        si
    si

    class REFERENCES_HANDLER: CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            _watchdog = watchdog;
            _symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let written_header = false;

            try
                let path = reader.read_line();
                let line = System.Convert.to_int32(reader.read_line());
                let column = System.Convert.to_int32(reader.read_line());

                writer.write_line("REFERENCES");
                written_header = true;

                if !_watchdog.want_restart then
                    let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);

                    if symbol? then
                        let locations = _symbol_use_locations.find_references_to_symbol(symbol);

                        write_location_list(writer, locations);
                    fi
                fi

            catch e: Exception
                Std.error.write_line("REFERENCES: " + e.get_type() + ": " + e.message);

                if !written_header then
                    writer.write_line("REFERENCES");
                fi
            yrt

            Std.error.flush();

            writer.write("" + cast char(12));
            writer.flush();
        si

        write_location_list(writer: IO.TextWriter, locations: Iterable[LOCATION]) is
            for location in locations do
                writer.write_line(
                    format_location(location)
                );
            od
        si

        format_location(location: LOCATION) -> string is
            let result = new System.Text.StringBuilder();

            result
                .append(location.file_name)
                .append('\t')
                .append(location.start_line)
                .append('\t')
                .append(location.start_column)
                .append('\t')
                .append(location.end_line)
                .append('\t')
                .append(location.end_column);

            return result.to_string();
        si
    si

    class RESTART_HANDLER: CommandHandler is
        init() is si

        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            writer.write("" + cast char(12));
            writer.close();

            System.Environment.exit(1);
        si
    si
si