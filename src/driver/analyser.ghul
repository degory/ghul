namespace Driver is
    use System;
    use Generic;
 
    use IoC;
    use Logging;
    use Source;

    trait CommandHandler is
        handle(reader: IO.Reader, writer: IO.Writer);
    si

    trait WorkItemLookup is
        file_names: Collections.Iterable[String];
        find_work_item(file_name: String) -> WORK_ITEM;
    si

    class ANALYSER is
        _symbol_table: Semantic.SYMBOL_TABLE;
        _compiler: COMPILER;

        _command_map: Dict[String,CommandHandler];
        _despatcher: COMMAND_DESPATCHER;

        init(
            compiler: COMPILER,
            symbol_table: Semantic.SYMBOL_TABLE,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS,
            symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS,
            completer: Syntax.Process.COMPLETER,
            signature_help: Syntax.Process.SIGNATURE_HELP,
            reader: IO.Reader,
            writer: IO.Writer,
            build_flags: BUILD_FLAGS
        ) is
            IO.Std.err.println("ghūl: analyser starting up...");

            _compiler = compiler;
            _symbol_table = symbol_table;

            _command_map = new Map[String,CommandHandler]();

            let watchdog = new WATCHDOG();

            _despatcher = new COMMAND_DESPATCHER(reader, writer, watchdog);

            build_flags.want_legacy = false;
            build_flags.want_compile_expressions = true;

            let file_edited_handler = new FILE_EDITED_HANDLER(watchdog, compiler, build_flags);
            let analyse_handler = new ANALYSE_HANDLER(watchdog, compiler, symbol_table, file_edited_handler, file_edited_handler);
            let hover_handler = new HOVER_HANDLER(watchdog, symbol_use_locations);
            let find_definition_handler = new FIND_DEFINITION_HANDLER(watchdog, symbol_use_locations);
            let completion_handler = new COMPLETION_HANDLER(watchdog, completer, file_edited_handler);
            let signature_handler = new SIGNATURE_HANDLER(watchdog, signature_help, file_edited_handler);
            let symbols_handler = new SYMBOLS_HANDLER(watchdog, symbol_definition_locations, file_edited_handler);
            let references_handler = new REFERENCES_HANDLER(watchdog, symbol_use_locations);
            let restart_handler = new RESTART_HANDLER();

            _despatcher.add_handler(
                "EDIT", file_edited_handler
            );

            _despatcher.add_handler(
                "ANALYSE", analyse_handler
            );

            _despatcher.add_handler(
                "HOVER", hover_handler
            );

            _despatcher.add_handler(
                "DEFINITION", find_definition_handler
            );

            _despatcher.add_handler(
                "COMPLETE", completion_handler
            );

            _despatcher.add_handler(
                "SIGNATURE", signature_handler
            );

            _despatcher.add_handler(
                "SYMBOLS", symbols_handler
            );

            _despatcher.add_handler(
                "REFERENCES", references_handler
            );

            _despatcher.add_handler(
                "RESTART", restart_handler
            );
        si

        run() is
            do
                if !_despatcher.poll() then
                    IO.Std.err.println("ghūl: exiting");
                    return;
                fi
            od
        si
    si

    class WATCHDOG is
        operation_limit: int static => 1024;
        _operation_count: int;

        _want_restart: bool;

        _poison_count: int;
        is_poisoned: bool => _poison_count > 10;

        init() is si

        poison() is
            _poison_count = _poison_count + 1;

            IO.Std.err.println("poison: " + _poison_count);
            IO.Std.err.flush();
        si

        antidote() is
            _poison_count = 0;
        si
                
        request_restart() is
            _want_restart = true;
        si

        increment(writer: IO.Writer) is
            _operation_count = _operation_count + 1;

            if _operation_count > operation_limit || _want_restart then
                _want_restart = false;

                IO.Std.err.println("watchdog: requesting restart...");
                IO.Std.err.flush();

                writer.println("RESTART");
                writer.print("" + cast char(12));
                writer.flush();
            fi
        si
    si

    class COMMAND_DESPATCHER is
        _watchdog: WATCHDOG;
        _reader: IO.Reader;
        _writer: IO.Writer;
        _command_map: Dict[String,CommandHandler];

        _listening: bool;

        init(reader: IO.Reader, writer: IO.Writer, watchdog: WATCHDOG) is
            _reader = reader;
            _writer = writer;
            _watchdog = watchdog;

            _command_map = new Map[String,CommandHandler]();
        si

        add_handler(command_name: String, command_handler: CommandHandler) is
            assert(_command_map[command_name] == null, "replacing command handler for " + command_name);

            _command_map[command_name] = command_handler;
        si

        poll() -> bool is
            IO.Std.err.FlushOnPrintln = true;

            if !_listening then
                _writer.println("LISTEN");
                _writer.print("" + cast char(12));
                _writer.flush();

                _listening = true;
            fi

            let command = read_command();

            if command? then
                let handler = _command_map[command];

                if handler? then
                    if _watchdog.is_poisoned && !["EDIT", "ANALYSE"].contains(command) then
                        IO.Std.err.println("poisoned: ignoring non-edit command: " + command);
                    fi

                    handler.handle(_reader, _writer);
                    
                    _watchdog.increment(_writer);

                    return true;
                else
                    IO.Std.err.println("ghūl: no handler found for command: '" + command + "' in " + _command_map);

                    _watchdog.request_restart();

                    return true;
                fi
            else
                IO.Std.err.println("ghūl: reader is at end");
            fi

            IO.Std.err.flush();

            return false;
        si

        read_command() -> System.String is
            let desynchronized = false;

            while !_reader.isAtEnd() do
                let command = _reader.readLine();

                while command.startsWith('\014') do
                    command = command.substring(1);
                od

                if command.Length >= 3 && command.startsWith('#') && command.endsWith('#') then
                    if desynchronized then
                        IO.Std.err.println("ghūl: well-formed command received: resynchronized");
                    fi

                    return command.substring(1, command.Length-1);
                fi

                if !desynchronized then
                    IO.Std.err.println("ghūl: garbled command: attempting to resynchronize");

                    desynchronized = true;
                fi
            od

            return null;
        si

        restart(writer: IO.Writer) is
            writer.flush();

            let executable_path = System.Arguments.ProgramArguments[0];

            let p = new Util.Process();

            p.spawn(
                executable_path,
                Arguments.ProgramArguments,
                Arguments.ProgramEnvironment
            );
        si
    si

    class HOVER_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            self._watchdog = watchdog;
            self._symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.readLine();
            let line = reader.readLine().toInt();
            let column = reader.readLine().toInt() + 1;

            let written_header = false;
            
            try
                writer.println("HOVER");
                written_header = true;
                
                if !_watchdog.is_poisoned then
                    let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);

                    if symbol? then
                        writer.println(symbol.description);
                    fi
                fi
            catch e: Exception
                IO.Std.err.println(e);
                _watchdog.poison();

                if !written_header then
                    writer.println("HOVER");                    
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si
    si

    class FIND_DEFINITION_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            self._watchdog = watchdog;
            self._symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let path = reader.readLine();
            let line = reader.readLine().toInt();
            let column = reader.readLine().toInt();

            let written_header = false;

            try
                writer.println("DEFINITION");
                written_header = true;
                
                if !_watchdog.is_poisoned then
                    let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);                    
                    
                    if symbol? then
                        writer.println("" + symbol.location.file_name);
                        writer.println("" + symbol.location.start_line);
                        writer.println("" + symbol.location.start_column);
                        writer.println("" + symbol.location.end_line);
                        writer.println("" + symbol.location.end_column);
                    fi
                fi
            catch e: Exception
                IO.Std.err.println(e);
                _watchdog.poison();

                if !written_header then
                    writer.println("DEFINITION");                    
                fi                
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si
    si

    class FILE_EDITED_HANDLER: Object, CommandHandler, WorkItemLookup, Collections.Iterable[WORK_ITEM] is
        _watchdog: WATCHDOG;
        _compiler: COMPILER;
        _work_items: Collections.MutableMap[String,WORK_ITEM];
        _build_flags: BUILD_FLAGS;

        file_names: Collections.Iterable[String] => _work_items.keys;

        iterator: Collections.Iterator[WORK_ITEM]
            => _work_items.values.iterator;

        init(
            watchdog: WATCHDOG,
            compiler: COMPILER,
            build_flags: BUILD_FLAGS)
        is
            _watchdog = watchdog;
            _compiler = compiler;
            _work_items = new Collections.MAP[String,WORK_ITEM]();
            _build_flags = build_flags;
        si

        find_work_item(path: String) -> WORK_ITEM =>
            _work_items[path];

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let node_id = Syntax.Tree.NODE.debug_next_id;

            let path = reader.readLine();

            writer.println("DIAG PARSE");

            try
                _work_items[path] =
                    _compiler.parse(path, reader, _build_flags);

                _watchdog.antidote();
            catch e: Exception
                IO.Std.err.println(e);

                _watchdog.request_restart();
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si
    si

    class ANALYSE_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _compiler: COMPILER;
        _symbol_table: Semantic.SYMBOL_TABLE;
        _work_item_source: Collections.Iterable[WORK_ITEM];
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            compiler: COMPILER,
            symbol_table: Semantic.SYMBOL_TABLE,
            work_item_source: Collections.Iterable[WORK_ITEM],
            work_item_lookup: WorkItemLookup
        ) is
            _watchdog = watchdog;
            _compiler = compiler;
            _symbol_table = symbol_table;
            _work_item_source = work_item_source;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            writer.println("DIAG ANALYSIS");
            let node_id = Syntax.Tree.NODE.debug_next_id;

            let uris = reader.readLine().split('\t');

            try
                if !_watchdog.is_poisoned then
                    if uris.Length >= 1 && uris[0] =~ "all" then
                        for i in _work_item_source do
                            i.build_flags.want_compile_expressions = true;
                        od
                    else
                        let count = 0;

                        for i in _work_item_source do
                            i.build_flags.want_declare_symbols = true;
                            i.build_flags.want_compile_expressions = false;
                        od

                        for uri in uris do
                            let i = _work_item_lookup.find_work_item(uri);

                            if i? then
                                count = count + 1;
                                i.build_flags.want_compile_expressions = true;
                            fi
                        od
                    fi
                        
                    _compiler.clear_symbols();

                    _compiler.queue(_work_item_source);

                    _compiler.build();

                    _watchdog.antidote();
                fi

                writer.print("" + cast char(12));
                writer.println("ANALYSED");

            catch e: Exception
                IO.Std.err.println(e);

                _watchdog.poison();

                writer.print("" + cast char(12));
                writer.println("ANALYSED");
            finally
                _compiler.clear_queue();

                writer.print("" + cast char(12));
                writer.flush();
            yrt
        si

        format_thousands(value: long) -> String is
            let result = new StringBuffer();

            result.append(value / 1000L);
            result.append(',');
            result.append(cast int(value % 1000L), 10, 3, '0');

            return result;
        si
    si

    class COMPLETION_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _completer: Syntax.Process.COMPLETER;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            completer: Syntax.Process.COMPLETER,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _completer = completer;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            var written_header = false;

            try
                let path = reader.readLine();
                let target_line = reader.readLine().toInt();
                let target_column = reader.readLine().toInt();

                writer.println("COMPLETION");
                written_header = true;

                if !_watchdog.is_poisoned then

                    let results = find_completions(path, target_line, target_column);

                    if results? then
                        for symbol in results do
                            writer.println("%\t%\t%" % [symbol.name, symbol.completion_kind, symbol.description]: Object);
                        od
                    fi
                fi
            catch e: Exception
                IO.Std.err.println(e);

                _watchdog.poison();

                if !written_header then
                    writer.println("COMPLETION");
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si

        find_completions(path: String, target_line: int, target_column: int) -> Collections.Iterable[Semantic.Symbol.BASE] is
            let i = _work_item_lookup.find_work_item(path);

            return _completer.find_completions(i.definition, target_line, target_column);
        si
    si

    class SIGNATURE_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _signature_help: Syntax.Process.SIGNATURE_HELP;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            signature_help: Syntax.Process.SIGNATURE_HELP,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _signature_help = signature_help;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            var written_header = false;

            try
                let path = reader.readLine();
                let target_line = reader.readLine().toInt();
                let target_column = reader.readLine().toInt();

                if !_watchdog.is_poisoned then
                    writer.println("SIGNATURE");
                    written_header = true;

                    let results = find_signatures(path, target_line, target_column);                    

                    if results? then
                        writer.println("" + results.best_result_index);
                        writer.println("" + results.current_parameter_index);
                        for symbol in results.results do
                            let line = get_function_doc_for(symbol);
                            writer.println(line);
                        od
                    fi
                fi
            catch e: Exception
                IO.Std.err.println(e);

                _watchdog.poison();

                if !written_header then
                    writer.println("SIGNATURE");
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si

        get_function_doc_for(function: Semantic.Symbol.Function) -> String is
            let result = new StringBuffer();

            result
                .append(function.short_description);

            for i in 0..function.arguments.Length do
                result
                    .append('\t')
                    .append(function.get_short_argument_description(i));
            od

            return result;
        si

        find_signatures(path: String, target_line: int, target_column: int) -> Semantic.OVERLOAD_MATCHES_RESULT is
            let i = _work_item_lookup.find_work_item(path);

            return _signature_help.find_signatures(i.definition, target_line, target_column);
        si
    si

    class SYMBOLS_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS;
        _work_item_lookup: WorkItemLookup;

        init(
            watchdog: WATCHDOG,
            symbol_definition_locations: Semantic.SYMBOL_DEFINITION_LOCATIONS,
            work_item_lookup: WorkItemLookup
        )
        is
            _watchdog = watchdog;
            _symbol_definition_locations = symbol_definition_locations;
            _work_item_lookup = work_item_lookup;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            var written_header = false;

            try
                let path = reader.readLine();

                writer.println("SYMBOLS");
                written_header = true;

                if !_watchdog.is_poisoned then
                    if path? && path.Length > 0 then
                        write_symbol_list_for_file(writer, path, _symbol_definition_locations.find_definitions_from_file(path, false));
                    else
                        for i in _work_item_lookup.file_names do
                            if i? && i.Length > 0 then
                                write_symbol_list_for_file(writer, i, _symbol_definition_locations.find_definitions_from_file(i, true));
                            fi
                        od
                    fi
                fi
            catch e: Exception
                IO.Std.err.println(e);

                _watchdog.poison();

                if !written_header then
                    writer.println("SYMBOLS");
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si

        write_symbol_list_for_file(writer: IO.Writer, path: String, symbols: Collections.Iterable[Semantic.Symbol.BASE]) is
            writer.println(path);

            if symbols? then
                for symbol in symbols do
                    writer.println(
                        get_symbol_info_for(symbol)
                    );
                od
            fi
        si

        get_symbol_info_for(symbol: Semantic.Symbol.BASE) -> String is
            let result = new StringBuffer();

            let qualified_name = symbol.qualified_name;

            let qualifier = qualified_name.substring(0, qualified_name.Length - symbol.name.Length - 1);

            result
                .append(symbol.name)
                .append('\t')
                .append(cast int(symbol.symbol_kind))
                .append('\t')
                .append(symbol.location.start_line)
                .append('\t')
                .append(symbol.location.start_column)
                .append('\t')
                .append(symbol.location.end_line)
                .append('\t')
                .append(symbol.location.end_column)
                .append('\t')
                .append(qualifier);

            return result;
        si
    si

    class REFERENCES_HANDLER: Object, CommandHandler is
        _watchdog: WATCHDOG;
        _symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS;

        init(
            watchdog: WATCHDOG,
            symbol_use_locations: Semantic.SYMBOL_USE_LOCATIONS
        )
        is
            _watchdog = watchdog;
            _symbol_use_locations = symbol_use_locations;
        si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            var written_header = false;

            try
                let path = reader.readLine();
                let line = reader.readLine().toInt();
                let column = reader.readLine().toInt();

                writer.println("REFERENCES");
                written_header = true;

                if !_watchdog.is_poisoned then
                    let symbol = _symbol_use_locations.find_definition_from_use(path, line, column);

                    if symbol? then
                        let locations = _symbol_use_locations.find_references_to_symbol(symbol);

                        write_location_list(writer, locations);
                    fi
                fi

            catch e: Exception
                IO.Std.err.println(e);

                if !written_header then
                    writer.println("REFERENCES");
                fi
            yrt

            IO.Std.err.flush();

            writer.print("" + cast char(12));
            writer.flush();
        si

        write_location_list(writer: IO.Writer, locations: Collections.Iterable[LOCATION]) is
            for location in locations do
                writer.println(
                    format_location(location)
                );
            od
        si

        format_location(location: LOCATION) -> String is
            let result = new StringBuffer();

            result
                .append(location.file_name)
                .append('\t')
                .append(location.start_line)
                .append('\t')
                .append(location.start_column)
                .append('\t')
                .append(location.end_line)
                .append('\t')
                .append(location.end_column);

            return result;
        si
    si

    class RESTART_HANDLER: Object, CommandHandler is
        init() is si

        handle(reader: IO.Reader, writer: IO.Writer) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            try
                writer.flush();

                let executable_path = System.Arguments.ProgramArguments[0];

                let p = new Util.Process();

                p.spawn(
                    executable_path,
                    Arguments.ProgramArguments,
                    Arguments.ProgramEnvironment
                );
            catch e: Exception
                IO.Std.err.println(e);

                writer.print("" + cast char(12));
                writer.println("EXCEPT");
                writer.println(e);
            yrt

            writer.print("" + cast char(12));
            writer.flush();
        si
    si
si