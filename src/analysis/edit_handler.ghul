namespace Analysis is
    use System.Exception;
    use IO.Std;

    use Collections.Iterable;

    use Pair = Collections.KeyValuePair`2;

    use IoC;
    use Logging;
    use Source;
    use Compiler;

    class FILE_EDITED_HANDLER: CommandHandler, SourceFileLookup, Iterable[SOURCE_FILE] is
        _logger: Logger;
        _diagnostic_writer: Diagnostics.DiagnosticWriter;
        _watchdog: WATCHDOG;
        _build_state: FILE_BUILD_STATE;
        _compiler: COMPILER;
        _symbol_table: Semantic.SYMBOL_TABLE;
        
        _source_files: Collections.MutableMap[string,SOURCE_FILE];
        _build_flags: BUILD_FLAGS;
        _library_files: Iterable[string];

        file_names: Iterable[string] => _source_files.keys;

        iterator: Collections.Iterator[SOURCE_FILE]
            => _source_files.values.iterator;

        init(
            logger: Logger,
            diagnostic_writer: Diagnostics.DiagnosticWriter,
            watchdog: WATCHDOG,
            compiler: COMPILER,
            build_flags: BUILD_FLAGS,
            library_files: Iterable[string],
            symbol_table: Semantic.SYMBOL_TABLE
        ) is
            _logger = logger;
            _diagnostic_writer = diagnostic_writer;
            _watchdog = watchdog;
            _compiler = compiler;
            _build_flags = build_flags;
            _library_files = library_files;
            _symbol_table = symbol_table;

            _source_files = new Collections.MAP[string,SOURCE_FILE]();
        si

        find_source_file(path: string) -> SOURCE_FILE is
            if _source_files.contains_key(path) then
                return _source_files[path];
            fi
        si

        parse_and_add_file(path: string, reader: IO.TextReader, is_internal_file: bool) is
            let source_file = _compiler.parse(path, reader, _build_flags, is_internal_file);
            _source_files[path] = source_file;

            _compiler.post_parse([source_file]);
        si
        
        handle(reader: IO.TextReader, writer: IO.TextWriter) is
            IoC.CONTAINER.instance.want_tab_delimited_logger(writer);

            let paths = new Collections.LIST[string]();

            do
                let path = reader.read_line();

                if string.is_null_or_white_space(path) then
                    break;
                fi

                paths.add(path);
            od

            if _library_files? then
                for library_file_path in _library_files do
                    parse_and_add_file(library_file_path, IO.File.open_text(library_file_path), true);
                od  

                _library_files = null;                    

            fi

            try
                for path in paths do
                    parse_and_add_file(path, reader, false);
                od
            catch e: Exception
                _watchdog.request_restart();
            finally
                writer.write_line("DIAG PARSE");

                _logger.write_to(_diagnostic_writer);

                writer.write("" + cast char(12));
                writer.flush();
            yrt

            _logger.clear();

            // TODO: run this as a cancellable task:

            try
                if !_watchdog.want_restart then
                    for i in _source_files.values do
                        i.build_flags.want_compile_expressions = true;
                    od

                    _compiler.clear_symbols(); 

                    _compiler.queue(self);

                    _compiler.build();
                fi

                _watchdog.enable();

            catch e: Exception
                Std.error.write_line("ANALYSE:" + e.get_type() + ": " + e.message);

                _watchdog.request_restart();
            finally
                _compiler.clear_queue();
 
                writer.write_line("DIAG ANALYSIS");

                _logger.write_to(_diagnostic_writer);

                writer.write("" + cast char(12));
                writer.flush();
            yrt
        si
    si
si